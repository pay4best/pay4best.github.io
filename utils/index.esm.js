function _iterableToArrayLimit(arr, i) {
  var _i = null == arr ? null : "undefined" != typeof Symbol && arr[Symbol.iterator] || arr["@@iterator"];
  if (null != _i) {
    var _s,
      _e,
      _x,
      _r,
      _arr = [],
      _n = !0,
      _d = !1;
    try {
      if (_x = (_i = _i.call(arr)).next, 0 === i) {
        if (Object(_i) !== _i) return;
        _n = !1;
      } else for (; !(_n = (_s = _x.call(_i)).done) && (_arr.push(_s.value), _arr.length !== i); _n = !0);
    } catch (err) {
      _d = !0, _e = err;
    } finally {
      try {
        if (!_n && null != _i.return && (_r = _i.return(), Object(_r) !== _r)) return;
      } finally {
        if (_d) throw _e;
      }
    }
    return _arr;
  }
}
function ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function (sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread2(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = null != arguments[i] ? arguments[i] : {};
    i % 2 ? ownKeys(Object(source), !0).forEach(function (key) {
      _defineProperty(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
function _regeneratorRuntime() {
  _regeneratorRuntime = function () {
    return exports;
  };
  var exports = {},
    Op = Object.prototype,
    hasOwn = Op.hasOwnProperty,
    defineProperty = Object.defineProperty || function (obj, key, desc) {
      obj[key] = desc.value;
    },
    $Symbol = "function" == typeof Symbol ? Symbol : {},
    iteratorSymbol = $Symbol.iterator || "@@iterator",
    asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator",
    toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";
  function define(obj, key, value) {
    return Object.defineProperty(obj, key, {
      value: value,
      enumerable: !0,
      configurable: !0,
      writable: !0
    }), obj[key];
  }
  try {
    define({}, "");
  } catch (err) {
    define = function (obj, key, value) {
      return obj[key] = value;
    };
  }
  function wrap(innerFn, outerFn, self, tryLocsList) {
    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator,
      generator = Object.create(protoGenerator.prototype),
      context = new Context(tryLocsList || []);
    return defineProperty(generator, "_invoke", {
      value: makeInvokeMethod(innerFn, self, context)
    }), generator;
  }
  function tryCatch(fn, obj, arg) {
    try {
      return {
        type: "normal",
        arg: fn.call(obj, arg)
      };
    } catch (err) {
      return {
        type: "throw",
        arg: err
      };
    }
  }
  exports.wrap = wrap;
  var ContinueSentinel = {};
  function Generator() {}
  function GeneratorFunction() {}
  function GeneratorFunctionPrototype() {}
  var IteratorPrototype = {};
  define(IteratorPrototype, iteratorSymbol, function () {
    return this;
  });
  var getProto = Object.getPrototypeOf,
    NativeIteratorPrototype = getProto && getProto(getProto(values([])));
  NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype);
  var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype);
  function defineIteratorMethods(prototype) {
    ["next", "throw", "return"].forEach(function (method) {
      define(prototype, method, function (arg) {
        return this._invoke(method, arg);
      });
    });
  }
  function AsyncIterator(generator, PromiseImpl) {
    function invoke(method, arg, resolve, reject) {
      var record = tryCatch(generator[method], generator, arg);
      if ("throw" !== record.type) {
        var result = record.arg,
          value = result.value;
        return value && "object" == typeof value && hasOwn.call(value, "__await") ? PromiseImpl.resolve(value.__await).then(function (value) {
          invoke("next", value, resolve, reject);
        }, function (err) {
          invoke("throw", err, resolve, reject);
        }) : PromiseImpl.resolve(value).then(function (unwrapped) {
          result.value = unwrapped, resolve(result);
        }, function (error) {
          return invoke("throw", error, resolve, reject);
        });
      }
      reject(record.arg);
    }
    var previousPromise;
    defineProperty(this, "_invoke", {
      value: function (method, arg) {
        function callInvokeWithMethodAndArg() {
          return new PromiseImpl(function (resolve, reject) {
            invoke(method, arg, resolve, reject);
          });
        }
        return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg();
      }
    });
  }
  function makeInvokeMethod(innerFn, self, context) {
    var state = "suspendedStart";
    return function (method, arg) {
      if ("executing" === state) throw new Error("Generator is already running");
      if ("completed" === state) {
        if ("throw" === method) throw arg;
        return doneResult();
      }
      for (context.method = method, context.arg = arg;;) {
        var delegate = context.delegate;
        if (delegate) {
          var delegateResult = maybeInvokeDelegate(delegate, context);
          if (delegateResult) {
            if (delegateResult === ContinueSentinel) continue;
            return delegateResult;
          }
        }
        if ("next" === context.method) context.sent = context._sent = context.arg;else if ("throw" === context.method) {
          if ("suspendedStart" === state) throw state = "completed", context.arg;
          context.dispatchException(context.arg);
        } else "return" === context.method && context.abrupt("return", context.arg);
        state = "executing";
        var record = tryCatch(innerFn, self, context);
        if ("normal" === record.type) {
          if (state = context.done ? "completed" : "suspendedYield", record.arg === ContinueSentinel) continue;
          return {
            value: record.arg,
            done: context.done
          };
        }
        "throw" === record.type && (state = "completed", context.method = "throw", context.arg = record.arg);
      }
    };
  }
  function maybeInvokeDelegate(delegate, context) {
    var methodName = context.method,
      method = delegate.iterator[methodName];
    if (undefined === method) return context.delegate = null, "throw" === methodName && delegate.iterator.return && (context.method = "return", context.arg = undefined, maybeInvokeDelegate(delegate, context), "throw" === context.method) || "return" !== methodName && (context.method = "throw", context.arg = new TypeError("The iterator does not provide a '" + methodName + "' method")), ContinueSentinel;
    var record = tryCatch(method, delegate.iterator, context.arg);
    if ("throw" === record.type) return context.method = "throw", context.arg = record.arg, context.delegate = null, ContinueSentinel;
    var info = record.arg;
    return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, "return" !== context.method && (context.method = "next", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = "throw", context.arg = new TypeError("iterator result is not an object"), context.delegate = null, ContinueSentinel);
  }
  function pushTryEntry(locs) {
    var entry = {
      tryLoc: locs[0]
    };
    1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry);
  }
  function resetTryEntry(entry) {
    var record = entry.completion || {};
    record.type = "normal", delete record.arg, entry.completion = record;
  }
  function Context(tryLocsList) {
    this.tryEntries = [{
      tryLoc: "root"
    }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0);
  }
  function values(iterable) {
    if (iterable) {
      var iteratorMethod = iterable[iteratorSymbol];
      if (iteratorMethod) return iteratorMethod.call(iterable);
      if ("function" == typeof iterable.next) return iterable;
      if (!isNaN(iterable.length)) {
        var i = -1,
          next = function next() {
            for (; ++i < iterable.length;) if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next;
            return next.value = undefined, next.done = !0, next;
          };
        return next.next = next;
      }
    }
    return {
      next: doneResult
    };
  }
  function doneResult() {
    return {
      value: undefined,
      done: !0
    };
  }
  return GeneratorFunction.prototype = GeneratorFunctionPrototype, defineProperty(Gp, "constructor", {
    value: GeneratorFunctionPrototype,
    configurable: !0
  }), defineProperty(GeneratorFunctionPrototype, "constructor", {
    value: GeneratorFunction,
    configurable: !0
  }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction"), exports.isGeneratorFunction = function (genFun) {
    var ctor = "function" == typeof genFun && genFun.constructor;
    return !!ctor && (ctor === GeneratorFunction || "GeneratorFunction" === (ctor.displayName || ctor.name));
  }, exports.mark = function (genFun) {
    return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, "GeneratorFunction")), genFun.prototype = Object.create(Gp), genFun;
  }, exports.awrap = function (arg) {
    return {
      __await: arg
    };
  }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () {
    return this;
  }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) {
    void 0 === PromiseImpl && (PromiseImpl = Promise);
    var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl);
    return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) {
      return result.done ? result.value : iter.next();
    });
  }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, "Generator"), define(Gp, iteratorSymbol, function () {
    return this;
  }), define(Gp, "toString", function () {
    return "[object Generator]";
  }), exports.keys = function (val) {
    var object = Object(val),
      keys = [];
    for (var key in object) keys.push(key);
    return keys.reverse(), function next() {
      for (; keys.length;) {
        var key = keys.pop();
        if (key in object) return next.value = key, next.done = !1, next;
      }
      return next.done = !0, next;
    };
  }, exports.values = values, Context.prototype = {
    constructor: Context,
    reset: function (skipTempReset) {
      if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = "next", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) "t" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined);
    },
    stop: function () {
      this.done = !0;
      var rootRecord = this.tryEntries[0].completion;
      if ("throw" === rootRecord.type) throw rootRecord.arg;
      return this.rval;
    },
    dispatchException: function (exception) {
      if (this.done) throw exception;
      var context = this;
      function handle(loc, caught) {
        return record.type = "throw", record.arg = exception, context.next = loc, caught && (context.method = "next", context.arg = undefined), !!caught;
      }
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i],
          record = entry.completion;
        if ("root" === entry.tryLoc) return handle("end");
        if (entry.tryLoc <= this.prev) {
          var hasCatch = hasOwn.call(entry, "catchLoc"),
            hasFinally = hasOwn.call(entry, "finallyLoc");
          if (hasCatch && hasFinally) {
            if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0);
            if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc);
          } else if (hasCatch) {
            if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0);
          } else {
            if (!hasFinally) throw new Error("try statement without catch or finally");
            if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc);
          }
        }
      }
    },
    abrupt: function (type, arg) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) {
          var finallyEntry = entry;
          break;
        }
      }
      finallyEntry && ("break" === type || "continue" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null);
      var record = finallyEntry ? finallyEntry.completion : {};
      return record.type = type, record.arg = arg, finallyEntry ? (this.method = "next", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record);
    },
    complete: function (record, afterLoc) {
      if ("throw" === record.type) throw record.arg;
      return "break" === record.type || "continue" === record.type ? this.next = record.arg : "return" === record.type ? (this.rval = this.arg = record.arg, this.method = "return", this.next = "end") : "normal" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel;
    },
    finish: function (finallyLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel;
      }
    },
    catch: function (tryLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc === tryLoc) {
          var record = entry.completion;
          if ("throw" === record.type) {
            var thrown = record.arg;
            resetTryEntry(entry);
          }
          return thrown;
        }
      }
      throw new Error("illegal catch attempt");
    },
    delegateYield: function (iterable, resultName, nextLoc) {
      return this.delegate = {
        iterator: values(iterable),
        resultName: resultName,
        nextLoc: nextLoc
      }, "next" === this.method && (this.arg = undefined), ContinueSentinel;
    }
  }, exports;
}
function _typeof(obj) {
  "@babel/helpers - typeof";

  return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) {
    return typeof obj;
  } : function (obj) {
    return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
  }, _typeof(obj);
}
function _wrapRegExp() {
  _wrapRegExp = function (re, groups) {
    return new BabelRegExp(re, void 0, groups);
  };
  var _super = RegExp.prototype,
    _groups = new WeakMap();
  function BabelRegExp(re, flags, groups) {
    var _this = new RegExp(re, flags);
    return _groups.set(_this, groups || _groups.get(re)), _setPrototypeOf(_this, BabelRegExp.prototype);
  }
  function buildGroups(result, re) {
    var g = _groups.get(re);
    return Object.keys(g).reduce(function (groups, name) {
      var i = g[name];
      if ("number" == typeof i) groups[name] = result[i];else {
        for (var k = 0; void 0 === result[i[k]] && k + 1 < i.length;) k++;
        groups[name] = result[i[k]];
      }
      return groups;
    }, Object.create(null));
  }
  return _inherits(BabelRegExp, RegExp), BabelRegExp.prototype.exec = function (str) {
    var result = _super.exec.call(this, str);
    if (result) {
      result.groups = buildGroups(result, this);
      var indices = result.indices;
      indices && (indices.groups = buildGroups(indices, this));
    }
    return result;
  }, BabelRegExp.prototype[Symbol.replace] = function (str, substitution) {
    if ("string" == typeof substitution) {
      var groups = _groups.get(this);
      return _super[Symbol.replace].call(this, str, substitution.replace(/\$<([^>]+)>/g, function (_, name) {
        var group = groups[name];
        return "$" + (Array.isArray(group) ? group.join("$") : group);
      }));
    }
    if ("function" == typeof substitution) {
      var _this = this;
      return _super[Symbol.replace].call(this, str, function () {
        var args = arguments;
        return "object" != typeof args[args.length - 1] && (args = [].slice.call(args)).push(buildGroups(args, _this)), substitution.apply(this, args);
      });
    }
    return _super[Symbol.replace].call(this, str, substitution);
  }, _wrapRegExp.apply(this, arguments);
}
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
  try {
    var info = gen[key](arg);
    var value = info.value;
  } catch (error) {
    reject(error);
    return;
  }
  if (info.done) {
    resolve(value);
  } else {
    Promise.resolve(value).then(_next, _throw);
  }
}
function _asyncToGenerator(fn) {
  return function () {
    var self = this,
      args = arguments;
    return new Promise(function (resolve, reject) {
      var gen = fn.apply(self, args);
      function _next(value) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
      }
      function _throw(err) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
      }
      _next(undefined);
    });
  };
}
function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);
  }
}
function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", {
    writable: false
  });
  return Constructor;
}
function _defineProperty(obj, key, value) {
  key = _toPropertyKey(key);
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  Object.defineProperty(subClass, "prototype", {
    writable: false
  });
  if (superClass) _setPrototypeOf(subClass, superClass);
}
function _getPrototypeOf(o) {
  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return _getPrototypeOf(o);
}
function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };
  return _setPrototypeOf(o, p);
}
function _isNativeReflectConstruct() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
    return true;
  } catch (e) {
    return false;
  }
}
function _assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self;
}
function _possibleConstructorReturn(self, call) {
  if (call && (typeof call === "object" || typeof call === "function")) {
    return call;
  } else if (call !== void 0) {
    throw new TypeError("Derived constructors may only return object or undefined");
  }
  return _assertThisInitialized(self);
}
function _createSuper(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived),
      result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn(this, result);
  };
}
function _slicedToArray(arr, i) {
  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();
}
function _toArray(arr) {
  return _arrayWithHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableRest();
}
function _toConsumableArray(arr) {
  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
}
function _arrayWithoutHoles(arr) {
  if (Array.isArray(arr)) return _arrayLikeToArray(arr);
}
function _arrayWithHoles(arr) {
  if (Array.isArray(arr)) return arr;
}
function _iterableToArray(iter) {
  if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
}
function _unsupportedIterableToArray(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
}
function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length) len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
  return arr2;
}
function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _createForOfIteratorHelper(o, allowArrayLike) {
  var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
  if (!it) {
    if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
      if (it) o = it;
      var i = 0;
      var F = function () {};
      return {
        s: F,
        n: function () {
          if (i >= o.length) return {
            done: true
          };
          return {
            done: false,
            value: o[i++]
          };
        },
        e: function (e) {
          throw e;
        },
        f: F
      };
    }
    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
  var normalCompletion = true,
    didErr = false,
    err;
  return {
    s: function () {
      it = it.call(o);
    },
    n: function () {
      var step = it.next();
      normalCompletion = step.done;
      return step;
    },
    e: function (e) {
      didErr = true;
      err = e;
    },
    f: function () {
      try {
        if (!normalCompletion && it.return != null) it.return();
      } finally {
        if (didErr) throw err;
      }
    }
  };
}
function _toPrimitive(input, hint) {
  if (typeof input !== "object" || input === null) return input;
  var prim = input[Symbol.toPrimitive];
  if (prim !== undefined) {
    var res = prim.call(input, hint || "default");
    if (typeof res !== "object") return res;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (hint === "string" ? String : Number)(input);
}
function _toPropertyKey(arg) {
  var key = _toPrimitive(arg, "string");
  return typeof key === "symbol" ? key : String(key);
}

var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

function getAugmentedNamespace(n) {
  if (n.__esModule) return n;
  var f = n.default;
	if (typeof f == "function") {
		var a = function a () {
			if (this instanceof a) {
				var args = [null];
				args.push.apply(args, arguments);
				var Ctor = Function.bind.apply(f, args);
				return new Ctor();
			}
			return f.apply(this, arguments);
		};
		a.prototype = f.prototype;
  } else a = {};
  Object.defineProperty(a, '__esModule', {value: true});
	Object.keys(n).forEach(function (k) {
		var d = Object.getOwnPropertyDescriptor(n, k);
		Object.defineProperty(a, k, d.get ? d : {
			enumerable: true,
			get: function () {
				return n[k];
			}
		});
	});
	return a;
}

var utils = {};

var BaseConversionError;
(function (BaseConversionError) {
  BaseConversionError["tooLong"] = "An alphabet may be no longer than 254 characters.";
  BaseConversionError["ambiguousCharacter"] = "A character code may only appear once in a single alphabet.";
  BaseConversionError["unknownCharacter"] = "Encountered an unknown character for this alphabet.";
})(BaseConversionError || (BaseConversionError = {}));
/**
 * Create a {@link BaseConverter}, exposing methods for encoding and decoding
 * `Uint8Array`s using bitcoin-style padding: each leading zero in the input is
 * replaced with the zero-index character of the `alphabet`, then the remainder
 * of the input is encoded as a large number in the specified alphabet.
 *
 * For example, using the alphabet `01`, the input `[0, 15]` is encoded `01111`
 * – a single `0` represents the leading padding, followed by the base2 encoded
 * `0x1111` (15). With the same alphabet, the input `[0, 0, 255]` is encoded
 * `0011111111` - only two `0` characters are required to represent both
 * leading zeros, followed by the base2 encoded `0x11111111` (255).
 *
 * **This is not compatible with `RFC 3548`'s `Base16`, `Base32`, or `Base64`.**
 *
 * If the alphabet is malformed, this method returns the error as a `string`.
 *
 * @param alphabet - an ordered string that maps each index to a character,
 * e.g. `0123456789`.
 */
// Algorithm from the `base-x` implementation (derived from the original Satoshi implementation): https://github.com/cryptocoinjs/base-x
var createBaseConverter = function createBaseConverter(alphabet) {
  var undefinedValue = 255;
  var uint8ArrayBase = 256;
  if (alphabet.length >= undefinedValue) return BaseConversionError.tooLong;
  var alphabetMap = new Uint8Array(uint8ArrayBase).fill(undefinedValue);
  // eslint-disable-next-line functional/no-loop-statement, functional/no-let, no-plusplus
  for (var index = 0; index < alphabet.length; index++) {
    var characterCode = alphabet.charCodeAt(index);
    if (alphabetMap[characterCode] !== undefinedValue) {
      return BaseConversionError.ambiguousCharacter;
    }
    // eslint-disable-next-line functional/no-expression-statement, functional/immutable-data
    alphabetMap[characterCode] = index;
  }
  var base = alphabet.length;
  var paddingCharacter = alphabet.charAt(0);
  var factor = Math.log(base) / Math.log(uint8ArrayBase);
  var inverseFactor = Math.log(uint8ArrayBase) / Math.log(base);
  return {
    // eslint-disable-next-line complexity
    decode: function decode(input) {
      if (input.length === 0) return Uint8Array.of();
      var firstNonZeroIndex = input.split('').findIndex(function (character) {
        return character !== paddingCharacter;
      });
      if (firstNonZeroIndex === -1) {
        return new Uint8Array(input.length);
      }
      var requiredLength = Math.floor((input.length - firstNonZeroIndex) * factor + 1);
      var decoded = new Uint8Array(requiredLength);
      /* eslint-disable functional/no-let, functional/no-expression-statement */
      var nextByte = firstNonZeroIndex;
      var remainingBytes = 0;
      // eslint-disable-next-line functional/no-loop-statement
      while (input[nextByte] !== undefined) {
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        var carry = alphabetMap[input.charCodeAt(nextByte)];
        if (carry === undefinedValue) return BaseConversionError.unknownCharacter;
        var digit = 0;
        // eslint-disable-next-line functional/no-loop-statement
        for (var steps = requiredLength - 1; (carry !== 0 || digit < remainingBytes) && steps !== -1;
        // eslint-disable-next-line no-plusplus
        steps--, digit++) {
          // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
          carry += Math.floor(base * decoded[steps]);
          // eslint-disable-next-line functional/immutable-data
          decoded[steps] = Math.floor(carry % uint8ArrayBase);
          carry = Math.floor(carry / uint8ArrayBase);
        }
        remainingBytes = digit;
        // eslint-disable-next-line no-plusplus
        nextByte++;
      }
      /* eslint-enable functional/no-let, functional/no-expression-statement */
      var firstNonZeroResultDigit = decoded.findIndex(function (value) {
        return value !== 0;
      });
      var bin = new Uint8Array(firstNonZeroIndex + (requiredLength - firstNonZeroResultDigit));
      // eslint-disable-next-line functional/no-expression-statement
      bin.set(decoded.slice(firstNonZeroResultDigit), firstNonZeroIndex);
      return bin;
    },
    // eslint-disable-next-line complexity
    encode: function encode(input) {
      if (input.length === 0) return '';
      var firstNonZeroIndex = input.findIndex(function (byte) {
        return byte !== 0;
      });
      if (firstNonZeroIndex === -1) {
        return paddingCharacter.repeat(input.length);
      }
      var requiredLength = Math.floor((input.length - firstNonZeroIndex) * inverseFactor + 1);
      var encoded = new Uint8Array(requiredLength);
      /* eslint-disable functional/no-let, functional/no-expression-statement */
      var nextByte = firstNonZeroIndex;
      var remainingBytes = 0;
      // eslint-disable-next-line functional/no-loop-statement
      while (nextByte !== input.length) {
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        var carry = input[nextByte];
        var digit = 0;
        // eslint-disable-next-line functional/no-loop-statement
        for (var steps = requiredLength - 1; (carry !== 0 || digit < remainingBytes) && steps !== -1;
        // eslint-disable-next-line no-plusplus
        steps--, digit++) {
          // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
          carry += Math.floor(uint8ArrayBase * encoded[steps]);
          // eslint-disable-next-line functional/immutable-data
          encoded[steps] = Math.floor(carry % base);
          carry = Math.floor(carry / base);
        }
        remainingBytes = digit;
        // eslint-disable-next-line no-plusplus
        nextByte++;
      }
      /* eslint-enable functional/no-let, functional/no-expression-statement */
      var firstNonZeroResultDigit = encoded.findIndex(function (value) {
        return value !== 0;
      });
      var padding = paddingCharacter.repeat(firstNonZeroIndex);
      return encoded.slice(firstNonZeroResultDigit).reduce(function (all, digit) {
        return all + alphabet.charAt(digit);
      }, padding);
    }
  };
};
var bitcoinBase58Alphabet = '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz';
var base58$1 = createBaseConverter(bitcoinBase58Alphabet);
/**
 * Convert a bitcoin-style base58-encoded string to a Uint8Array.
 *
 * See {@link createBaseConverter} for format details.
 * @param input - a valid base58-encoded string to decode
 */
var base58ToBin = base58$1.decode;
/**
 * Convert a Uint8Array to a bitcoin-style base58-encoded string.
 *
 * See {@link createBaseConverter} for format details.
 * @param input - the Uint8Array to base58 encode
 */
var binToBase58 = base58$1.encode;

// base64 encode/decode derived from: https://github.com/niklasvh/base64-arraybuffer
var chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
var base64GroupLength = 4;
var nonBase64Chars = new RegExp("[^".concat(chars, "=]"), 'u');
/**
 * For use before {@link base64ToBin}. Returns true if the provided string is
 * valid base64 (length is divisible by 4, only uses base64 characters).
 * @param maybeBase64 - a string to test
 */
var isBase64 = function isBase64(maybeBase64) {
  return maybeBase64.length % base64GroupLength === 0 && !nonBase64Chars.test(maybeBase64);
};
/* eslint-disable functional/no-expression-statement, functional/immutable-data, @typescript-eslint/no-magic-numbers, no-bitwise, no-plusplus, @typescript-eslint/no-non-null-assertion */
/**
 * Convert a base64-encoded string to a Uint8Array.
 *
 * Note, this method always completes. If `validBase64` is not valid base64, an
 * incorrect result will be returned. If `validBase64` is potentially malformed,
 * check it with {@link isBase64} before calling this method.
 *
 * @param validBase64 - a valid base64-encoded string to decode
 */
var base64ToBin = function base64ToBin(validBase64) {
  var lookup = new Uint8Array(123);
  // eslint-disable-next-line functional/no-let, functional/no-loop-statement
  for (var i = 0; i < chars.length; i++) {
    lookup[chars.charCodeAt(i)] = i;
  }
  var bufferLengthEstimate = validBase64.length * 0.75;
  var stringLength = validBase64.length;
  var bufferLength = validBase64[validBase64.length - 1] === '=' // eslint-disable-line @typescript-eslint/prefer-string-starts-ends-with
  ? validBase64[validBase64.length - 2] === '=' ? bufferLengthEstimate - 2 : bufferLengthEstimate - 1 : bufferLengthEstimate;
  var buffer = new ArrayBuffer(bufferLength);
  var bytes = new Uint8Array(buffer);
  // eslint-disable-next-line functional/no-let
  var p = 0;
  // eslint-disable-next-line functional/no-let, functional/no-loop-statement
  for (var _i = 0; _i < stringLength; _i += 4) {
    var encoded1 = lookup[validBase64.charCodeAt(_i)];
    var encoded2 = lookup[validBase64.charCodeAt(_i + 1)];
    var encoded3 = lookup[validBase64.charCodeAt(_i + 2)];
    var encoded4 = lookup[validBase64.charCodeAt(_i + 3)];
    bytes[p++] = encoded1 << 2 | encoded2 >> 4;
    bytes[p++] = (encoded2 & 15) << 4 | encoded3 >> 2;
    bytes[p++] = (encoded3 & 3) << 6 | encoded4 & 63;
  }
  return bytes;
};
/**
 * Convert a Uint8Array to a base64-encoded string.
 * @param bytes - the Uint8Array to base64 encode
 */
var binToBase64 = function binToBase64(bytes) {
  // eslint-disable-next-line functional/no-let
  var result = '';
  // eslint-disable-next-line functional/no-let, functional/no-loop-statement
  for (var i = 0; i < bytes.length; i += 3) {
    result += chars[bytes[i] >> 2];
    result += chars[(bytes[i] & 3) << 4 | bytes[i + 1] >> 4];
    result += chars[(bytes[i + 1] & 15) << 2 | bytes[i + 2] >> 6];
    result += chars[bytes[i + 2] & 63];
  }
  var padded = bytes.length % 3 === 2 ? "".concat(result.substring(0, result.length - 1), "=") : bytes.length % 3 === 1 ? "".concat(result.substring(0, result.length - 2), "==") : result;
  return padded;
};
/* eslint-enable functional/no-expression-statement, functional/immutable-data, @typescript-eslint/no-magic-numbers, no-bitwise, no-plusplus, @typescript-eslint/no-non-null-assertion */

/**
 * Returns an array of incrementing values starting at `begin` and incrementing
 * by one for `length`.
 *
 * E.g.: `range(3)` → `[0, 1, 2]` and `range(3, 1)` → `[1, 2, 3]`
 *
 * @param length - the number of elements in the array
 * @param begin - the index at which the range starts (default: `0`)
 */
var range = function range(length) {
  var begin = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
  return Array.from({
    length: length
  }, function (_, index) {
    return begin + index;
  });
};
/**
 * Split a string into an array of `chunkLength` strings. The final string may
 * have a length between 1 and `chunkLength`.
 *
 * E.g.: `splitEvery('abcde', 2)` → `['ab', 'cd', 'e']`
 */
var splitEvery = function splitEvery(input, chunkLength) {
  return range(Math.ceil(input.length / chunkLength)).map(function (index) {
    return index * chunkLength;
  }).map(function (begin) {
    return input.slice(begin, begin + chunkLength);
  });
};
var hexByteWidth = 2;
var hexadecimal = 16;
/**
 * Decode a hexadecimal-encoded string into a Uint8Array.
 *
 * E.g.: `hexToBin('2a64ff')` → `new Uint8Array([42, 100, 255])`
 *
 * Note, this method always completes. If `validHex` is not divisible by 2,
 * the final byte will be parsed as if it were prepended with a `0` (e.g. `aaa`
 * is interpreted as `aa0a`). If `validHex` is potentially malformed, check
 * it with {@link isHex} before calling this method.
 *
 * @param validHex - a string of valid, hexadecimal-encoded data
 */
var hexToBin = function hexToBin(validHex) {
  return Uint8Array.from(splitEvery(validHex, hexByteWidth).map(function (byte) {
    return parseInt(byte, hexadecimal);
  }));
};
/**
 * For use before {@link hexToBin}. Returns true if the provided string is valid
 * hexadecimal (length is divisible by 2, only uses hexadecimal characters).
 * @param maybeHex - a string to test
 */
var isHex = function isHex(maybeHex) {
  return maybeHex.length % hexByteWidth === 0 && !/(?:[\0-\/:-@G-`g-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])/.test(maybeHex);
};
/**
 * Encode a Uint8Array into a hexadecimal-encoded string.
 *
 * E.g.: `binToHex(new Uint8Array([42, 100, 255]))` → `'2a64ff'`
 *
 * @param bytes - a Uint8Array to encode
 */
var binToHex = function binToHex(bytes) {
  return bytes.reduce(function (str, byte) {
    return str + byte.toString(hexadecimal).padStart(hexByteWidth, '0');
  }, '');
};
/**
 * Decode a hexadecimal-encoded string into bytes, reverse it, then re-encode.
 *
 * @param validHex - a string of valid, hexadecimal-encoded data. See
 * {@link hexToBin} for more information.
 */
var swapEndianness = function swapEndianness(validHex) {
  return binToHex(hexToBin(validHex).reverse());
};
/**
 * Reduce an array of `Uint8Array`s into a single `Uint8Array`.
 * @param array - the array of `Uint8Array`s to flatten
 */
var flattenBinArray = function flattenBinArray(array) {
  var totalLength = array.reduce(function (total, bin) {
    return total + bin.length;
  }, 0);
  var flattened = new Uint8Array(totalLength);
  // eslint-disable-next-line functional/no-expression-statement
  array.reduce(function (index, bin) {
    // eslint-disable-next-line functional/no-expression-statement
    flattened.set(bin, index);
    return index + bin.length;
  }, 0);
  return flattened;
};
/**
 * Compare to `Uint8Array`s, return true if their contents are exactly the same,
 * otherwise return false.
 * @param a - the first Uint8Array
 * @param b - the second Uint8Array
 */
var binsAreEqual = function binsAreEqual(a, b) {
  if (a.length !== b.length) {
    return false;
  }
  // eslint-disable-next-line functional/no-let, functional/no-loop-statement, no-plusplus
  for (var i = 0; i < a.length; i++) {
    if (a[i] !== b[i]) {
      return false;
    }
  }
  return true;
};

var binaryByteWidth = 8;
var binary = 2;
/**
 * Decode a binary-encoded string into a Uint8Array.
 *
 * E.g.: `binStringToBin('0010101001100100')` → `new Uint8Array([42, 100])`
 *
 * Note, this method always completes. If `binaryDigits` is not divisible by 8,
 * the final byte will be parsed as if it were prepended with `0`s (e.g. `1`
 * is interpreted as `00000001`). If `binaryDigits` is potentially malformed,
 * check it with `isBinString` before calling this method.
 *
 * @param binaryDigits - a string of `0`s and `1`s with a length divisible by 8
 */
var binStringToBin = function binStringToBin(binaryDigits) {
  return Uint8Array.from(splitEvery(binaryDigits, binaryByteWidth).map(function (byteString) {
    return parseInt(byteString, binary);
  }));
};
/**
 * Encode a Uint8Array into a binary-encoded string.
 *
 * E.g.: `binToBinString(Uint8Array.from([42, 100]))` → `'0010101001100100'`
 *
 * @param bytes - a Uint8Array to encode
 */
var binToBinString = function binToBinString(bytes) {
  return bytes.reduce(function (str, byte) {
    return str + byte.toString(binary).padStart(binaryByteWidth, '0');
  }, '');
};
/**
 * For use before {@link binStringToBin}. Returns true if the provided string is
 * a valid binary string (length is divisible by 8 and only uses the characters
 * `0` and `1`).
 * @param maybeBinString - a string to test
 */
var isBinString = function isBinString(maybeBinString) {
  return maybeBinString.length % binaryByteWidth === 0 && !/(?:[\0-\/2-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])/.test(maybeBinString);
};

/**
 * A simple method used throughout Libauth to format error messages. By
 * formatting errors this way, downstream consumers can detect specific error
 * types by matching the `errorType`. For example, the error:
 *
 * ```ts
 * formatError(SomeTypeOfError.exceedsMaximum, `Provided value: ${value}`);
 * ```
 *
 * Can be detected with `String.includes()`, even if the
 * `SomeTypeOfError.exceedsMaximum` error message changes:
 * ```ts
 * error.includes(SomeTypeOfError.exceedsMaximum);
 * // => true
 * ```
 *
 * Using this method ensures consistency across the library.
 *
 * @remarks
 * In Libauth, expected errors use the type `string` rather than `Error` (or
 * other objects that inherit from `Error`) to simplify the resulting types and
 * typechecking requirements. This ensures consistency of returned errors in all
 * environments, avoids exposing internal details like stack traces and line
 * numbers, and allows error messages to be recorded or used as text without an
 * intermediate `toString()` method.
 *
 * @param errorType - the error enum member representing this error type
 * @param errorDetails - optional, additional details to include in the error
 * message
 */
var formatError$1 = function formatError(errorType, errorDetails) {
  return "".concat(errorType).concat(errorDetails === undefined ? '' : " ".concat(errorDetails));
};
var unknownValue = function unknownValue(value) {
  var message = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "Received an unknown value: ".concat(String(value), ". This should have been caught by TypeScript - are your types correct?");
  // eslint-disable-next-line functional/no-throw-statement
  throw new Error(message);
};

var defaultStringifySpacing = 2;
/**
 * A safe method to `JSON.stringify` a value, useful for debugging and logging
 * purposes.
 *
 * @remarks
 * Without modifications, `JSON.stringify` has several shortcomings in
 * debugging and logging usage:
 * - throws when serializing anything containing a `bigint`
 * - `Uint8Array`s are often encoded in base 10 with newlines between each
 *   index item
 * - `functions` and `symbols` are not clearly marked
 *
 * This method is more helpful in these cases:
 * - `bigint`: `0n` → `<bigint: 0n>`
 * - `Uint8Array`: `Uint8Array.of(0,0)` → `<Uint8Array: 0x0000>`
 * - `function`: `(x) => x * 2` → `<function: (x) => x * 2>`
 * - `symbol`: `Symbol(A)` → `<symbol: Symbol(A)>`
 *
 * @param value - the data to stringify
 * @param spacing - the number of spaces to use in
 */
// eslint-disable-next-line @typescript-eslint/no-explicit-any
var stringify = function stringify(value) {
  var spacing = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : defaultStringifySpacing;
  return JSON.stringify(value,
  // eslint-disable-next-line complexity
  function (_, item) {
    var type = _typeof(item);
    var name = _typeof(item) === 'object' && item !== null ? item.constructor.name : type;
    switch (name) {
      case 'Uint8Array':
        return "<Uint8Array: 0x".concat(binToHex(item), ">");
      case 'bigint':
        return "<bigint: ".concat(item.toString(), "n>");
      case 'function':
      case 'symbol':
        // eslint-disable-next-line @typescript-eslint/ban-types
        return "<".concat(name, ": ").concat(item.toString(), ">");
      default:
        return item;
    }
  }, spacing);
};
/**
 * Given a value, recursively sort the keys of all objects it references
 * (without sorting arrays).
 *
 * @param objectOrArray - the object or array in which to sort object keys
 */
var sortObjectKeys = function sortObjectKeys(objectOrArray
// eslint-disable-next-line @typescript-eslint/no-explicit-any
) {
  if (Array.isArray(objectOrArray)) {
    // eslint-disable-next-line @typescript-eslint/no-unsafe-return
    return objectOrArray.map(sortObjectKeys);
  }
  if (_typeof(objectOrArray) !== 'object' || objectOrArray === null || objectOrArray.constructor.name !== 'Object') {
    return objectOrArray;
  }
  // eslint-disable-next-line functional/immutable-data
  var keys = Object.keys(objectOrArray).sort(function (a, b) {
    return a.localeCompare(b, 'en');
  });
  return keys.reduce(function (all, key) {
    return _objectSpread2(_objectSpread2({}, all), {}, _defineProperty({}, key, sortObjectKeys(objectOrArray[key])));
  }, {});
};
var uint8ArrayRegex = /*#__PURE__*/_wrapRegExp(/"<Uint8Array: 0x([0-9a-f]*)>"/g, {
  hex: 1
});
var bigIntRegex = /*#__PURE__*/_wrapRegExp(/"<bigint: ([0-9]*)n>"/g, {
  bigint: 1
});
/**
 * An alternative to {@link stringify} that produces valid JavaScript for use
 * as a test vector in this library. `Uint8Array`s are constructed using
 * {@link hexToBin} and `bigint` values use the `BigInt` constructor. If
 * `alphabetize` is `true`, all objects will be sorted in the output.
 *
 * Note, this assumes all strings that match the expected regular expressions
 * are values of type `Uint8Array` and `bigint` respectively. String values
 * that otherwise happen to match these regular expressions will be converted
 * incorrectly.
 *
 * @param value - the value to stringify
 * @param alphabetize - whether or not to alphabetize object keys, defaults
 * to true
 */
var stringifyTestVector = function stringifyTestVector(
// eslint-disable-next-line @typescript-eslint/no-explicit-any
value) {
  var alphabetize = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
  var stringified = alphabetize ? stringify(sortObjectKeys(value)) : stringify(value);
  return stringified.replace(uint8ArrayRegex, "hexToBin('$1')").replace(bigIntRegex, '$1n');
};

/**
 * Encode a positive integer as a little-endian Uint8Array. For values exceeding
 * `Number.MAX_SAFE_INTEGER` (`9007199254740991`), use `bigIntToBinUintLE`.
 * Negative values will return the same result as `0`.
 *
 * @param value - the number to encode
 */
var numberToBinUintLE = function numberToBinUintLE(value) {
  var baseUint8Array = 256;
  var result = [];
  // eslint-disable-next-line functional/no-let
  var remaining = value;
  // eslint-disable-next-line functional/no-loop-statement
  while (remaining >= baseUint8Array) {
    // eslint-disable-next-line functional/no-expression-statement, functional/immutable-data
    result.push(remaining % baseUint8Array);
    // eslint-disable-next-line functional/no-expression-statement
    remaining = Math.floor(remaining / baseUint8Array);
  }
  // eslint-disable-next-line functional/no-conditional-statement, functional/no-expression-statement, functional/immutable-data
  if (remaining > 0) result.push(remaining);
  return Uint8Array.from(result);
};
/**
 * Fill a new Uint8Array of a specific byte-length with the contents of a given
 * Uint8Array, truncating or padding the Uint8Array with zeros.
 *
 * @param bin - the Uint8Array to resize
 * @param bytes - the desired byte-length
 */
var binToFixedLength = function binToFixedLength(bin, bytes) {
  var fixedBytes = new Uint8Array(bytes);
  var maxValue = 255;
  // eslint-disable-next-line functional/no-expression-statement
  bin.length > bytes ? fixedBytes.fill(maxValue) : fixedBytes.set(bin);
  return fixedBytes;
};
/**
 * Encode a positive integer as a 2-byte Uint16LE Uint8Array, clamping the
 * results – values exceeding `0xffff` (`65535`) return the same result as
 * `0xffff`, negative values will return the same result as `0`.
 *
 * @param value - the number to encode
 */
var numberToBinUint16LEClamped = function numberToBinUint16LEClamped(value) {
  var uint16 = 2;
  return binToFixedLength(numberToBinUintLE(value), uint16);
};
/**
 * Encode a positive integer as a 4-byte Uint32LE Uint8Array, clamping the
 * results – values exceeding `0xffffffff` (`4294967295`) return the same result
 * as `0xffffffff`, negative values will return the same result as `0`.
 *
 * @param value - the number to encode
 */
var numberToBinUint32LEClamped = function numberToBinUint32LEClamped(value) {
  var uint32 = 4;
  return binToFixedLength(numberToBinUintLE(value), uint32);
};
/**
 * Encode a positive integer as a 2-byte Uint16LE Uint8Array.
 *
 * This method will return an incorrect result for values outside of the range
 * `0` to `0xffff` (`65535`). If applicable, applications should handle such
 * cases prior to calling this method.
 *
 * @param value - the number to encode
 */
var numberToBinUint16LE = function numberToBinUint16LE(value) {
  var uint16Length = 2;
  var bin = new Uint8Array(uint16Length);
  var writeAsLittleEndian = true;
  var view = new DataView(bin.buffer, bin.byteOffset, bin.byteLength);
  // eslint-disable-next-line functional/no-expression-statement
  view.setUint16(0, value, writeAsLittleEndian);
  return bin;
};
/**
 * Encode an integer as a 2-byte Int16LE Uint8Array.
 *
 * This method will return an incorrect result for values outside of the range
 * `0x0000` to `0xffff` (`65535`). If applicable, applications should handle
 * such cases prior to calling this method.
 *
 * @param value - the number to encode
 */
var numberToBinInt16LE = function numberToBinInt16LE(value) {
  var int16Length = 2;
  var bin = new Uint8Array(int16Length);
  var writeAsLittleEndian = true;
  var view = new DataView(bin.buffer, bin.byteOffset, bin.byteLength);
  // eslint-disable-next-line functional/no-expression-statement
  view.setInt16(0, value, writeAsLittleEndian);
  return bin;
};
/**
 * Encode an integer as a 4-byte Uint32LE Uint8Array.
 *
 * This method will return an incorrect result for values outside of the range
 * `0x00000000` to `0xffffffff` (`4294967295`). If applicable, applications
 * should handle such cases prior to calling this method.
 *
 * @param value - the number to encode
 */
var numberToBinInt32LE = function numberToBinInt32LE(value) {
  var int32Length = 4;
  var bin = new Uint8Array(int32Length);
  var writeAsLittleEndian = true;
  var view = new DataView(bin.buffer, bin.byteOffset, bin.byteLength);
  // eslint-disable-next-line functional/no-expression-statement
  view.setInt32(0, value, writeAsLittleEndian);
  return bin;
};
/**
 * Decode a 2-byte Int16LE Uint8Array into a number.
 *
 * Throws if `bin` is shorter than 2 bytes.
 *
 * @param bin - the Uint8Array to decode
 */
var binToNumberInt16LE = function binToNumberInt16LE(bin) {
  var view = new DataView(bin.buffer, bin.byteOffset, bin.byteLength);
  var readAsLittleEndian = true;
  return view.getInt16(0, readAsLittleEndian);
};
/**
 * Decode a 4-byte Int32LE Uint8Array into a number.
 *
 * Throws if `bin` is shorter than 4 bytes.
 *
 * @param bin - the Uint8Array to decode
 */
var binToNumberInt32LE = function binToNumberInt32LE(bin) {
  var view = new DataView(bin.buffer, bin.byteOffset, bin.byteLength);
  var readAsLittleEndian = true;
  return view.getInt32(0, readAsLittleEndian);
};
/**
 * Encode a positive integer as a 2-byte Uint16LE Uint8Array.
 *
 * This method will return an incorrect result for values outside of the range
 * `0` to `0xffff` (`65535`). If applicable, applications should handle such
 * cases prior to calling this method.
 *
 * @param value - the number to encode
 */
var numberToBinUint16BE = function numberToBinUint16BE(value) {
  var uint16Length = 2;
  var bin = new Uint8Array(uint16Length);
  var writeAsLittleEndian = false;
  var view = new DataView(bin.buffer, bin.byteOffset, bin.byteLength);
  // eslint-disable-next-line functional/no-expression-statement
  view.setUint16(0, value, writeAsLittleEndian);
  return bin;
};
/**
 * Encode a positive number as a 4-byte Uint32LE Uint8Array.
 *
 * This method will return an incorrect result for values outside of the range
 * `0` to `0xffffffff` (`4294967295`). If applicable, applications should handle
 * such cases prior to calling this method.
 *
 * @param value - the number to encode
 */
var numberToBinUint32LE = function numberToBinUint32LE(value) {
  var uint32Length = 4;
  var bin = new Uint8Array(uint32Length);
  var writeAsLittleEndian = true;
  var view = new DataView(bin.buffer, bin.byteOffset, bin.byteLength);
  // eslint-disable-next-line functional/no-expression-statement
  view.setUint32(0, value, writeAsLittleEndian);
  return bin;
};
/**
 * Encode a positive number as a 4-byte Uint32BE Uint8Array.
 *
 * This method will return an incorrect result for values outside of the range
 * `0` to `0xffffffff` (`4294967295`). If applicable, applications should handle
 * such cases prior to calling this method.
 *
 * @param value - the number to encode
 */
var numberToBinUint32BE = function numberToBinUint32BE(value) {
  var uint32Length = 4;
  var bin = new Uint8Array(uint32Length);
  var writeAsLittleEndian = false;
  var view = new DataView(bin.buffer, bin.byteOffset, bin.byteLength);
  // eslint-disable-next-line functional/no-expression-statement
  view.setUint32(0, value, writeAsLittleEndian);
  return bin;
};
/**
 * Encode a positive BigInt as little-endian Uint8Array. Negative values will
 * return the same result as `0`.
 *
 * @param value - the number to encode
 */
var bigIntToBinUintLE = function bigIntToBinUintLE(value) {
  var baseUint8Array = 256;
  var base = BigInt(baseUint8Array);
  var result = [];
  // eslint-disable-next-line functional/no-let
  var remaining = value;
  // eslint-disable-next-line functional/no-loop-statement
  while (remaining >= base) {
    // eslint-disable-next-line functional/no-expression-statement, functional/immutable-data
    result.push(Number(remaining % base));
    // eslint-disable-next-line functional/no-expression-statement
    remaining /= base;
  }
  // eslint-disable-next-line functional/no-conditional-statement, functional/no-expression-statement, functional/immutable-data
  if (remaining > 0n) result.push(Number(remaining));
  return Uint8Array.from(result.length > 0 ? result : [0]);
};
/**
 * Encode a positive BigInt as an 8-byte Uint64LE Uint8Array, clamping the
 * results – values exceeding `0xffff_ffff_ffff_ffff` (`18446744073709551615`)
 * return the same result as `0xffff_ffff_ffff_ffff`, negative values return the
 * same result as `0`.
 *
 * @param value - the number to encode
 */
var bigIntToBinUint64LEClamped = function bigIntToBinUint64LEClamped(value) {
  var uint64 = 8;
  return binToFixedLength(bigIntToBinUintLE(value), uint64);
};
/**
 * Encode a positive BigInt as an 8-byte Uint64LE Uint8Array.
 *
 * This method will return an incorrect result for values outside of the range
 * `0` to `0xffff_ffff_ffff_ffff` (`18446744073709551615`).
 *
 * @param value - the number to encode
 */
var bigIntToBinUint64LE = function bigIntToBinUint64LE(value) {
  var uint64LengthInBits = 64;
  var valueAsUint64 = BigInt.asUintN(uint64LengthInBits, value);
  var fixedLengthBin = bigIntToBinUint64LEClamped(valueAsUint64);
  return fixedLengthBin;
};
/**
 * Encode an integer as a 4-byte, little-endian Uint8Array using the number's
 * two's compliment representation (the format used by JavaScript's bitwise
 * operators).
 *
 * @remarks
 * The C++ bitcoin implementations sometimes represent short vectors using
 * signed 32-bit integers (e.g. `sighashType`). This method can be used to test
 * compatibility with those implementations.
 *
 * @param value - the number to encode
 */
var numberToBinInt32TwosCompliment = function numberToBinInt32TwosCompliment(value) {
  var bytes = 4;
  var bitsInAByte = 8;
  var bin = new Uint8Array(bytes);
  // eslint-disable-next-line functional/no-let, functional/no-loop-statement, no-plusplus
  for (var index = 0; index < bytes; index++) {
    // eslint-disable-next-line functional/no-expression-statement, functional/immutable-data
    bin[index] = value;
    // eslint-disable-next-line functional/no-expression-statement, no-bitwise, no-param-reassign
    value >>>= bitsInAByte;
  }
  return bin;
};
/**
 * Decode a little-endian Uint8Array of any length into a number. For numbers
 * larger than `Number.MAX_SAFE_INTEGER` (`9007199254740991`), use
 * `binToBigIntUintLE`.
 *
 * The `bytes` parameter can be set to constrain the expected length (default:
 * `bin.length`). This method throws if `bin.length` is not equal to `bytes`.
 *
 * @privateRemarks
 * We avoid a bitwise strategy here because JavaScript uses 32-bit signed
 * integers for bitwise math, so larger numbers are converted incorrectly. E.g.
 * `2147483648 << 8` is `0`, while `2147483648n << 8n` is `549755813888n`.
 *
 * @param bin - the Uint8Array to decode
 * @param bytes - the number of bytes to read (default: `bin.length`)
 */
var binToNumberUintLE = function binToNumberUintLE(bin) {
  var bytes = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : bin.length;
  var base = 2;
  var bitsInAByte = 8;
  if (bin.length !== bytes) {
    // eslint-disable-next-line functional/no-throw-statement
    throw new TypeError("Bin length must be ".concat(bytes, "."));
  }
  return new Uint8Array(bin.buffer, bin.byteOffset, bin.length).reduce(function (accumulated, byte, i) {
    return accumulated + byte * Math.pow(base, bitsInAByte * i);
  }, 0);
};
/**
 * Decode a 2-byte Uint16LE Uint8Array into a number.
 *
 * Throws if `bin` is shorter than 2 bytes.
 *
 * @param bin - the Uint8Array to decode
 */
var binToNumberUint16LE = function binToNumberUint16LE(bin) {
  var view = new DataView(bin.buffer, bin.byteOffset, bin.byteLength);
  var readAsLittleEndian = true;
  return view.getUint16(0, readAsLittleEndian);
};
/**
 * Decode a 4-byte Uint32LE Uint8Array into a number.
 *
 * Throws if `bin` is shorter than 4 bytes.
 *
 * @param bin - the Uint8Array to decode
 */
var binToNumberUint32LE = function binToNumberUint32LE(bin) {
  var view = new DataView(bin.buffer, bin.byteOffset, bin.byteLength);
  var readAsLittleEndian = true;
  return view.getUint32(0, readAsLittleEndian);
};
/**
 * Decode a big-endian Uint8Array of any length into a BigInt. If starting from
 * a hex value, consider using the BigInt constructor instead:
 * ```
 * BigInt(`0x${hex}`)
 * ```
 *
 * The `bytes` parameter can be set to constrain the expected length (default:
 * `bin.length`). This method throws if `bin.length` is not equal to `bytes`.
 *
 * @param bin - the Uint8Array to decode
 * @param bytes - the number of bytes to read (default: `bin.length`)
 */
var binToBigIntUintBE = function binToBigIntUintBE(bin) {
  var bytes = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : bin.length;
  var bitsInAByte = 8;
  var shift = BigInt(bitsInAByte);
  if (bin.length !== bytes) {
    // eslint-disable-next-line functional/no-throw-statement
    throw new TypeError("Bin length must be ".concat(bytes, "."));
  }
  return new Uint8Array(bin.buffer, bin.byteOffset, bin.length).reduce(
  // eslint-disable-next-line no-bitwise
  function (accumulated, byte) {
    return accumulated << shift | BigInt(byte);
  }, 0n);
};
/**
 * Decode an unsigned, 32-byte big-endian Uint8Array into a BigInt. This can be
 * used to decode Uint8Array-encoded cryptographic primitives like private
 * keys, public keys, curve parameters, and signature points.
 *
 * If starting from a hex value, consider using the BigInt constructor instead:
 * ```
 * BigInt(`0x${hex}`)
 * ```
 * @param bin - the Uint8Array to decode
 */
var binToBigIntUint256BE = function binToBigIntUint256BE(bin) {
  var uint256Bytes = 32;
  return binToBigIntUintBE(bin, uint256Bytes);
};
/**
 * Encode a positive BigInt into an unsigned 32-byte big-endian Uint8Array. This
 * can be used to encoded numbers for cryptographic primitives like private
 * keys, public keys, curve parameters, and signature points.
 *
 * Negative values will return the same result as `0`, values higher than
 * 2^256-1 will return the maximum expressible unsigned 256-bit value
 * (`0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff`).
 *
 * @param value - the BigInt to encode
 */
var bigIntToBinUint256BEClamped = function bigIntToBinUint256BEClamped(value) {
  var uint256Bytes = 32;
  return binToFixedLength(bigIntToBinUintLE(value), uint256Bytes).reverse();
};
/**
 * Decode a little-endian Uint8Array of any length into a BigInt.
 *
 * The `bytes` parameter can be set to constrain the expected length (default:
 * `bin.length`). This method throws if `bin.length` is not equal to `bytes`.
 *
 * @param bin - the Uint8Array to decode
 * @param bytes - the number of bytes to read (default: `bin.length`)
 */
var binToBigIntUintLE = function binToBigIntUintLE(bin) {
  var bytes = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : bin.length;
  var bitsInAByte = 8;
  if (bin.length !== bytes) {
    // eslint-disable-next-line functional/no-throw-statement
    throw new TypeError("Bin length must be ".concat(bytes, "."));
  }
  return new Uint8Array(bin.buffer, bin.byteOffset, bin.length).reduceRight(
  // eslint-disable-next-line no-bitwise
  function (accumulated, byte) {
    return accumulated << BigInt(bitsInAByte) | BigInt(byte);
  }, 0n);
};
/**
 * Decode an 8-byte Uint64LE Uint8Array into a BigInt.
 *
 * Throws if `bin` is shorter than 8 bytes.
 *
 * @param bin - the Uint8Array to decode
 */
var binToBigIntUint64LE = function binToBigIntUint64LE(bin) {
  var uint64LengthInBytes = 8;
  var truncatedBin = bin.length > uint64LengthInBytes ? bin.slice(0, uint64LengthInBytes) : bin;
  return binToBigIntUintLE(truncatedBin, uint64LengthInBytes);
};
/**
 * Decode an {@link Output.valueSatoshis} into a `BigInt`. This is an alias for
 * {@link binToBigIntUint64LE}.
 *
 * Throws if the provided value is shorter than 8 bytes.
 */
var binToValueSatoshis = binToBigIntUint64LE;
/**
 * Encode a `BigInt` into an {@link Output.valueSatoshis}. This is an alias for
 * {@link bigIntToBinUint64LE}.
 *
 * This method will return an incorrect result for values outside of the range 0
 * to 0xffff_ffff_ffff_ffff (`18446744073709551615`).
 */
var valueSatoshisToBin = bigIntToBinUint64LE;
/**
 * Get the expected byte length of a CompactSize given a first byte.
 *
 * @param firstByte - the first byte of the CompactSize
 */
var compactSizePrefixToSize = function compactSizePrefixToSize(firstByte) {
  switch (firstByte) {
    case 253 /* CompactSize.uint16Prefix */:
      return 2 /* CompactSize.uint16 */ + 1;
    case 254 /* CompactSize.uint32Prefix */:
      return 4 /* CompactSize.uint32 */ + 1;
    case 255 /* CompactSize.uint64Prefix */:
      return 8 /* CompactSize.uint64 */ + 1;
    default:
      return 1 /* CompactSize.uint8 */;
  }
};

var CompactSizeError;
(function (CompactSizeError) {
  CompactSizeError["noPrefix"] = "Error reading CompactSize: requires at least one byte.";
  CompactSizeError["insufficientBytes"] = "Error reading CompactSize: insufficient bytes.";
  CompactSizeError["nonMinimal"] = "Error reading CompactSize: CompactSize is not minimally encoded.";
  CompactSizeError["excessiveBytes"] = "Error decoding CompactSize: unexpected bytes after CompactSize.";
})(CompactSizeError || (CompactSizeError = {}));
/**
 * Read a non-minimally-encoded `CompactSize` (see {@link bigIntToCompactSize})
 * from the provided {@link ReadPosition}, returning either an error message (as
 * a string) or an object containing the value and the
 * next {@link ReadPosition}.
 *
 * Rather than this function, most applications should
 * use {@link readCompactSizeMinimal}.
 *
 * @param position - the {@link ReadPosition} at which to start reading the
 * `CompactSize`
 */
var readCompactSize = function readCompactSize(position) {
  var bin = position.bin,
    index = position.index;
  var prefix = bin[index];
  if (prefix === undefined) {
    return formatError$1(CompactSizeError.noPrefix);
  }
  var bytes = compactSizePrefixToSize(prefix);
  if (bin.length - index < bytes) {
    return formatError$1(CompactSizeError.insufficientBytes, "CompactSize prefix ".concat(prefix, " requires at least ").concat(bytes, " bytes. Remaining bytes: ").concat(bin.length - index));
  }
  var hasPrefix = bytes !== 1;
  var contents = hasPrefix ? bin.subarray(index + 1, index + bytes) : bin.subarray(index, index + bytes);
  return {
    position: {
      bin: bin,
      index: index + bytes
    },
    result: binToBigIntUintLE(contents)
  };
};
/**
 * Encode a positive BigInt as a `CompactSize` (Satoshi's variable-length,
 * positive integer format).
 *
 * Note: the maximum value of a CompactSize is `0xffff_ffff_ffff_ffff`
 * (`18446744073709551615`). This method will return an incorrect result for
 * values outside of the range `0` to `0xffff_ffff_ffff_ffff`. If applicable,
 * applications should handle such cases prior to calling this method.
 *
 * @param value - the BigInt to encode (must be no larger than
 * `0xffff_ffff_ffff_ffff`)
 */
var bigIntToCompactSize = function bigIntToCompactSize(value) {
  return value <= BigInt(252 /* CompactSize.uint8MaxValue */) ? Uint8Array.of(Number(value)) : value <= BigInt(65535 /* CompactSize.uint16MaxValue */) ? Uint8Array.from([253 /* CompactSize.uint16Prefix */].concat(_toConsumableArray(numberToBinUint16LE(Number(value))))) : value <= BigInt(4294967295 /* CompactSize.uint32MaxValue */) ? Uint8Array.from([254 /* CompactSize.uint32Prefix */].concat(_toConsumableArray(numberToBinUint32LE(Number(value))))) : Uint8Array.from([255 /* CompactSize.uint64Prefix */].concat(_toConsumableArray(bigIntToBinUint64LE(value))));
};
/**
 * Read a minimally-encoded `CompactSize` from the provided
 * {@link ReadPosition}, returning either an error message (as a string) or an
 * object containing the value and the next {@link ReadPosition}.
 *
 * @param position - the {@link ReadPosition} at which to start reading the
 * `CompactSize`
 */
var readCompactSizeMinimal = function readCompactSizeMinimal(position) {
  var read = readCompactSize(position);
  if (typeof read === 'string') {
    return read;
  }
  var readLength = read.position.index - position.index;
  var canonicalEncoding = bigIntToCompactSize(read.result);
  if (readLength !== canonicalEncoding.length) {
    return formatError$1(CompactSizeError.nonMinimal, "Value: ".concat(read.result.toString(), ", encoded length: ").concat(readLength, ", canonical length: ").concat(canonicalEncoding.length));
  }
  return read;
};
/**
 * Decode a minimally-encoded `CompactSize` (Satoshi's variable-length, positive
 * integer format) from a Uint8Array, returning the value as a BigInt. This
 * function returns an error if the entire input is not consumed – to read a
 * `CompactSize` from a position within a larger `Uint8Array`,
 * use {@link readCompactSizeMinimal} or {@link readCompactSize}.
 *
 * @param bin - the Uint8Array from which to read the CompactSize
 */
var compactSizeToBigInt = function compactSizeToBigInt(bin) {
  var read = readCompactSizeMinimal({
    bin: bin,
    index: 0
  });
  if (typeof read === 'string') {
    return read;
  }
  if (read.position.index !== bin.length) {
    return formatError$1(CompactSizeError.excessiveBytes, "CompactSize ends at index ".concat(read.position.index, ", but input includes ").concat(bin.length, " bytes."));
  }
  return read.result;
};
/**
 * Convert a signed integer into it's two's compliment unsigned equivalent, e.g.
 * `0b11111111111111111111111111111110` is `-2` as a signed integer or
 * `4294967294` as an unsigned integer.
 */
var int32SignedToUnsigned = function int32SignedToUnsigned(int32) {
  return (
    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
    Uint32Array.from(Int32Array.of(int32))[0]
  );
};
/**
 * Convert an unsigned integer into it's two's compliment signed equivalent,
 * e.g. `0b11111111111111111111111111111110` is `4294967294` as an unsigned
 * integer or `-2` as a signed integer.
 */
var int32UnsignedToSigned = function int32UnsignedToSigned(int32) {
  return (
    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
    Int32Array.from(Uint32Array.of(int32))[0]
  );
};

/**
 * Given an initial {@link ReadPosition} and a list of {@link ReadFunction}s,
 * apply each {@link ReadFunction} in order, aggregating each result and passing
 * the next {@link ReadPosition} into the next {@link ReadFunction}. If an error
 * occurs, immediately return the error message (`string`), otherwise, return
 * the array of results.
 *
 * @param position - the {@link ReadPosition} at which to start the first read
 * @param readFunctions - the ordered list of {@link ReadFunction}s to apply to
 * the {@link ReadPosition}
 */
var readMultiple = function readMultiple(position, readFunctions) {
  // eslint-disable-next-line functional/no-let
  var nextPosition = position;
  var results = [];
  // eslint-disable-next-line functional/no-loop-statement
  var _iterator = _createForOfIteratorHelper(readFunctions),
    _step;
  try {
    for (_iterator.s(); !(_step = _iterator.n()).done;) {
      var readFunction = _step.value;
      var out = readFunction(nextPosition);
      if (typeof out === 'string') {
        return out;
      }
      // eslint-disable-next-line functional/no-expression-statement, functional/immutable-data
      results.push(out.result);
      // eslint-disable-next-line functional/no-expression-statement
      nextPosition = out.position;
    }
  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }
  return {
    position: nextPosition,
    result: results
  };
};
var ReadItemCountError;
(function (ReadItemCountError) {
  ReadItemCountError["itemCount"] = "Error reading item count.";
  ReadItemCountError["item"] = "Error reading item.";
})(ReadItemCountError || (ReadItemCountError = {}));
/**
 * Read a count of items indicated by the CompactSize at {@link ReadPosition}.
 * The CompactSize will be read to determine the number of items, and the read
 * function will be applied in series, aggregated each result and passing the
 * next {@link ReadPosition} into each iteration. If an error occurs,
 * immediately return the error message (`string`), otherwise, return the array
 * of results.
 */
var readItemCount = function readItemCount(position, readFunction) {
  var countRead = readCompactSizeMinimal(position);
  if (typeof countRead === 'string') {
    return formatError$1(ReadItemCountError.itemCount, countRead);
  }
  // eslint-disable-next-line functional/no-let
  var nextPosition = countRead.position;
  var result = [];
  // eslint-disable-next-line functional/no-loop-statement, functional/no-let, no-plusplus
  for (var remaining = Number(countRead.result); remaining > 0; remaining--) {
    var read = readFunction(nextPosition);
    if (typeof read === 'string') {
      return formatError$1(ReadItemCountError.item, read);
    }
    // eslint-disable-next-line functional/no-expression-statement, functional/immutable-data
    result.push(read.result);
    // eslint-disable-next-line functional/no-expression-statement
    nextPosition = read.position;
  }
  return {
    position: nextPosition,
    result: result
  };
};

var msPerLocktimeSecond = 1000;
/**
 * The minimum Unix timestamp (inclusive) that can be encoded by a
 * transaction's `locktime`.
 */
var minimumLocktimeTimestamp = 500000000;
/**
 * The maximum Unix timestamp (inclusive) that can be encoded by a
 * transaction's `locktime`.
 */
var maximumLocktimeTimestamp = 0xffffffff;
/**
 * The minimum Date (inclusive) that can be encoded by a transaction's
 * `locktime`.
 */
var minimumLocktimeDate = new Date(minimumLocktimeTimestamp * msPerLocktimeSecond);
/**
 * The maximum Date (inclusive) that can be encoded by a transaction's
 * `locktime`.
 */
var maximumLocktimeDate = new Date(maximumLocktimeTimestamp * msPerLocktimeSecond);
var LocktimeError;
(function (LocktimeError) {
  LocktimeError["dateOutOfRange"] = "The provided Date is outside of the range that can be encoded in locktime.";
  LocktimeError["locktimeOutOfRange"] = "The provided locktime is outside of the range that can be encoded as a Date (greater than or equal to 500000000 and less than or equal to 4294967295).";
  LocktimeError["incorrectLength"] = "The provided locktime is not the correct length (4 bytes).";
})(LocktimeError || (LocktimeError = {}));
/**
 * Convert a JavaScript `Date` object to its equivalent transaction `locktime`
 * representation. The `date` is rounded to the nearest second (the precision of
 * `locktime` Dates).
 *
 * Note, a locktime values greater than or equal to `500000000`
 * See {@link Transaction.locktime} for details.
 *
 * @param date - the Date to convert to a locktime number
 */
var dateToLocktime = function dateToLocktime(date) {
  return date < minimumLocktimeDate || date > maximumLocktimeDate ? LocktimeError.dateOutOfRange : Math.round(date.getTime() / msPerLocktimeSecond);
};
/**
 * Convert a transaction `locktime` to its equivalent JavaScript `Date` object.
 * If locktime is outside the possible range (greater than or equal to
 * `500000000` and less than or equal to `4294967295`), an error message is
 * returned.
 *
 * @param locktime - a positive integer between `500000000` and `4294967295`,
 * inclusive
 */
var locktimeToDate = function locktimeToDate(locktime) {
  return locktime < minimumLocktimeTimestamp || locktime > maximumLocktimeTimestamp ? LocktimeError.locktimeOutOfRange : new Date(locktime * msPerLocktimeSecond);
};
/**
 * Convert a JavaScript `Date` object to its equivalent transaction `locktime`
 * bytecode representation. The `date` is rounded to the nearest second (the
 * precision of `locktime` Dates).
 *
 * Note: a block-based locktime can simply be encoded with
 * {@link numberToBinUint32LE} (provided it is no larger than the
 * maximum, `499999999`).
 *
 * @param date - the Date to convert to a locktime Uint8Array
 */
var dateToLocktimeBin = function dateToLocktimeBin(date) {
  var result = dateToLocktime(date);
  return typeof result === 'string' ? result : numberToBinUint32LE(result);
};
var locktimeByteLength = 4;
/**
 * Decode a locktime, returning a `number` for block heights, a `Date` for block
 * times, or a string for parsing errors.
 *
 * @param bin - the 4-byte Uint8Array locktime to parse
 */
var decodeLocktime = function decodeLocktime(bin) {
  if (bin.length !== locktimeByteLength) return LocktimeError.incorrectLength;
  var parsed = binToNumberUint32LE(bin);
  return parsed >= minimumLocktimeTimestamp ? new Date(parsed * msPerLocktimeSecond) : parsed;
};

var utf8Encoder = new TextEncoder();
/**
 * Interpret a string as UTF-8 and encode it as a Uint8Array.
 * @param utf8 - the string to encode
 */
var utf8ToBin = function utf8ToBin(utf8) {
  return utf8Encoder.encode(utf8);
};
var utf8Decoder = new TextDecoder();
/**
 * Decode a Uint8Array as a UTF-8 string.
 * @param bytes - the Uint8Array to decode
 */
var binToUtf8 = function binToUtf8(bytes) {
  return utf8Decoder.decode(bytes);
};

/* eslint-disable functional/no-conditional-statement, functional/no-let, functional/no-expression-statement, no-underscore-dangle, functional/no-try-statement, @typescript-eslint/no-magic-numbers, max-params, @typescript-eslint/no-unsafe-call, @typescript-eslint/no-unsafe-member-access, @typescript-eslint/no-unsafe-assignment, @typescript-eslint/no-non-null-assertion */
/**
 * Note, most of this method is translated and boiled-down from the wasm-pack
 * workflow. Significant changes to wasm-bindgen or wasm-pack build will likely
 * require modifications to this method.
 */
var instantiateRustWasm = /*#__PURE__*/function () {
  var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(webassemblyBytes, expectedImportModuleName, hashExportName, initExportName, updateExportName, finalExportName) {
    var wasm, cachedUint8Memory, cachedUint32Memory, cachedGlobalArgumentPtr, globalArgumentPtr, getUint8Memory, getUint32Memory, passArray8ToWasm, getArrayU8FromWasm, hash, init, update, final;
    return _regeneratorRuntime().wrap(function _callee$(_context) {
      while (1) switch (_context.prev = _context.next) {
        case 0:
          getUint8Memory = function _getUint8Memory() {
            if (cachedUint8Memory === undefined || cachedUint8Memory.buffer !== wasm.memory.buffer) {
              // eslint-disable-next-line @typescript-eslint/no-unsafe-argument
              cachedUint8Memory = new Uint8Array(wasm.memory.buffer);
            }
            return cachedUint8Memory;
          };
          _context.next = 3;
          return WebAssembly.instantiate(webassemblyBytes, _defineProperty({}, expectedImportModuleName, {
            /**
             * This would only be called in cases where a `__wbindgen_malloc` failed.
             * Since `__wbindgen_malloc` isn't exposed to consumers, this error
             * can only be encountered if the code below is broken.
             */
            // eslint-disable-next-line camelcase, @typescript-eslint/naming-convention
            __wbindgen_throw: /* istanbul ignore next */function __wbindgen_throw(ptr, len) {
              // eslint-disable-next-line functional/no-throw-statement
              throw new Error(
              // eslint-disable-next-line @typescript-eslint/no-use-before-define
              Array.from(getUint8Memory().subarray(ptr, ptr + len)).map(function (num) {
                return String.fromCharCode(num);
              }).join(''));
            }
          }));
        case 3:
          wasm = _context.sent.instance.exports;
          // eslint-disable-line @typescript-eslint/init-declarations
          globalArgumentPtr = function globalArgumentPtr() {
            if (cachedGlobalArgumentPtr === undefined) {
              cachedGlobalArgumentPtr = wasm.__wbindgen_global_argument_ptr();
            }
            return cachedGlobalArgumentPtr;
          };
          /**
           * Must be hoisted for `__wbindgen_throw`.
           */
          // eslint-disable-next-line func-style
          getUint32Memory = function getUint32Memory() {
            if (cachedUint32Memory === undefined || cachedUint32Memory.buffer !== wasm.memory.buffer) {
              // eslint-disable-next-line @typescript-eslint/no-unsafe-argument
              cachedUint32Memory = new Uint32Array(wasm.memory.buffer);
            }
            return cachedUint32Memory;
          };
          passArray8ToWasm = function passArray8ToWasm(array) {
            var ptr = wasm.__wbindgen_malloc(array.length);
            getUint8Memory().set(array, ptr);
            return [ptr, array.length];
          };
          getArrayU8FromWasm = function getArrayU8FromWasm(ptr, len) {
            return getUint8Memory().subarray(ptr, ptr + len);
          };
          hash = function hash(input) {
            var _passArray8ToWasm = passArray8ToWasm(input),
              _passArray8ToWasm2 = _slicedToArray(_passArray8ToWasm, 2),
              ptr0 = _passArray8ToWasm2[0],
              len0 = _passArray8ToWasm2[1];
            var retPtr = globalArgumentPtr();
            try {
              wasm[hashExportName](retPtr, ptr0, len0);
              var mem = getUint32Memory();
              var ptr = mem[retPtr / 4];
              var len = mem[retPtr / 4 + 1];
              var realRet = getArrayU8FromWasm(ptr, len).slice();
              wasm.__wbindgen_free(ptr, len);
              return realRet;
            } finally {
              wasm.__wbindgen_free(ptr0, len0);
            }
          };
          init = function init() {
            var retPtr = globalArgumentPtr();
            wasm[initExportName](retPtr);
            var mem = getUint32Memory();
            var ptr = mem[retPtr / 4];
            var len = mem[retPtr / 4 + 1];
            var realRet = getArrayU8FromWasm(ptr, len).slice();
            wasm.__wbindgen_free(ptr, len);
            return realRet;
          };
          update = function update(rawState, input) {
            var _passArray8ToWasm3 = passArray8ToWasm(rawState),
              _passArray8ToWasm4 = _slicedToArray(_passArray8ToWasm3, 2),
              ptr0 = _passArray8ToWasm4[0],
              len0 = _passArray8ToWasm4[1];
            var _passArray8ToWasm5 = passArray8ToWasm(input),
              _passArray8ToWasm6 = _slicedToArray(_passArray8ToWasm5, 2),
              ptr1 = _passArray8ToWasm6[0],
              len1 = _passArray8ToWasm6[1];
            var retPtr = globalArgumentPtr();
            try {
              wasm[updateExportName](retPtr, ptr0, len0, ptr1, len1);
              var mem = getUint32Memory();
              var ptr = mem[retPtr / 4];
              var len = mem[retPtr / 4 + 1];
              var realRet = getArrayU8FromWasm(ptr, len).slice();
              wasm.__wbindgen_free(ptr, len);
              return realRet;
            } finally {
              rawState.set(getUint8Memory().subarray(ptr0 / 1, ptr0 / 1 + len0));
              wasm.__wbindgen_free(ptr0, len0);
              wasm.__wbindgen_free(ptr1, len1);
            }
          };
          final = function final(rawState) {
            var _passArray8ToWasm7 = passArray8ToWasm(rawState),
              _passArray8ToWasm8 = _slicedToArray(_passArray8ToWasm7, 2),
              ptr0 = _passArray8ToWasm8[0],
              len0 = _passArray8ToWasm8[1];
            var retPtr = globalArgumentPtr();
            try {
              wasm[finalExportName](retPtr, ptr0, len0);
              var mem = getUint32Memory();
              var ptr = mem[retPtr / 4];
              var len = mem[retPtr / 4 + 1];
              var realRet = getArrayU8FromWasm(ptr, len).slice();
              wasm.__wbindgen_free(ptr, len);
              return realRet;
            } finally {
              rawState.set(getUint8Memory().subarray(ptr0 / 1, ptr0 / 1 + len0));
              wasm.__wbindgen_free(ptr0, len0);
            }
          };
          return _context.abrupt("return", {
            final: final,
            hash: hash,
            init: init,
            update: update
          });
        case 13:
        case "end":
          return _context.stop();
      }
    }, _callee);
  }));
  return function instantiateRustWasm(_x, _x2, _x3, _x4, _x5, _x6) {
    return _ref.apply(this, arguments);
  };
}();
/* eslint-enable functional/no-conditional-statement, functional/no-let, functional/no-expression-statement, no-underscore-dangle, functional/no-try-statement, @typescript-eslint/no-magic-numbers, max-params, @typescript-eslint/no-unsafe-call, @typescript-eslint/no-unsafe-member-access, @typescript-eslint/no-unsafe-assignment, @typescript-eslint/no-non-null-assertion */

/* eslint-disable tsdoc/syntax */
/**
 * @hidden
 */
// prettier-ignore
var ripemd160Base64Bytes = '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AgQMBQsgAEH8EigCACACaiICQQFyNgIEQYQTIAA2AgBB/BIgAjYCACAAIAJqIAI2AgAMBAsgAxAgDAELQewPQewPKAIAQX4gAUEDdndxNgIACyAEIAJqIQIgAyAEaiEDCyADIAMoAgRBfnE2AgQgACACQQFyNgIEIAAgAmogAjYCAAJ/AkAgAkH/AU0EQCACQQN2IgFBA3RB9A9qIQJB7A8oAgAiA0EBIAFBH3F0IgFxRQ0BIAJBCGohAyACKAIIDAILIAAgAhAhDAILQewPIAMgAXI2AgAgAkEIaiEDIAILIQEgAyAANgIAIAEgADYCDCAAIAI2AgwgACABNgIICyAFQQhqDwtBgBMgACACayIBNgIAQYgTQYgTKAIAIgAgAmoiAzYCACADIAFBAXI2AgQgACACQQNyNgIEIABBCGoLpQEBAn9BAiEFAkACQAJAAkACQCAAKAIEIgYgAWsgAk8NACABIAJqIgIgAUkhAQJAIAQEQEEAIQUgAQ0CIAZBAXQiASACIAIgAUkbIQIMAQtBACEFIAENAQsgAkEASA0AIAZFDQEgACgCACACEBMiAUUNAgwDCyAFDwsgAhAEIgENAQsgAw0BCyABBEAgACABNgIAIABBBGogAjYCAEECDwtBAQ8LAAsIAEGMFBAHAAtmAgF/A34jAEEwayIBJAAgACkCECECIAApAgghAyAAKQIAIQQgAUEUakEANgIAIAEgBDcDGCABQgE3AgQgAUH0DDYCECABIAFBGGo2AgAgASADNwMgIAEgAjcDKCABIAFBIGoQJQALuAEBAX8jAEHgAWsiAyQAIANBOGpBzAgoAgA2AgAgA0EwakHECCkCADcDACADQgA3AyAgA0G8CCkCADcDKCADQTxqQQBBxAAQKhogA0EgaiABIAIQCSADQYABaiADQSBqQeAAECgaIANBCGogA0GAAWoQCiADQSBqIANBCGpBFBADIANBiAFqIANBKGooAgA2AgAgAyADKQMgNwOAASADIANBgAFqEAsgACADKQMANwIAIANB4AFqJAALlwMBBH8jAEFAaiIDJAAgACAAKQMAIAKtfDcDACADIABBCGo2AiggAyADQShqNgIsAkACQAJAAkACQAJAIAAoAhwiBQRAQcAAIAVrIgQgAk0NASADQRhqIAUgBSACaiIEIABBIGoQFiADKAIcIAJHDQUgAygCGCABIAIQKBoMAwsgAiEEDAELIANBMGogASACIAQQFyADQTxqKAIAIQQgAygCOCEBIAMoAjAhBSADKAI0IQIgA0EgaiAAQSBqIgYgACgCHBAYIAIgAygCJEcNBCADKAIgIAUgAhAoGiAAQRxqQQA2AgAgA0EsaiAGEBkLIANBPGohAiADQThqIQUCQANAIARBP00NASADQTBqIAEgBEHAABAXIAIoAgAhBCAFKAIAIQEgA0EIakEAQcAAIAMoAjAgAygCNBAaIANBLGogAygCCBAZDAALAAsgA0EQaiAAQSBqIAQQGyADKAIUIARHDQEgAygCECABIAQQKBoLIABBHGogBDYCACADQUBrJAAPC0H0ExAHAAtB9BMQBwALQfQTEAcAC+MCAgR/AX4jAEFAaiICJAAgAiABQQhqIgU2AiQgASkDACEGIAEoAhwhAyACIAJBJGo2AigCQCADQT9NBEAgAUEgaiIEIANqQYABOgAAIAEgASgCHEEBaiIDNgIcIAJBGGogBCADEBggAigCGEEAIAIoAhwQKhpBwAAgASgCHGtBB00EQCACQShqIAQQGSACQRBqIAQgAUEcaigCABAbIAIoAhBBACACKAIUECoaCyACQQhqIARBOBAYIAIoAgxBCEcNASACKAIIIAZCA4Y3AAAgAkEoaiAEEBkgAUEcakEANgIAIAJBADYCKEEEIQECQANAIAFBGEYNASACQShqIAFqQQA6AAAgAiACKAIoQQFqNgIoIAFBAWohAQwACwALIAAgBSkAADcAACAAQRBqIAVBEGooAAA2AAAgAEEIaiAFQQhqKQAANwAAIAJBQGskAA8LQcwTIANBwAAQHQALQdwTEAcAC2MBAn8gASgCACECAkACQCABKAIEIgMgASgCCCIBRgRAIAMhAQwBCyADIAFJDQEgAQRAIAIgARATIgINAQALIAIgAxARQQEhAkEAIQELIAAgATYCBCAAIAI2AgAPC0G0ExAHAAuQAQEBfyMAQYABayIBJAAgAUEwakHECCkCADcDACABQThqQcwIKAIANgIAIAFCADcDICABQbwIKQIANwMoIAFBPGpBAEHEABAqGiABQRBqIAFBIGpB4AAQAyABQShqIAFBGGooAgA2AgAgASABKQMQNwMgIAFBCGogAUEgahALIAAgASkDCDcCACABQYABaiQAC4YB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';

// cSpell:ignore noncefp, ndata, outputlen
/**
 * bitflags used in secp256k1's public API (translated from secp256k1.h)
 */
/* eslint-disable no-bitwise, @typescript-eslint/no-magic-numbers, @typescript-eslint/prefer-literal-enum-member */
/** All flags' lower 8 bits indicate what they're for. Do not use directly. */
// const SECP256K1_FLAGS_TYPE_MASK = (1 << 8) - 1;
var SECP256K1_FLAGS_TYPE_CONTEXT = 1 << 0;
var SECP256K1_FLAGS_TYPE_COMPRESSION = 1 << 1;
/** The higher bits contain the actual data. Do not use directly. */
var SECP256K1_FLAGS_BIT_CONTEXT_VERIFY = 1 << 8;
var SECP256K1_FLAGS_BIT_CONTEXT_SIGN = 1 << 9;
var SECP256K1_FLAGS_BIT_COMPRESSION = 1 << 8;
/** Flags to pass to secp256k1_context_create. */
var SECP256K1_CONTEXT_VERIFY = SECP256K1_FLAGS_TYPE_CONTEXT | SECP256K1_FLAGS_BIT_CONTEXT_VERIFY;
var SECP256K1_CONTEXT_SIGN = SECP256K1_FLAGS_TYPE_CONTEXT | SECP256K1_FLAGS_BIT_CONTEXT_SIGN;
var SECP256K1_CONTEXT_NONE = SECP256K1_FLAGS_TYPE_CONTEXT;
/** Flag to pass to secp256k1_ec_pubkey_serialize and secp256k1_ec_privkey_export. */
var SECP256K1_EC_COMPRESSED = SECP256K1_FLAGS_TYPE_COMPRESSION | SECP256K1_FLAGS_BIT_COMPRESSION;
var SECP256K1_EC_UNCOMPRESSED = SECP256K1_FLAGS_TYPE_COMPRESSION;
/**
 * Flag to pass to a Secp256k1.contextCreate method.
 *
 * The purpose of context structures is to cache large precomputed data tables
 * that are expensive to construct, and also to maintain the randomization data
 * for blinding.
 *
 * You can create a context with only VERIFY or only SIGN capabilities, or you
 * can use BOTH. (NONE can be used for conversion/serialization.)
 */
var ContextFlag;
(function (ContextFlag) {
  ContextFlag[ContextFlag["NONE"] = SECP256K1_CONTEXT_NONE] = "NONE";
  ContextFlag[ContextFlag["VERIFY"] = SECP256K1_CONTEXT_VERIFY] = "VERIFY";
  ContextFlag[ContextFlag["SIGN"] = SECP256K1_CONTEXT_SIGN] = "SIGN";
  ContextFlag[ContextFlag["BOTH"] = SECP256K1_CONTEXT_SIGN | SECP256K1_CONTEXT_VERIFY] = "BOTH";
})(ContextFlag || (ContextFlag = {}));
/**
 * Flag to pass a Secp256k1 public key serialization method.
 *
 * You can indicate COMPRESSED (33 bytes, header byte 0x02 or 0x03) or
 * UNCOMPRESSED (65 bytes, header byte 0x04) format.
 */
var CompressionFlag;
(function (CompressionFlag) {
  CompressionFlag[CompressionFlag["COMPRESSED"] = SECP256K1_EC_COMPRESSED] = "COMPRESSED";
  CompressionFlag[CompressionFlag["UNCOMPRESSED"] = SECP256K1_EC_UNCOMPRESSED] = "UNCOMPRESSED";
})(CompressionFlag || (CompressionFlag = {}));

/* eslint-disable tsdoc/syntax */
/**
 * @hidden
 */
// prettier-ignore
var secp256k1Base64Bytes = 'AGFzbQEAAAABXg5gAn9/AGAGf39/f39/AX9gAX8AYAABf2AAAGADf39/AX9gAX8Bf2ACf38Bf2AEf39/fwF/YAV/f39/fwF/YAN/f38AYAd/f39/f39/AX9gBH9/f38AYAV/f39/fwAC5wEMA2VudgZtZW1vcnkCAYACgAIDZW52BXRhYmxlAXABBgYDZW52CXRhYmxlQmFzZQN/AANlbnYORFlOQU1JQ1RPUF9QVFIDfwADZW52CFNUQUNLVE9QA38AA2VudgVhYm9ydAACA2Vudg1lbmxhcmdlTWVtb3J5AAMDZW52DmdldFRvdGFsTWVtb3J5AAMDZW52F2Fib3J0T25DYW5ub3RHcm93TWVtb3J5AAMDZW52C19fX3NldEVyck5vAAIDZW52Bl9hYm9ydAAEA2VudhZfZW1zY3JpcHRlbl9tZW1jcHlfYmlnAAUDSUgAAAYKBQAKCgIMAAYABwACBgUNCgAKAAoAAAcHAAAAAgYMCgoFAAUFAAULAQYFAwcBCAgBCAgKBwUFBQUHAQEIBQUFCAUICQgGCwJ/ASMBC38BIwILB/QGGxFfX19lcnJub19sb2NhdGlvbgA1BV9mcmVlACYHX21hbGxvYwAnGV9zZWNwMjU2azFfY29udGV4dF9jcmVhdGUAMxxfc2VjcDI1NmsxX2NvbnRleHRfcmFuZG9taXplAD4fX3NlY3AyNTZrMV9lY19wcml2a2V5X3R3ZWFrX2FkZABCH19zZWNwMjU2azFfZWNfcHJpdmtleV90d2Vha19tdWwAQBtfc2VjcDI1NmsxX2VjX3B1YmtleV9jcmVhdGUAMBpfc2VjcDI1NmsxX2VjX3B1YmtleV9wYXJzZQBOHl9zZWNwMjU2azFfZWNfcHVia2V5X3NlcmlhbGl6ZQBNHl9zZWNwMjU2azFfZWNfcHVia2V5X3R3ZWFrX2FkZABBHl9zZWNwMjU2azFfZWNfcHVia2V5X3R3ZWFrX211bAA/G19zZWNwMjU2azFfZWNfc2Vja2V5X3ZlcmlmeQBDGF9zZWNwMjU2azFfZWNkc2FfcmVjb3ZlcgA5NF9zZWNwMjU2azFfZWNkc2FfcmVjb3ZlcmFibGVfc2lnbmF0dXJlX3BhcnNlX2NvbXBhY3QAPDhfc2VjcDI1NmsxX2VjZHNhX3JlY292ZXJhYmxlX3NpZ25h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iCEuIAogLadJIAkgLKdJaiALICinSWogISAbRXFqIBkgE0VxaiAaIBRFcWogDiAbSWogByATSWogBSAUSWogECAISWogESAGSSAqQgGGpyIJciAiaiITaiIOIBIgBEkgK0IBhqciCnIgF2oiFGoiByAMIANJICVCAYanIgtyIBVqIhBqIgUgDSACSSAkQgGGpyIIciAWaiIRaiIGICOnIgRBAXQiEmoiASASSSEZIB8oAgCtICd+IiNCIIghLCABICOnIgNBAXQiDGoiASAMSSEaIBgoAgCtICZ+IiNCIIghKCABICOnIgJBAXQiDWoiASANSSEbIAogK6dJIAkgKqdJaiALICWnSWogCCAkp0lqICIgE0VxaiAOIBNJaiAXIBRFcWogByAUSWogFSAQRXFqIAUgEElqIBYgEUVxaiAGIBFJaiASIARJIC5CAYanIg5yIBlqIhVqIgogDCADSSAsQgGGpyIHciAaaiIWaiILIA0gAkkgKEIBhqciBXIgG2oiEGoiCCABIB4oAgCtIiQgJH4iI6ciAmoiASACSSAjQiCIp2oiBmohESAPIAE2AiAgICgCAK0iKSAcKAIArX4iI0IgiCEtIBEgI6ciBEEBdCIMaiIBIAxJIRMgHygCAK0iJyAdKAIArSImfiIjQiCIISogASAjpyIDQQF0Ig1qIgEgDUkhFCAYKAIArSIlICR+IiNCIIghJCABICOnIgJBAXQiCWoiASAJSSESIA8gATYCJCApICZ+IiNCIIghKyAHICynSSAOIC6nSWogBSAop0lqIBkgFUVxaiAaIBZFcWogGyAQRXFqIAogFUlqIAsgFklqIAggEElqIBEgBklqIAwgBEkgLUIBhqciB3IgE2oiDGoiCyANIANJICpCAYanIgVyIBRqIg1qIgggCSACSSAkQgGGpyIGciASaiIJaiIEICOnIgNBAXQiDmoiASAOSSEQICcgHigCAK0iJn4iI0IgiCEoIAEgI6ciAkEBdCIKaiIBIApJIREgBSAqp0kgByAtp0lqIAYgJKdJaiATIAxFcWogCyAMSWogFCANRXFqIAggDUlqIBIgCUVxaiAEIAlJaiAOIANJICtCAYanIgtyIBBqIhJqIgUgCiACSSAoQgGGpyIIciARaiIMaiIGIAEgJSAlfiIjpyICaiIBIAJJICNCIIinaiIEaiENIA8g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QUBrIAJB////H3EiAkHRB2pBGnZqQf///x9LIAYgAXEgB3EgCHEgBEH///8fcSIEcSAJcSALcUH///8fRiAFQf///wFGcXFyIgprQdEHcSACaiECIApBBnQgA2ogAkEadmoiA0EadiABQf///x9xaiIKQRp2IAZB////H3FqIgZBGnYgB0H///8fcWoiB0EadiAIQf///x9xaiIIQRp2IARqIgRBGnYgCUH///8fcWoiCUEadiALQf///x9xaiEBIAAgAkH///8fcTYCACANIANB////H3E2AgAgDiAKQf///x9xNgIAIA8gBkH///8fcTYCACAQIAdB////H3E2AgAgESAIQf///x9xNgIAIBIgBEH///8fcTYCACATIAlB////H3E2AgAgFCABQf///x9xNgIAIAwgAUEadiAFakH///8BcTYCAAuhFwEnfyMEIQQjBEHAA2okBCACKAJQIQYgASgCeARAIAAgBjYCeCAAIAIpAgA3AgAgACACKQIINwIIIAAgAikCEDcCECAAIAIpAhg3AhggACACKQIgNwIgIABBKGoiAyACQShqIgEpAgA3AgAgAyABKQIINwIIIAMgASkCEDcCECADIAEpAhg3AhggAyABKQIgNwIgIABBATYCUCAAQdQAaiIAQgA3AgAgAEIANwIIIABCADcCECAAQgA3AhggAEEANgIgIAQkBA8LIAYEQCADBEAgA0EBNgIAIANBBGoiAkIANwIAIAJCADcCCCACQgA3AhAgAkIANwIYIAJBADYCIAsgACABKQIANwIAIAAgASkCCDcCCCAAIAEpAhA3AhAgACABKQIYNwIYIAAgASkCIDcCICAAIAEpAig3AiggACABKQIwNwIwIAAgASkCODcCOCAAQUBrIAFBQGspAgA3AgAgACABKQJINwJIIAAgASkCUDcCUCAAIAEpAlg3AlggACABKQJgNwJgIAAgASkCaDcCaCAAIAEpAnA3AnAgACABKAJ4NgJ4IAQkBA8LIARB+ABqIQwgBEHQAGohJCAEQShqIQogAEH4AGoiKUEANgIAIARBkANqIiUgAUHQAGoiJhAHIARB6AJqIgggASkCADcCACAIIAEpAgg3AgggCCABKQIQNwIQIAggASkCGDcCGCAIIAEpAiA3AiAgCEEkaiIdKAIAIhNBFnYiBkHRB2wgCCgCAGohGyAGQQZ0IAhBBGoiFygCAGogG0EadmoiGEEadiAIQQhqIhkoAgBqIhpBGnYgCEEMaiIFKAIAaiIHQRp2IAhBEGoiDSgCAGoiFEEadiAIQRRqIhUoAgBqIg5BGnYgCEEYaiIPKAIAaiIQQRp2IAhBHGoiESgCAGoiEkEadiAIQSBqIgYoAgBqIRwgCCAbQf///x9xIio2AgAgFyAYQf///x9xIgs2AgAgGSAaQf///x9xIh42AgAgBSAHQf///x9xIh82AgAgDSAUQf///x9xIiA2AgAgFSAOQf///x9xIiE2AgAgDyAQQf///x9xIiI2AgAgESASQf///x9xIiM2AgAgBiAcQf///x9xIhs2AgAgHSAcQRp2IBNB////AXFqIhw2AgAgBEHAAmoiFiACICUQCiAEQZgCaiIJIAFBKGoiBikCADcCACAJIAYpAgg3AgggCSAGKQIQNwIQIAkgBikCGDcCGCAJIAYpAiA3AiAgCUEkaiInKAIAIh1BFnYiBkHRB2wgCSgCAGohDSAGQQZ0IAlBBGoiEygCAGogDUEadmoiFEEadiAJQQhqIhcoAgBqIhVBGnYgCUEMaiIYKAIAaiIOQRp2IAlBEGoiGSgCAGoiD0EadiAJQRRqIhooAgBqIhBBGnYgCUEYaiIFKAIAaiIRQRp2IAlBHGoiBygCAGoiEkEadiAJQSBqIgYoAgBqISggCSANQf///x9xIg02AgAgEyAUQf///x9xIhQ2AgAgFyAVQf///x9xIhU2AgAgGCAOQf///x9xIg42AgAgGSAPQf///x9xIg82AgAgGiAQQf///x9xIhA2AgAgBSARQf///x9xIhE2AgAgByASQf///x9xIhI2AgAgBiAoQf///x9xIgY2AgAgJyAoQRp2IB1B////AXFqNgIAIARB8AFqIgcgAkEoaiAlEAogByAHICYQCiAEQcgBaiIFQbzh//8AICprIBYoAgBqNgIAIAVB/P3//wAgC2sgFigCBGo2AgQgBUH8////ACAeayAWKAIIajYCCCAFQfz///8AIB9rIBYoAgxqNgIMIAVB/P///wAgIGsgFigCEGo2AhAgBUH8////ACAhayAWKAIUajYCFCAFQfz///8AICJrIBYoAhhqNgIYIAVB/P///wAgI2sgFigCHGo2AhwgBUH8////ACAbayAWKAIgajYCICAFQfz//wcgHGsgFigCJGo2AiRB/P//ByAnKAIAayECIARBoAFqIgtBvOH//wAgDWsgBygCAGo2AgAgC0H8/f//ACAUayAHKAIEajYCBCALQfz///8AIBVrIAcoAghqNgIIIAtB/P///wAgDmsgBygCDGo2AgwgC0H8////ACAPayAHKAIQajYCECALQfz///8AIBBrIAcoAhRqNgIUIAtB/P///wAgEWsgBygCGGo2AhggC0H8////ACASayAHKAIcajYCHCALQfz///8AIAZrIAcoAiBqNgIgIAsgAiAHKAIkajYCJCAFEBdFBEAgDCALEAcgJCAFEAcgCiAFICQQCiADBEAgAyAFKQIANwIAIAMgBSkCCDcCCCADIAUpAhA3AhAgAyAFKQIYNwIYIAMgBSkCIDcCIAsgAEHQAGogJiAFEAogBCAIICQQCiAAIAQpAgA3AgAgACAEKQIINwIIIAAgBCkCEDcCECAAIAQpAhg3AhggACAEKQIgNwIgQfj7//8BIABBBGoiEygCAEEBdCAKQQRqIh4oAgBqayEOQfj///8BIABBCGoiFygCAEEBdCAKQQhqIh8oAgBqayEPQfj///8BIABBDGoiGCgCAEEBdCAKQQxqIiAoAgBqayEQQfj///8BIABBEGoiGSgCAEEBdCAKQRBqIiEoAgBqayERQfj///8BIABBFGoiGigCAEEBdCAKQRRqIiIoAgBqayESQfj///8BIABBGGoiBSgCAEEBdCAKQRhqIiMoAgBqayEGQfj///8BIABBHGoiBygCAEEBdCAKQRxqIhsoAgBqayEDQfj///8BIABBIGoiDSgCAEEBdCAKQSBqIhwoAgBqayECQfj//w8gAEEkaiIUKAIAQQF0IApBJGoiHSgCAGprIQEgAEH4wv//ASAAKAIAQQF0IAooAgBqayAMKAIAaiIVNgIAIBMgDiAMKAIEaiIONgIAIBcgDyAMKAIIaiIPNgIAIBggECAMKAIMaiIQNgIAIBkgESAMKAIQaiIRNgIAIBogEiAMKAIUaiISNgIAIAUgBiAMKAIYaiIGNgIAIAcgAyAMKAIcaiIDNgIAIA0gAiAMKAIgaiICNgIAIBQgASAMKAIkaiIBNgIAIABBKGoiE0G0pP//AiAVayAEKAIAajYCACAAQSxqIhdB9Pn//wIgDmsgBCgCBGo2AgAgAEEwaiIYQfT///8CIA9rIAQoAghqNgIAIABBNGoiGUH0////AiAQayAEKAIMajYCACAAQThqIhpB9P///wIgEWsgBCgCEGo2AgAgAEE8aiIFQfT///8CIBJrIAQoAhRqNgIAIABBQGsiB0H0////AiAGayAEKAIYajYCACAAQcQAaiINQfT///8CIANrIAQoAhxqNgIAIABByABqIhRB9P///wIgAmsgBCgCIGo2AgAgAEHMAGoiFUH0//8XIAFrIAQoAiRqNgIAIBMgEyALEAogCiAKIAkQCiAKQbzh//8AIAooAgBrIg42AgAgHkH8/f//ACAeKAIAayIPNgIAIB9B/P///wAgHygCAGsiEDYCACAgQfz///8AICAoAgBrIhE2AgAgIUH8////ACAhKAIAayISNgIAICJB/P///wAgIigCAGsiBjYCACAjQfz///8AICMoAgBrIgM2AgAgG0H8////ACAbKAIAayICNgIAIBxB/P///wAgHCgCAGsiATYCACAdQfz//wcgHSgCAGsiADYCACATIBMoAgAgDmo2AgAgFyAXKAIAIA9qNgIAIBggGCgCACAQajYCACAZIBkoAgAgEWo2AgAgGiAaKAIAIBJqNgIAIAUgBSgCACAGajYCACAHIAcoAgAgA2o2AgAgDSANKAIAIAJqNgIAIBQgFCgCACABajYCACAVIBUoAgAgAGo2AgAgBCQEDwsgCxAXBEAgACABIAMQGiAEJAQPCyADBEAgA0IANwIAIANCADcCCCADQgA3AhAgA0IANwIYIANCADcCIAsgKUEBNgIAIAQkBAuvAwEBfyAAIAFBHGoiAigCAEEYdjoAACAAIAIoAgBBEHY6AAEgACACKAIAQQh2OgACIAAgAigCADoAAyAAIAFBGGoiAigCAEEYdjoABCAAIAIoAgBBEHY6AAUgACACKAIAQQh2OgAGIAAgAigCADoAByAAIAFBFGoiAigCAEEYdjoACCAAIAIoAgBBEHY6AAkgACACKAIAQQh2OgAKIAAgAigCADoACyAAIAFBEGoiAigCAEEYdjoADCAAIAIoAgBBEHY6AA0gACACKAIAQQh2OgAOIAAgAigCADoADyAAIAFBDGoiAigCAEEYdjoAECAAIAIoAgBBEHY6ABEgACACKAIAQQh2OgASIAAgAigCADoAEyAAIAFBCGoiAigCAEEYdjoA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BxAHIAcgBxAHIAcgBxAHIAcgBxAHIAcgBxAHIAcgByAGEAogBEHIAWoiBSAHKQIANwIAIAUgBykCCDcCCCAFIAcpAhA3AhAgBSAHKQIYNwIYIAUgBykCIDcCICAFIAUQByAFIAUQByAFIAUQByAFIAUQByAFIAUQByAFIAUQByAFIAUQByAFIAUQByAFIAUQByAFIAUQByAFIAUQByAFIAUQByAFIAUQByAFIAUQByAFIAUQByAFIAUQByAFIAUQByAFIAUQByAFIAUQByAFIAUQByAFIAUQByAFIAUQByAFIAUgBxAKIARBoAFqIgIgBSkCADcCACACIAUpAgg3AgggAiAFKQIQNwIQIAIgBSkCGDcCGCACIAUpAiA3AiAgAiACEAcgAiACEAcgAiACEAcgAiACEAcgAiACEAcgAiACEAcgAiACEAcgAiACEAcgAiACEAcgAiACEAcgAiACEAcgAiACEAcgAiACEAcgAiACEAcgAiACEAcgAiACEAcgAiACEAcgAiACEAcgAiACEAcgAiACEAcgAiACEAcgAiACEAcgAiACEAcgAiACEAcgAiACEAcgAiACEAcgAiACEAcgAiACEAcgAiACEAcgAiACEAcgAiACEAcgAiACEAcgAiACEAcgAiACEAcgAiACEAcgAiACEAcgAiACEAcgAiACEAcgAiACEAcgAiACEAcgAiACEAcgAiACEAcgAiACEAcgAiACEAcgAiACIAUQCiAEQfgAaiIJIAIpAgA3AgAgCSACKQIINwIIIAkgAikCEDcCECAJIAIpAhg3AhggCSACKQIgNwIgQQAhBgNAIAkgCRAHIAZBAWoiBkHYAEcNAAsgCSAJIAIQCiADIAkpAgA3AgAgAyAJKQIINwIIIAMgCSkCEDcCECADIAkpAhg3AhggAyAJKQIgNwIgIAMgAxAHIAMgAxAHIAMgAxAHIAMgAxAHIAMgAxAHIAMgAxAHIAMgAxAHIAMgAxAHIAMgAxAHIAMgAxAHIAMgAxAHIAMgAxAHIAMgAxAHIAMgAxAHIAMgAxAHIAMgAxAHIAMgAxAHIAMgAxAHIAMgAxAHIAMgAxAHIAMgAxAHIAMgAxAHIAMgAxAHIAMgAxAHIAMgAxAHIAMgAxAHIAMgAxAHIAMgAxAHIAMgAxAHIAMgAxAHIAMgAxAHIAMgAxAHIAMgAxAHIAMgAxAHIAMgAxAHIAMgAxAHIAMgAxAHIAMgAxAHIAMgAxAHIAMgAxAHIAMgAxAHIAMgAxAHIAMgAxAHIAMgAxAHIAMgAyAFEAogCCADKQIANwIAIAggAykCCDcCCCAIIAMpAhA3AhAgCCADKQIYNwIYIAggAykCIDcCICAIIAgQByAIIAgQByAIIAgQByAIIAggChAKIAQgCCkCADcCACAEIAgpAgg3AgggBCAIKQIQNwIQIAQgCCkCGDcCGCAEIAgpAiA3AiAgBCAEEAcgBCAEEAcgBCAEEAcgBCAEEAcgBCAEEAcgBCAEEAcgBCAEEAcgBCAEEAcgBCAEEAcgBCAEEAcgBCAEEAcgBCAEEAcgBCAEEAcgBCAEEAcgBCAEEAcgBCAEEAcgBCAEEAcgBCAEEAcgBCAEEAcgBCAEEAcgBCAEEAcgBCAEEAcgBCAEEAcgBCAEIAcQCiAEIAQQByAEIAQQByAEIAQQByAEIAQQByAEIAQQByAEIAQgARAKIAQgBBAHIAQgBBAHIAQgBBAHIAQgBCALEAogBCAEEAcgBCAEEAcgACABIAQQCiAEJAQL7gQBG38gAEEkaiILKAIAIgJBFnYiAUHRB2wgACgCAGohBCABQQZ0IABBBGoiDCgCAGogBEEadmoiBUEadiAAQQhqIg0oAgBqIgZB////H3EhByAGQRp2IABBDGoiDigCAGoiCEEadiAAQRBqIg8oAgBqIQEgCEH///8fcSEJIAFB////H3EhCiABQRp2IABBFGoiECgCAGoiEUEadiAAQRhqIhIoAgBqIRMgEUH///8fcSEUIBNBGnYgAEEcaiIVKAIAaiIWQRp2IABBIGoiFygCAGohAyAWQf///x9xIRggA0H///8fcSEZIANBGnYgAkH///8BcWoiAkEWdiAFQf///x9xIgVBQGsgBEH///8fcSIEQdEHaiIaQRp2IhtqQf///x9LIAggBnEgAXEgEXEgE0H///8fcSIBcSAWcSADcUH///8fRiACQf///wFGcXFyIgNFBEAgACAENgIAIAwgBTYCACANIAc2AgAgDiAJNgIAIA8gCjYCACAQIBQ2AgAgEiABNgIAIBUgGDYCACAXIBk2AgAgCyACNgIADwsgGyAFaiADQQZ0aiIDQRp2IAdqIgRBGnYgCWoiBkEadiAKaiIHQRp2IBRqIghBGnYgAWoiAUEadiAYaiIJQRp2IBlqIgpBGnYgAmpB////AXEhAiAAIBpB////H3E2AgAgDCADQf///x9xNgIAIA0gBEH///8fcTYCACAOIAZB////H3E2AgAgDyAHQf///x9xNgIAIBAgCEH///8fcTYCACASIAFB////H3E2AgAgFSAJQf///x9xNgIAIBcgCkH///8fcTYCACALIAI2AgALsAIBCn8gACgCJCIBQRZ2IgJB0QdsIAAoAgBqIgNB////H3EiBEHQB3MhBSAEQQBHIAVB////H0dxBEBBAA8LIANBGnYgAkEGdHIgACgCBGoiAkEadiAAKAIIaiIDQRp2IAAoAgxqIgZBGnYgACgCEGoiB0EadiAAKAIUaiIIQRp2IAAoAhhqIglBGnYgACgCHGoiCkEadiAAKAIgaiIAQRp2IAFB////AXFqIQEgAkHAAHMgBXEgA3EgBnEgB3EgCHEgCXEgCnEgAHEgAUGAgIAec3FB////H0YEf0EBBSACQf///x9xIARyIANB////H3FyIAZB////H3FyIAdB////H3FyIAhB////H3FyIAlB////H3FyIApB////H3FyIABB////H3FyIAFyRQtBAXELmAIBBH8gACACaiEEIAFB/wFxIQEgAkHDAE4EQANAIABBA3EEQCAAIAE6AAAgAEEBaiEADAELCyAEQXxxIgVBQGohBiABIAFBCHRyIAFBEHRyIAFBGHRyIQMDQCAAIAZMBEAgACADNgIAIAAgAzYCBCAAIAM2AgggACADNgIMIAAgAzYCECAAIAM2AhQgACADNgIYIAAgAzYCHCAAIAM2AiAgACADNgIkIAAgAzYCKCAAIAM2AiwgACADNgIwIAAgAzYCNCAAIAM2AjggACADNgI8IABBQGshAAwBCwsDQCAAIAVIBEAgACADNgIAIABBBGohAAwBCwsLA0AgACAESARAIAAgAToAACAAQQFqIQAMAQsLIAQgAmsLqy8BnwF/IwQhDSMEQbAmaiQEIA1BgCZqIQ4gDUHYJWohESANQdgkaiEGIA1BhCRqIRIgDUGwI2ohDCANQcgfaiEWIA1ByBdqIUkgDUHoD2ohBSANQagNaiEJIA1BiAhqIQsCfwJAIAMoAgQgAygCAHIgAygCCHIgAygCDHIgAygCEHIgAygCFHIgAygCGHIgAygCHHJFDQAgAigCeA0AIA1BhAhqIgpBADYCACANQYAIaiANIANBBRArIgM2AgAgBiACIAooAgAiD0H8AGxqIhBBABAaIAwgBikCADcCACAMIAYpAgg3AgggDCAGKQIQNwIQIAwgBikCGDcCGCAMIAYpAiA3AiAgDEEoaiIKIAZBKGoiCCkCADcCACAKIAgpAgg3AgggCiAIKQIQNwIQIAogCCkCGDcCGCAKIAgpAiA3AiAgDEEANgJQIA4gBkHQAGoiChAHIBEgDiAKEAogEiAQIA4QCiASQShqIgggAiAPQfwAbGpBKGogERAKIBIgAiAPQfwAbGooAng2AlAgBSASKQIANwIAIAUgEikCCDcCCCAFIBIpAhA3AhAgBSASKQIYNwIYIAUgEikCIDcCICAFQShqIhAgCCkCADcCACAQIAgpAgg3AgggECAIKQIQNwIQIBAgCCkCGDcCGCAQIAgpAiA3AiAgBUHQAGoiCCACIA9B/ABsakHQAGoiAikCADcCACAIIAIpAgg3AgggCCACKQIQNwIQIAggAikCGDcCGCAIIAIpAiA3AiAgBUH4AGoiE0EANgIAIAkgCikCADcCACAJIAopAgg3AgggCSAKKQIQNwIQIAkgCikCGDcCGCAJIAopAiA3AiAgBUH8AGoiAiAFIAwgCUEoaiIUEBAgBUH4AWoiCCACIAwgCUHQAGoiBxAQIAVB9AJqIgIgCCAMIAlB+ABqIh0QECAFQfADaiIIIAIgDCAJQaABaiIeEBAgBUHsBGoiAiAIIAwgCUHIAWoiHxAQIAVB6AVqIg8gAiAMIAlB8AFqIiEQECAFQeQGaiIIIA8gDCAJQZgCaiIPEBAgBUG0B2oiAiACIAoQCiALQcwEaiIJIAgpAgA3AgAgCSAIKQIINwIIIAkgCCkCEDcCECAJIAgpAhg3AhggCSAIKQIgNwIgIAtB9ARqIgkgBUGMB2oiCikCADcCACAJIAopAgg3AgggCSAKKQIQNwIQIAkgCikCGDcCGCAJIAopAiA3AiAgC0GYBWoiIigCACIjQRZ2IghB0QdsIAkoAgBqIQogCEEGdCALQfgEaiIkKAIAaiAKQRp2aiIlQRp2IAtB/ARqIiYoAgBqIidBGnYgC0GABWoiKCgCAGoiKUEadiALQYQFaiIqKAIAaiIrQRp2IAtBiAVqIiwoAgBqIi1BGnYgC0GMBWoiLigCAGoiL0EadiALQZAFaiIwKAIAaiIxQRp2IAtBlAVqIjIoAgBqIQggCSAKQf///x9xNgIAICQgJUH///8fcTYCACAmICdB////H3E2AgAgKCApQf///x9xNgIAICogK0H///8fcTYCACAsIC1B////H3E2AgAgLiAvQf///x9xNgIAIDAgMUH///8fcTYCACAyIAhB////H3E2AgAgIiAIQRp2ICNB////AXFqNgIAIBYgAikCADcCACAWIAIpAgg3AgggFiACKQIQNwIQIBYgAikCGDcCGCAWIAIpAiA3AiAgC0EANgKcBSAGIA8pAgA3AgAgBiAPKQIINwIIIAYgDykCEDcCECAGIA8pAhg3AhggBiAPKQIgNwIgIA4gBhAHIBEgDiAGEAogC0H4A2ogBUHoBWogDhAKIAtBoARqIAVBkAZqIBEQCiALIAUoAuAGNgLIBCAGIAYgIRAKIA4gBhAHIBEgDiAGEAogC0GkA2ogBUHsBGogDhAKIAtBzANqIAVBlAVqIBEQCiALIAUoAuQFNgL0AyAGIAYgHxAKIA4gBhAHIBEgDiAGEAogC0HQAmogBUHwA2ogDhAKIAtB+AJqIAVBmARqIBEQCiALIAUoAugENgKgAyAGIAYgHhAKIA4gBhAHIBEgDiAGEAogC0H8AWogBUH0AmogDhAKIAtBpAJqIAVBnANqIBEQCiALIAUoAuwDNgLMAiAGIAYgHRAKIA4gBhAHIBEgDiAGEAogC0GoAWogBUH4AWogDhAKIAtB0AFqIAVBoAJqIBEQCiALIAUoAvACNgL4ASAGIAYgBxAKIA4gBhAHIBEgDiAGEAogC0HUAGogBUH8AGogDhAKIAtB/ABqIAVBpAFqIBEQCiALIAUoAvQBNgKkASAGIAYgFBAKIA4gBhAHIBEgDiAGEAogCyAFIA4QCiALQShqIBAgERAKIAsgEygCADYCUEEBIUogA0EASgR/IAMFQQALDAELIBZBATYCACAWQQRqIgJCADcCACACQgA3AgggAkIANwIQIAJCADcCGCACQQA2AiBBASFLQQALIQIgBARAIEkgBEEPECsiAyFMIAMgAkoEQCADIQILCyABQfgAaiIdQQE2AgAgAUIANwIAIAFCADcCCCABQgA3AhAgAUIANwIYIAFCADcCICABQgA3AiggAUIANwIwIAFCADcCOCABQUBrQgA3AgAgAUIANwJIIAFCADcCUCABQgA3AlggAUIANwJgIAFCADcCaCABQgA3AnAgAkEATARAIA0kBA8LIA1B6CFqISsgDUHwIGohLCANQcggaiFNIA1B8B9qIgVB0ABqIWogAUHQAGohHiAGQQRqIU4gBkEIaiFPIAZBDGohUCAGQRBqIVEgBkEUaiFSIAZBGGohUyAGQRxqIVQgBkEgaiFVIAZBJGohViABQShqIRMgDEEEaiFXIAxBCGohWCAMQQxqIVkgDEEQaiFaIAxBFGohWyAMQRhqIVwgDEEcaiFdIAxBIGohXiAMQSRqIV8gBUEoaiFgIA1B4CJqIghBBGohayAIQQhqIWwgCEEMaiFtIAhBEGohbiAIQRRqIW8gCEEYaiFwIAhBHGohcSAIQSBqIXIgCEEkaiFzIBJBBGohdCASQQhqIXUgEkEMaiF2IBJBEGohdyASQRRqIXggEkEYaiF5IBJBHGoheiASQSBqIXsgEkEkaiF8IA1BuCJqIhBBBGohfSAQQQhqIX4gEEEMaiF/IBBBEGohgAEgEEEUaiGBASAQQRhqIYIBIBBBHGohgwEgEEEgaiGEASAQQSRqIYUBIA1BiCNqIg9BBGohhgEgD0EIaiGHASAPQQxqIYgBIA9BEGohiQEgD0EUaiGKASAPQRhqIYsBIA9BHGohjAEgD0EgaiGNASAPQSRqIY4BIAFBBGohYSABQQhqIWIgAUEMaiFjIAFBEGohZCABQRRqIWUgAUEYaiFmIAFBHGohZyABQSBqIWggAUEkaiFpIA1BwCFqIgpBBGohLSAKQQhqIS4gCkEMaiEvIApBEGohMCAKQRRqITEgCkEYaiEyIApBHGohOSAKQSBqITogCkEkaiE7IA1BkCJqIhRBBGohjwEgFEEIaiGQASAUQQxqIZEBIBRBEGohkgEgFEEUaiGTASAUQRhqIZQBIBRBHGohlQEgFEEgaiGWASAUQSRqIZcBIAFBLGohPCABQTBqIT0gAUE0aiE+IAFBOGohPyABQTxqIUAgAUFAayFBIAFBxABqIUIgAUHIAGohQyABQcwAaiFEIA1BmCFqIglBBGohmAEgCUEIaiGZASAJQQxqIZoBIAlBEGohmwEgCUEUaiGcASAJQRhqIZ0BIAlBHGohngEgCUEgaiGfASAJQSRqIaABIAFB0ABqIaEBIAFB1ABqIR8gBUEoaiEhIAVBLGohIiAFQTBqISMgBUE0aiEkIAVBOGohJSAFQTxqISYgBUFAayEnIAVBxABqISggBUHIAGohKSAFQcwAaiEqIA1BgAhqKAIAIaIBA0AgAkF/aiEEIAEgAUEAEBogSyACIKIBSnJFBEBBACEDA0AgDSADQYgIbGogBEECdGooAgAiBwRAIAsgA0EDdEHUAGxqIRUgB0EASgRAIAUgFSAHQX9qQQJtQdQAbGoiBykCADcCACAFIAcpAgg3AgggBSAHKQIQNwIQIAUgBykCGDcCGCAFIAcpAiA3AiAgBSAHKQIoNwIoIAUgBykCMDcCMCAFIAcpAjg3AjggBUFAayAHQUBrKQIANwIAIAUgBykCSDcCSCAFIAcoAlA2AlAFIAUgFSAHQX9zQQJtQdQAbGoiBykCADcCACAFIAcpAgg3AgggBSAHKQIQNwIQIAUgBykCGDcCGCAFIAcpAiA3AiAgBSAHKQIoNwIoIAUgBykCMDcCMCAFIAcpAjg3AjggBUFAayAHQUBrKQIANwIAIAUgBykCSDcCSCAFIAcoAlA2AlAgIUG84f//ACAhKAIAazYCACAiQfz9//8AICIoAgBrNgIAICNB/P///wAgIygCAGs2AgAgJEH8////ACAkKAIAazYCACAlQfz///8AICUoAgBrNgIAICZB/P///wAgJigCAGs2AgAgJ0H8////ACAnKAIAazYCACAoQfz///8AICgoAgBrNgIAIClB/P///wAgKSgCAGs2AgAgKkH8//8HICooAgBrNgIACyABIAEgBUEAEBALIANBAWoiAyBKRw0ACwsgAiBMTARAIEkgBEECdGooAgAiAwRAIAAoAgAhByADQQBKBEAgBSAHIANBf2pBAm1BBnRqECMFIAUgByADQX9zQQJtQQZ0ahAjICFBvOH//wAgISgCAGs2AgAgIkH8/f//ACAiKAIAazYCACAjQfz///8AICMoAgBrNgIAICRB/P///wAgJCgCAGs2AgAgJUH8////ACAlKAIAazYCACAmQfz///8AICYoAgBrNgIAICdB/P///wAgJygCAGs2AgAgKEH8////ACAoKAIAazYCACApQfz///8AICkoAgBrNgIAICpB/P//ByAqKAIAazYCAAsCQCBqKAIARQRAIB0oAgAEQCAdQQA2AgAgLCAWEAcgTSAsIBYQCiABIAUgLBAKIBMgYCBNEAogoQFBATYCACAfQgA3AgAgH0IANwIIIB9CADcCECAfQgA3AhggH0EANgIgDAILIB1BADYCACAOIB4gFhAKIBEgDhAHIAYgASkCADcCACAGIAEpAgg3AgggBiABKQIQNwIQIAYgASkCGDcCGCAGIAEpAiA3AiAgVigCACIVQRZ2IgdB0QdsIAYoAgBqIQMgB0EGdCBOKAIAaiADQRp2aiIXQRp2IE8oAgBqIhhBGnYgUCgCAGoiGUEadiBRKAIAaiIaQRp2IFIoAgBqIhtBGnYgUygCAGoiHEEadiBUKAIAaiIgQRp2IFUoAgBqIQcgBiADQf///x9xIkU2AgAgTiAXQf///x9xIhc2AgAgTyAYQf///x9xIhg2AgAgUCAZQf///x9xIhk2AgAgUSAaQf///x9xIho2AgAgUiAbQf///x9xIhs2AgAgUyAcQf///x9xIhw2AgAgVCAgQf///x9xIiA2AgAgVSAHQf///x9xIkY2AgAgViAHQRp2IBVB////AXFqIhU2AgAgEiAFIBEQCiAMIBMpAgA3AgAgDCATKQIINwIIIAwgEykCEDcCECAMIBMpAhg3AhggDCATKQIgNwIgIF8oAgAiR0EWdiIHQdEHbCAMKAIAaiEDIAdBBnQgVygCAGogA0EadmoiM0EadiBYKAIAaiI0QRp2IFkoAgBqIjVBGnYgWigCAGoiNkEadiBbKAIAaiI3QRp2IFwoAgBqIjhBGnYgXSgCAGoiSEEadiBeKAIAaiEHIAwgA0H///8fcSIDNgIAIFcgM0H///8fcSIzNgIAIFggNEH///8fcSI0NgIAIFkgNUH///8fcSI1NgIAIFogNkH///8fcSI2NgIAIFsgN0H///8fcSI3NgIAIFwgOEH///8fcSI4NgIAIF0gSEH///8fcSJINgIAIF4gB0H///8fcSKjATYCACBfIAdBGnYgR0H///8BcWoiBzYCACAPIGAgERAKIA8gDyAOEAogCEG84f//ACBFayASKAIAajYCACBrQfz9//8AIBdrIHQoAgBqNgIAIGxB/P///wAgGGsgdSgCAGo2AgAgbUH8////ACAZayB2KAIAajYCACBuQfz///8AIBprIHcoAgBqNgIAIG9B/P///wAgG2sgeCgCAGo2AgAgcEH8////ACAcayB5KAIAajYCACBxQfz///8AICBrIHooAgBqNgIAIHJB/P///wAgRmsgeygCAGo2AgAgc0H8//8HIBVrIHwoAgBqNgIAIBBBvOH//wAgA2sgDygCAGo2AgAgfUH8/f//ACAzayCGASgCAGo2AgAgfkH8////ACA0ayCHASgCAGo2AgAgf0H8////ACA1ayCIASgCAGo2AgAggAFB/P///wAgNmsgiQEoAgBqNgIAIIEBQfz///8AIDdrIIoBKAIAajYCACCCAUH8////ACA4ayCLASgCAGo2AgAggwFB/P///wAgSGsgjAEoAgBqNgIAIIQBQfz///8AIKMBayCNASgCAGo2AgAghQFB/P//ByAHayCOASgCAGo2AgAgCBAXRQRAIBQgEBAHICsgCBAHIAogCCArEAogHiAeIAgQCiAJIAYgKxAKIAEgCSkCADcCACABIAkpAgg3AgggASAJKQIQNwIQIAEgCSkCGDcCGCABIAkpAiA3AiAgLSgCACEDIC4oAgAhByAvKAIAIRUgMCgCACEXIDEoAgAhGCAyKAIAIRkgOSgCACEaIDooAgAhGyA7KAIAIRwgYSgCAEF+bCEgIGIoAgBBfmwhRSBjKAIAQX5sIUYgZCgCAEF+bCFHIGUoAgBBfmwhMyBmKAIAQX5sITQgZygCAEF+bCE1IGgoAgBBfmwhNiBpKAIAQX5sITcgASABKAIAQX5sQfjC//8BaiAKKAIAayAUKAIAaiI4NgIAIGEgIEH4+///AWogA2sgjwEoAgBqIgM2AgAgYiBFQfj///8BaiAHayCQASgCAGoiBzYCACBjIEZB+P///wFqIBVrIJEBKAIAaiIVNgIAIGQgR0H4////AWogF2sgkgEoAgBqIhc2AgAgZSAzQfj///8BaiAYayCTASgCAGoiGDYCACBmIDRB+P///wFqIBlrIJQBKAIAaiIZNgIAIGcgNUH4////AWogGmsglQEoAgBqIho2AgAgaCA2Qfj///8BaiAbayCWASgCAGoiGzYCACBpIDdB+P//D2ogHGsglwEoAgBqIhw2AgAgE0G0pP//AiA4ayAJKAIAajYCACA8QfT5//8CIANrIJgBKAIAajYCACA9QfT///8CIAdrIJkBKAIAajYCACA+QfT///8CIBVrIJoBKAIAajYCACA/QfT///8CIBdrIJsBKAIAajYCACBAQfT/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NwIIIAAgAykCEDcCECAAIAMpAhg3AhggACADKQIgNwIgQfb6/78CIABBBGoiASgCAEECdGshD0H2//+/AiAAQQhqIhAoAgBBAnRrIRFB9v//vwIgAEEMaiIbKAIAQQJ0ayEcQfb//78CIABBEGoiHSgCAEECdGshHkH2//+/AiAAQRRqIh8oAgBBAnRrISBB9v//vwIgAEEYaiIhKAIAQQJ0ayEiQfb//78CIABBHGoiIygCAEECdGshJEH2//+/AiAAQSBqIiUoAgBBAnRrISZB9v//EyAAQSRqIicoAgBBAnRrISggAEHWs/+/AiAAKAIAQQJ0ayAHKAIAIilqNgIAIAEgDyAHQQRqIg8oAgAiAWo2AgAgECARIAdBCGoiECgCACIRajYCACAbIBwgB0EMaiIbKAIAIhxqNgIAIB0gHiAHQRBqIh0oAgAiHmo2AgAgHyAgIAdBFGoiHygCACIgajYCACAhICIgB0EYaiIhKAIAIiJqNgIAICMgJCAHQRxqIiMoAgAiJGo2AgAgJSAmIAdBIGoiJSgCACImajYCACAnICggB0EkaiInKAIAIihqNgIAIAIoAgBBBmwhKiAGKAIAQQZsISsgCCgCAEEGbCEsIAkoAgBBBmwhLSAKKAIAQQZsIS4gCygCAEEGbCEvIAwoAgBBBmwhMCANKAIAQQZsITEgDigCAEEGbCEyIAMgAygCAEEGbEG84f//ACApa2o2AgAgAiAqQfz9//8AIAFrajYCACAGICtB/P///wAgEWtqNgIAIAggLEH8////ACAca2o2AgAgCSAtQfz///8AIB5rajYCACAKIC5B/P///wAgIGtqNgIAIAsgL0H8////ACAia2o2AgAgDCAwQfz///8AICRrajYCACANIDFB/P///wAgJmtqNgIAIA4gMkH8//8HIChrajYCACAAQShqIgEgBSADEAogB0Ga0v+/ASAEKAIAayICNgIAIA9B+vz/vwEgEigCAGsiAzYCACAQQfr//78BIBMoAgBrIgU2AgAgG0H6//+/ASAUKAIAayIHNgIAIB1B+v//vwEgFSgCAGsiBjYCACAfQfr//78BIBYoAgBrIgg2AgAgIUH6//+/ASAXKAIAayIJNgIAICNB+v//vwEgGCgCAGsiCjYCACAlQfr//78BIBkoAgBrIgs2AgAgJ0H6//8LIBooAgBr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BGohBCAGIAgQDEEBIANrIgNBwABJBH8gBAUgAkGBf2oiDUFAcSIOIAJrQcSSBGohBSADIQIgBCEDA0AgCCADKQAANwAAIAggAykACDcACCAIIAMpABA3ABAgCCADKQAYNwAYIAggAykAIDcAICAIIAMpACg3ACggCCADKQAwNwAwIAggAykAODcAOCADQUBrIQMgBiAIEAwgAkFAaiICQcAATw0ACyANIA5rIQMgBQshAiADBEAgAiEEQQAhAgwCCwsMAQsgCCACaiAEIAMQCxoLIAogECgCACICQR12QRh0NgIAIAogAkELdEGAgPwHcSACQRt0ciACQQV2QYD+A3FyIAJBFXZB/wFxcjYCBCAQIAJBNyACa0E/cUEBaiIDajYCACAGQSBqIQUCQAJAIANBwAAgAkE/cSICayIESQRAQfmMBCEEDAEFIAUgAmpB+YwEIAQQCxogBEH5jARqIQIgBiAFEAwgAyAEayIDQcAATwRAA0AgBSACKQAANwAAIAUgAikACDcACCAFIAIpABA3ABAgBSACKQAYNwAYIAUgAikAIDcAICAFIAIpACg3ACggBSACKQAwNwAwIAUgAikAODcAOCACQUBrIQIgBiAFEAwgA0FAaiIDQcAATw0ACwsgAwRAIAIhBEEAIQIMAgsLDAELIAUgAmogBCADEAsaCyAQKAIAIgJBP3EhBCAQIAJBCGo2AgAgBkEgaiEFAkACQEHAACAEayIDQQhLBEAgCiECQQghAwwBBSAFIARqIAogAxALGiAKIANqIQIgBiAFEAxBCCADayIDQcAATwRAA0AgBSACKQAANwAAIAUgAikACDcACCAFIAIpABA3ABAgBSACKQAYNwAYIAUgAikAIDcAICAFIAIpACg3ACggBSACKQAwNwAwIAUgAikAODcAOCACQUBrIQIgBiAFEAwgA0FAaiIDQcAATw0ACwsgAwRAQQAhBAwCCwsMAQsgBSAEaiACIAMQCxoLIAYoAgAQCSESIAZBADYCACAGQQRqIh4oAgAQCSEIIB5BADYCACAGQQhqIh8oAgAQCSENIB9BADYCACAGQQxqIiAoAgAQCSEOICBBADYCACAGQRBqIiEoAgAQCSEFICFBADYCACAGQRRqIiMoAgAQCSEEICNBADYCACAGQRhqIhMoAgAQCSEDIBNBADYCACAGQRxqIh0oAgAQ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EAggAyADEAggAyADEAggAyADEAggAyADEAggAyADEAggAyADEAggAyADEAggAyADEAggAyADEAggAyADEAggAyADEAggAyADEAggAyADEAggAyADEAggAyADEAggAyADEAggAyADEAggAyADEAggAyADEAggAyADEAggAyADEAggAyADEAggAyADEAggAyADEAggAyADEAggAyADEAggAyADEAggAyADEAggAyADEAggAyADEAggAyADEAggAyADEAggAyADEAggAyADEAggAyADEAggAyADEAggAyADEAggAyADEAggAyADEAggAyADEAggAyADEAggAyADEAggAyADEAggAyADEAggAyADIAIQDSAEQaABaiICIAMQCCACIAIQCCACIAIQCCACIAIQCCACIAIQCCACIAIQCCACIAIQCCACIAIQCCACIAIQCCACIAIQCCACIAIQCCACIAIQCCACIAIQCCACIAIQCCACIAIgBRANIAIgAhAIIAIgAhAIIAIgAhAIIAIgAiAJEA0gAiACEAggAiACEAggAiACEAggAiACEAggAiACIAYQDSACIAIQCCACIAIQCCACIAIQCCACIAIQCCACIAIgCRANIAIgAhAIIAIgAhAIIAIgAhAIIAIgAhAIIAIgAhAIIAIgAiAKEA0gAiACEAggAiACEAggAiACEAggAiACEAggAiACIAoQDSACIAIQCCACIAIQCCACIAIQCCACIAIQCCACIAIgBhANIAIgAhAIIAIgAhAIIAIgAhAIIAIgAhAIIAIgAhAIIAIgAiAGEA0gAiACEAggAiACEAggAiACEAggAiACEAggAiACEAggAiACEAggAiACIAQQDSACIAIQCCACIAIQCCACIAIQCCACIAIQCCACIAIgCRANIAIgAhAIIAIgAhAIIAIgAhAIIAIgAiAGEA0gAiACEAggAiACEAggAiACEAggAiACEAggAiACEAggAiACIAsQDSACIAIQCCACIAIQCCACIAIQCCACIAIQCCACIAIQCCACIAIQCCACIAIgCRANIAIgAhAIIAIgAhAIIAIgAhAIIAIgAhAIIAIgAhAIIAIgAhAIIAIgAhAIIAIgAhAIIAIgAhAIIAIgAhAIIAIgAiAGEA0gAiACEAggAiACEAggAiACEAggAiACEAggAiACIAYQDSACIAIQCCACIAIQCCACIAIQCCACIAIQCCACIAIQCCACIAIQCCACIAIQCCACIAIQCCACIAIQCCACIAIgCBANIAIgAhAIIAIgAhAIIAIgAhAIIAIgAhAIIAIgAhAIIAIgAiALEA0gAiACEAggAiACEAggAiACEAggAiACEAggAiACEAggAiACEAggAiACIAoQDSACIAIQCCACIAIQCCACIAIQCCACIAIQCCACIAIgBBANIAIgAhAIIAIgAhAIIAIgAhAIIAIgAhAIIAIgAhAIIAIgAiAMEA0gAiACEAggAiACEAggAiACEAggAiACEAggAiACEAggAiACEAggAiACIAQQDSACIAIQCCACIAIQCCACIAIQCCACIAIQCCACIAIQCCACIAIQCCACIAIQCCACIAIQCCACIAIQCCACIAIQCCACIAIgBBANIAIgAhAIIAIgAhAIIAIgAhAIIAIgAhAIIAIgAiALEA0gAiACEAggAiACEAggAiACEAggAiACEAggAiACEAggAiACEAggAiACIAEQDSACIAIQCCACIAIQCCACIAIQCCACIAIQCCACIAIQCCACIAIQCCACIAIQCCACIAIQCCAAIAIgBxANIAQkBAvYAwETfyMEIQIjBEHQAGokBCACIAFB0ABqEAcgAiACIAAQCiABKAIkIgZBFnYiAEHRB2wgASgCAGohBCAAQQZ0IAEoAgRqIARBGnZqIgdBGnYgASgCCGoiCEEadiABKAIMaiIJQRp2IAEoAhBqIgpBGnYgASgCFGoiC0EadiABKAIYaiIMQRp2IAEoAhxqIg1BGnYgASgCIGohBUH8/f//ACACKAIEayEOQfz///8AIAIoAghrIQ9B/P///wAgAigCDGshEEH8////ACACKAIQayERQfz///8AIAIoAhRrIRJB/P///wAgAigCGGshE0H8////ACACKAIcayEUQfz///8AIAIoAiBrIQEgAigCJCEAIAJBKGoiA0G84f//ACACKAIAayAEQf///x9xajYCACADIA4gB0H///8fcWo2AgQgAyAPIAhB////H3FqNgIIIAMgECAJQf///x9xajYCDCADIBEgCkH///8fcWo2AhAgAyASIAtB////H3FqNgIUIAMgEyAMQf///x9xajYCGCADIBQgDUH///8fcWo2AhwgAyABIAVB////H3FqNgIgIAMgBkH///8BcUH8//8HaiAAayAFQRp2ajYCJCADEBchACACJAQgAAuXEAEKfyMEIQQjBEHgA2okBCAEQdAAaiEDIARBKGohCCAEQbgDaiILIAEQByALIAsgARAKIARBkANqIgogCxAHIAogCiABEAogBEHoAmoiBiAKKQIANwIAIAYgCikCCDcCCCAGIAopAhA3AhAgBiAKKQIYNwIYIAYgCikCIDcCICAGIAYQByAGIAYQByAGIAYQByAGIAYgChAKIARBwAJqIgIgBikCADcCACACIAYpAgg3AgggAiAGKQIQNwIQIAIgBikCGDcCGCACIAYpAiA3AiAgAiACEAcgAiACEAcgAiACEAcgAiACIAoQCiAEQZgCaiIGIAIpAgA3AgAgBiACKQIINwIIIAYgAikCEDcCECAGIAIpAhg3AhggBiACKQIgNwIgIAYgBhAHIAYgBhAHIAYgBiALEAogBEHwAWoiByAGKQIANwIAIAcgBikCCDcCCCAHIAYpAhA3AhAgByAGKQIYNwIYIAcgBikCIDcCICAHIAcQByAHIAcQByAHIAcQByAHIAcQByAHIAcQByAHIAcQByAHIAcQByAHIAcQByAHIAcQByAHIAcQByAHIAcQByAHIAcgBhAKIARByAFqIgUgBykCADcCACAFIAcpAgg3AgggBSAHKQIQNwIQIAUgBykCGDcCGCAFIAcpAiA3AiAgBSAFEAcgBSAFEAcgBSAFEAcgBSAFEAcgBSAFEAcgBSAFEAcgBSAFEAcgBSAFEAcgBSAFEAcgBSAFEAcgBSAFEAcgBSAFEAcgBSAFEAcgBSAFEAcgBSAFEAcgBSAFEAcgBSAFEAcgBSAFEAcgBSAFEAcgBSAFEAcgBSAFEAcgBSAFEAcgBSAFIAcQCiAEQaABaiICIAUpAgA3AgAgAiAFKQIINwIIIAIgBSkCEDcCECACIAUpAhg3AhggAiAFKQIgNwIgIAIgAhAHIAIgAhAHIAIgAhAHIAIgAhAHIAIgAhAHIAIgAhAHIAIgAhAHIAIgAhAHIAIgAhAHIAIgAhAHIAIgAhAHIAIgAhAHIAIgAhAHIAIgAhAHIAIgAhAHIAIgAhAHIAIgAhAHIAIgAhAHIAIgAhAHIAIgAhAHIAIgAhAHIAIgAhAHIAIgAhAHIAIgAhAHIAIgAhAHIAIgAhAHIAIgAhAHIAIgAhAHIAIgAhAHIAIgAhAHIAIgAhAHIAIgAhAHIAIgAhAHIAIgAhAHIAIgAhAHIAIgAhAHIAIgAhAHIAIgAhAHIAIgAhAHIAIgAhAHIAIgAhAHIAIgAhAHIAIgAhAHIAIgAhAHIAIgAiAFEAogBEH4AGoiCSACKQIANwIAIAkgAikCCDcCCCAJIAIpAhA3AhAgCSACKQIYNwIYIAkgAikCIDcCIEEAIQYDQCAJIAkQByAGQQFqIgZB2ABHDQALIAkgCSACEAogAyAJKQIANwIAIAMgCSkCCDcCCCADIAkpAhA3AhAgAyAJKQIYNwIYIAMgCSkCIDcCICADIAMQByADIAMQByADIAMQByADIAMQByADIAMQByADIAMQByADIAMQByADIAMQByADIAMQByADIAMQByADIAMQByADIAMQByADIAMQByADIAMQByADIAMQByADIAMQByADIAMQByADIAMQByADIAMQByADIAMQByADIAMQByADIAMQByADIAMQByADIAMQByADIAMQByADIAMQByADIAMQByADIAMQByADIAMQByADIAMQByADIAMQByADIAMQByADIAMQByADIAMQByADIAMQByADIAMQByADIAMQByADIAMQByADIAMQByADIAMQByADIAMQByADIAMQByADIAMQByADIAMQByADIAMgBRAKIAggAykCADcCACAIIAMpAgg3AgggCCADKQIQNwIQIAggAykCGDcCGCAIIAMpAiA3AiAgCCAIEAcgCCAIEAcgCCAIEAcgCCAIIAoQCiAEIAgpAgA3AgAgBCAIKQIINwIIIAQgCCkCEDcCECAEIAgpAhg3AhggBCAIKQIgNwIgIAQgBBAHIAQgBBAHIAQgBBAHIAQgBBAHIAQgBBAHIAQgBBAHIAQgBBAHIAQgBBAHIAQgBBAHIAQgBBAHIAQgBBAHIAQgBBAHIAQgBBAHIAQgBBAHIAQgBBAHIAQgBBAHIAQgBBAHIAQgBBAHIAQgBBAHIAQgBBAHIAQgBBAHIAQgBBAHIAQgBBAHIAQgBCAHEAogBCAEEAcgBCAEEAcgBCAEEAcgBCAEEAcgBCAEEAcgBCAEEAcgBCAEIAsQCiAEIAQQByAAIAQQByAEIAAQB0G84f//ACAEKAIAayABKAIAaiABKAIkQfz//wcgBCgCJGtqIgpBFnYiBkHRB2xqIQBB/P///wAgBCgCIGsgASgC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ACggBCABKQAwNwAwIAQgASkAODcAOCABQUBrIQEgBiAEEAwgAkFAaiICQcAATw0ACwsgAgRAQQAhAwwCCwsMAQsgBCADaiABIAIQCxoLIAYoAgAQCSEIIAZBADYCACAKKAIAEAkhCSAKQQA2AgAgCygCABAJIQogC0EANgIAIAwoAgAQCSELIAxBADYCACANKAIAEAkhByANQQA2AgAgDigCABAJIQMgDkEANgIAIA8oAgAQCSECIA9BADYCACARKAIAEAkhASAFIAg2AgAgBSAJNgIEIAUgCjYCCCAFIAs2AgwgBSAHNgIQIAUgAzYCFCAFIAI2AhggBSABNgIcIAAgBSAQEA4gBSQEC+YBAQN/IABB4ABqIgMoAgAiBEE/cSEFIAMgBCACajYCAEHAACAFayIEIAJNBEAgAEEgaiIDIAVqIAEgBBALGiABIARqIQEgACADEAwgAiAEayICQcAASQRAQQAhBQUDQCADIAEpAAA3AAAgAyABKQAINwAIIAMgASkAEDcAECADIAEpABg3ABggAyABKQAgNwAgIAMgASkAKDcAKCADIAEpADA3ADAgAyABKQA4NwA4IAFBQGshASAAIAMQDCACQUBqIgJBwABPDQBBACEFCwsLIAJFBEAPCyAAQSBqIAVqIAEgAhALGgvASwEzfyMEIQkjBEHwAWokBCAAQoGChIiQoMCAATcCACAAQoGChIiQoMCAATcCCCAAQoGChIiQoMCAATcCECAAQoGChIiQoMCAATcCGCAAQSBqIhlCADcCACAZQgA3AgggGUIANwIQIBlCADcCGCAJIgogGRATIApB4ABqIg0oAgAiCUE/cSEEIA0gCUEgajYCACAKQSBqIQsCQAJAQcAAIARrIglBIEsEQCAAIQkgBCEDQSAhCAwBBSALIARqIAAgCRALGiAAIAlqIQMgCiALEAxBICAJayIIQcAASQR/IAMFIABB5ABqIARBoH9qIgdBQHEiBkEcciAEa2ohBCAIIQkgAyEIA0AgCyAIKQAANwAAIAsgCCkACDcACCALIAgpABA3ABAgCyAIKQAYNwAYIAsgCCkAIDcAICALIAgpACg3ACggCyAIKQAwNwAwIAsgCCkAODcAOCAIQUBrIQggCiALEAwgCUFAaiIJQcAATw0ACyAHIAZrIQggBAshCSAIBEBBACEDDAILCwwBCyAL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cXIgAUEVdkH/AXFyNgIEIA0gAUE3IAFrQT9xQQFqIgJqNgIAIApBIGohBAJAAkAgAkHAACABQT9xIgFrIgNJBEBB+YwEIQMMAQUgBCABakH5jAQgAxALGiADQfmMBGohASAKIAQQDCACIANrIgJBwABPBEADQCAEIAEpAAA3AAAgBCABKQAINwAIIAQgASkAEDcAECAEIAEpABg3ABggBCABKQAgNwAgIAQgASkAKDcAKCAEIAEpADA3ADAgBCABKQA4NwA4IAFBQGshASAKIAQQDCACQUBqIgJBwABPDQALCyACBEAgASEDQQAhAQwCCwsMAQsgBCABaiADIAIQCxoLIA0oAgAiAUE/cSEDIA0gAUEIajYCACAKQSBqIQQCQAJAQcAAIANrIgJBCEsEQCAJIQFBCCECDAEFIAQgA2ogCSACEAsaIAkgAmohASAKIAQQDEEIIAJrIgJBwABPBEADQCAEIAEpAAA3AAAgBCABKQAINwAIIAQgASkAEDcAECAEIAEpABg3ABggBCABKQAgNwAgIAQgASkAKDcAKCAEIAEpADA3ADAgBCABKQA4NwA4IAFBQGshASAKIAQQDCACQUBqIgJBwABPDQALCyACBEBBACEDDAILCwwBCyAEIANqIAEgAhALGgsgCigCABAJIQ4gCkEANgIAIBooAgAQCSELIBpBADYCACAbKAIAEAkhByAbQQA2AgAgHCgCABAJIQYgHEEANgIAIB0oAgAQCSEEIB1BADYCACAeKAIAEAkhAyAeQQA2AgAgHygCABAJIQIgH0EANgIAICAoAgAQCSEBICBBADYCACAIIA42AgAgIiALNgIAICMgBzYCACAkIAY2AgAgJSAENgIAICYgAzYCACAnIAI2AgAgKCABNgIAIBEoAgAiAUE/cSEDIBEgAUEgajYCAAJAAkBBwAAgA2siBEEgSwRAIAghASADIQJBICEDDAEFIAUgA2ogCCAEEAsaIAggBGohAiAMIAUQDEEgIARrIgFBwABJBH8gASEDIAIFIANBoH9qIgNBBnZBAXQhBiAEQUBqIQQDQCAFIAIpAAA3AAAgBSACKQAINwAIIAUgAikAEDcAECAFIAIpABg3ABggBSACKQAgNwAgIAUgAikAKDcAKCAFIAIpADA3ADAgBSACKQA4NwA4IAJBQGshAiAMIAUQDCABQUBqIgFBwABPDQALIANBP3EhAyAIIAZBBGpBBXRqIARqCyEBIAMEQEEAIQIMAgsLDAELIAUgAmogASADEAsaCyAJIBEoAgAiAUEddkEYdDYCACAJIAFBC3RBgID8B3EgAUEbdHIgAUEFdkGA/gNxciABQRV2Qf8BcXI2AgQgESABQTcgAWtBP3FBAWoiAmo2AgACQAJAIAJBwAAgAUE/cSIBayIDSQRAQfmMBCEDDAEFIAUgAWpB+YwEIAMQCxogA0H5jARqIQEgDCAFEAwgAiADayICQcAATwRAA0AgBSABKQAANwAAIAUgASkACDcACCAFIAEpABA3ABAgBSABKQAYNwAYIAUgASkAIDcAICAFIAEpACg3ACggBSABKQAwNwAwIAUgASkAODcAOCABQUBrIQEgDCAFEAwgAkFAaiICQcAATw0ACwsgAgRAIAEhA0EAIQEMAgsLDAELIAUgAWogAyACEAsaCyARKAIAIgFBP3EhAyARIAFBCGo2AgACQAJAQcAAIANrIgJBCEsEQCAJIQFBCCECDAEFIAUgA2ogCSACEAsaIAkgAmohASAMIAUQDEEIIAJrIgJBwABPBEADQCAFIAEpAAA3AAAgBSABKQAINwAIIAUgASkAEDcAECAFIAEpABg3ABggBSABKQAgNwAgIAUgASkAKDcAKCAFIAEpADA3ADAgBSABKQA4NwA4IAFBQGshASAMIAUQDCACQUBqIgJBwABPDQALCyACBEBBACEDDAILCwwBCyAFIANqIAEgAhALGgsgDCgCABAJIQ4gDEEANgIAIBMoAgAQCSELIBNBADYCACAUKAIAEAkhByAUQQA2AgAgFSgCABAJIQYgFUEANgIAIBYoAgAQCSEEIBZBADYCACAXKAIAEAkhAyAXQQA2AgAgGCgCABAJIQIgGEEANgIAICEoAgAQCSEBICFBADYCACAuIA42AAAgLyALNgAAIDAgBzYAACAxIAY2AAAgMiAENgAAIDMgAzYAACA0IAI2AAAgNSABNgAAIAogGRATIA0oAgAiAUE/cSEEIA0gAUEgajYCACAKQSBqIQsCQAJAQcAAIARrIgFBIEsEQCAAIQEgBCEDQSAhAgwBBSALIARqIAAgARALGiAAIAFqIQMgCiALEAxBICABayICQcAASQR/IAMFIABB5ABqIARBoH9qIgdBQHEiBkEcciAEa2ohBCACIQEgAyECA0AgCyACKQAANwAAIAsgAikACDcACCALIAIpABA3ABAgCyACKQAYNwAYIAsgAikAIDcAICALIAIpACg3ACggCyACKQAwNwAwIAsgAikAODcAOCACQUBrIQIgCiALEAwgAUFAaiIBQcAATw0ACyAHIAZrIQIgBAshASACBEBBACEDDAILCwwBCyALIANqIAEgAhALGgsgCSANKAIAIgFBHXZBGHQ2AgAgCSABQQt0QYCA/AdxIAFBG3RyIAFBBXZBgP4DcXIgAUEVdkH/AXFyNgIEIA0gAUE3IAFrQT9xQQFqIgJqNgIAIApBIGohBAJAAkAgAkHAACABQT9xIgFrIgNJBEBB+YwEIQMMAQUgBCABakH5jAQgAxALGiADQfmMBGohASAKIAQQDCACIANrIgJBwABPBEADQCAEIAEpAAA3AAAgBCABKQAINwAIIAQgASkAEDcAECAEIAEpABg3ABggBCABKQAgNwAgIAQgASkAKDcAKCAEIAEpADA3ADAgBCABKQA4NwA4IAFBQGshASAKIAQQDCACQUBqIgJBwABPDQALCyACBEAgASEDQQAhAQwCCwsMAQsgBCABaiADIAIQCxoLIA0oAgAiAUE/cSEDIA0gAUEIajYCACAKQSBqIQQCQAJAQcAAIANrIgJBCEsEQCAJIQFBCCECDAEFIAQgA2ogCSACEAsaIAkgAmohASAKIAQQDEEIIAJrIgJBwABPBEADQCAEIAEpAAA3AAAgBCABKQAINwAIIAQgASkAEDcAECAEIAEpABg3ABggBCABKQAgNwAgIAQgASkAKDcAKCAEIAEpADA3ADAgBCABKQA4NwA4IAFBQGshASAKIAQQDCACQUBqIgJBwABPDQALCyACBEBBACEDDAILCwwBCyAEIANqIAEgAhALGgsgCigCABAJIQ4gCkEANgIAIBooAgAQCSELIBpBADYCACAbKAIAEAkhByAbQQA2AgAgHCgCABAJIQYgHEEANgIAIB0oAgAQCSEEIB1BADYCACAeKAIAEAkhAyAeQQA2AgAgHygCABAJIQIgH0EANgIAICAoAgAQCSEBICBBADYCACAIIA42AgAgIiALNgIAICMgBzYCACAkIAY2AgAgJSAENgIAICYgAzYCACAnIAI2AgAgKCABNgIAIBEoAgAiAUE/cSEDIBEgAUEgajYC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AEIANwIQIABCADcCGAsgASABKAIAIARqNgIAIAMkBEEBC9YDAQN/IwQhAyMEQYABaiQEIAAgASkCADcCACAAIAEpAgg3AgggACABKQIQNwIQIAAgASkCGDcCGCAAIAEpAiA3AiAgA0HQAGoiBSABEAcgA0EoaiIEIAEgBRAKIABBADYCUCADIAQoAgBBB2o2AgAgAyAEKAIENgIEIAMgBCgCCDYCCCADIAQoAgw2AgwgAyAEKAIQNgIQIAMgBCgCFDYCFCADIAQoAhg2AhggAyAEKAIcNgIcIAMgBCgCIDYCICADIAQoAiQ2AiQgAEEoaiIFIAMQIkUEQCADJARBAA8LIAUQFiAFKAIAIgFBAXEgAkYEQCADJARBAQ8LIAVBvOH//wAgAWs2AgAgAEEsaiIBQfz9//8AIAEoAgBrNgIAIABBMGoiAUH8////ACABKAIAazYCACAAQTRqIgFB/P///wAgASgCAGs2AgAgAEE4aiIBQfz///8AIAEoAgBrNgIAIABBPGoiAUH8////ACABKAIAazYCACAAQUBrIgFB/P///wAgASgCAGs2AgAgAEHEAGoiAUH8////ACABKAIAazYCACAAQcgAaiIBQfz///8AIAEoAgBrNgIAIABBzABqIgBB/P//ByAAKAIAazYCACADJARBAQv2CwIRfwJ+IwQhBSMEQaADaiQEIAVBuAJqIgJCADcAACACQgA3AAggAkIANwAQIAJCADcAGCACQgA3ACAgAkIANwAoIAJCADcAMCACQgA3ADggAUUEQCAAQQA2ApwBIABBJGoiA0GQiAQpAgA3AgAgA0GYiAQpAgA3AgggA0GgiAQpAgA3AhAgA0GoiAQpAgA3AhggA0GwiAQpAgA3AiAgAEEBNgJ0IABB+ABqIgNCADcCACADQgA3AgggA0IANwIQIANCADcCGCADQQA2AiAgAEGEuLznADYCTCAAQf61r/AANgJQIABBuMz59QA2AlQgAEHny/X2ADYCWCAAQcjQi/gANgJcIABB0vvu4wA2AmAgAEG8gMHtADYCZCAAQYbVuecANgJoIABB2bKj7AA2AmwgAEHG4rcHNgJwIABBATYCBCAAQQhqIgNCADcCACADQgA3AgggA0IANwIQIANBADYCGAsgBUH4AmoiBiAAQQRqIg8QESACIAYpAAA3AAAgAiAGKQAINwAIIAIgBikAEDcAECACIAYpABg3ABggAUEARyIHBEAgAkEgaiIDIAEpAAA3AAAgAyABKQAINwAIIAMgASkAEDcAECADIAEpABg3ABgLIAVBkAJqIQggBUHwAWohBCAFQfAAaiEDIAVByABqIQEgBUEEaiIQIAIgBwR/QcAABUEgCxAqIAJCADcAACACQgA3AAggAkIANwAQIAJCADcAGCACQgA3ACAgAkIANwAoIAJCADcAMCACQgA3ADggAUEEaiECIAFBCGohByABQQxqIQkgAUEQaiEKIAFBFGohCyABQRhqIQwgAUEcaiENIAFBIGohESABQSRqIRIDQCAQIAYQHyAFIAEgBhAURSIONgIAIA4EQCAFQQE2AgAMAQUgBSACKAIAIAEoAgByIAcoAgByIAkoAgByIAooAgByIAsoAgByIAwoAgByIA0oAgByIBEoAgByIBIoAgByRSIONgIAIA4NAQsLIAggARAHIABBJGoiAiACIAgQCiAAQcwAaiIHIAcgCBAKIAcgByABEAogAEH0AGoiCCAIIAEQCiABQgA3AgAgAUIANwIIIAFCADcCECABQgA3AhggAUIANwIgIARBBGohASAEQQhqIQggBEEMaiEHIARBEGohCSAEQRRqIQogBEEYaiELIARBHGohDANAIBAgBhAfIAQgBiAFEA4gBSgCAARAIAVBATYCAAwBBSAFIAEoAgAgBCgCAHIgCCgCAHIgBygCAHIgCSgCAHIgCigCAHIgCygCAHIgDCgCAHJFIg02AgAgDQ0BCwsgBkIANwAAIAZCADcACCAGQgA3ABAgBkIANwAYIAAgAyAEEB4gBCAEKAIAIgBBf3OtQsKC2YENfCITIAEoAgAiBiAAciAIKAIAIgByIAcoAgAiEHIgCSgCACINciAKKAIAIhFyIAsoAgAiEnIgDCgCACIOckEAR0EfdEEfda0iFIM+AgAgASATQiCIQoy9yf4LhCAGQX9zrXwiEyAUgz4CACAIIABBf3OtQrvAovoKfCATQiCIfCITIBSDPgIAIAcgEEF/c61C5rm71Qt8IBNCIIh8IhMgFIM+AgAgCSANQX9zrUL+////D3wgE0IgiHwiEyAUgz4CACAKIBFBf3OtQv////8PfCATQiCIfCITIBSDPgIAIAsgEkF/c61C/////w98IBNCIIh8IhMgFIM+AgAgDCAOQX9zrUL/////D3wgE0IgiHwgFIM+AgAgDyAEKQIANwIAIA8gBCkCCDcCCCAPIAQpAhA3AhAgDyAEKQIYNwIYIAIgAykCADcCACACIAMpAgg3AgggAiADKQIQNwIQIAIgAykCGDcCGCACIAMpAiA3AiAgAiADKQIoNwIoIAIgAykCMDcCMCACIAMpAjg3AjggAkFAayADQUBrKQIANwIAIAIgAykCSDcCSCACIAMpAlA3AlAgAiADKQJYNwJYIAIgAykCYDcCYCACIAMpAmg3AmggAiADKQJwNwJwIAIgAygCeDYCeCAFJAQLuAQBB38jBCEFIwRB0AJqJAQgAUUEQEHkiAQgACgCqAEgACgCpAFBA3FBAmoRAAAgBSQEQQAPCyABQgA3AAAgAUIANwAIIAFCADcAECABQgA3ABggAUIANwAgIAFCADcAKCABQgA3ADAgAUIANwA4IABBBGoiBigCAEUEQEG6iwQgACgCqAEgACgCpAFBA3FBAmoRAAAgBSQEQQAPCyACRQRAQYiMBCAAKAKoASAAKAKkAUEDcUECahEAACAFJARBAA8LIAVBoAJqIQggBUH4AWohCSAFQfwAaiEDIAVBKGohByAFQQhqIgQgAiAFEA4gBSgCAARAQQAhAAUgBCgCBCAEKAIAciAEKAIIciAEKAIMciAEKAIQciAEKAIUciAEKAIYciAEKAIcckEARyICIQAgAgRAIAYgAyAEEB4gByADKAJ4NgJQIANB0ABqIgYgBhAVIAggBhAHIAkgBiAIEAogAyADIAgQCiADQShqIgIgAiAJEAogBkEBNgIAIANB1ABqIgZCADcCACAGQgA3AgggBkIANwIQIAZCADcCGCAGQQA2AiAgByADKQIANwIAIAcgAykCCDcCCCAHIAMpAhA3AhAgByADKQIYNwIYIAcgAykCIDcCICAHQShqIgMgAikCADcCACADIAIpAgg3AgggAyACKQIQNwIQIAMgAikCGDcCGCADIAIpAiA3AiAgASAHEBsLCyAEQgA3AgAgBEIANwIIIARCADcCECAEQgA3AhggBSQEIAAL9gsCDn8BfiMEIQwjBEHwAmokBCAMQQA2AgAgACAMQfwAaiIIIAUQHiAMQShqIgcgCCgCeDYCUCAIQdAAaiILIAsQFSAMQaACaiIAIAsQByAMQfgBaiIJIAsgABAKIAggCCAAEAogCEEoaiIAIAAgCRAKIAtBATYCACAIQdQAaiILQgA3AgAgC0IANwIIIAtCADcCECALQgA3AhggC0EANgIgIAcgCCkCADcCACAHIAgpAgg3AgggByAIKQIQNwIQIAcgCCkCGDcCGCAHIAgpAiA3AiAgB0EoaiILIAApAgA3AgAgCyAAKQIINwIIIAsgACkCEDcCECALIAApAhg3AhggCyAAKQIgNwIgIAcQDyALEA8gDEHIAmoiACAHKAIkIgpBDnY6AAAgACAKQQZ2OgABIAAgBygCICIJQRh2QQNxIApBAnRyOgACIAAgCUEQdjoAAyAAIAlBCHY6AAQgACAJOgAFIAAgBygCHCIJQRJ2OgAGIAAgCUEKdjoAByAAIAlBAnY6AAggACAHKAIYIgpBFHZBP3EgCUEGdHI6AAkgACAKQQx2OgAKIAAgCkEEdjoACyAAIAcoAhQiCUEWdkEPcSAKQQR0cjoADCAAIAlBDnY6AA0gACAJQQZ2OgAOIAAgBygCECIKQRh2QQNxIAlBAnRyOgAPIAAgCkEQdjoAECAAIApBCHY6ABEgACAKOgASIAAgBygCDCIJQRJ2OgATIAAgCUEKdjoAFCAAIAlBAnY6ABUgACAHKAIIIgpBFHZBP3EgCUEGdHI6ABYgACAKQQx2OgAXIAAgCkEEdjoAGCAAIAcoAgQiCUEWdkEPcSAKQQR0cjoAGSAAIAlBDnY6ABogACAJQQZ2OgAbIAAgBygCACIKQRh2QQNxIAlBAnRyOgAcIAAgCkEQdjoAHSAAIApBCHY6AB4gACAKOgAfIAEgACAMEA4gBkEARyIKBEAgBiAMKAIABH9BAgVBAAsgCygCAEEBcXI2AgALIAxBCGoiACABIAMQDSAAIAAgBBAcIAIgBRAgIAIgAiAAEA0gAEIANwIAIABCADcCCCAAQgA3AhAgAEIANwIYIAhCADcCACAIQgA3AgggCEIANwIQIAhCADcCGCAIQgA3AiAgCEIANwIoIAhCADcCMCAIQgA3AjggCEFAa0IANwIAIAhCADcCSCAIQgA3AlAgCEIANwJYIAhCADcCYCAIQgA3AmggCEIANwJwIAhBADYCeCAHQgA3AgAgB0IANwIIIAdCADcCECAHQgA3AhggB0IANwIgIAdCADcCKCAHQgA3AjAgB0IANwI4IAdBQGtCADcCACAHQgA3AkggB0EANgJQIAJBBGoiDigCACIAIAIoAgAiAXIgAkEIaiIPKAIAIgNyIAJBDGoiECgCACIEciACQRBqIhEoAgAiCHIgAkEUaiISKAIAIgtyIAJBGGoiEygCACIJciACQRxqIhQoAgAiBXJFBEAgDCQEQQAPCyAJQX9HIAVBH3YiDUF/cyIHcSAFQf////8HSXIgByALQX9HcXIgByAIQX9HcXIgByAEQfPc3eoFSXFyIgdBAXMgBEHz3N3qBUtxIA1yIg1BAXMgA0GdoJG9BUlxIAdyIgdBAXMgA0GdoJG9BUtxIA1yIg1BAXMgAEHG3qT/fUlxIAdyQX9zIgcgAEHG3qT/fUtxIA1yIAcgAUGgwezABktxckUEQCAMJARBAQ8LIAJBwYLZgX0gAWs2AgAgDiABQX9zrULCgtmBDXxCIIhCjL3J/guEIABBf3OtfCIVPgIAIA8gA0F/c61Cu8Ci+gp8IBVCIIh8IhU+AgAgECAEQX9zrULmubvVC3wgFUIgiHwiFT4CACARIAhBf3OtQv7///8PfCAVQiCIfCIVPgIAIBIgC0F/c61C/////w98IBVCIIh8IhU+AgAgEyAJQX9zrUL/////D3wgFUIgiHwiFT4CACAUIAVBf3OtQv////8PfCAVQiCIfD4CACAKRQRAIAwkBEEBDwsgBiAGKAIAQQFzNgIAIAwkBEEBCwgAQQAQAEEACzwBAX8gAEH/AXFBAUcEQBAFCyAAQQt0QYCAIHFBuAFyECciAUUEQBAFCyABIAAQNgR/IAEFIAEQJkEACwtdAQF/IAEgAEggACABIAJqSHEEQCABIAJqIQEgACIDIAJqIQADQCACQQBKBEAgAkEBayECIABBAWsiACABQQFrIgEsAAA6AAAMAQsLIAMhAAUgACABIAIQCxoLIAALBgBBwJEEC64YATp/IwQhCCMEQcAGaiQEIAFB/wFxQQFHBEAQBQsgAEGACCkDADcCpAEgAEGICCkDADcCrAEgAEEANgIAIABBBGoiAkEANgIAIAFBgARxBEAgAkGQCDYCACACQQAQLwsgAUGAAnFFBEAgCCQEIAAPCyAIQZAGaiEDIAhB6AVqIQQgCEHsBGohDiAIQZgEaiEPIAhBxANqIQYgCEHIAmohCSAIQaACaiEQIAhB+AFqIQwgCEHQAWohDSAIQagBaiEUIAhBgAFqISggAEG4AWohByAAKAIARQRAIAhBADYCeCAIQZCIBCkCADcCACAIQZiIBCkCADcCCCAIQaCIBCkCADcCECAIQaiIBCkCADcCGCAIQbCIBCkCADcCICAIQShqIgVBuIgEKQIANwIAIAVBwIgEKQIANwIIIAVByIgEKQIANwIQIAVB0IgEKQIANwIYIAVB2IgEKQIANwIgIAhBATYCUCAIQdQAaiIBQgA3AgAgAUIANwIIIAFCADcCECABQgA3AhggAUEANgIgIAAgBzYCACAOIAhBABAaIA8gDikCADcCACAPIA4pAgg3AgggDyAOKQIQNwIQIA8gDikCGDcCGCAPIA4pAiA3AiAgD0EoaiICIA5BKGoiASkCADcCACACIAEpAgg3AgggAiABKQIQNwIQIAIgASkCGDcCGCACIAEpAiA3AiAgD0EANgJQIAMgDkHQAGoiExAHIAQgAyATEAogBiAIIAMQCiAGQShqIgogBSAEEAogBkHQAGoiFUEANgIAIAkgBikCADcCACAJIAYpAgg3AgggCSAGKQIQNwIQIAkgBikCGDcCGCAJIAYpAiA3AiAgCUEoaiIRIAopAgA3AgAgESAKKQIINwIIIBEgCikCEDcCECARIAopAhg3AhggESAKKQIgNwIgIAlB0ABqIhIgCEHQAGoiASkCADcCACASIAEpAgg3AgggEiABKQIQNwIQIBIgASkCGDcCGCASIAEpAiA3AiAgCUH4AGoiFkEANgIAIAlBLGohFyAJQTBqIRggCUE0aiEZIAlBOGohGiAJQTxqIRsgCUFAayEcIAlBxABqIR0gCUHIAGohHiAJQcwAaiEfIAxBBGohICAMQQhqISEgDEEMaiEiIAxBEGohIyAMQRRqISQgDEEYaiElIAxBHGohJiAMQSBqIScgDEEkaiELQQAhAQNAIBEQFiAHIAFBBnRqIBcoAgAiBUEadCARKAIAcjYCICAHIAFBBnRqIBgoAgAiAkEUdCAFQQZ2cjYCJCAHIAFBBnRqIBkoAgAiBUEOdCACQQx2cjYCKCAHIAFBBnRqIBooAgAiAkEIdCAFQRJ2cjYCLCAHIAFBBnRqIBsoAgBBAnQgAkEYdnIgHCgCACICQRx0cjYCMCAHIAFBBnRqIB0oAgAiBUEWdCACQQR2cjYCNCAHIAFBBnRqIB4oAgAiAkEQdCAFQQp2cjYCOCAHIAFBBnRqIB8oAgBBCnQgAkEQdnI2AjwgCSAJIA8gDBAQIAwQFiAHIAFBBnRqICAoAgAiBUEadCAMKAIAcjYCACAHIAFBBnRqICEoAgAiAkEUdCAFQQZ2cjYCBCAHIAFBBnRqICIoAgAiBUEOdCACQQx2cjYCCCAHIAFBBnRqICMoAgAiAkEIdCAFQRJ2cjYCDCAHIAFBBnRqICQoAgBBAnQgAkEYdnIgJSgCACICQRx0cjYCECAHIAFBBnRqICYoAgAiBUEWdCACQQR2cjYCFCAHIAFBBnRqICcoAgAiAkEQdCAFQQp2cjYCGCAHIAFBBnRqIAsoAgBBCnQgAkEQdnI2AhwgAUEBaiIBQf8/Rw0ACyAQIBIgExAKIBAgEBAVIAMgEBAHIAQgAyAQEAogBiAJIAMQCiAKIBEgBBAKIBUgFigCADYCACADIAYpAgA3AgAgAyAGKQIINwIIIAMgBikCEDcCECADIAYpAhg3AhggAyAGKQIgNwIgIAMQDyAEIAopAgA3AgAgBCAKKQIINwIIIAQgCikCEDcCECAEIAopAhg3AhggBCAKKQIgNwIgIAQQDyAAQfiAIGogAygCBCICQRp0IAMoAgByNgIAIABB/IAgaiADKAIIIgFBFHQgAkEGdnI2AgAgAEGAgSBqIAMoAgwiAkEOdCABQQx2cjYCACAAQYSBIGogAygCECIBQQh0IAJBEnZyNgIAIABBiIEgaiADKAIUQQJ0IAFBGHZyIAMoAhgiAUEcdHI2AgAgAEGMgSBqIAMoAhwiAkEWdCABQQR2cjYCACAAQZCBIGogAygCICIBQRB0IAJBCnZyNgIAIABBlIEgaiADKAIkQQp0IAFBEHZyNgIAIABBmIEgaiAEKAIEIgJBGnQgBCgCAHI2AgAgAEGcgSBqIAQoAggiAUEUdCACQQZ2cjYCACAAQaCBIGogBCgCDCICQQ50IAFBDHZyNgIAIABBpIEgaiAEKAIQIgFBCHQgAkESdnI2AgAgAEGogSBqIAQoAhRBAnQgAUEYdnIgBCgCGCIBQRx0cjYCACAAQayBIGogBCgCHCICQRZ0IAFBBHZyNgIAIABBsIEgaiAEKAIgIgFBEHQgAkEKdnI2AgAgAEG0gSBqIAQoAiRBCnQgAUEQdnI2AgAgEyAQIBIQCiANIBMQByANIA0gDhAKIAZBBGohKSAGQQhqISogBkEMaiErIAZBEGohLCAGQRRqIS0gBkEYaiEuIAZBHGohLyAGQSBqITAgBkEkaiExIANBBGohMiADQQhqITMgA0EMaiE0IANBEGohNSADQRRqITYgA0EYaiE3IANBHGohOCADQSBqITkgA0EkaiE6IARBBGohOyAEQQhqIQkgBEEMaiEMIARBEGohDiAEQRRqIQ8gBEEYaiERIARBHGohEiAEQSBqIRMgBEEkaiEVIA0oAgBBvOH//wBqIRYgDSgCBEH8/f//AGohFyANKAIIQfz///8AaiEYIA0oAgxB/P///wBqIRkgDSgCEEH8////AGohGiANKAIUQfz///8AaiEbIA0oAhhB/P///wBqIRwgDSgCHEH8////AGohHSANKAIgQfz///8AaiEeIA0oAiRB/P//B2ohH0H/PyEBA0AgBiAHIAFBf2oiAkEGdGoiIBAjIBAgECAGEAogFCAQEAcgKCAUIBAQCiAGIAYgFBAKICkoAgAhISAqKAIAISIgKygCACEjICwoAgAhJCAtKAIAISUgLigCACEmIC8oAgAhJyAwKAIAIQsgMSgCACEFIAYgFiAGKAIAazYCACApIBcgIWs2AgAgKiAYICJrNgIAICsgGSAjazYCACAsIBogJGs2AgAgLSAbICVrNgIAIC4gHCAmazYCACAvIB0gJ2s2AgAgMCAeIAtrNgIAIDEgHyAFazYCACAKIAogKBAKIAMgBikCADcCACADIAYpAgg3AgggAyAGKQIQNwIQIAMgBikCGDcCGCADIAYpAiA3AiAgAxAPIAQgCikCADcCACAEIAopAgg3AgggBCAKKQIQNwIQIAQgCikCGDcCGCAEIAopAiA3AiAgBBAPICAgMigCACILQRp0IAMoAgByNgIAIAcgAkEGdGogMygCACIFQRR0IAtBBnZyNgIEIAcgAkEGdGogNCgCACILQQ50IAVBDHZyNgIIIAcgAkEGdGogNSgCACIFQQh0IAtBEnZyNgIMIAcgAkEGdGogNigCAEECdCAFQRh2ciA3KAIAIgVBHHRyNgIQIAcgAkEGdGogOCgCACILQRZ0IAVBBHZyNgIUIAcgAkEGdGogOSgCACIFQRB0IAtBCnZyNgIYIAcgAkEGdGogOigCAEEKdCAFQRB2cjYCHCAHIAJBBnRqIDsoAgAiC0EadCAEKAIA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IAYoAgBFBEAgBygCBCAHKAIAciAHKAIIciAHKAIMciAHKAIQciAHKAIUciAHKAIYciAHKAIccgRAIAkgAkEAEA4CQCAMIAIgA0EAIAVBACAOQQFxEQEAIgAEQCAIQQRqIRAgCEEIaiERIAhBDGohEiAIQRBqIRMgCEEUaiEUIAhBGGohFSAIQRxqIRZBACEEA0AgCCAMIAYQDiAGKAIARQRAIBAoAgAgCCgCAHIgESgCAHIgEigCAHIgEygCAHIgFCgCAHIgFSgCAHIgFigCAHIEQCAPIAogCyAHIAkgCCANEDENBAsLIAwgAiADQQAgBSAEQQFqIgQgDkEBcREBACIADQBBACEACwVBACEACwsgCUIANwIAIAlCADcCCCAJQgA3AhAgCUIANwIYIAhCADcCACAIQgA3AgggCEIANwIQIAhCADcCGCAHQgA3AgAgB0IANwIIIAdCADcCECAHQgA3AhggAARAIA0oAgAhAyABIAopAAA3AAAgASAKKQAINwAIIAEgCikAEDcAECABIAopABg3ABggAUEgaiICIAspAAA3AAAgAiALKQAINwAIIAIgCykAEDcAECACIAspABg3ABggAUFAayADOgAAIAYkBCAADwsLCyABQgA3AAAgAUIANwAIIAFCADcAECABQgA3ABggAUIANwAgIAFCADcAKCABQgA3ADAgAUIANwA4IAFBQGtBADoAACAGJARBAAv+AQECfyMEIQQjBEFAayQEIAFFBEBByooEIAAoAqgBIAAoAqQBQQNxQQJqEQAAIAQkBEEADwsgA0UEQEGuigQgACgCqAEgACgCpAFBA3FBAmoRAAAgBCQEQQAPCyAEQSBqIQUgAgR/IAUgAykAADcAACAFIAMpAAg3AAggBSADKQAQNwAQIAUgAykAGDcAGCAEIANBIGoiACkAADcAACAEIAApAAg3AAggBCAAKQAQNwAQIAQgACkAGDcAGCACIANBQGstAAA2AgAgASAFEBEgAUEgaiAEEBEgBCQEQQEFQb6MBCAAKAKoASAAKAKkAUEDcUECahEAACAEJARBAAsL7wIBA38jBCEEIwRB0ABqJAQgBEEANgIAIAFFBEBBrooEIAAoAqgBIAAoAqQBQQNxQQJqEQAAIAQkBEEADwsgAkUEQEG6igQgACgCqAEgACgCpAFBA3FBAmoRAAAgBCQEQQAPCyADQQNLBEBBpYwEIAAoAqgBIAAoAqQBQQNxQQJqEQAAIAQkBEEADwsgBEEoaiIFIAIgBBAOIAQoAgAhACAEQQhqIgYgAkEgaiAEEA4gBCgCACAAckUiACECIAAEfyABIAUpAAA3AAAgASAFKQAINwAIIAEgBSkAEDcAECABIAUpABg3ABggAUEgaiIAIAYpAAA3AAAgACAGKQAINwAIIAAgBikAEDcAECAAIAYpABg3ABggAUFAayADOgAAIAQkBCACBSABQgA3AAAgAUIANwAIIAFCADcAECABQgA3ABggAUIANwAgIAFCADcAKCABQgA3ADAgAUIANwA4IAFBQGtBADoAACAEJAQgAgsLlCoBX38jBCEHIwRBwANqJAQgB0GgAWohCCAHQfgAaiEKIAFB+ABqIUAgB0GQA2oiBiABQdAAaiI9EAcgB0HoAmoiAyABKQIANwIAIAMgASkCCDcCCCADIAEpAhA3AhAgAyABKQIYNwIYIAMgASkCIDcCICADQSRqIiUoAgAiFEEWdiIEQdEHbCADKAIAaiEFIARBBnQgA0EEaiImKAIAaiAFQRp2aiIVQRp2IANBCGoiJygCAGoiFkEadiADQQxqIhwoAgBqIhdBGnYgA0EQaiIdKAIAaiIYQRp2IANBFGoiMSgCAGoiDkEadiADQRhqIjIoAgBqIiBBGnYgA0EcaiIzKAIAaiIhQRp2IANBIGoiNCgCAGohBCADIAVB////H3E2AgAgJiAVQf///x9xNgIAICcgFkH///8fcTYCACAcIBdB////H3E2AgAgHSAYQf///x9xNgIAIDEgDkH///8fcTYCACAyICBB////H3E2AgAgMyAhQf///x9xNgIAIDQgBEH///8fcTYCACAlIARBGnYgFEH///8BcWo2AgAgB0HAAmoiBCACIAYQCiABKAJMIhlBFnYiBUHRB2wgASgCKGohGiAFQQZ0IAEoAixqIBpBGnZqIihBGnYgASgCMGoiKUEadiABKAI0aiIqQRp2IAEoAjhqIitBGnYgASgCPGoiLEEadiABQUBrKAIAaiItQRp2IAEoAkRqIiJBGnYgASgCSGohHiAHQZgCaiIFIAJBKGoiWCAGEAogBSAFID0QCiAHQfABaiIBIAMpAgA3AgAgASADKQIINwIIIAEgAykCEDcCECABIAMpAhg3AhggASAD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aiI6KAIAayETIDogEzYCAEH8////ACAKQSBqIjsoAgBrIR8gOyAfNgIAQfz//wcgCkEkaiI/KAIAayEbID8gGzYCACAuKAIAIBtqIkJBFnYiPEHRB2wgASgCACAkamohGyA8QQZ0IBQoAgAgCWpqIBtBGnZqIiRBGnYgFSgCACALamoiC0EadiAWKAIAIA9qaiIPQRp2IBcoAgAgDGpqIgxBGnYgGCgCACANamoiDUEadiAOKAIAIBJqaiISQRp2ICAoAgAgE2pqIhNBGnYgISgCACAfamohCSABIBtB////H3EiHzYCACAUICRB////H3EiGzYCACAVIAtB////H3EiCzYCACAWIA9B////H3EiDzYCACAXIAxB////H3EiDDYCACAYIA1B////H3EiDTYCACAOIBJB////H3EiEjYCACAgIBNB////H3EiEzYCACAhIAlB////H3EiJDYCACAuIAlBGnYgQkH///8BcWoiCTYCACAAIAEpAgA3AgAgACABKQIINwIIIAAgASkCEDcCECAAIAEpAhg3AhggACABKQIgNwIgIAEgH0EBdCAKKAIAajYCACAUIBtBAXQgAygCAGo2AgAgFSALQQF0IBAoAgBqNgIAIBYgD0EBdCARKAIAajYCACAXIAxBAXQgIygCAGo2AgAgGCANQQF0IDAoAgBqNgIAIA4gEkEBdCA5KAIAajYCACAgIBNBAXQgOigCAGo2AgAgISAkQQF0IDsoAgBqNgIAIC4gCUEBdCA/KAIAajYCACABIAEgBxAKIAEgASgCACAIKAIAaiIBNgIAIBQgFCgCACAeKAIAaiIDNgIAIBUgFSgCACAZKAIAaiIINgIAIBYgFigCACAlKAIAaiIKNgIAIBcgFygCACAmKAIAaiIUNgIAIBggGCgCACAnKAIAaiIVNgIAIA4gDigCACAcKAIAaiIWNgIAICAgICgCACAdKAIAaiIXNgIAICEgISgCACAiKAIAaiIYNgIAIC4gLigCACAvKAIAaiIONgIAQfj//w8gDmsiD0EWdiIOQdEHbEH4wv//ASABa2ohASAOQQZ0Qfj7//8BIANraiABQRp2aiIcQRp2Qfj///8BIAhraiIdQRp2Qfj///8BIApraiIJQRp2Qfj///8BIBRraiIQQRp2Qfj///8BIBVraiILQRp2Qfj///8BIBZraiIR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FHZyNgIwIAIgEUESdEGAgPAfcSAQQQ52cjYCNCACIAVBGHRBgICAGHEgEUEIdnI2AjggAiAFQQJ2Qf///x9xNgI8IAJBQGsgEkEEdEHw//8fcSAFQRx2cjYCACACIBNBCnRBgPj/H3EgEkEWdnI2AkQgAiAUQRB0QYCA/B9xIBNBEHZyNgJIIAIgFEEKdjYCTCACQdAAaiINQQA2AgAgDiACKAIAciAGciAHciAIciAVciADciAKciALciAMckUEQEHajAQgACgCqAEgACgCpAFBA3FBAmoRAAAgAUIANwAAIAFCADcACCABQgA3ABAgAUIANwAYIAFCADcAICABQgA3ACggAUIANwAwIAFCADcAOCAEJARBAA8LIARBwAJqIQogBEGYAmohCyAEQfgBaiEIIARB/ABqIQMgAUIANwAAIAFCADcACCABQgA3ABAgAUIANwAYIAFCADcAICABQgA3ACggAUIANwAwIAFCADcAOCAJKAIEIAkoAgByIAkoAghyIAkoAgxyIAkoAhByIAkoAhRyIAkoAhhyIAkoAhxyBH8gCEIANwIAIAhCADcCCCAIQgA3AhAgCEIANwIYIANB+ABqIgxBADYCACADIAIpAgA3AgAgAyACKQIINwIIIAMgAikCEDcCECADIAIpAhg3AhggAyACKQIgNwIgIANBKGoiBSACQShqIgYpAgA3AgAgBSAGKQIINwIIIAUgBikCEDcCECAFIAYpAhg3AhggBSAGKQIgNwIgIANBATYCUCADQdQAaiIHQgA3AgAgB0IANwIIIAdCADcCECAHQgA3AhggB0EANgIgIAAgAyADIAkgCBAZIA0gDCgCADYCACADQdAAaiIAIAAQFSAKIAAQByALIAAgChAKIAMgAyAKEAogBSAFIAsQCiAAQQE2AgAgB0IANwIAIAdCADcCCCAHQgA3AhAgB0IANwIYIAdBADYCICACIAMpAgA3AgAgAiADKQIINwIIIAIgAykCEDcCECACIAMpAhg3AhggAiADKQIgNwIgIAYgBSkCADcCACAGIAUpAgg3AgggBiAFKQIQNwIQIAYgBSkCGDcCGCAGIAUpAiA3AiAgASACEBsgBCQEQQEFIAQkBEEACwvhAgEBfyMEIQMjBEHQAGokBCADQQA2AgAgAUUEQEGIjAQgACgCqAEgACgCpAFBA3FBAmoRAAAgAyQEQQAPCyACRQRAQZeMBCAAKAKoASAAKAKkAUEDcUECahEAACADJARBAA8LIANBKGoiACACIAMQDiADQQhqIgIgAUEAEA4gAygCAAR/IAFCADcAACABQgA3AAggAUIANwAQIAFCADcAGEEABSAAKAIEIAAoAgByIAAoAghyIAAoAgxyIAAoAhByIAAoAhRyIAAoAhhyIAAoAhxyBH8gAiACIAAQDSABQgA3AAAgAUIANwAIIAFCADcAECABQgA3ABggASACEBFBAQUgAUIANwAAIAFCADcACCABQgA3ABAgAUIANwAYQQALCyEBIAJCADcCACACQgA3AgggAkIANwIQIAJCADcCGCAAQgA3AgAgAEIANwIIIABCADcCECAAQgA3AhggAyQEIAELgAsBE38jBCEEIwRB8AJqJAQgBEEANgIAIAAoAgBFBEBB+IoEIAAoAqgBIAAoAqQBQQNxQQJqEQAAIAQkBEEADwsgAUUEQEHkiAQgACgCqAEgACgCpAFBA3FBAmoRAAAgBCQEQQAPCyACRQRAQZeMBCAAKAKoASAAKAKkAUEDcUECahEAACAEJARBAA8LIARBCGoiFCACIAQQDiAEKAIABEAgAUIANwAAIAFCADcACCABQgA3ABAgAUIANwAYIAFCADcAICABQgA3ACggAUIANwAwIAFCADcAOCAEJARBAA8LIAEoAAQhBiABKAAIIQcgASgADCEIIAEoABAhAyABKAAUIQkgASgAGCEKIAEoABwhCyABKAAgIQwgASgAJCENIAEoACghDyABKAAsIRAgASgAMCEFIAEoADQhESABKAA4IRIgASgAPCETIARBKGoiAiABKAAAIg5B////H3E2AgAgAiAGQQZ0QcD//x9xIA5BGnZyIg42AgQgAiAHQQx0QYDg/x9xIAZBFHZyIgY2AgggAiAIQRJ0QYCA8B9xIAdBDnZyIgc2AgwgAiADQRh0QYCAgBhxIAhBCHZyIgg2AhAgAiADQQJ2Qf///x9xIhU2AhQgAiAJQQR0QfD//x9xIANBHHZyIgM2AhggAiAKQQp0QYD4/x9xIAlBFnZyIgk2AhwgAiALQRB0QYCA/B9xIApBEHZyIgo2AiAgAiALQQp2Igs2AiQgAiAMQf///x9xNgIoIAIgDUEGdEHA//8fcSAMQRp2cjYCLCACIA9BDHRBgOD/H3Eg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AWoiBCANQQFxEQEAIgANAEEAIQALBUEAIQALCyAJQgA3AgAgCUIANwIIIAlCADcCECAJQgA3AhggCEIANwIAIAhCADcCCCAIQgA3AhAgCEIANwIYIAdCADcCACAHQgA3AgggB0IANwIQIAdCADcCGCAABEAgASAKKQAANwAAIAEgCikACDcACCABIAopABA3ABAgASAKKQAYNwAYIAFBIGoiASALKQAANwAAIAEgCykACDcACCABIAspABA3ABAgASALKQAYNwAYIAYkBCAADwsLCyABQgA3AAAgAUIANwAIIAFCADcAECABQgA3ABggAUIANwAgIAFCADcAKCABQgA3ADAgAUIANwA4IAYkBEEAC9cCAQJ/IwQhByMEQcABaiQEIAdByABqIgYgAikAADcAACAGIAIpAAg3AAggBiACKQAQNwAQIAYgAikAGDcAGCAGQSBqIgIgASkAADcAACACIAEpAAg3AAggAiABKQAQNwAQIAIgASkAGDcAGCAEBH8gBkFAayIBIAQpAAA3AAAgASAEKQAINwAIIAEgBCkAEDcAECABIAQpABg3ABhB4AAFQcAACyEBIAMEQCAGIAFqIgIgAykAADcAACACIAMpAAg3AAggAUEQciEBCyAHIAYgARAqIAZCADcAACAGQgA3AAggBkIANwAQIAZCADcAGCAGQgA3ACAgBkIANwAoIAZCADcAMCAGQgA3ADggBkFAa0IANwAAIAZCADcASCAGQgA3AFAgBkIANwBYIAZCADcAYCAGQgA3AGhBACEBA0AgByAAEB8gAUEBaiIBIAVNDQALIAckBEEBC90QASl/IwQhBSMEQYAEaiQEIAAoAgBFBEBB+IoEIAAoAqgBIAAoAqQBQQNxQQJqEQAAIAUkBEEADwsgAkUEQEGsiwQgACgCqAEgACgCpAFBA3FBAmoRAAAgBSQEQQAPCyABRQRAQa6KBCAAKAKoASAAKAKkAUEDcUECahEAACAFJARBAA8LIANFBEBB5IgEIAAoAqgBIAAoAqQBQQNxQQJqEQAAIAUkBEEADwsgBSACQQAQDiAFQUBrIgYgASkAADcAACAGIAEpAAg3AAggBiABKQAQNwAQIAYgASkAGDcAGCAFQSBqIgQgAUEgaiIBKQAANwAAIAQgASkACDcACCAEIAEpABA3ABAgBCABKQAYNwAYIARBGGoi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////HzYCACAGQf///x82AgAgAkH///8BNgIAIAMgBxAhQQBHCwsLCwsLCwsFQQALBUEACwshACAFJAQgAAuYBQIJfwd+IwQhBCMEQSBqJAQgAkUEQEHbigQgACgCqAEgACgCpAFBA3FBAmoRAAAgBCQEQQAPCyAEIgAgAikAADcAACAAIAIpAAg3AAggACACKQAQNwAQIAAgAikAGDcAGCACKAA4IghBf0cgAigAPCIEQR92IgVBf3MiA3EgBEH/////B0lyIAMgAigANCIJQX9HcXIgAyACKAAwIgpBf0dxciADIAIoACwiA0Hz3N3qBUlxciIGQQFzIANB89zd6gVLcSAFciIHQQFzIAIoACgiBUGdoJG9BUlxIAZyIgtBAXMgBUGdoJG9BUtxIAdyIgdBAXMgAigAJCIGQcbepP99SXEgC3JBf3MiCyAGQcbepP99S3EgB3IgCyACKAAgIgJBoMHswAZLcXIhByABRQRAIAAkBCAHDwsgBwRAIAhBf3OtQv////8PfCAJQX9zrUL/////D3wgCkF/c61C/v///w98IANBf3OtQua5u9ULfCAFQX9zrUK7wKL6CnwgBkF/c61CjL3J/gt8IAJBf3OtQsKC2YENfCIMQiCIfCIOQiCIfCIPQiCIfCIQQiCIfCIRQiCIfCISQiCIfCENIAwgBiACciAFciADciAKciAJciAIciAEckEAR0EfdEEfda0iDIOnIQIgDyAMg6chBSAQIAyDpyEDIBEgDIOnIQogEiAMg6chCSANIAyDpyEIIARBf3OtQv////8PfCANQiCIfCAMg6chBCAOIAyDpyEGCyABIAApAAA3AAAgASAAKQAINwAIIAEgACkAEDcAECABIAApABg3ABggASACNgAgIAEgBjYAJCABIAU2ACggASADNgAsIAEgCjYAMCABIAk2ADQgASAINgA4IAEgBDYAPCAAJAQgBwuDAwIGfwh+IAJFBEBB24oEIAAoAqgBIAAoAqQBQQNxQQJqEQAAQQAPCyABBH8gAigAICIAQX9zrULCgtmBDXwhCiACKAAkIgMgAHIgAigAKCIAciACKAAsIgRyIAIoADAiBXIgAigANCIGciACKAA4IgdyIAIoADwiCHJBAEdBH3RBH3WtIQkgB0F/c61C/////w98IAZBf3OtQv////8PfCAFQX9zrUL+////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';

/* eslint-disable @typescript-eslint/no-explicit-any, @typescript-eslint/no-unsafe-return, @typescript-eslint/no-unsafe-call, @typescript-eslint/no-unsafe-member-access, @typescript-eslint/no-unsafe-assignment */
var wrapSecp256k1Wasm$1 = function wrapSecp256k1Wasm(instance, heapU8, heapU32) {
  return {
    contextCreate: function contextCreate(context) {
      return instance.exports._secp256k1_context_create(context);
    },
    contextRandomize: function contextRandomize(contextPtr, seedPtr) {
      return instance.exports._secp256k1_context_randomize(contextPtr, seedPtr);
    },
    free: function free(pointer) {
      return instance.exports._free(pointer);
    },
    heapU32: heapU32,
    heapU8: heapU8,
    instance: instance,
    malloc: function malloc(bytes) {
      return instance.exports._malloc(bytes);
    },
    mallocSizeT: function mallocSizeT(num) {
      // eslint-disable-next-line @typescript-eslint/no-magic-numbers
      var pointer = instance.exports._malloc(4);
      // eslint-disable-next-line no-bitwise, @typescript-eslint/no-magic-numbers
      var pointerView32 = pointer >> 2;
      // eslint-disable-next-line functional/no-expression-statement
      heapU32.set([num], pointerView32);
      return pointer;
    },
    mallocUint8Array: function mallocUint8Array(array) {
      var pointer = instance.exports._malloc(array.length);
      // eslint-disable-next-line functional/no-expression-statement
      heapU8.set(array, pointer);
      return pointer;
    },
    privkeyTweakAdd: function privkeyTweakAdd(contextPtr, secretKeyPtr, tweakNum256Ptr) {
      return instance.exports._secp256k1_ec_privkey_tweak_add(contextPtr, secretKeyPtr, tweakNum256Ptr);
    },
    privkeyTweakMul: function privkeyTweakMul(contextPtr, secretKeyPtr, tweakNum256Ptr) {
      return instance.exports._secp256k1_ec_privkey_tweak_mul(contextPtr, secretKeyPtr, tweakNum256Ptr);
    },
    pubkeyCreate: function pubkeyCreate(contextPtr, publicKeyPtr, secretKeyPtr) {
      return instance.exports._secp256k1_ec_pubkey_create(contextPtr, publicKeyPtr, secretKeyPtr);
    },
    pubkeyParse: function pubkeyParse(contextPtr, publicKeyOutPtr, publicKeyInPtr, publicKeyInLength) {
      return instance.exports._secp256k1_ec_pubkey_parse(contextPtr, publicKeyOutPtr, publicKeyInPtr, publicKeyInLength);
    },
    pubkeySerialize: function pubkeySerialize(contextPtr, outputPtr, outputLengthPtr, publicKeyPtr, compression) {
      return instance.exports._secp256k1_ec_pubkey_serialize(contextPtr, outputPtr, outputLengthPtr, publicKeyPtr, compression);
    },
    pubkeyTweakAdd: function pubkeyTweakAdd(contextPtr, publicKeyPtr, tweakNum256Ptr) {
      return instance.exports._secp256k1_ec_pubkey_tweak_add(contextPtr, publicKeyPtr, tweakNum256Ptr);
    },
    pubkeyTweakMul: function pubkeyTweakMul(contextPtr, publicKeyPtr, tweakNum256Ptr) {
      return instance.exports._secp256k1_ec_pubkey_tweak_mul(contextPtr, publicKeyPtr, tweakNum256Ptr);
    },
    readHeapU8: function readHeapU8(pointer, bytes) {
      return new Uint8Array(heapU8.buffer, pointer, bytes);
    },
    readSizeT: function readSizeT(pointer) {
      // eslint-disable-next-line no-bitwise, @typescript-eslint/no-magic-numbers
      var pointerView32 = pointer >> 2;
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      return heapU32[pointerView32];
    },
    recover: function recover(contextPtr, outputPubkeyPointer, rSigPtr, msg32Ptr) {
      return instance.exports._secp256k1_ecdsa_recover(contextPtr, outputPubkeyPointer, rSigPtr, msg32Ptr);
    },
    recoverableSignatureParse: function recoverableSignatureParse(contextPtr, outputRSigPtr, inputSigPtr, rid) {
      return instance.exports._secp256k1_ecdsa_recoverable_signature_parse_compact(contextPtr, outputRSigPtr, inputSigPtr, rid);
    },
    recoverableSignatureSerialize: function recoverableSignatureSerialize(contextPtr, sigOutPtr, recIDOutPtr, rSigPtr) {
      return instance.exports._secp256k1_ecdsa_recoverable_signature_serialize_compact(contextPtr, sigOutPtr, recIDOutPtr, rSigPtr);
    },
    schnorrSign: function schnorrSign(contextPtr, outputSigPtr, msg32Ptr, secretKeyPtr) {
      return instance.exports._secp256k1_schnorr_sign(contextPtr, outputSigPtr, msg32Ptr, secretKeyPtr);
    },
    schnorrVerify: function schnorrVerify(contextPtr, sigPtr, msg32Ptr, publicKeyPtr) {
      return instance.exports._secp256k1_schnorr_verify(contextPtr, sigPtr, msg32Ptr, publicKeyPtr);
    },
    seckeyVerify: function seckeyVerify(contextPtr, secretKeyPtr) {
      return instance.exports._secp256k1_ec_seckey_verify(contextPtr, secretKeyPtr);
    },
    sign: function sign(contextPtr, outputSigPtr, msg32Ptr, secretKeyPtr) {
      return instance.exports._secp256k1_ecdsa_sign(contextPtr, outputSigPtr, msg32Ptr, secretKeyPtr);
    },
    signRecoverable: function signRecoverable(contextPtr, outputRSigPtr, msg32Ptr, secretKeyPtr) {
      return instance.exports._secp256k1_ecdsa_sign_recoverable(contextPtr, outputRSigPtr, msg32Ptr, secretKeyPtr);
    },
    signatureMalleate: function signatureMalleate(contextPtr, outputSigPtr, inputSigPtr) {
      return instance.exports._secp256k1_ecdsa_signature_malleate(contextPtr, outputSigPtr, inputSigPtr);
    },
    signatureNormalize: function signatureNormalize(contextPtr, outputSigPtr, inputSigPtr) {
      return instance.exports._secp256k1_ecdsa_signature_normalize(contextPtr, outputSigPtr, inputSigPtr);
    },
    signatureParseCompact: function signatureParseCompact(contextPtr, sigOutPtr, compactSigInPtr) {
      return instance.exports._secp256k1_ecdsa_signature_parse_compact(contextPtr, sigOutPtr, compactSigInPtr);
    },
    signatureParseDER: function signatureParseDER(contextPtr, sigOutPtr, sigDERInPtr, sigDERInLength) {
      return instance.exports._secp256k1_ecdsa_signature_parse_der(contextPtr, sigOutPtr, sigDERInPtr, sigDERInLength);
    },
    signatureSerializeCompact: function signatureSerializeCompact(contextPtr, outputCompactSigPtr, inputSigPtr) {
      return instance.exports._secp256k1_ecdsa_signature_serialize_compact(contextPtr, outputCompactSigPtr, inputSigPtr);
    },
    signatureSerializeDER: function signatureSerializeDER(contextPtr, outputDERSigPtr, outputDERSigLengthPtr, inputSigPtr) {
      return instance.exports._secp256k1_ecdsa_signature_serialize_der(contextPtr, outputDERSigPtr, outputDERSigLengthPtr, inputSigPtr);
    },
    verify: function verify(contextPtr, sigPtr, msg32Ptr, pubkeyPtr) {
      return instance.exports._secp256k1_ecdsa_verify(contextPtr, sigPtr, msg32Ptr, pubkeyPtr);
    }
  };
};
/* eslint-enable @typescript-eslint/no-explicit-any, @typescript-eslint/no-unsafe-return, @typescript-eslint/no-unsafe-call, @typescript-eslint/no-unsafe-member-access, @typescript-eslint/no-unsafe-assignment */
/* eslint-disable functional/immutable-data, functional/no-expression-statement, @typescript-eslint/no-magic-numbers, functional/no-conditional-statement, no-bitwise, functional/no-throw-statement */
/**
 * Method extracted from Emscripten's preamble.js
 */
var isLittleEndian = function isLittleEndian(buffer) {
  var littleEndian = true;
  var notLittleEndian = false;
  var heap16 = new Int16Array(buffer);
  var heap32 = new Int32Array(buffer);
  var heapU8 = new Uint8Array(buffer);
  heap32[0] = 1668509029;
  heap16[1] = 25459;
  return heapU8[2] !== 115 || heapU8[3] !== 99 ? /* istanbul ignore next */notLittleEndian : littleEndian;
};
/**
 * Method derived from Emscripten's preamble.js
 */
var alignMemory = function alignMemory(factor, size) {
  return Math.ceil(size / factor) * factor;
};
/**
 * The most performant way to instantiate secp256k1 functionality. To avoid
 * using Node.js or DOM-specific APIs, you can use {@link instantiateSecp256k1}.
 *
 * Note, most of this method is translated and boiled-down from Emscripten's
 * preamble.js. Significant changes to the WASM build or breaking updates to
 * Emscripten will likely require modifications to this method.
 *
 * @param webassemblyBytes - A buffer containing the secp256k1 binary.
 */
var instantiateSecp256k1WasmBytes = /*#__PURE__*/function () {
  var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(webassemblyBytes) {
    var STACK_ALIGN, GLOBAL_BASE, WASM_PAGE_SIZE, TOTAL_STACK, TOTAL_MEMORY, wasmMemory, STATIC_BASE, STATICTOP_INITIAL, DYNAMICTOP_PTR, DYNAMICTOP_PTR_SIZE, STATICTOP, STACKTOP, STACK_BASE, STACK_MAX, DYNAMIC_BASE, heapU8, heap32, heapU32, TABLE_SIZE, MAX_TABLE_SIZE, getErrNoLocation, env, info;
    return _regeneratorRuntime().wrap(function _callee$(_context) {
      while (1) switch (_context.prev = _context.next) {
        case 0:
          STACK_ALIGN = 16;
          GLOBAL_BASE = 1024;
          WASM_PAGE_SIZE = 65536;
          TOTAL_STACK = 5242880;
          TOTAL_MEMORY = 16777216;
          wasmMemory = new WebAssembly.Memory({
            initial: TOTAL_MEMORY / WASM_PAGE_SIZE,
            maximum: TOTAL_MEMORY / WASM_PAGE_SIZE
          });
          /* istanbul ignore if  */
          if (isLittleEndian(wasmMemory.buffer)) {
            _context.next = 8;
            break;
          }
          throw new Error('Runtime error: expected the system to be little-endian.');
        case 8:
          STATIC_BASE = GLOBAL_BASE;
          STATICTOP_INITIAL = STATIC_BASE + 67696 + 16;
          DYNAMICTOP_PTR = STATICTOP_INITIAL;
          DYNAMICTOP_PTR_SIZE = 4;
          STATICTOP = STATICTOP_INITIAL + DYNAMICTOP_PTR_SIZE + 15 & -16;
          STACKTOP = alignMemory(STACK_ALIGN, STATICTOP);
          STACK_BASE = STACKTOP;
          STACK_MAX = STACK_BASE + TOTAL_STACK;
          DYNAMIC_BASE = alignMemory(STACK_ALIGN, STACK_MAX);
          heapU8 = new Uint8Array(wasmMemory.buffer);
          heap32 = new Int32Array(wasmMemory.buffer);
          heapU32 = new Uint32Array(wasmMemory.buffer);
          heap32[DYNAMICTOP_PTR >> 2] = DYNAMIC_BASE;
          TABLE_SIZE = 6;
          MAX_TABLE_SIZE = 6; // eslint-disable-next-line functional/no-let, @typescript-eslint/init-declarations
          /*
           * note: A number of methods below are excluded from test coverage. They are
           * a) not part of the regular usage of this library (should only be evaluated
           * if the consumer mis-implements the library and exist only to make
           * debugging easier) and B) already tested adequately in Emscripten, from
           * which this section is extracted.
           */
          env = {
            DYNAMICTOP_PTR: DYNAMICTOP_PTR,
            STACKTOP: STACKTOP,
            ___setErrNo: /* istanbul ignore next */function ___setErrNo(value) {
              if (getErrNoLocation !== undefined) {
                heap32[getErrNoLocation() >> 2] = value;
              }
              return value;
            },
            _abort: /* istanbul ignore next */function _abort() {
              var err = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'Secp256k1 Error';
              throw new Error(err);
            },
            // eslint-disable-next-line camelcase
            _emscripten_memcpy_big: /* istanbul ignore next */function _emscripten_memcpy_big(dest, src, num) {
              heapU8.set(heapU8.subarray(src, src + num), dest);
              return dest;
            },
            abort: /* istanbul ignore next */function abort() {
              var err = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'Secp256k1 Error';
              throw new Error(err);
            },
            abortOnCannotGrowMemory: /* istanbul ignore next */function abortOnCannotGrowMemory() {
              throw new Error('Secp256k1 Error: abortOnCannotGrowMemory was called.');
            },
            enlargeMemory: /* istanbul ignore next */function enlargeMemory() {
              throw new Error('Secp256k1 Error: enlargeMemory was called.');
            },
            getTotalMemory: function getTotalMemory() {
              return TOTAL_MEMORY;
            }
          };
          info = {
            env: _objectSpread2(_objectSpread2({}, env), {}, {
              memory: wasmMemory,
              memoryBase: STATIC_BASE,
              table: new WebAssembly.Table({
                element: 'anyfunc',
                initial: TABLE_SIZE,
                maximum: MAX_TABLE_SIZE
              }),
              tableBase: 0
            }),
            global: {
              Infinity: Infinity,
              NaN: NaN
            }
          };
          return _context.abrupt("return", WebAssembly.instantiate(webassemblyBytes, info).then(function (result) {
            // eslint-disable-next-line @typescript-eslint/no-explicit-any, @typescript-eslint/no-unsafe-assignment
            getErrNoLocation = result.instance.exports['___errno_location'];
            return wrapSecp256k1Wasm$1(result.instance, heapU8, heapU32);
          }));
        case 26:
        case "end":
          return _context.stop();
      }
    }, _callee);
  }));
  return function instantiateSecp256k1WasmBytes(_x) {
    return _ref.apply(this, arguments);
  };
}();
/* eslint-enable functional/immutable-data, functional/no-expression-statement, @typescript-eslint/no-magic-numbers, functional/no-conditional-statement, no-bitwise, functional/no-throw-statement */
var getEmbeddedSecp256k1Binary = function getEmbeddedSecp256k1Binary() {
  return base64ToBin(secp256k1Base64Bytes).buffer;
};
/**
 * An ultimately-portable (but slower) version of
 * {@link instantiateSecp256k1Bytes} that does not require the consumer to
 * provide the secp256k1 binary buffer.
 */
var instantiateSecp256k1Wasm = /*#__PURE__*/function () {
  var _ref2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2() {
    return _regeneratorRuntime().wrap(function _callee2$(_context2) {
      while (1) switch (_context2.prev = _context2.next) {
        case 0:
          return _context2.abrupt("return", instantiateSecp256k1WasmBytes(getEmbeddedSecp256k1Binary()));
        case 1:
        case "end":
          return _context2.stop();
      }
    }, _callee2);
  }));
  return function instantiateSecp256k1Wasm() {
    return _ref2.apply(this, arguments);
  };
}();

/* eslint-disable tsdoc/syntax */
/**
 * @hidden
 */
// prettier-ignore
var sha1Base64Bytes = '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cjYCBEG8FCAANgIAQbQUIAI2AgAgACACaiACNgIADAQLIAMQJQwBC0GkEUGkESgCAEF+IAFBA3Z3cTYCAAsgBCACaiECIAMgBGohAwsgAyADKAIEQX5xNgIEIAAgAkEBcjYCBCAAIAJqIAI2AgACfwJAIAJB/wFNBEAgAkEDdiIBQQN0QawRaiECQaQRKAIAIgNBASABQR9xdCIBcUUNASACQQhqIQMgAigCCAwCCyAAIAIQJgwCC0GkESADIAFyNgIAIAJBCGohAyACCyEBIAMgADYCACABIAA2AgwgACACNgIMIAAgATYCCAsgBUEIag8LQbgUIAAgAmsiATYCAEHAFEHAFCgCACIAIAJqIgM2AgAgAyABQQFyNgIEIAAgAkEDcjYCBCAAQQhqC6UBAQJ/QQIhBQJAAkACQAJAAkAgACgCBCIGIAFrIAJPDQAgASACaiICIAFJIQECQCAEBEBBACEFIAENAiAGQQF0IgEgAiACIAFJGyECDAELQQAhBSABDQELIAJBAEgNACAGRQ0BIAAoAgAgAhATIgFFDQIMAwsgBQ8LIAIQBCIBDQELIAMNAQsgAQRAIAAgATYCACAAQQRqIAI2AgBBAg8LQQEPCwALCABB5BUQBwALZgIBfwN+IwBBMGsiASQAIAApAhAhAiAAKQIIIQMgACkCACEEIAFBFGpBADYCACABIAQ3AxggAUIBNwIEIAFBrA42AhAgASABQRhqNgIAIAEgAzcDICABIAI3AyggASABQSBqECIAC7gBAQF/IwBB4AFrIgMkACADQThqQcwIKAIANgIAIANBMGpBxAgpAgA3AwAgA0IANwMgIANBvAgpAgA3AyggA0E8akEAQcQAEC4aIANBIGogASACEAkgA0GAAWogA0EgakHgABAsGiADQQhqIANBgAFqEAogA0EgaiADQQhqQRQQAyADQYgBaiADQShqKAIANgIAIAMgAykDIDcDgAEgAyADQYABahALIAAgAykDADcCACADQeABaiQAC5cDAQR/IwBBQGoiAyQAIAAgACkDACACrXw3AwAgAyAAQQhqNgIoIAMgA0EoajYCLAJAAkACQAJAAkACQCAAKAIcIgUEQEHAACAFayIEIAJNDQEgA0EYaiAFIAUgAmoiBCAAQSBqEBUgAygCHCACRw0FIAMoAhggASACECwaDAMLIAIhBAwBCyADQTBqIAEgAiAEEBYgA0E8aigCACEEIAMoAjghASADKAIwIQUgAygCNCECIANBIGogAEEgaiIGIAAoAhwQFyACIAMoAiRHDQQgAygCICAFIAIQLBogAEEcakEANgIAIANBLGogBhAYCyADQTxqIQIgA0E4aiEFAkADQCAEQT9NDQEgA0EwaiABIARBwAAQFiACKAIAIQQgBSgCACEBIANBCGpBAEHAACADKAIwIAMoAjQQGSADQSxqIAMoAggQGAwACwALIANBEGogAEEgaiAEEBogAygCFCAERw0BIAMoAhAgASAEECwaCyAAQRxqIAQ2AgAgA0FAayQADwtBrBUQBwALQawVEAcAC0GsFRAHAAu3BAIEfwF+IwBBQGoiAiQAIAIgAUEIaiIFNgIkIAEpAwAhBiABKAIcIQQgAiACQSRqNgIoAkAgBEE/TQRAIAFBIGoiAyAEakGAAToAACABIAEoAhxBAWoiBDYCHCACQRhqIAMgBBAXIAIoAhhBACACKAIcEC4aQcAAIAEoAhxrQQdNBEAgAkEoaiADEBggAkEQaiADIAFBHGooAgAQGiACKAIQQQAgAigCFBAuGgsgAkEIaiADQTgQFyACKAIMQQhHDQEgAigCCCAGQjuGIAZCK4ZCgICAgICAwP8Ag4QgBkIbhkKAgICAgOA/gyAGQguGQoCAgIDwH4OEhCAGQgWIQoCAgPgPgyAGQhWIQoCA/AeDhCAGQiWIQoD+A4MgBkIDhkI4iISEhDcAACACQShqIAMQGCABQRxqQQA2AgAgAkEANgIoQQQhAQJAA0AgAUEYRg0BIAJBKGogAWpBADoAACACIAIoAihBAWo2AiggAUEBaiEBDAALAAsgAkE4aiAFQRBqKAAANgIAIAJBMGogBUEIaikAADcDACACIAUpAAA3AyhBACEBAkADQCABQRRGDQEgAkEoaiABaiIDIAMoAgAiA0EYdCADQQh0QYCA/AdxciADQQh2QYD+A3EgA0EYdnJyNgIAIAFBBGohAQwACwALIAAgAikDKDcAACAAQRBqIAJBOGooAgA2AAAgAEEIaiACQTBqKQMANwAAIAJBQGskAA8LQYQVIARBwAAQHQALQZQVEAcAC2MBAn8gASgCACECAkACQCABKAIEIgMgASgCCCIBRgRAIAMhAQwBCyADIAFJDQEgAQRAIAIgARATIgINAQALIAIgAxARQQEhAkEAIQELIAAgATYCBCAAIAI2AgAPC0HsFBAHAAuQAQEBfyMAQYABayIBJAAgAUEwakHECCkCADcDACABQThqQcwIKAIANgIAIAFCADcDICABQbwIKQIANwMoIAFBPGpBAEHEABAuGiABQRBqIAFBIGpB4AAQAyABQShqIAFBGGooAgA2AgAgASABKQMQNwMgIAFBCGogAUEgahALIAAgASkDCDcCACABQYABaiQAC4YBAQF/IwBB4AFrIgUkACAFQSBqIAEgAhABQeAAEC0aIAVBIGogAyAEEAkgBUGAAWogBUEgakHgABAsGiAFQRBqIAVBgAFqQeAAEAMgBUGIAWogBUEYaigCADYCACAFIAUpAxA3A4ABIAVBCGogBUGAAWoQCyAAIAUpAwg3AgAgBUHgAWokAAtuAQF/IwBBkAFrIgMkACADQTBqIAEgAhABQeAAECwaIANBGGogA0EwahAKIANBCGogA0EYakEUEAMgA0E4aiADQRBqKAIANgIAIAMgAykDCDcDMCADIANBMGoQCyAAIAMpAwA3AgAgA0GQAWokAAtKAQF/IwBBEGsiASQAIAFCATcDACABQQA2AgggAUEAIABBAEEAEAVB/wFxQQJGBEAgASgCACEAIAFBEGokACAADwtBgAhBFhAAAAsIACAAIAEQEQsLACABBEAgABAUCwsFAEHIEAvHBQEIfwJAAkACQAJAAkACQCABQb9/Sw0AQRAgAUELakF4cSABQQtJGyECIABBfGoiBigCACIHQXhxIQMCQAJAAkACQCAHQQNxBEAgAEF4aiIIIANqIQUgAyACTw0BQcAUKAIAIAVGDQJBvBQoAgAgBUYNAyAFKAIEIgdBAnENBCAHQXhxIgkgA2oiAyACSQ0EIAMgAmshASAJQf8BSw0HIAUoAgwiBCAFKAIIIgVGDQggBSAENgIMIAQgBTYCCAwJCyACQYACSQ0DIAMgAkEEckkNAyADIAJrQYGACE8NAwwJCyADIAJrIgFBEEkNCCAGIAIgB0EBcXJBAnI2AgAgCCACaiIEIAFBA3I2AgQgBSAFKAIEQQFyNgIEIAQgARAnDAgLQbgUKAIAIANqIgMgAk0NASAGIAIgB0EBcXJBAnI2AgBBwBQgCCACaiIBNgIAQbgUIAMgAmsiBDYCACABIARBAXI2AgQMBwtBtBQoAgAgA2oiAyACTw0CCyABEAQiAkUNACACIAAgASAGKAIAIgRBeHFBBEEIIARBA3EbayIEIAQgAUsbECwhASAAEBQgASEECyAEDwsCQCADIAJrIgFBEEkEQCAGIAdBAXEgA3JBAnI2AgAgCCADaiIBIAEoAgRBAXI2AgRBACEBDAELIAYgAiAHQQFxckECcjYCACAIIAJqIgQgAUEBcjYCBCAIIANqIgIgATYCACACIAIoAgRBfnE2AgQLQbwUIAQ2AgBBtBQgATYCAAwDCyAFECUMAQtBpBFBpBEoAgBBfiAHQQN2d3E2AgALIAFBD00EQCAGIAMgBigCAEEBcXJBAnI2AgAgCCADaiIBIAEoAgRBAXI2AgQMAQsgBiACIAYoAgBBAXFyQQJyNgIAIAggAmoiBCABQQNyNgIEIAggA2oiAiACKAIEQQFyNgIEIAQgARAnIAAPCyAAC+AGAQV/AkAgAEF4aiIBIABBfGooAgAiA0F4cSIAaiECAkACQCADQQFxDQAgA0EDcUUNASABKAIAIgMgAGohAAJAAkBBvBQoAgAgASADayIBRwRAIANB/wFLDQEgASgCDCIEIAEoAggiBUYNAiAFIAQ2AgwgBCAFNgIIDAMLIAIoAgQiA0EDcUEDRw0CQbQUIAA2AgAgAkEEaiADQX5xNgIADAQLIAEQJQwBC0GkEUGkESgCAEF+IANBA3Z3cTYCAAsCQAJ/AkACQAJAAkACQAJAIAIoAgQiA0ECcUUEQEHAFCgCACACRg0BQbwUKAIAIAJGDQIgA0F4cSIEIABqIQAgBEH/AUsNAyACKAIMIgQgAigCCCICRg0EIAIgBDYCDCAEIAI2AggMBQsgAkEEaiADQX5xNgIAIAEgAEEBcjYCBCABIABqIAA2AgAMBwtBwBQgATYCAEG4FEG4FCgCACAAaiIANgIAIAEgAEEBcjYCBCABQbwUKAIARgRAQbQUQQA2AgBBvBRBADYCAAtB3BQoAgAgAE8NBwJAIABBKUkNAEHMFCEAA0AgACgCACICIAFNBEAgAiAAKAIEaiABSw0CCyAAKAIIIgANAAsLQQAhAUHUFCgCACIARQ0EA0AgAUEBaiEBIAAoAggiAA0ACyABQf8fIAFB/x9LGwwFC0G8FCABNgIAQbQUQbQUKAIAIABqIgA2AgAMBwsgAhAlDAELQaQRQaQRKAIAQX4gA0EDdndxNgIACyABIABBAXI2AgQgASAAaiAANgIAIAFBvBQoAgBHDQJBtBQgADYCAA8LQf8fCyEBQdwUQX82AgBB5BQgATYCAA8LQeQUAn8CQAJ/AkAgAEH/AU0EQCAAQQN2IgJBA3RBrBFqIQBBpBEoAgAiA0EBIAJBH3F0IgJxRQ0BIABBCGohAyAAKAIIDAILIAEgABAmQeQUQeQUKAIAQX9qIgE2AgAgAQ0EQdQUKAIAIgBFDQJBACEBA0AgAUEBaiEBIAAoAggiAA0ACyABQf8fIAFB/x9LGwwDC0GkESADIAJyNgIAIABBCGohAyAACyECIAMgATYCACACIAE2AgwgASAANgIMIAEgAjYCCA8LQf8fCyIBNgIACw8LIAEgAEEBcjYCBCABIABqIAA2AgALOQACQCACIAFPBEAgAkHBAE8NASAAIAIgAWs2AgQgACADIAFqNgIADwsgASACEBwACyACQcAAEAIAC00CAX8CfiMAQRBrIgQkACAEQQhqQQAgAyABIAIQGSAEKQMIIQUgBCADIAIgASACEBkgBCkDACEGIAAgBTcCACAAIAY3AgggBEEQaiQACywBAX8jAEEQayIDJAAgA0EIaiACQcAAIAEQFSAAIAMpAwg3AgAgA0EQaiQACw4AIAAoAgAoAgAgARAbCzcAAkAgAiABTwRAIAQgAkkNASAAIAIgAWs2AgQgACADIAFqNgIADwsgASACEBwACyACIAQQAgALKwEBfyMAQRBrIgMkACADQQhqQQAgAiABEBUgACADKQMINwIAIANBEGokAAuFHwIdfwF+IwBBkAFrIgIkACACIAFBwAAQLCEBQQAhAgJAA0AgAkHAAEYNASABIAJqIhMgEygCACITQRh0IBNBCHRBgID8B3FyIBNBCHZBgP4DcSATQRh2cnI2AgAgAkEEaiECDAALAAsgACgCDCEbIAAoAgghHCAAKAIAIRkgASgCACEDIAEoAgwhBCABKAIIIQUgASgCBCELIAEgACgCBCIdNgJ0IAEgGTYCcCABIBw2AnggASAbNgJ8IAEgCzYChAEgASAFNgKIASABIAQ2AowBIAEgAyAAKAIQIh5qNgKAASABQUBrIAFB8ABqIAFBgAFqQQAQHiABKAIcIQYgASgCGCEPIAEoAhAhFCABKAIUIQwgAUH4AGoiEyABQcgAaiICKQMANwMAIAEgASkDQDcDcCABIAw2AoQBIAEgFCAZQR53ajYCgAEgASAPNgKIASABIAY2AowBIAFB4ABqIAFB8ABqIAFBgAFqQQAQHiABKAJsIRYgASkCZCEfIAEoAiAhDSABKAIsIRAgASgCKCEKIAEoAiQhESABIAEoAmAiDjYCcCABIB83AnQgASAWNgJ8IAEgETYChAEgASAKNgKIASABIBA2AowBIAEgDSABKAJAQR53ajYCgAEgAUHgAGogAUHwAGogAUGAAWpBABAeIAIgAUHoAGoiFikDADcDACABIAEpA2A3A0AgASgCPCEHIAEoAjghCCABKAIwIRIgASgCNCEJIBMgAikDADcDACABIAEpA0A3A3AgASAJNgKEASABIBIgDkEed2o2AoABIAEgCDYCiAEgASAHNgKMASABQeAAaiABQfAAaiABQYABakEAEB4gASgCbCEOIAEpAmQhHyABKAJgIRcgASARIAQgC3NzNgKEASABIA0gBSADc3M2AoABIAEgCiAUIAVzczYCiAEgASAQIAwgBHNzNgKMASABQdAAaiABQYABaiAJIAggBxAfIAEgFzYCcCABIB83AnQgASAONgJ8IAEgASgCVCIDNgKEASABIAEoAlgiCzYCiAEgASABKAJcIg42AowBIAEgASgCQEEedyABKAJQIhVqNgKAASABQeAAaiABQfAAaiABQYABakEAEB4gAiAWKQMANwMAIAEgASkDYDcDQCABIAkgBiAMc3M2AoQBIAEgEiAPIBRzczYCgAEgASAIIA0gD3NzNgKIASABIAcgESAGc3M2AowBIAFB8ABqIAFBgAFqIAMgCyAOEB8gASgCfCEEIAEoAnghBSABKAJwIQ8gASgCdCEGIBMgAikDADcDACABIAEpA0A3A3AgASAGNgKEASABIA8gF0Eed2o2AoABIAEgBTYCiAEgASAENgKMASABQeAAaiABQfAAaiABQYABakEBEB4gASgCbCEMIAEpAmQhHyABKAJgIRcgASADIBAgEXNzNgKEASABIBUgCiANc3M2AoABIAEgCyASIApzczYCiAEgASAOIAkgEHNzNgKMASABQfAAaiABQYABaiAGIAUgBBAfIAEoAnAhFCABKAJ8IQ0gASgCeCEQIAEoAnQhCiABIBc2AnAgASAfNwJ0IAEgDDYCfCABIAo2AoQBIAEgEDYCiAEgASANNgKMASABIBQgASgCQEEed2o2AoABIAFB4ABqIAFB8ABqIAFBgAFqQQEQHiACIBYpAwA3AwAgASABKQNgNwNAIAEgBiAHIAlzczYChAEgASAPIAggEnNzNgKAASABIAUgFSAIc3M2AogBIAEgBCADIAdzczYCjAEgAUHwAGogAUGAAWogCiAQIA0QHyABKAJ8IQcgASgCeCEIIAEoAnAhDCABKAJ0IQkgEyACKQMANwMAIAEgASkDQDcDcCABIAk2AoQBIAEgDCAXQR53ajYCgAEgASAINgKIASABIAc2AowBIAFB4ABqIAFB8ABqIAFBgAFqQQEQHiABKAJsIRcgASkCZCEfIAEoAmAhGCABIAogDiADc3M2AoQBIAEgFCALIBVzczYCgAEgASAQIA8gC3NzNgKIASABIA0gBiAOc3M2AowBIAFB8ABqIAFBgAFqIAkgCCAHEB8gASgCcCELIAEoAnwhESABKAJ4IRIgASgCdCEDIAEgGDYCcCABIB83AnQgASAXNgJ8IAEgAzYChAEgASASNgKIASABIBE2AowBIAEgCyABKAJAQR53ajYCgAEgAUHgAGogAUHwAGogAUGAAWpBARAeIAIgFikDADcDACABIAEpA2A3A0AgASAJIAQgBnNzNgKEASABIAwgBSAPc3M2AoABIAEgCCAUIAVzczYCiAEgASAHIAogBHNzNgKMASABQdAAaiABQYABaiADIBIgERAfIBMgAikDADcDACABIAEpA0A3A3AgASABKAJUIg42AoQBIAEgASgCWCIPNgKIASABIAEoAlwiFTYCjAEgASABKAJQIhcgGEEed2o2AoABIAFB4ABqIAFB8ABqIAFBgAFqQQEQHiABKAJsIRogASkCZCEfIAEoAmAhGCABIAMgDSAKc3M2AoQBIAEgCyAQIBRzczYCgAEgASASIAwgEHNzNgKIASABIBEgCSANc3M2AowBIAFB8ABqIAFBgAFqIA4gDyAVEB8gASgCcCEUIAEoAnwhBCABKAJ4IQUgASgCdCEGIAEgGDYCcCABIB83AnQgASAaNgJ8IAEgBjYChAEgASAFNgKIASABIAQ2AowBIAEgFCABKAJAQR53ajYCgAEgAUHgAGogAUHwAGogAUGAAWpBAhAeIAIgFikDADcDACABIAEpA2A3A0AgASAOIAcgCXNzNgKEASABIBcgCCAMc3M2AoABIAEgDyALIAhzczYCiAEgASAVIAMgB3NzNgKMASABQfAAaiABQYABaiAGIAUgBBAfIAEoAnwhByABKAJ4IQggASgCcCEMIAEoAnQhCSATIAIpAwA3AwAgASABKQNANwNwIAEgCTYChAEgASAMIBhBHndqNgKAASABIAg2AogBIAEgBzYCjAEgAUHgAGogAUHwAGogAUGAAWpBAhAeIAEoAmwhGiABKQJkIR8gASgCYCEYIAEgBiARIANzczYChAEgASAUIBIgC3NzNgKAASABIAUgFyASc3M2AogBIAEgBCAOIBFzczYCjAEgAUHwAGogAUGAAWogCSAIIAcQHyABKAJwIQsgASgCfCENIAEoAnghECABKAJ0IQogASAYNgJwIAEgHzcCdCABIBo2AnwgASAKNgKEASABIBA2AogBIAEgDTYCjAEgASALIAEoAkBBHndqNgKAASABQeAAaiABQfAAaiABQYABakECEB4gAiAWKQMANwMAIAEgASkDYDcDQCABIAkgFSAOc3M2AoQBIAEgDCAPIBdzczYCgAEgASAIIBQgD3NzNgKIASABIAcgBiAVc3M2AowBIAFB8ABqIAFBgAFqIAogECANEB8gASgCfCERIAEoAnghEiABKAJwIQ4gASgCdCEDIBMgAikDADcDACABIAEpA0A3A3AgASADNgKEASABIA4gGEEed2o2AoABIAEgEjYCiAEgASARNgKMASABQeAAaiABQfAAaiABQYABakECEB4gASgCbCEPIAEpAmQhHyABKAJgIRUgASAKIAQgBnNzNgKEASABIAsgBSAUc3M2AoABIAEgECAMIAVzczYCiAEgASANIAkgBHNzNgKMASABQdAAaiABQYABaiADIBIgERAfIAEgFTYCcCABIB83AnQgASAPNgJ8IAEgASgCVCIENgKEASABIAEoAlgiBTYCiAEgASABKAJcIgY2AowBIAEgASgCQEEedyABKAJQIhRqNgKAASABQeAAaiABQfAAaiABQYABakECEB4gAiAWKQMANwMAIAEgASkDYDcDQCABIAMgByAJc3M2AoQBIAEgDiAIIAxzczYCgAEgASASIAsgCHNzNgKIASABIBEgCiAHc3M2AowBIAFB8ABqIAFBgAFqIAQgBSAGEB8gASgCfCEHIAEoAnghCCABKAJwIQ8gASgCdCEJIBMgAikDADcDACABIAEpA0A3A3AgASAJNgKEASABIA8gFUEed2o2AoABIAEgCDYCiAEgASAHNgKMASABQeAAaiABQfAAaiABQYABakEDEB4gASgCbCEVIAEpAmQhHyABKAJgIQwgASAEIA0gCnNzNgKEASABIBQgECALc3M2AoABIAEgBSAOIBBzczYCiAEgASAGIAMgDXNzNgKMASABQfAAaiABQYABaiAJIAggBxAfIAEoAnAhECABKAJ8IQogASgCeCELIAEoAnQhDSABIAw2AnAgASAfNwJ0IAEgFTYCfCABIA02AoQBIAEgCzYCiAEgASAKNgKMASABIBAgASgCQEEed2o2AoABIAFB4ABqIAFB8ABqIAFBgAFqQQMQHiACIBYpAwA3AwAgASABKQNgNwNAIAEgCSARIANzczYChAEgASAPIBIgDnNzNgKAASABIAggFCASc3M2AogBIAEgByAEIBFzczYCjAEgAUHwAGogAUGAAWogDSALIAoQHyABKAJ8IREgASgCeCESIAEoAnAhDiABKAJ0IQMgEyACKQMANwMAIAEgASkDQDcDcCABIAM2AoQBIAEgDiAMQR53ajYCgAEgASASNgKIASABIBE2AowBIAFB4ABqIAFB8ABqIAFBgAFqQQMQHiABKAJsIRUgASkCZCEfIAEoAmAhDCABIA0gBiAEc3M2AoQBIAEgECAFIBRzczYCgAEgASALIA8gBXNzNgKIASABIAogCSAGc3M2AowBIAFB8ABqIAFBgAFqIAMgEiAREB8gASgCcCEKIAEoAnwhBCABKAJ4IQUgASgCdCEGIAEgDDYCcCABIB83AnQgASAVNgJ8IAEgBjYChAEgASAFNgKIASABIAQ2AowBIAEgCiABKAJAQR53ajYCgAEgAUHgAGogAUHwAGogAUGAAWpBAxAeIAIgFikDADcDACABIAEpA2A3A0AgASADIAcgCXNzNgKEASABIA4gCCAPc3M2AoABIAEgEiAQIAhzczYCiAEgASARIA0gB3NzNgKMASABQdAAaiABQYABaiAGIAUgBBAfIBMgAikDADcDACABIAEpA0A3A3AgASABKQJUNwKEASABIAEoAlw2AowBIAEgASgCUCAMQR53ajYCgAEgAUHgAGogAUHwAGogAUGAAWpBAxAe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DSAKIABBDHZBD3FB4AFyOgAMQQMMAQsgCiAAQRJ2QfABcjoADCAKIABBP3FBgAFyOgAPIAogAEEMdkE/cUGAAXI6AA0gCiAAQQZ2QT9xQYABcjoADkEECyEIIAEoAhghAkF/IQAgAUEcaigCACIJQQxqIQECQAJAAkADQCAAQQFqIgAgBE8NASACIApBDGogCCABKAIAEQUARQ0ACwwBCyACIAcgBiAJQQxqKAIAIgERBQANAEF/IQADQCAAQQFqIgAgA08NAiACIApBDGogCCABEQUARQ0ACwtBAQwBC0EACyEAIApBEGokACAAC0YCAX8BfiMAQSBrIgIkACABKQIAIQMgAkEUaiABKQIINwIAIAJBlBY2AgQgAkGsDjYCACACIAA2AgggAiADNwIMIAIQJAALUAACQAJAQZARKAIAQQFGBEBBlBFBlBEoAgBBAWoiADYCACAAQQNJDQEMAgtBkBFCgYCAgBA3AwALQZwRKAIAIgBBf0wNAEGcESAANgIACwALPwECfyMAQRBrIgEkAAJ/IAAoAggiAiACDQAaQfwVEAcACxogASAAKQIMNwMAIAEgAEEUaikCADcDCCABECMAC7MCAQV/IAAoAhghAwJAAkACQCAAKAIMIgIgAEcEQCAAKAIIIgEgAjYCDCACIAE2AgggAw0BDAILIABBFGoiASAAQRBqIAEoAgAbIgQoAgAiAQRAAkADQCAEIQUgASICQRRqIgQoAgAiAQRAIAENAQwCCyACQRBqIQQgAigCECIBDQALCyAFQQA2AgAgAw0BDAILQQAhAiADRQ0BCwJAIAAoAhwiBEECdEG0E2oiASgCACAARwRAIANBEGogA0EUaiADKAIQIABGGyACNgIAIAINAQwCCyABIAI2AgAgAkUNAgsgAiADNgIYIAAoAhAiAQRAIAIgATYCECABIAI2AhgLIABBFGooAgAiAUUNACACQRRqIAE2AgAgASACNgIYCw8LQagRQagRKAIAQX4gBHdxNgIAC8UCAQR/IAACf0EAIAFBCHYiA0UNABpBHyICIAFB////B0sNABogAUEmIANnIgJrQR9xdkEBcUEfIAJrQQF0cgsiAjYCHCAAQgA3AhAgAkECdEG0E2ohAwJAAkACQEGoESgCACIEQQEgAkEfcXQiBXEEQCADKAIAIgQoAgRBeHEgAUcNASAEIQIM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LTFlY2M2Mjk5ZGI5ZWM4MjMvYmxvY2stYnVmZmVyLTAuMy4zL3NyYy9saWIucnNkZXN0aW5hdGlvbiBhbmQgc291cmNlIHNsaWNlcyBoYXZlIGRpZmZlcmVudCBsZW5ndGhzL3Jvb3QvLmNhcmdvL3JlZ2lzdHJ5L3NyYy9naXRodWIuY29tLTFlY2M2Mjk5ZGI5ZWM4MjMvc2hhLTEtMC43LjAvc3JjL3V0aWxzLnJzaW50ZXJuYWwgZXJyb3I6IGVudGVyZWQgdW5yZWFjaGFibGUgY29kZTogdW5rbm93biBpY29zYXJvdW5kIGluZGV4AEHwCwvSBAEAAAAAAAAAIAAAAAAAAAADAAAAAAAAAAMAAAAAAAAAAwAAAGNhcGFjaXR5IG92ZXJmbG93Y2FsbGVkIGBPcHRpb246OnVud3JhcCgpYCBvbiBhIGBOb25lYCB2YWx1ZWxpYmNvcmUvb3B0aW9uLnJzMDAwMTAyMDMwNDA1MDYwNzA4MDkxMDExMTIxMzE0MTUxNjE3MTgxOTIwMjEyMjIzMjQyNTI2MjcyODI5MzAzMTMyMzMzNDM1MzYzNzM4Mzk0MDQxNDI0MzQ0NDU0NjQ3NDg0OTUwNTE1MjUzNTQ1NTU2NTc1ODU5NjA2MTYyNjM2NDY1NjY2NzY4Njk3MDcxNzI3Mzc0NzU3Njc3Nzg3OTgwODE4MjgzODQ4NTg2ODc4ODg5OTA5MTkyOTM5NDk1OTY5Nzk4OTkAAAAAaW5kZXggb3V0IG9mIGJvdW5kczogdGhlIGxlbiBpcyAgYnV0IHRoZSBpbmRleCBpcyBsaWJjb3JlL3NsaWNlL21vZC5ycwABAAAAAAAAACAAAAAAAAAAAwAAAAAAAAADAAAAAAAAAAMAAAABAAAAAQAAACAAAAAAAAAAAwAAAAAAAAADAAAAAAAAAAMAAABpbmRleCAgb3V0IG9mIHJhbmdlIGZvciBzbGljZSBvZiBsZW5ndGggc2xpY2UgaW5kZXggc3RhcnRzIGF0ICBidXQgZW5kcyBhdCBpbnRlcm5hbCBlcnJvcjogZW50ZXJlZCB1bnJlYWNoYWJsZSBjb2RlbGliYWxsb2MvcmF3X3ZlYy5ycwBB7BQLnQIWBAAAJAAAAC8IAAATAAAASAIAAAkAAADQBAAAUwAAAEsAAAARAAAAUAQAACAAAABwBAAAWgAAAB8AAAAFAAAAIwUAADQAAABfBwAAFAAAAG0GAAAJAAAAzwUAABgAAAClBQAAKgAAAFcFAABOAAAAQgAAAA4AAAAUBgAAEQAAAC8IAAATAAAA8gIAAAUAAAAlBgAAKwAAAFAGAAARAAAAWQEAABUAAAADAAAAAAAAAAEAAAAEAAAALQcAACAAAABNBwAAEgAAALwHAAAGAAAAwgcAACIAAABfBwAAFAAAAK0HAAAFAAAA5AcAABYAAAD6BwAADQAAAF8HAAAUAAAAswcAAAUAAAAHCAAAKAAAAC8IAAATAAAA9QEAAB4ADAdsaW5raW5nAwKMDw==';

/* eslint-disable tsdoc/syntax */
/**
 * @hidden
 */
// prettier-ignore
var sha256Base64Bytes = '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IAJHDQUgAygCGCABIAIQKxoMAwsgAiEEDAELIANBMGogASACIAQQFiADQTxqKAIAIQQgAygCOCEBIAMoAjAhBSADKAI0IQIgA0EgaiAAQQxqIgYgACgCCBAXIAIgAygCJEcNBCADKAIgIAUgAhArGiAAQQhqQQA2AgAgA0EsaiAGEBgLIANBPGohAiADQThqIQUCQANAIARBP00NASADQTBqIAEgBEHAABAWIAIoAgAhBCAFKAIAIQEgA0EIakEAQcAAIAMoAjAgAygCNBAZIANBLGogAygCCBAYDAALAAsgA0EQaiAAQQxqIAQQGiADKAIUIARHDQEgAygCECABIAQQKxoLIABBCGogBDYCACADQUBrJAAPC0GEFBAHAAtBhBQQBwALQYQUEAcAC98EAgN/AX4jAEHQAGsiAiQAIAIgAUHMAGo2AiQgASkDACEFIAEoAgghBCACIAJBJGo2AigCQCAEQT9NBEAgAUEMaiIDIARqQYABOgAAIAEgASgCCEEBaiIENgIIIAJBGGogAyAEEBcgAigCGEEAIAIoAhwQLRpBwAAgASgCCGtBB00EQCACQShqIAMQGCACQRBqIAMgAUEIaigCABAaIAIoAhBBACACKAIUEC0aCyACQQhqIANBOBAXIAIoAgxBCEcNASACKAIIIAVCOIYgBUIohkKAgICAgIDA/wCDhCAFQhiGQoCAgICA4D+DIAVCCIZCgICAgPAfg4SEIAVCCIhCgICA+A+DIAVCGIhCgID8B4OEIAVCKIhCgP4DgyAFQjiIhISENwAAIAJBKGogAxAYIAFBCGpBADYCACACQQA2AiggAkEoakEEciEEQQAhAwJAA0AgA0EgRg0BIAQgA2pBADoAACACIAIoAihBAWo2AiggA0EBaiEDDAALAAsgAkFAayABQeQAaikAADcDACACQThqIAFB3ABqKQAANwMAIAJBMGogAUHUAGopAAA3AwAgAiABKQBMNwMoQQAhAwJAA0AgA0EgRg0BIAJBKGogA2oiBCAEKAIAIgRBGHQgBEEIdEGAgPwHcXIgBEEIdkGA/gNxIARBGHZycjYCACADQQRqIQMMAAsACyAAIAIpAyg3AAAgAEEYaiACQUBrKQMANwAAIABBEGogAkE4aikDADcAACAAQQhqIAJBMGopAwA3AAAgAkHQAGokAA8LQdwTIARBwAAQ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KAJsIQggASAPNgJkIAEgDjYCYCABIBM2AmggASAYNgJsIAEgAjYCdCABIBc2AnAgASAQNgJ4IAEgDDYCfCABQdAAaiABQeAAaiABQfAAaiAHQevZwaJ6aiAIQfr/+4V5ahAeIAEoAlwhByABKAJYIQggASgCUCEKIAEoAlQhESABIAI2AmQgASAXNgJgIAEgEDYCaCABIAw2AmwgASARNgJ0IAEgCjYCcCABIAg2AnggASAHNgJ8IAFB0ABqIAFB4ABqIAFB8ABqIA1B8vHFs3xqIBlB98fm93tqEB4gASgCXCENIAEoAlghGCABKAJQIRMgACAeIAEoAlRqNgIEIAAgEyAdajYCACAAIAogIWo2AgggACARICJqNgIMIAAgGCAcajYCECAAIA0gG2o2AhQgACAIICBqNgIYIAAgByAfajYCHCABQYABaiQAC30BAX8jAEEwayICJAAgAiABNgIEIAIgADYCACACQSxqQQE2AgAgAkEUakECNgIAIAJBHGpBAjYCACACQQE2AiQgAkGMFTYCCCACQQI2AgwgAkHMDTYCECACIAI2AiAgAiACQQRqNgIoIAIgAkEgajYCGCACQQhqQZwVECgAC3wBAX8jAEEwayIDJAAgAyACNgIEIAMgATYCACADQSxqQQE2AgAgA0EUakECNgIAIANBHGpBAjYCACADQQE2AiQgA0HcFDYCCCADQQI2AgwgA0HMDTYCECADIANBBGo2AiAgAyADNgIoIAMgA0EgajYCGCADQQhqIAAQKAAL1gEBBn8gACABKAIAIgggAigCBCIHcyACKAIAIgVxIAggB3FzIAVBHncgBUETd3MgBUEKd3NqIAIoAggiBkEadyAGQRV3cyAGQQd3cyAEaiABKAIMaiABKAIIIgQgAigCDCIJcyAGcSAEc2oiCmoiAjYCBCAAIAogASgCBGoiATYCDCAAIAJBHncgAkETd3MgAkEKd3MgAiAHIAVzcSAHIAVxc2ogBCADaiAJIAEgCSAGc3FzaiABQRp3IAFBFXdzIAFBB3dzaiIFajYCACAAIAUgCGo2AggLeAAgACACQRl3IAJBA3ZzIAJBDndzIAEoAgAiAmo2AgAgACACQRl3IAJBA3ZzIAJBDndzIAEoAgQiAmo2AgQgACACQRl3IAJBA3ZzIAJBDndzIAEoAggiAmo2AgggACACQRl3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';

/* eslint-disable tsdoc/syntax */
/**
 * @hidden
 */
// prettier-ignore
var sha512Base64Bytes = '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AjYCACAAIAJBAXI2AgQMBQsgAEGsEygCACACaiICQQFyNgIEQbQTIAA2AgBBrBMgAjYCACAAIAJqIAI2AgAMBAsgAxAiDAELQZwQQZwQKAIAQX4gAUEDdndxNgIACyAEIAJqIQIgAyAEaiEDCyADIAMoAgRBfnE2AgQgACACQQFyNgIEIAAgAmogAjYCAAJ/AkAgAkH/AU0EQCACQQN2IgFBA3RBpBBqIQJBnBAoAgAiA0EBIAFBH3F0IgFxRQ0BIAJBCGohAyACKAIIDAILIAAgAhAjDAILQZwQIAMgAXI2AgAgAkEIaiEDIAILIQEgAyAANgIAIAEgADYCDCAAIAI2AgwgACABNgIICyAFQQhqDwtBsBMgACACayIBNgIAQbgTQbgTKAIAIgAgAmoiAzYCACADIAFBAXI2AgQgACACQQNyNgIEIABBCGoLpQEBAn9BAiEFAkACQAJAAkACQCAAKAIEIgYgAWsgAk8NACABIAJqIgIgAUkhAQJAIAQEQEEAIQUgAQ0CIAZBAXQiASACIAIgAUkbIQIMAQtBACEFIAENAQsgAkEASA0AIAZFDQEgACgCACACEBMiAUUNAgwDCyAFDwsgAhAEIgENAQsgAw0BCyABBEAgACABNgIAIABBBGogAjYCAEECDwtBAQ8LAAsIAEG8FBAHAAtmAgF/A34jAEEwayIBJAAgACkCECECIAApAgghAyAAKQIAIQQgAUEUakEANgIAIAEgBDcDGCABQgE3AgQgAUGkDTYCECABIAFBGGo2AgAgASADNwMgIAEgAjcDKCABIAFBIGoQJwALsgEBAn8jAEGABGsiAyQAIANB2ABqIgRCADcDACADQgA3A1AgA0GgAWpBAEGEARAsGiADQeAAakHICkHAABAqGiADQdAAaiABIAIQCSADQagCaiADQdAAakHYARAqGiADQRBqIANBqAJqEAogA0HQAGogA0EQakHAABADIANBsAJqIAQoAgA2AgAgAyADKQNQNwOoAiADQQhqIANBqAJqEAsgACADKQMINwIAIANBgARqJAALuwMCBH8CfiMAQUBqIgMkACAAIAApAwgiByACrUIDhnwiCDcDCCAIIAdUBEAgACAAKQMAQgF8NwMACyADIABBEGo2AiggAyADQShqNgIsAkACQAJAAkACQAJAIAAoAlAiBQRAQYABIAVrIgQg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sBMoAgAgAGoiADYCACABIABBAXI2AgQgAUG0EygCAEYEQEGsE0EANgIAQbQTQQA2AgALQdQTKAIAIABPDQcCQCAAQSlJDQBBxBMhAANAIAAoAgAiAiABTQRAIAIgACgCBGogAUsNAgsgACgCCCIADQALC0EAIQFBzBMoAgAiAEUNBANAIAFBAWohASAAKAIIIgANAAsgAUH/HyABQf8fSxsMBQtBtBMgATYCAEGsE0GsEygCACAAaiIANgIADAcLIAIQIgwBC0GcEEGcECgCAEF+IANBA3Z3cTYCAAsgASAAQQFyNgIEIAEgAGogADYCACABQbQTKAIARw0CQawTIAA2AgAPC0H/HwshAUHUE0F/NgIAQdwTIAE2AgAPC0HcEwJ/AkACfwJAIABB/wFNBEAgAEEDdiICQQN0QaQQaiEAQZwQKAIAIgNBASACQR9xdCICcUUNASAAQQhqIQMgACgCCAwCCyABIAAQI0HcE0HcEygCAEF/aiIBNgIAIAENBEHMEygCACIARQ0CQQAhAQNAIAFBAWohASAAKAIIIgANAAsgAUH/HyABQf8fSxsMAwtBnBAgAyACcjYCACAAQQhqIQMgAAshAiADIAE2AgAgAiABNgIMIAEgADYCDCABIAI2AggPC0H/HwsiATYCAAsPCyABIABBAXI2AgQgASAAaiAANgIACzkAAkAgAiABTwRAIAJBgQFPDQEgACACIAFrNgIEIAAgAyABajYCAA8LIAEgAhAcAAsgAkGAARACAAtNAgF/An4jAEEQayIEJAAgBEEIakEAIAMgASACEBkgBCkDCCEFIAQgAyACIAEgAhAZIAQpAwAhBiAAIAU3AgAgACAGNwIIIARBEGokAAssAQF/IwBBEGsiAyQAIANBCGogAkGAASABEBUgACADKQMINwIAIANBEGokAAsOACAAKAIAKAIAIAEQGws3AAJAIAIgAU8EQCAEIAJJDQEgACACIAFrNgIEIAAgAyABajYCAA8LIAEgAhAcAAsgAiAEEAIACysBAX8jAEEQayIDJAAgA0EIakEAIAIgARAVIAAgAykDCDcCACADQRBqJAALqioCAn8ifiMAQYAPayICJAAgAkGADmogAUGAARAqGkEAIQECQANAIAFBgAFGDQEgAkGADmogAWoiAyADKQMAIhxCOIYgHEIohkKAgICAgIDA/wCD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c2VydGlvbiBmYWlsZWQ6IDggPT0gZHN0LmxlbigpL3Jvb3QvLmNhcmdvL3JlZ2lzdHJ5L3NyYy9naXRodWIuY29tLTFlY2M2Mjk5ZGI5ZWM4MjMvYnl0ZS10b29scy0wLjIuMC9zcmMvd3JpdGVfc2luZ2xlLnJzAEHwCQvKBS9yb290Ly5jYXJnby9yZWdpc3RyeS9zcmMvZ2l0aHViLmNvbS0xZWNjNjI5OWRiOWVjODIzL2Jsb2NrLWJ1ZmZlci0wLjMuMy9zcmMvbGliLnJzAAAAAAAIybzzZ+YJajunyoSFrme7K/iU/nLzbjzxNh1fOvVPpdGC5q1/Ug5RH2w+K4xoBZtrvUH7q9mDH3khfhMZzeBbAAAAAABjYXBhY2l0eSBvdmVyZmxvd2NhbGxlZCBgT3B0aW9uOjp1bndyYXAoKWAgb24gYSBgTm9uZWAgdmFsdWVsaWJjb3JlL29wdGlvbi5yczAwMDEwMjAzMDQwNTA2MDcwODA5MTAxMTEyMTMxNDE1MTYxNzE4MTkyMDIxMjIyMzI0MjUyNjI3MjgyOTMwMzEzMjMzMzQzNTM2MzczODM5NDA0MTQyNDM0NDQ1NDY0NzQ4NDk1MDUxNTI1MzU0NTU1NjU3NTg1OTYwNjE2MjYzNjQ2NTY2Njc2ODY5NzA3MTcyNzM3NDc1NzY3Nzc4Nzk4MDgxODI4Mzg0ODU4Njg3ODg4OTkwOTE5MjkzOTQ5NTk2OTc5ODk5AAAAaW5kZXggb3V0IG9mIGJvdW5kczogdGhlIGxlbiBpcyAgYnV0IHRoZSBpbmRleCBpcyBsaWJjb3JlL3NsaWNlL21vZC5ycwABAAAAAAAAACAAAAAAAAAAAwAAAAAAAAADAAAAAAAAAAMAAAABAAAAAQAAACAAAAAAAAAAAwAAAAAAAAADAAAAAAAAAAMAAABpbmRleCAgb3V0IG9mIHJhbmdlIGZvciBzbGljZSBvZiBsZW5ndGggc2xpY2UgaW5kZXggc3RhcnRzIGF0ICBidXQgZW5kcyBhdCBpbnRlcm5hbCBlcnJvcjogZW50ZXJlZCB1bnJlYWNoYWJsZSBjb2RlbGliYWxsb2MvcmF3X3ZlYy5ycwBB5BML/QEWBAAAJAAAAKcHAAATAAAASAIAAAkAAAA6BAAANAAAANcGAAAUAAAAbQYAAAkAAADwBAAAUwAAAEsAAAARAAAAbgQAACAAAACOBAAAWgAAAB8AAAAFAAAAjQUAABEAAACnBwAAEwAAAPICAAAFAAAAngUAACsAAADJBQAAEQAAAFkBAAAVAAAAAgAAAAAAAAABAAAAAwAAAKUGAAAgAAAAxQYAABIAAAA0BwAABgAAADoHAAAiAAAA1wYAABQAAACtBwAABQAAAFwHAAAWAAAAcgcAAA0AAADXBgAAFAAAALMHAAAFAAAAfwcAACgAAACnBwAAEwAAAPUBAAAeAAwHbGlua2luZwMC5A0=';

/**
 * The most performant way to instantiate ripemd160 functionality. To avoid
 * using Node.js or DOM-specific APIs, you can use {@link instantiateRipemd160}.
 *
 * @param webassemblyBytes - A buffer containing the ripemd160 binary.
 */
var instantiateRipemd160Bytes = /*#__PURE__*/function () {
  var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(webassemblyBytes) {
    var wasm;
    return _regeneratorRuntime().wrap(function _callee$(_context) {
      while (1) switch (_context.prev = _context.next) {
        case 0:
          _context.next = 2;
          return instantiateRustWasm(webassemblyBytes, './ripemd160', 'ripemd160', 'ripemd160_init', 'ripemd160_update', 'ripemd160_final');
        case 2:
          wasm = _context.sent;
          return _context.abrupt("return", {
            final: wasm.final,
            hash: wasm.hash,
            init: wasm.init,
            update: wasm.update
          });
        case 4:
        case "end":
          return _context.stop();
      }
    }, _callee);
  }));
  return function instantiateRipemd160Bytes(_x) {
    return _ref.apply(this, arguments);
  };
}();
var getEmbeddedRipemd160Binary = function getEmbeddedRipemd160Binary() {
  return base64ToBin(ripemd160Base64Bytes).buffer;
};
/**
 * An ultimately-portable (but slower) version of
 * {@link instantiateRipemd160Bytes} that does not require the consumer to
 * provide the ripemd160 binary buffer.
 */
var instantiateRipemd160 = /*#__PURE__*/function () {
  var _ref2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2() {
    return _regeneratorRuntime().wrap(function _callee2$(_context2) {
      while (1) switch (_context2.prev = _context2.next) {
        case 0:
          return _context2.abrupt("return", instantiateRipemd160Bytes(getEmbeddedRipemd160Binary()));
        case 1:
        case "end":
          return _context2.stop();
      }
    }, _callee2);
  }));
  return function instantiateRipemd160() {
    return _ref2.apply(this, arguments);
  };
}();

/* eslint-enable @typescript-eslint/no-duplicate-enum-values */
var Secp256k1Error;
(function (Secp256k1Error) {
  Secp256k1Error["unparsableSignature"] = "Failed to parse signature.";
  Secp256k1Error["unparsablePublicKey"] = "Failed to parse public key.";
  Secp256k1Error["derivePublicKeyFromInvalidPrivateKey"] = "Cannot derive public key from invalid private key.";
  Secp256k1Error["signWithInvalidPrivateKey"] = "Failed to sign message hash. The private key is not valid.";
  Secp256k1Error["recoverPublicKeyWithUnparsableSignature"] = "Failed to recover public key. Could not parse signature.";
  Secp256k1Error["recoverPublicKeyInvalidMaterial"] = "Failed to recover public key. The compact signature, recovery, or message hash is invalid.";
  Secp256k1Error["addTweakPrivateKey"] = "Private key is invalid or adding failed.";
  Secp256k1Error["mulTweakPrivateKey"] = "Private key is invalid or multiplying failed.";
  Secp256k1Error["addTweakPublicKey"] = "Failed to tweak public key (by addition).";
  Secp256k1Error["mulTweakPublicKey"] = "Failed to tweak public key (by multiplication).";
})(Secp256k1Error || (Secp256k1Error = {}));
/**
 * @param secp256k1Wasm - a Secp256k1Wasm object
 * @param randomSeed - a 32-byte random seed used to randomize the context after
 * creation
 */
var wrapSecp256k1Wasm = function wrapSecp256k1Wasm(secp256k1Wasm, randomSeed) {
  /**
   * Currently, this wrapper creates a context with both SIGN and VERIFY
   * capabilities. For better initialization performance, consumers could
   * re-implement a wrapper with only the capabilities they require.
   */
  var contextPtr = secp256k1Wasm.contextCreate(ContextFlag.BOTH);
  /**
   * Since all of these methods are single-threaded and synchronous, we can
   * reuse allocated WebAssembly memory for each method without worrying about
   * calls interfering with each other. Likewise, these spaces never need to be
   * `free`d, since we will continue using them until this entire object (and
   * with it, the entire WebAssembly instance) is garbage collected.
   *
   * If malicious javascript gained access to this object, it should be
   * considered a critical vulnerability in the consumer. However, as a best
   * practice, we zero out private keys below when we're finished with them.
   */
  var sigScratch = secp256k1Wasm.malloc(72 /* ByteLength.maxECDSASig */);
  var publicKeyScratch = secp256k1Wasm.malloc(65 /* ByteLength.maxPublicKey */);
  var messageHashScratch = secp256k1Wasm.malloc(32 /* ByteLength.messageHash */);
  var internalPublicKeyPtr = secp256k1Wasm.malloc(64 /* ByteLength.internalPublicKey */);
  var internalSigPtr = secp256k1Wasm.malloc(64 /* ByteLength.internalSig */);
  var schnorrSigPtr = secp256k1Wasm.malloc(64 /* ByteLength.schnorrSig */);
  var privateKeyPtr = secp256k1Wasm.malloc(32 /* ByteLength.privateKey */);
  var internalRSigPtr = secp256k1Wasm.malloc(65 /* ByteLength.recoverableSig */);
  // eslint-disable-next-line @typescript-eslint/no-magic-numbers
  var recoveryNumPtr = secp256k1Wasm.malloc(4);
  // eslint-disable-next-line no-bitwise, @typescript-eslint/no-magic-numbers
  var recoveryNumPtrView32 = recoveryNumPtr >> 2;
  var getRecoveryNumPtr = function getRecoveryNumPtr() {
    return secp256k1Wasm.heapU32[recoveryNumPtrView32];
  };
  // eslint-disable-next-line @typescript-eslint/no-magic-numbers
  var lengthPtr = secp256k1Wasm.malloc(4);
  // eslint-disable-next-line no-bitwise, @typescript-eslint/no-magic-numbers
  var lengthPtrView32 = lengthPtr >> 2;
  var cloneAndPad = function cloneAndPad(value, expectedLength) {
    var zeroPaddedValue = new Uint8Array(expectedLength);
    zeroPaddedValue.set(value);
    return zeroPaddedValue;
  };
  var parsePublicKey = function parsePublicKey(publicKey) {
    var paddedPublicKey = cloneAndPad(publicKey, 65 /* ByteLength.maxPublicKey */);
    secp256k1Wasm.heapU8.set(paddedPublicKey, publicKeyScratch);
    return secp256k1Wasm.pubkeyParse(contextPtr, internalPublicKeyPtr, publicKeyScratch,
    // eslint-disable-next-line @typescript-eslint/no-magic-numbers
    publicKey.length) === 1;
  };
  var setLengthPtr = function setLengthPtr(value) {
    secp256k1Wasm.heapU32.set([value], lengthPtrView32);
  };
  // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
  var getLengthPtr = function getLengthPtr() {
    return secp256k1Wasm.heapU32[lengthPtrView32];
  };
  var serializePublicKey = function serializePublicKey(length, flag) {
    setLengthPtr(length);
    secp256k1Wasm.pubkeySerialize(contextPtr, publicKeyScratch, lengthPtr, internalPublicKeyPtr, flag);
    return secp256k1Wasm.readHeapU8(publicKeyScratch, getLengthPtr()).slice();
  };
  var getSerializedPublicKey = function getSerializedPublicKey(compressed) {
    return compressed ? serializePublicKey(33 /* ByteLength.compressedPublicKey */, CompressionFlag.COMPRESSED) : serializePublicKey(65 /* ByteLength.uncompressedPublicKey */, CompressionFlag.UNCOMPRESSED);
  };
  var convertPublicKey = function convertPublicKey(compressed) {
    return function (publicKey) {
      if (!parsePublicKey(publicKey)) {
        return Secp256k1Error.unparsablePublicKey;
      }
      return getSerializedPublicKey(compressed);
    };
  };
  var parseSignature = function parseSignature(signature, isDer) {
    var paddedSignature = cloneAndPad(signature, 72 /* ByteLength.maxECDSASig */);
    secp256k1Wasm.heapU8.set(paddedSignature, sigScratch);
    return isDer ? secp256k1Wasm.signatureParseDER(contextPtr, internalSigPtr, sigScratch, signature.length) === 1 : secp256k1Wasm.signatureParseCompact(contextPtr, internalSigPtr, sigScratch) === 1;
  };
  var getCompactSig = function getCompactSig() {
    secp256k1Wasm.signatureSerializeCompact(contextPtr, sigScratch, internalSigPtr);
    return secp256k1Wasm.readHeapU8(sigScratch, 64 /* ByteLength.compactSig */).slice();
  };
  var getDERSig = function getDERSig() {
    setLengthPtr(72 /* ByteLength.maxECDSASig */);
    secp256k1Wasm.signatureSerializeDER(contextPtr, sigScratch, lengthPtr, internalSigPtr);
    return secp256k1Wasm.readHeapU8(sigScratch, getLengthPtr()).slice();
  };
  var convertSignature = function convertSignature(wasDER) {
    return function (signature) {
      if (!parseSignature(signature, wasDER)) {
        return Secp256k1Error.unparsableSignature;
      }
      return wasDER ? getCompactSig() : getDERSig();
    };
  };
  var fillPrivateKeyPtr = function fillPrivateKeyPtr(privateKey) {
    var paddedPrivateKey = cloneAndPad(privateKey, 32 /* ByteLength.privateKey */);
    secp256k1Wasm.heapU8.set(paddedPrivateKey, privateKeyPtr);
  };
  var zeroOutPtr = function zeroOutPtr(pointer, bytes) {
    secp256k1Wasm.heapU8.fill(0, pointer, pointer + bytes);
  };
  var zeroOutPrivateKeyPtr = function zeroOutPrivateKeyPtr() {
    zeroOutPtr(privateKeyPtr, 32 /* ByteLength.privateKey */);
  };

  var withPrivateKey = function withPrivateKey(privateKey, instructions) {
    fillPrivateKeyPtr(privateKey);
    var ret = instructions();
    zeroOutPrivateKeyPtr();
    return ret;
  };
  var derivePublicKey = function derivePublicKey(compressed) {
    return function (privateKey) {
      var invalid = withPrivateKey(privateKey, function () {
        return secp256k1Wasm.pubkeyCreate(contextPtr, internalPublicKeyPtr, privateKeyPtr) !== 1;
      });
      if (invalid) {
        return Secp256k1Error.derivePublicKeyFromInvalidPrivateKey;
      }
      return getSerializedPublicKey(compressed);
    };
  };
  var fillMessageHashScratch = function fillMessageHashScratch(messageHash) {
    var paddedMessageHash = cloneAndPad(messageHash, 32 /* ByteLength.messageHash */);
    secp256k1Wasm.heapU8.set(paddedMessageHash, messageHashScratch);
  };
  var normalizeSignature = function normalizeSignature() {
    secp256k1Wasm.signatureNormalize(contextPtr, internalSigPtr, internalSigPtr);
  };
  var modifySignature = function modifySignature(isDer, normalize) {
    return function (signature) {
      if (!parseSignature(signature, isDer)) {
        return Secp256k1Error.unparsableSignature;
      }
      if (normalize) {
        normalizeSignature();
      } else {
        secp256k1Wasm.signatureMalleate(contextPtr, internalSigPtr, internalSigPtr);
      }
      return isDer ? getDERSig() : getCompactSig();
    };
  };
  var parseAndNormalizeSignature = function parseAndNormalizeSignature(signature, isDer, normalize) {
    var ret = parseSignature(signature, isDer);
    if (normalize) {
      normalizeSignature();
    }
    return ret;
  };
  var signMessageHash = function signMessageHash(isDer) {
    return function (privateKey, messageHash) {
      fillMessageHashScratch(messageHash);
      return withPrivateKey(privateKey, function () {
        var failed = secp256k1Wasm.sign(contextPtr, internalSigPtr, messageHashScratch, privateKeyPtr) !== 1;
        if (failed) {
          return Secp256k1Error.signWithInvalidPrivateKey;
        }
        if (isDer) {
          setLengthPtr(72 /* ByteLength.maxECDSASig */);
          secp256k1Wasm.signatureSerializeDER(contextPtr, sigScratch, lengthPtr, internalSigPtr);
          return secp256k1Wasm.readHeapU8(sigScratch, getLengthPtr()).slice();
        }
        secp256k1Wasm.signatureSerializeCompact(contextPtr, sigScratch, internalSigPtr);
        return secp256k1Wasm.readHeapU8(sigScratch, 64 /* ByteLength.compactSig */).slice();
      });
    };
  };
  var signMessageHashSchnorr = function signMessageHashSchnorr() {
    return function (privateKey, messageHash) {
      fillMessageHashScratch(messageHash);
      return withPrivateKey(privateKey, function () {
        var failed = secp256k1Wasm.schnorrSign(contextPtr, schnorrSigPtr, messageHashScratch, privateKeyPtr) !== 1;
        if (failed) {
          return Secp256k1Error.signWithInvalidPrivateKey;
        }
        return secp256k1Wasm.readHeapU8(schnorrSigPtr, 64 /* ByteLength.schnorrSig */).slice();
      });
    };
  };
  var verifyMessage = function verifyMessage(messageHash) {
    fillMessageHashScratch(messageHash);
    return secp256k1Wasm.verify(contextPtr, internalSigPtr, messageHashScratch, internalPublicKeyPtr) === 1;
  };
  var verifySignature = function verifySignature(isDer, normalize) {
    return function (signature, publicKey, messageHash) {
      return parsePublicKey(publicKey) && parseAndNormalizeSignature(signature, isDer, normalize) && verifyMessage(messageHash);
    };
  };
  var verifyMessageSchnorr = function verifyMessageSchnorr(messageHash, signature) {
    fillMessageHashScratch(messageHash);
    var paddedSignature = cloneAndPad(signature, 64 /* ByteLength.schnorrSig */);
    secp256k1Wasm.heapU8.set(paddedSignature, schnorrSigPtr);
    return secp256k1Wasm.schnorrVerify(contextPtr, schnorrSigPtr, messageHashScratch, internalPublicKeyPtr) === 1;
  };
  var verifySignatureSchnorr = function verifySignatureSchnorr() {
    return function (signature, publicKey, messageHash) {
      return parsePublicKey(publicKey) ? verifyMessageSchnorr(messageHash, signature) : false;
    };
  };
  var signMessageHashRecoverable = function signMessageHashRecoverable(privateKey, messageHash) {
    fillMessageHashScratch(messageHash);
    return withPrivateKey(privateKey, function () {
      if (secp256k1Wasm.signRecoverable(contextPtr, internalRSigPtr, messageHashScratch, privateKeyPtr) !== 1) {
        return Secp256k1Error.signWithInvalidPrivateKey;
      }
      secp256k1Wasm.recoverableSignatureSerialize(contextPtr, sigScratch, recoveryNumPtr, internalRSigPtr);
      return {
        recoveryId: getRecoveryNumPtr(),
        signature: secp256k1Wasm.readHeapU8(sigScratch, 64 /* ByteLength.compactSig */).slice()
      };
    });
  };
  var recoverPublicKey = function recoverPublicKey(compressed) {
    return function (signature, recoveryId, messageHash) {
      fillMessageHashScratch(messageHash);
      var paddedSignature = cloneAndPad(signature, 72 /* ByteLength.maxECDSASig */);
      secp256k1Wasm.heapU8.set(paddedSignature, sigScratch);
      if (secp256k1Wasm.recoverableSignatureParse(contextPtr, internalRSigPtr, sigScratch, recoveryId) !== 1) {
        return Secp256k1Error.recoverPublicKeyWithUnparsableSignature;
      }
      if (secp256k1Wasm.recover(contextPtr, internalPublicKeyPtr, internalRSigPtr, messageHashScratch) !== 1) {
        return Secp256k1Error.recoverPublicKeyInvalidMaterial;
      }
      return getSerializedPublicKey(compressed);
    };
  };
  var addTweakPrivateKey = function addTweakPrivateKey(privateKey, tweakValue) {
    fillMessageHashScratch(tweakValue);
    return withPrivateKey(privateKey, function () {
      if (secp256k1Wasm.privkeyTweakAdd(contextPtr, privateKeyPtr, messageHashScratch) !== 1) {
        return Secp256k1Error.addTweakPrivateKey;
      }
      return secp256k1Wasm.readHeapU8(privateKeyPtr, 32 /* ByteLength.privateKey */).slice();
    });
  };
  var mulTweakPrivateKey = function mulTweakPrivateKey(privateKey, tweakValue) {
    fillMessageHashScratch(tweakValue);
    return withPrivateKey(privateKey, function () {
      if (secp256k1Wasm.privkeyTweakMul(contextPtr, privateKeyPtr, messageHashScratch) !== 1) {
        return Secp256k1Error.mulTweakPrivateKey;
      }
      return secp256k1Wasm.readHeapU8(privateKeyPtr, 32 /* ByteLength.privateKey */).slice();
    });
  };
  var addTweakPublicKey = function addTweakPublicKey(compressed) {
    return function (publicKey, tweakValue) {
      if (!parsePublicKey(publicKey)) {
        return Secp256k1Error.unparsablePublicKey;
      }
      fillMessageHashScratch(tweakValue);
      if (secp256k1Wasm.pubkeyTweakAdd(contextPtr, internalPublicKeyPtr, messageHashScratch) !== 1) {
        return Secp256k1Error.addTweakPublicKey;
      }
      return getSerializedPublicKey(compressed);
    };
  };
  var mulTweakPublicKey = function mulTweakPublicKey(compressed) {
    return function (publicKey, tweakValue) {
      if (!parsePublicKey(publicKey)) {
        return Secp256k1Error.unparsablePublicKey;
      }
      fillMessageHashScratch(tweakValue);
      if (secp256k1Wasm.pubkeyTweakMul(contextPtr, internalPublicKeyPtr, messageHashScratch) !== 1) {
        return Secp256k1Error.mulTweakPublicKey;
      }
      return getSerializedPublicKey(compressed);
    };
  };
  if (randomSeed !== undefined) {
    var randomSeedPtr = messageHashScratch;
    var paddedRandomSeed = cloneAndPad(randomSeed, 32 /* ByteLength.randomSeed */);
    secp256k1Wasm.heapU8.set(paddedRandomSeed, randomSeedPtr);
    secp256k1Wasm.contextRandomize(contextPtr, randomSeedPtr);
    zeroOutPtr(randomSeedPtr, 32 /* ByteLength.randomSeed */);
  }

  return {
    addTweakPrivateKey: addTweakPrivateKey,
    addTweakPublicKeyCompressed: addTweakPublicKey(true),
    addTweakPublicKeyUncompressed: addTweakPublicKey(false),
    compressPublicKey: convertPublicKey(true),
    derivePublicKeyCompressed: derivePublicKey(true),
    derivePublicKeyUncompressed: derivePublicKey(false),
    malleateSignatureCompact: modifySignature(false, false),
    malleateSignatureDER: modifySignature(true, false),
    mulTweakPrivateKey: mulTweakPrivateKey,
    mulTweakPublicKeyCompressed: mulTweakPublicKey(true),
    mulTweakPublicKeyUncompressed: mulTweakPublicKey(false),
    normalizeSignatureCompact: modifySignature(false, true),
    normalizeSignatureDER: modifySignature(true, true),
    recoverPublicKeyCompressed: recoverPublicKey(true),
    recoverPublicKeyUncompressed: recoverPublicKey(false),
    signMessageHashCompact: signMessageHash(false),
    signMessageHashDER: signMessageHash(true),
    signMessageHashRecoverableCompact: signMessageHashRecoverable,
    signMessageHashSchnorr: signMessageHashSchnorr(),
    signatureCompactToDER: convertSignature(false),
    signatureDERToCompact: convertSignature(true),
    uncompressPublicKey: convertPublicKey(false),
    validatePrivateKey: function validatePrivateKey(privateKey) {
      return withPrivateKey(privateKey, function () {
        return secp256k1Wasm.seckeyVerify(contextPtr, privateKeyPtr) === 1;
      });
    },
    validatePublicKey: parsePublicKey,
    verifySignatureCompact: verifySignature(false, true),
    verifySignatureCompactLowS: verifySignature(false, false),
    verifySignatureDER: verifySignature(true, true),
    verifySignatureDERLowS: verifySignature(true, false),
    verifySignatureSchnorr: verifySignatureSchnorr()
  };
};
/**
 * This method is like {@link instantiateSecp256k1}, but requires the consumer
 * to `Window.fetch` or `fs.readFile` the `secp256k1.wasm` binary and provide it
 * to this method as `webassemblyBytes`. This skips a base64 decoding of an
 * embedded binary.
 *
 * ### Randomizing the Context with `randomSeed`
 * This method also accepts an optional, 32-byte `randomSeed`, which is passed
 * to the `contextRandomize` method in the underlying WebAssembly.
 *
 * In the secp256k1 C library, context randomization is an additional layer of
 * security from side-channel attacks that attempt to extract private key
 * information by analyzing things like a CPU's emitted radio frequencies or
 * power usage.
 *
 * As most applications also benefit from deterministic, reproducible behavior,
 * context is not randomized by default in Libauth. To randomize the context,
 * provide a 32-byte Uint8Array of cryptographically strong random values
 * (e.g. `Crypto.getRandomValues()`).
 *
 * @param webassemblyBytes - an ArrayBuffer containing the bytes from Libauth's
 * `secp256k1.wasm` binary. Providing this buffer manually may be faster than
 * the internal base64 decode that happens in {@link instantiateSecp256k1}.
 * @param randomSeed - a 32-byte random seed used to randomize the secp256k1
 * context after creation. See above for details.
 */
var instantiateSecp256k1Bytes = /*#__PURE__*/function () {
  var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(webassemblyBytes, randomSeed) {
    return _regeneratorRuntime().wrap(function _callee$(_context) {
      while (1) switch (_context.prev = _context.next) {
        case 0:
          _context.t0 = wrapSecp256k1Wasm;
          _context.next = 3;
          return instantiateSecp256k1WasmBytes(webassemblyBytes);
        case 3:
          _context.t1 = _context.sent;
          _context.t2 = randomSeed;
          return _context.abrupt("return", (0, _context.t0)(_context.t1, _context.t2));
        case 6:
        case "end":
          return _context.stop();
      }
    }, _callee);
  }));
  return function instantiateSecp256k1Bytes(_x, _x2) {
    return _ref.apply(this, arguments);
  };
}();
/**
 * Create and wrap a Secp256k1 WebAssembly instance to expose a set of
 * purely-functional Secp256k1 methods. For slightly faster initialization, use
 * {@link instantiateSecp256k1Bytes}.
 *
 * @param randomSeed - a 32-byte random seed used to randomize the secp256k1
 * context after creation. See the description in
 * {@link instantiateSecp256k1Bytes} for details.
 */
var instantiateSecp256k1 = /*#__PURE__*/function () {
  var _ref2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(randomSeed) {
    return _regeneratorRuntime().wrap(function _callee2$(_context2) {
      while (1) switch (_context2.prev = _context2.next) {
        case 0:
          _context2.t0 = wrapSecp256k1Wasm;
          _context2.next = 3;
          return instantiateSecp256k1Wasm();
        case 3:
          _context2.t1 = _context2.sent;
          _context2.t2 = randomSeed;
          return _context2.abrupt("return", (0, _context2.t0)(_context2.t1, _context2.t2));
        case 6:
        case "end":
          return _context2.stop();
      }
    }, _callee2);
  }));
  return function instantiateSecp256k1(_x3) {
    return _ref2.apply(this, arguments);
  };
}();

/**
 * The most performant way to instantiate sha1 functionality. To avoid
 * using Node.js or DOM-specific APIs, you can use {@link instantiateSha1}.
 *
 * @param webassemblyBytes - A buffer containing the sha1 binary.
 */
var instantiateSha1Bytes = /*#__PURE__*/function () {
  var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(webassemblyBytes) {
    var wasm;
    return _regeneratorRuntime().wrap(function _callee$(_context) {
      while (1) switch (_context.prev = _context.next) {
        case 0:
          _context.next = 2;
          return instantiateRustWasm(webassemblyBytes, './sha1', 'sha1', 'sha1_init', 'sha1_update', 'sha1_final');
        case 2:
          wasm = _context.sent;
          return _context.abrupt("return", {
            final: wasm.final,
            hash: wasm.hash,
            init: wasm.init,
            update: wasm.update
          });
        case 4:
        case "end":
          return _context.stop();
      }
    }, _callee);
  }));
  return function instantiateSha1Bytes(_x) {
    return _ref.apply(this, arguments);
  };
}();
var getEmbeddedSha1Binary = function getEmbeddedSha1Binary() {
  return base64ToBin(sha1Base64Bytes).buffer;
};
/**
 * An ultimately-portable (but slower) version of {@link instantiateSha1Bytes}
 * that does not require the consumer to provide the sha1 binary buffer.
 */
var instantiateSha1 = /*#__PURE__*/function () {
  var _ref2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2() {
    return _regeneratorRuntime().wrap(function _callee2$(_context2) {
      while (1) switch (_context2.prev = _context2.next) {
        case 0:
          return _context2.abrupt("return", instantiateSha1Bytes(getEmbeddedSha1Binary()));
        case 1:
        case "end":
          return _context2.stop();
      }
    }, _callee2);
  }));
  return function instantiateSha1() {
    return _ref2.apply(this, arguments);
  };
}();

/**
 * The most performant way to instantiate sha256 functionality. To avoid
 * using Node.js or DOM-specific APIs, you can use {@link instantiateSha256}.
 *
 * @param webassemblyBytes - A buffer containing the sha256 binary.
 */
var instantiateSha256Bytes = /*#__PURE__*/function () {
  var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(webassemblyBytes) {
    var wasm;
    return _regeneratorRuntime().wrap(function _callee$(_context) {
      while (1) switch (_context.prev = _context.next) {
        case 0:
          _context.next = 2;
          return instantiateRustWasm(webassemblyBytes, './sha256', 'sha256', 'sha256_init', 'sha256_update', 'sha256_final');
        case 2:
          wasm = _context.sent;
          return _context.abrupt("return", {
            final: wasm.final,
            hash: wasm.hash,
            init: wasm.init,
            update: wasm.update
          });
        case 4:
        case "end":
          return _context.stop();
      }
    }, _callee);
  }));
  return function instantiateSha256Bytes(_x) {
    return _ref.apply(this, arguments);
  };
}();
var getEmbeddedSha256Binary = function getEmbeddedSha256Binary() {
  return base64ToBin(sha256Base64Bytes).buffer;
};
/**
 * An ultimately-portable (but possibly slower) version of
 * {@link instantiateSha256Bytes} which does not require the consumer to provide
 * the sha256 binary buffer.
 */
var instantiateSha256 = /*#__PURE__*/function () {
  var _ref2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2() {
    return _regeneratorRuntime().wrap(function _callee2$(_context2) {
      while (1) switch (_context2.prev = _context2.next) {
        case 0:
          return _context2.abrupt("return", instantiateSha256Bytes(getEmbeddedSha256Binary()));
        case 1:
        case "end":
          return _context2.stop();
      }
    }, _callee2);
  }));
  return function instantiateSha256() {
    return _ref2.apply(this, arguments);
  };
}();

/**
 * The most performant way to instantiate sha512 functionality. To avoid
 * using Node.js or DOM-specific APIs, you can use {@link instantiateSha512}.
 *
 * @param webassemblyBytes - A buffer containing the sha512 binary.
 */
var instantiateSha512Bytes = /*#__PURE__*/function () {
  var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(webassemblyBytes) {
    var wasm;
    return _regeneratorRuntime().wrap(function _callee$(_context) {
      while (1) switch (_context.prev = _context.next) {
        case 0:
          _context.next = 2;
          return instantiateRustWasm(webassemblyBytes, './sha512', 'sha512', 'sha512_init', 'sha512_update', 'sha512_final');
        case 2:
          wasm = _context.sent;
          return _context.abrupt("return", {
            final: wasm.final,
            hash: wasm.hash,
            init: wasm.init,
            update: wasm.update
          });
        case 4:
        case "end":
          return _context.stop();
      }
    }, _callee);
  }));
  return function instantiateSha512Bytes(_x) {
    return _ref.apply(this, arguments);
  };
}();
var getEmbeddedSha512Binary = function getEmbeddedSha512Binary() {
  return base64ToBin(sha512Base64Bytes).buffer;
};
/**
 * An ultimately-portable (but slower) version of {@link instantiateSha512Bytes}
 * that does not require the consumer to provide the sha512 binary buffer.
 */
var instantiateSha512 = /*#__PURE__*/function () {
  var _ref2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2() {
    return _regeneratorRuntime().wrap(function _callee2$(_context2) {
      while (1) switch (_context2.prev = _context2.next) {
        case 0:
          return _context2.abrupt("return", instantiateSha512Bytes(getEmbeddedSha512Binary()));
        case 1:
        case "end":
          return _context2.stop();
      }
    }, _callee2);
  }));
  return function instantiateSha512() {
    return _ref2.apply(this, arguments);
  };
}();

var _await$Promise$all = await Promise.all([instantiateSha1(), instantiateSha256(), instantiateSha512(), instantiateRipemd160(), instantiateSecp256k1()]),
  _await$Promise$all2 = _slicedToArray(_await$Promise$all, 5),
  sha1$1 = _await$Promise$all2[0],
  sha256$1 = _await$Promise$all2[1],
  sha512$1 = _await$Promise$all2[2],
  ripemd160$1 = _await$Promise$all2[3],
  secp256k1 = _await$Promise$all2[4];

/**
 * Hash the given payload with sha256, then hash the 32-byte result with
 * ripemd160, returning a 20-byte hash.
 *
 * This hash is used in both {@link AddressType.p2pkh} and
 * {@link AddressType.p2sh20} addresses.
 *
 * @param payload - the Uint8Array to hash
 */
var hash160 = function hash160(payload) {
  var crypto = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {
    ripemd160: ripemd160$1,
    sha256: sha256$1
  };
  return crypto.ripemd160.hash(crypto.sha256.hash(payload));
};
/**
 * Hash the given payload with sha256, then hash the 32-byte result with
 * one final round of sha256, returning a 32-byte hash.
 *
 * This type of hash is used to generate identifiers for transactions and blocks
 * (and therefore in block mining).
 *
 * @param payload - the Uint8Array to hash
 */
var hash256 = function hash256(payload) {
  var sha256 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : sha256$1;
  return sha256.hash(sha256.hash(payload));
};

/**
 * Instantiate a hash-based message authentication code (HMAC) function as
 * specified by RFC 2104.
 *
 * @param hashFunction - a cryptographic hash function that iterates a basic
 * compression function over blocks of data
 * @param blockByteLength - the byte-length of blocks used in `hashFunction`
 */
var instantiateHmacFunction = function instantiateHmacFunction(hashFunction, blockByteLength) {
  return function (secret, message) {
    var key = new Uint8Array(blockByteLength).fill(0);
    // eslint-disable-next-line functional/no-expression-statement
    key.set(secret.length > blockByteLength ? hashFunction(secret) : secret, 0);
    var innerPaddingFill = 0x36;
    var innerPadding = new Uint8Array(blockByteLength).fill(innerPaddingFill);
    // eslint-disable-next-line no-bitwise, @typescript-eslint/no-non-null-assertion
    var innerPrefix = innerPadding.map(function (pad, index) {
      return pad ^ key[index];
    });
    var innerContent = flattenBinArray([innerPrefix, message]);
    var innerResult = hashFunction(innerContent);
    var outerPaddingFill = 0x5c;
    var outerPadding = new Uint8Array(blockByteLength).fill(outerPaddingFill);
    // eslint-disable-next-line no-bitwise, @typescript-eslint/no-non-null-assertion
    var outerPrefix = outerPadding.map(function (pad, index) {
      return pad ^ key[index];
    });
    return hashFunction(flattenBinArray([outerPrefix, innerResult]));
  };
};
var sha256BlockByteLength = 64;
/**
 * Create a hash-based message authentication code using HMAC-SHA256 as
 * specified in `RFC 4231`. Returns a 32-byte Uint8Array.
 *
 * Secrets longer than the block byte-length (64 bytes) are hashed before
 * use, shortening their length to the minimum recommended length (32 bytes).
 * See `RFC 2104` for details.
 *
 * @param secret - the secret key (recommended length: 32-64 bytes)
 * @param message - the message to authenticate
 * @param sha256 - an implementation of Sha256
 */
var hmacSha256 = function hmacSha256(secret, message) {
  var sha256 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : sha256$1;
  return instantiateHmacFunction(sha256.hash, sha256BlockByteLength)(secret, message);
};
var sha512BlockByteLength = 128;
/**
 * Create a hash-based message authentication code using HMAC-SHA512 as
 * specified in `RFC 4231`. Returns a 64-byte Uint8Array.
 *
 * Secrets longer than the block byte-length (128 bytes) are hashed before
 * use, shortening their length to the minimum recommended length (64 bytes).
 * See `RFC 2104` for details.
 *
 * @param secret - the secret key (recommended length: 64-128 bytes)
 * @param message - the message to authenticate
 * @param sha512 - an implementation of Sha512
 */
var hmacSha512 = function hmacSha512(secret, message) {
  var sha512 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : sha512$1;
  return instantiateHmacFunction(sha512.hash, sha512BlockByteLength)(secret, message);
};

/**
 * Base58 version byte values for common Base58Address format versions.
 */
var Base58AddressFormatVersion;
(function (Base58AddressFormatVersion) {
  /**
   * A Pay to Public Key Hash (P2PKH) address – base58 encodes to a leading `1`.
   *
   * Hex: `0x00`
   */
  Base58AddressFormatVersion[Base58AddressFormatVersion["p2pkh"] = 0] = "p2pkh";
  /**
   * A 20-byte Pay to Script Hash (P2SH20) address – base58 encodes to a leading
   * `3`.
   *
   * Hex: `0x05`
   */
  Base58AddressFormatVersion[Base58AddressFormatVersion["p2sh20"] = 5] = "p2sh20";
  /**
   * A private key in Wallet Import Format. For private keys used with
   * uncompressed public keys, the payload is 32 bytes and causes the version
   * to be encoded as a `5`. For private keys used with compressed public keys,
   * a final `0x01` byte is appended to the private key, increasing the payload
   * to 33 bytes, and causing the version to be encoded as a `K` or `L`.
   *
   * Hex: `0x80`
   */
  Base58AddressFormatVersion[Base58AddressFormatVersion["wif"] = 128] = "wif";
  /**
   * A testnet Pay to Public Key Hash (P2PKH) address – base58 encodes to a
   * leading `m` or `n`.
   *
   * Hex: `0x6f`
   */
  Base58AddressFormatVersion[Base58AddressFormatVersion["p2pkhTestnet"] = 111] = "p2pkhTestnet";
  /**
   * A testnet 20-byte Pay to Script Hash (P2SH20) address – base58 encodes to a
   * leading `2`.
   *
   * Hex: `0xc4`
   */
  Base58AddressFormatVersion[Base58AddressFormatVersion["p2sh20Testnet"] = 196] = "p2sh20Testnet";
  /**
   * A private key in Wallet Import Format intended for testnet use. For private
   * keys used with uncompressed public keys, the payload is 32 bytes and causes
   * the version to be encoded as a `9`. For private keys used with compressed
   * public keys, a final `0x01` byte is appended to the private key, increasing
   * the payload to 33 bytes, and causing the version to be encoded as a `c`.
   *
   * Hex: `0xef`
   */
  Base58AddressFormatVersion[Base58AddressFormatVersion["wifTestnet"] = 239] = "wifTestnet";
  /**
   * A Pay to Public Key Hash (P2PKH) address intended for use on the Bitcoin
   * Cash network – base58 encodes to a leading `C`. This version was
   * temporarily used by the Copay project before the CashAddress format was
   * standardized.
   *
   * Hex: `0x1c`
   */
  Base58AddressFormatVersion[Base58AddressFormatVersion["p2pkhCopayBCH"] = 28] = "p2pkhCopayBCH";
  /**
   * A 20-byte Pay to Script Hash (P2SH20) address intended for use on the
   * Bitcoin Cash network – base58 encodes to a leading `H`. This version was
   * temporarily used by the Copay project before the CashAddress format was
   * standardized.
   *
   * Hex: `0x28`
   */
  Base58AddressFormatVersion[Base58AddressFormatVersion["p2sh20CopayBCH"] = 40] = "p2sh20CopayBCH";
})(Base58AddressFormatVersion || (Base58AddressFormatVersion = {}));
/**
 * Encode a payload using the Base58Address format, the original address format
 * used by the Satoshi implementation.
 *
 * Note, this method does not enforce error handling via the type system. The
 * returned string will not be a valid Base58Address if `hash` is not exactly 20
 * bytes. If needed, validate the length of `hash` before calling this method.
 *
 * @remarks
 * A Base58Address includes a 1-byte prefix to indicate the address version, a
 * variable-length payload, and a 4-byte checksum:
 *
 * `[version: 1 byte] [payload: variable length] [checksum: 4 bytes]`
 *
 * The checksum is the first 4 bytes of the double-SHA256 hash of the version
 * byte followed by the payload.
 *
 * @param version - the address version byte (see
 * {@link Base58AddressFormatVersion})
 * @param payload - the Uint8Array payload to encode
 * @param sha256 - an implementation of sha256 (defaults to the internal WASM
 * implementation)
 */
var encodeBase58AddressFormat = function encodeBase58AddressFormat(version, payload) {
  var sha256 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : sha256$1;
  var checksumBytes = 4;
  var content = Uint8Array.from([version].concat(_toConsumableArray(payload)));
  var checksum = hash256(content, sha256).slice(0, checksumBytes);
  var bin = flattenBinArray([content, checksum]);
  return binToBase58(bin);
};
/**
 * Encode a hash as a Base58Address.
 *
 * Note, this method does not enforce error handling via the type system. The
 * returned string will not be a valid Base58Address if `hash` is not exactly 20
 * bytes. If needed, validate the length of `hash` before calling this method.
 *
 * For other standards that use the Base58Address format but have other version
 * or length requirements, use {@link encodeCashAddressFormat}.
 *
 * @param type - the type of address to encode: `p2pkh`, `p2sh20`,
 * `p2pkh-testnet`, or `p2sh20-testnet`
 * @param hash - the 20-byte hash to encode
 * (`RIPEMD160(SHA256(public key or bytecode))`)
 * @param sha256 - an implementation of sha256 (defaults to the internal WASM
 * implementation)
 */
var encodeBase58Address = function encodeBase58Address(type, payload) {
  var sha256 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : sha256$1;
  return encodeBase58AddressFormat({
    p2pkh: Base58AddressFormatVersion.p2pkh,
    p2pkhCopayBCH: Base58AddressFormatVersion.p2pkhCopayBCH,
    p2pkhTestnet: Base58AddressFormatVersion.p2pkhTestnet,
    p2sh20: Base58AddressFormatVersion.p2sh20,
    p2sh20CopayBCH: Base58AddressFormatVersion.p2sh20CopayBCH,
    p2sh20Testnet: Base58AddressFormatVersion.p2sh20Testnet
  }[type], payload, sha256);
};
var Base58AddressError;
(function (Base58AddressError) {
  Base58AddressError["unknownCharacter"] = "Base58Address error: address may only contain valid base58 characters.";
  Base58AddressError["tooShort"] = "Base58Address error: address is too short to be valid.";
  Base58AddressError["invalidChecksum"] = "Base58Address error: address has an invalid checksum.";
  Base58AddressError["unknownAddressVersion"] = "Base58Address error: address uses an unknown address version.";
  Base58AddressError["incorrectLength"] = "Base58Address error: the encoded payload is not the correct length (20 bytes).";
})(Base58AddressError || (Base58AddressError = {}));
/**
 * Attempt to decode a Base58Address-formatted string. This is more lenient than
 * {@link decodeCashAddress}, which also validates the address version.
 *
 * Returns the contents of the address or an error message as a string.
 *
 * @param address - the string to decode as a base58 address
 * @param sha256 - an implementation of sha256 (defaults to the internal WASM
 * implementation)
 */
var decodeBase58AddressFormat = function decodeBase58AddressFormat(address) {
  var sha256 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : sha256$1;
  var checksumBytes = 4;
  var bin = base58ToBin(address);
  if (bin === BaseConversionError.unknownCharacter) {
    return Base58AddressError.unknownCharacter;
  }
  var minimumBase58AddressLength = 5;
  if (bin.length < minimumBase58AddressLength) {
    return Base58AddressError.tooShort;
  }
  var content = bin.slice(0, -checksumBytes);
  var checksum = bin.slice(-checksumBytes);
  var expectedChecksum = sha256.hash(sha256.hash(content)).slice(0, checksumBytes);
  if (!checksum.every(function (value, i) {
    return value === expectedChecksum[i];
  })) {
    return Base58AddressError.invalidChecksum;
  }
  return {
    payload: content.slice(1),
    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
    version: content[0]
  };
};
/**
 * Decode and validate a Base58Address, strictly checking the version and
 * payload length.
 *
 * For other address-like standards that closely follow the Base58Address
 * format (but have alternative version byte requirements), use
 * {@link decodeBase58AddressFormat}.
 *
 * @remarks
 * Because the Wallet Import Format (WIF) private key serialization format uses
 * the Base58Address format, some libraries allow WIF key decoding via the same
 * method as base58 address decoding. This method strictly accepts only
 * Base58Address types, but WIF keys can be decoded with
 * {@link decodePrivateKeyWif}.
 *
 * @param address - the string to decode as a base58 address
 * @param sha256 - an implementation of sha256 (defaults to the internal WASM
 * implementation)
 */
var decodeBase58Address$1 = function decodeBase58Address(address) {
  var sha256 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : sha256$1;
  var decoded = decodeBase58AddressFormat(address, sha256);
  if (typeof decoded === 'string') return decoded;
  if (![Base58AddressFormatVersion.p2pkh, Base58AddressFormatVersion.p2sh20, Base58AddressFormatVersion.p2pkhTestnet, Base58AddressFormatVersion.p2sh20Testnet, Base58AddressFormatVersion.p2pkhCopayBCH, Base58AddressFormatVersion.p2sh20CopayBCH].includes(decoded.version)) {
    return Base58AddressError.unknownAddressVersion;
  }
  var hash160Length = 20;
  if (decoded.payload.length !== hash160Length) {
    return Base58AddressError.incorrectLength;
  }
  return decoded;
};

/**
 * The list of 32 symbols used in Bech32 encoding.
 */
// cspell: disable-next-line
var bech32CharacterSet = 'qpzry9x8gf2tvdw0s3jn54khce6mua7l';
/**
 * An object mapping each of the 32 symbols used in Bech32 encoding to their respective index in the character set.
 */
// prettier-ignore
var bech32CharacterSetIndex = {
  q: 0,
  p: 1,
  z: 2,
  r: 3,
  y: 4,
  '9': 5,
  x: 6,
  '8': 7,
  g: 8,
  f: 9,
  '2': 10,
  t: 11,
  v: 12,
  d: 13,
  w: 14,
  '0': 15,
  s: 16,
  '3': 17,
  j: 18,
  n: 19,
  '5': 20,
  '4': 21,
  k: 22,
  h: 23,
  c: 24,
  e: 25,
  '6': 26,
  m: 27,
  u: 28,
  a: 29,
  '7': 30,
  l: 31
}; // eslint-disable-line sort-keys, @typescript-eslint/naming-convention
var BitRegroupingError;
(function (BitRegroupingError) {
  BitRegroupingError["integerOutOfRange"] = "An integer provided in the source array is out of the range of the specified source word length.";
  BitRegroupingError["hasDisallowedPadding"] = "Encountered padding when padding was disallowed.";
  BitRegroupingError["requiresDisallowedPadding"] = "Encoding requires padding while padding is disallowed.";
})(BitRegroupingError || (BitRegroupingError = {}));
/* eslint-disable functional/no-let, no-bitwise, functional/no-expression-statement, functional/no-conditional-statement, complexity */
/**
 * Given an array of integers, regroup bits from `sourceWordLength` to
 * `resultWordLength`, returning a new array of integers between 0 and
 * toWordLength^2.
 *
 * Note, if `bin` is within the range of `sourceWordLength` and `padding` is
 * `true`, this method will never error.
 *
 * A.K.A. `convertbits`
 */
// Derived from: https://github.com/sipa/bech32
var regroupBits = function regroupBits(_ref) {
  var bin = _ref.bin,
    sourceWordLength = _ref.sourceWordLength,
    resultWordLength = _ref.resultWordLength,
    _ref$allowPadding = _ref.allowPadding,
    allowPadding = _ref$allowPadding === void 0 ? true : _ref$allowPadding;
  var accumulator = 0;
  var bits = 0;
  var result = [];
  var maxResultInt = (1 << resultWordLength) - 1;
  // eslint-disable-next-line functional/no-loop-statement, @typescript-eslint/prefer-for-of, no-plusplus
  for (var p = 0; p < bin.length; ++p) {
    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
    var value = bin[p];
    if (value < 0 || value >> sourceWordLength !== 0) {
      return BitRegroupingError.integerOutOfRange;
    }
    accumulator = accumulator << sourceWordLength | value;
    bits += sourceWordLength;
    // eslint-disable-next-line functional/no-loop-statement
    while (bits >= resultWordLength) {
      bits -= resultWordLength;
      // eslint-disable-next-line functional/immutable-data
      result.push(accumulator >> bits & maxResultInt);
    }
  }
  if (allowPadding) {
    if (bits > 0) {
      // eslint-disable-next-line functional/immutable-data
      result.push(accumulator << resultWordLength - bits & maxResultInt);
    }
  } else if (bits >= sourceWordLength) {
    return BitRegroupingError.hasDisallowedPadding;
  } else if ((accumulator << resultWordLength - bits & maxResultInt) > 0) {
    return BitRegroupingError.requiresDisallowedPadding;
  }
  return result;
};
/* eslint-enable functional/no-let, no-bitwise, functional/no-expression-statement, functional/no-conditional-statement, complexity */
/**
 * Encode an array of numbers as a base32 string using the Bech32 character set.
 *
 * Note, this method always completes. For a valid result, all items in
 * `base32IntegerArray` must be between `0` and `32`. To prepare another array
 * type for encoding, see {@link regroupBits}.
 *
 * @param base32IntegerArray - the array of 5-bit integers to encode
 */
var encodeBech32 = function encodeBech32(base32IntegerArray) {
  // eslint-disable-next-line functional/no-let
  var result = '';
  // eslint-disable-next-line @typescript-eslint/prefer-for-of, functional/no-let, functional/no-loop-statement, no-plusplus
  for (var i = 0; i < base32IntegerArray.length; i++) {
    // eslint-disable-next-line functional/no-expression-statement, @typescript-eslint/no-non-null-assertion
    result += bech32CharacterSet[base32IntegerArray[i]];
  }
  return result;
};
/**
 * Decode a Bech32-encoded string into an array of 5-bit integers.
 *
 * Note, this method always completes. If `validBech32` is not valid bech32,
 * an incorrect result will be returned. If `validBech32` is potentially
 * malformed, check it with {@link isBech32CharacterSet} before calling
 * this method.
 *
 * @param validBech32 - the bech32-encoded string to decode
 */
var decodeBech32 = function decodeBech32(validBech32) {
  var result = [];
  // eslint-disable-next-line @typescript-eslint/prefer-for-of, functional/no-let, functional/no-loop-statement, no-plusplus
  for (var i = 0; i < validBech32.length; i++) {
    // eslint-disable-next-line functional/no-expression-statement, functional/immutable-data
    result.push(bech32CharacterSetIndex[validBech32[i]]);
  }
  return result;
};
var nonBech32Characters = new RegExp("[^".concat(bech32CharacterSet, "]"), 'u');
var base32WordLength = 5;
var base256WordLength = 8;
/**
 * Validate that a string uses only characters from the bech32 character set.
 *
 * @param maybeBech32 - a string to test for valid Bech32 encoding
 */
var isBech32CharacterSet = function isBech32CharacterSet(maybeBech32) {
  return !nonBech32Characters.test(maybeBech32);
};
var Bech32DecodingError;
(function (Bech32DecodingError) {
  Bech32DecodingError["notBech32CharacterSet"] = "Bech32 decoding error: input contains characters outside of the Bech32 character set.";
})(Bech32DecodingError || (Bech32DecodingError = {}));
/**
 * Convert a padded bech32-encoded string (without checksum) to a Uint8Array,
 * removing the padding. If the string is not valid Bech32, or if the array of
 * 5-bit integers would require padding to be regrouped into 8-bit bytes, this
 * method returns an error message.
 *
 * This method is the reverse of {@link binToBech32Padded}.
 *
 * @param bech32Padded - the padded bech32-encoded string to decode
 */
var bech32PaddedToBin = function bech32PaddedToBin(bech32Padded) {
  var result = isBech32CharacterSet(bech32Padded) ? regroupBits({
    allowPadding: false,
    bin: decodeBech32(bech32Padded),
    resultWordLength: base256WordLength,
    sourceWordLength: base32WordLength
  }) : Bech32DecodingError.notBech32CharacterSet;
  return typeof result === 'string' ? result : Uint8Array.from(result);
};
/**
 * Convert a Uint8Array to a padded bech32-encoded string (without a checksum),
 * adding padding bits as necessary to convert all bytes to 5-bit integers.
 *
 * This method is the reverse of {@link bech32PaddedToBin}.
 *
 * @param bytes - the Uint8Array to bech32 encode
 */
var binToBech32Padded = function binToBech32Padded(bytes) {
  return encodeBech32(regroupBits({
    bin: bytes,
    resultWordLength: base32WordLength,
    sourceWordLength: base256WordLength
  }));
};

var _cashAddressTypeToTyp, _cashAddressTypeBitsT;
var CashAddressNetworkPrefix;
(function (CashAddressNetworkPrefix) {
  CashAddressNetworkPrefix["mainnet"] = "bitcoincash";
  CashAddressNetworkPrefix["testnet"] = "bchtest";
  CashAddressNetworkPrefix["regtest"] = "bchreg";
})(CashAddressNetworkPrefix || (CashAddressNetworkPrefix = {}));
/**
 * The CashAddress specification standardizes the format of the version byte:
 * - Most significant bit: reserved, must be `0`
 * - next 4 bits: Address Type
 * - 3 least significant bits: Payload Size
 *
 * Two Address Type values are currently standardized:
 * - 0 (`0b0000`): P2PKH
 * - 1 (`0b0001`): P2SH
 *
 * And two are proposed by `CHIP-2022-02-CashTokens`:
 * - 2 (`0b0010`): P2PKH + Token Support
 * - 3 (`0b0011`): P2SH + Token Support
 *
 * The CashAddress specification standardizes expected payload size using
 * {@link CashAddressSizeBits}. Currently, two size bit values are in use by
 * standard CashAddress types:
 * - `0` (`0b000`): 20 bytes (in use by `p2pkh` and `p2sh20`)
 * - `3` (`0b011`): 32 bytes (in use by `p2sh32`)
 */
var CashAddressVersionByte;
(function (CashAddressVersionByte) {
  /**
   * Pay to Public Key Hash (P2PKH): `0b00000000`
   *
   * - Most significant bit: `0` (reserved)
   * - Address Type bits: `0000` (P2PKH)
   * - Size bits: `000` (20 bytes)
   */
  CashAddressVersionByte[CashAddressVersionByte["p2pkh"] = 0] = "p2pkh";
  /**
   * 20-byte Pay to Script Hash (P2SH20): `0b00001000`
   *
   * - Most significant bit: `0` (reserved)
   * - Address Type bits: `0001` (P2SH)
   * - Size bits: `000` (20 bytes)
   */
  CashAddressVersionByte[CashAddressVersionByte["p2sh20"] = 8] = "p2sh20";
  /**
   * 32-byte Pay to Script Hash (P2SH20): `0b00001000`
   *
   * - Most significant bit: `0` (reserved)
   * - Address Type bits: `0001` (P2SH)
   * - Size bits: `011` (32 bytes)
   */
  CashAddressVersionByte[CashAddressVersionByte["p2sh32"] = 11] = "p2sh32";
  /**
   * Pay to Public Key Hash (P2PKH) with token support: `0b00010000`
   *
   * - Most significant bit: `0` (reserved)
   * - Address Type bits: `0010` (P2PKH + Tokens)
   * - Size bits: `000` (20 bytes)
   */
  CashAddressVersionByte[CashAddressVersionByte["p2pkhWithTokens"] = 16] = "p2pkhWithTokens";
  /**
   * 20-byte Pay to Script Hash (P2SH20) with token support: `0b00011000`
   * - Most significant bit: `0` (reserved)
   * - Address Type bits: `0011` (P2SH + Tokens)
   * - Size bits: `000` (20 bytes)
   */
  CashAddressVersionByte[CashAddressVersionByte["p2sh20WithTokens"] = 24] = "p2sh20WithTokens";
  /**
   * 32-byte Pay to Script Hash (P2SH32) with token support: `0b00011011`
   * - Most significant bit: `0` (reserved)
   * - Address Type bits: `0011` (P2SH + Tokens)
   * - Size bits: `011` (32 bytes)
   */
  CashAddressVersionByte[CashAddressVersionByte["p2sh32WithTokens"] = 27] = "p2sh32WithTokens";
})(CashAddressVersionByte || (CashAddressVersionByte = {}));
/**
 * The address types currently defined in the CashAddress specification. See
 * also: {@link CashAddressVersionByte}.
 */
var CashAddressType;
(function (CashAddressType) {
  /**
   * Pay to Public Key Hash (P2PKH): `0b0000`
   */
  CashAddressType["p2pkh"] = "p2pkh";
  /**
   * Pay to Script Hash (P2SH): `0b0001`
   */
  CashAddressType["p2sh"] = "p2sh";
  /**
   * Pay to Public Key Hash (P2PKH) with token support: `0b0010`
   */
  CashAddressType["p2pkhWithTokens"] = "p2pkhWithTokens";
  /**
   * Pay to Script Hash (P2SH) with token support: `0b0011`
   */
  CashAddressType["p2shWithTokens"] = "p2shWithTokens";
})(CashAddressType || (CashAddressType = {}));
/**
 * The address type bits currently defined in the CashAddress specification.
 * These map to: {@link CashAddressType}.
 */
var CashAddressTypeBits;
(function (CashAddressTypeBits) {
  /**
   * Pay to Public Key Hash (P2PKH)
   */
  CashAddressTypeBits[CashAddressTypeBits["p2pkh"] = 0] = "p2pkh";
  /**
   * Pay to Script Hash (P2SH)
   */
  CashAddressTypeBits[CashAddressTypeBits["p2sh"] = 1] = "p2sh";
  /**
   * Pay to Public Key Hash (P2PKH) with token support
   */
  CashAddressTypeBits[CashAddressTypeBits["p2pkhWithTokens"] = 2] = "p2pkhWithTokens";
  /**
   * Pay to Script Hash (P2SH) with token support
   */
  CashAddressTypeBits[CashAddressTypeBits["p2shWithTokens"] = 3] = "p2shWithTokens";
})(CashAddressTypeBits || (CashAddressTypeBits = {}));
var cashAddressTypeToTypeBits = (_cashAddressTypeToTyp = {}, _defineProperty(_cashAddressTypeToTyp, CashAddressType.p2pkh, CashAddressTypeBits.p2pkh), _defineProperty(_cashAddressTypeToTyp, CashAddressType.p2sh, CashAddressTypeBits.p2sh), _defineProperty(_cashAddressTypeToTyp, CashAddressType.p2pkhWithTokens, CashAddressTypeBits.p2pkhWithTokens), _defineProperty(_cashAddressTypeToTyp, CashAddressType.p2shWithTokens, CashAddressTypeBits.p2shWithTokens), _cashAddressTypeToTyp);
var cashAddressTypeBitsToType = (_cashAddressTypeBitsT = {}, _defineProperty(_cashAddressTypeBitsT, CashAddressTypeBits.p2pkh, CashAddressType.p2pkh), _defineProperty(_cashAddressTypeBitsT, CashAddressTypeBits.p2sh, CashAddressType.p2sh), _defineProperty(_cashAddressTypeBitsT, CashAddressTypeBits.p2pkhWithTokens, CashAddressType.p2pkhWithTokens), _defineProperty(_cashAddressTypeBitsT, CashAddressTypeBits.p2shWithTokens, CashAddressType.p2shWithTokens), _cashAddressTypeBitsT);
/* eslint-disable @typescript-eslint/naming-convention */
var cashAddressSizeBitsToLength = {
  0: 20,
  1: 24,
  2: 28,
  3: 32,
  4: 40,
  5: 48,
  6: 56,
  7: 64
};
var cashAddressLengthToSizeBits = {
  20: 0,
  24: 1,
  28: 2,
  32: 3,
  40: 4,
  48: 5,
  56: 6,
  64: 7
};
/**
 * Encode a CashAddress version byte for the given address type and payload
 * length. See {@link CashAddressVersionByte} for more information.
 *
 * The `type` parameter must be a number between `0` and `15`, and `bitLength`
 * must be one of the standardized lengths. To use the contents of a variable,
 * cast it to {@link CashAddressType} or {@link CashAddressSize} respectively,
 * e.g.:
 * ```ts
 * const type = 3 as CashAddressType;
 * const size = 160 as CashAddressSize;
 * getCashAddressVersionByte(type, size);
 * ```
 * @param typeBits - the address type bit of the payload being encoded
 * @param length - the length of the payload being encoded
 */
var encodeCashAddressVersionByte = function encodeCashAddressVersionByte(typeBits, length) {
  return (
    // eslint-disable-next-line no-bitwise
    typeBits << 3 /* Constants.cashAddressTypeBitsShift */ | cashAddressLengthToSizeBits[length]
  );
};
var CashAddressVersionByteDecodingError;
(function (CashAddressVersionByteDecodingError) {
  CashAddressVersionByteDecodingError["reservedBitSet"] = "Reserved bit is set.";
})(CashAddressVersionByteDecodingError || (CashAddressVersionByteDecodingError = {}));
/**
 * Decode a CashAddress version byte. For a list of known versions, see
 * {@link CashAddressVersionByte}.
 *
 * @param version - the version byte to decode
 */
var decodeCashAddressVersionByte = function decodeCashAddressVersionByte(version) {
  return (
    // eslint-disable-next-line no-negated-condition, no-bitwise
    (version & 128 /* Constants.cashAddressReservedBitMask */) !== 0 ? CashAddressVersionByteDecodingError.reservedBitSet : {
      length: cashAddressSizeBitsToLength[
      // eslint-disable-next-line no-bitwise
      version & 7 /* Constants.cashAddressSizeBits */],
      typeBits:
      // eslint-disable-next-line no-bitwise
      version >>> 3 /* Constants.cashAddressTypeBitsShift */ & 15 /* Constants.cashAddressTypeBits */
    }
  );
};
/**
 * Convert a string into an array of 5-bit numbers, representing the characters
 * in a case-insensitive way.
 * @param prefix - the prefix to mask
 */
var maskCashAddressPrefix = function maskCashAddressPrefix(prefix) {
  var result = [];
  // eslint-disable-next-line functional/no-let, functional/no-loop-statement, no-plusplus
  for (var i = 0; i < prefix.length; i++) {
    // eslint-disable-next-line functional/no-expression-statement, no-bitwise, functional/immutable-data
    result.push(prefix.charCodeAt(i) & 31 /* Constants.asciiCaseInsensitiveBits */);
  }

  return result;
};
// prettier-ignore
var bech32GeneratorMostSignificantByte = [0x98, 0x79, 0xf3, 0xae, 0x1e]; // eslint-disable-line @typescript-eslint/no-magic-numbers
// prettier-ignore
var bech32GeneratorRemainingBytes = [0xf2bc8e61, 0xb76d99e2, 0x3e5fb3c4, 0x2eabe2a8, 0x4f43e470]; // eslint-disable-line @typescript-eslint/no-magic-numbers
/**
 * Perform the CashAddress polynomial modulo operation, which is based on the
 * Bech32 polynomial modulo operation, but the returned checksum is 40 bits,
 * rather than 30.
 *
 * A.K.A. `PolyMod`
 *
 * @remarks
 * Notes from C++ implementation:
 * This function will compute what 8 5-bit values to XOR into the last 8 input
 * values, in order to make the checksum 0. These 8 values are packed together
 * in a single 40-bit integer. The higher bits correspond to earlier values.
 *
 * The input is interpreted as a list of coefficients of a polynomial over F
 * = GF(32), with an implicit 1 in front. If the input is [v0,v1,v2,v3,v4],
 * that polynomial is v(x) = 1*x^5 + v0*x^4 + v1*x^3 + v2*x^2 + v3*x + v4.
 * The implicit 1 guarantees that [v0,v1,v2,...] has a distinct checksum
 * from [0,v0,v1,v2,...].
 *
 * The output is a 40-bit integer whose 5-bit groups are the coefficients of
 * the remainder of v(x) mod g(x), where g(x) is the cashaddr generator, x^8
 * + [19]*x^7 + [3]*x^6 + [25]*x^5 + [11]*x^4 + [25]*x^3 + [3]*x^2 + [19]*x
 * + [1]. g(x) is chosen in such a way that the resulting code is a BCH
 * code, guaranteeing detection of up to 4 errors within a window of 1025
 * characters. Among the various possible BCH codes, one was selected to in
 * fact guarantee detection of up to 5 errors within a window of 160
 * characters and 6 errors within a window of 126 characters. In addition,
 * the code guarantee the detection of a burst of up to 8 errors.
 *
 * Note that the coefficients are elements of GF(32), here represented as
 * decimal numbers between []. In this finite field, addition is just XOR of
 * the corresponding numbers. For example, [27] + [13] = [27 ^ 13] = [22].
 * Multiplication is more complicated, and requires treating the bits of
 * values themselves as coefficients of a polynomial over a smaller field,
 * GF(2), and multiplying those polynomials mod a^5 + a^3 + 1. For example,
 * [5] * [26] = (a^2 + 1) * (a^4 + a^3 + a) = (a^4 + a^3 + a) * a^2 + (a^4 +
 * a^3 + a) = a^6 + a^5 + a^4 + a = a^3 + 1 (mod a^5 + a^3 + 1) = [9].
 *
 * During the course of the loop below, `c` contains the bit-packed
 * coefficients of the polynomial constructed from just the values of v that
 * were processed so far, mod g(x). In the above example, `c` initially
 * corresponds to 1 mod (x), and after processing 2 inputs of v, it
 * corresponds to x^2 + v0*x + v1 mod g(x). As 1 mod g(x) = 1, that is the
 * starting value for `c`.
 *
 * @param v - Array of 5-bit integers over which the checksum is to be computed
 */
// Derived from the `bitcore-lib-cash` implementation (does not require BigInt): https://github.com/bitpay/bitcore
var cashAddressPolynomialModulo = function cashAddressPolynomialModulo(v) {
  /* eslint-disable functional/no-let, functional/no-loop-statement, functional/no-expression-statement, no-bitwise, @typescript-eslint/no-magic-numbers */
  var mostSignificantByte = 0;
  var lowerBytes = 1;
  var c = 0;
  // eslint-disable-next-line @typescript-eslint/prefer-for-of, no-plusplus
  for (var j = 0; j < v.length; j++) {
    c = mostSignificantByte >>> 3;
    mostSignificantByte &= 0x07;
    mostSignificantByte <<= 5;
    mostSignificantByte |= lowerBytes >>> 27;
    lowerBytes &= 0x07ffffff;
    lowerBytes <<= 5;
    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
    lowerBytes ^= v[j];
    // eslint-disable-next-line no-plusplus
    for (var i = 0; i < bech32GeneratorMostSignificantByte.length; ++i) {
      // eslint-disable-next-line functional/no-conditional-statement
      if (c & 1 << i) {
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        mostSignificantByte ^= bech32GeneratorMostSignificantByte[i];
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        lowerBytes ^= bech32GeneratorRemainingBytes[i];
      }
    }
  }
  lowerBytes ^= 1;
  // eslint-disable-next-line functional/no-conditional-statement
  if (lowerBytes < 0) {
    lowerBytes ^= 1 << 31;
    lowerBytes += (1 << 30) * 2;
  }
  return mostSignificantByte * (1 << 30) * 4 + lowerBytes;
  /* eslint-enable functional/no-let, functional/no-loop-statement, functional/no-expression-statement, no-bitwise, @typescript-eslint/no-magic-numbers */
};
/**
 * Convert the checksum returned by {@link cashAddressPolynomialModulo} to an
 * array of 5-bit positive integers that can be Base32 encoded.
 * @param checksum - a 40 bit checksum returned by
 * {@link cashAddressPolynomialModulo}
 */
var cashAddressChecksumToUint5Array = function cashAddressChecksumToUint5Array(checksum) {
  var result = [];
  // eslint-disable-next-line functional/no-let, functional/no-loop-statement, no-plusplus
  for (var i = 0; i < 8 /* Constants.base256WordLength */; ++i) {
    // eslint-disable-next-line functional/no-expression-statement, no-bitwise, @typescript-eslint/no-magic-numbers, functional/immutable-data
    result.push(checksum & 31);
    // eslint-disable-next-line functional/no-expression-statement, @typescript-eslint/no-magic-numbers, no-param-reassign
    checksum /= 32;
  }
  // eslint-disable-next-line functional/immutable-data
  return result.reverse();
};
/**
 * Encode a payload as a CashAddress-like string using the CashAddress format.
 *
 * To encode a standard CashAddress, use {@link encodeCashAddress}.
 *
 * @param prefix - a valid prefix indicating the network for which to encode the
 * address – must be only lowercase letters (for standard CashAddress prefixes,
 * see {@link CashAddressNetworkPrefix})
 * @param version - a single byte indicating the version of this address (for
 * standard CashAddress versions, see {@link CashAddressVersionByte})
 * @param payload - the payload to encode
 */
var encodeCashAddressFormat = function encodeCashAddressFormat(prefix, version, payload) {
  var checksum40BitPlaceholder = [0, 0, 0, 0, 0, 0, 0, 0];
  var payloadContents = regroupBits({
    bin: Uint8Array.from([version].concat(_toConsumableArray(payload))),
    resultWordLength: 5 /* Constants.base32WordLength */,
    sourceWordLength: 8 /* Constants.base256WordLength */
  });

  var checksumContents = [].concat(_toConsumableArray(maskCashAddressPrefix(prefix)), [0 /* Constants.payloadSeparator */], _toConsumableArray(payloadContents), checksum40BitPlaceholder);
  var checksum = cashAddressPolynomialModulo(checksumContents);
  var encoded = [].concat(_toConsumableArray(payloadContents), _toConsumableArray(cashAddressChecksumToUint5Array(checksum)));
  return "".concat(prefix, ":").concat(encodeBech32(encoded));
};
var CashAddressEncodingError;
(function (CashAddressEncodingError) {
  CashAddressEncodingError["unsupportedPayloadLength"] = "Error encoding CashAddress: a payload of this length can not be encoded as a valid CashAddress.";
  CashAddressEncodingError["noTypeBitsValueStandardizedForP2pk"] = "Error encoding CashAddress: no CashAddress type bit has been standardized for P2PK locking bytecode.";
  CashAddressEncodingError["unknownLockingBytecodeType"] = "Error encoding CashAddress: unknown locking bytecode type.";
})(CashAddressEncodingError || (CashAddressEncodingError = {}));
var isValidCashAddressPayloadLength = function isValidCashAddressPayloadLength(length) {
  return cashAddressLengthToSizeBits[length] !== undefined;
};
/**
 * Encode a payload as a CashAddress. This function is similar to
 * {@link encodeCashAddress} but supports non-standard `prefix`es and `type`s.
 *
 * **Note: this function cannot prevent all implementation errors via types.**
 * The function will throw if `payload` is not a valid
 * {@link CashAddressSupportedLength}. Confirm the length of untrusted inputs
 * before providing them to this function.
 *
 * For other address standards that closely follow the CashAddress
 * specification (but have alternative version byte requirements), use
 * {@link encodeCashAddressFormat}.
 *
 * @param prefix - a valid prefix indicating the network for which to encode the
 * address (usually a {@link CashAddressNetworkPrefix}) – must be only lowercase
 * letters
 * @param typeBits - the type bit to encode in the version byte – must be a
 * number between `0` and `15`
 * @param payload - the payload to encode (for P2PKH, the public key hash; for
 * P2SH, the redeem bytecode hash)
 */
var encodeCashAddressNonStandard = function encodeCashAddressNonStandard(prefix, typeBits, payload) {
  var length = payload.length;
  if (!isValidCashAddressPayloadLength(length)) {
    // eslint-disable-next-line functional/no-throw-statement
    throw new Error(formatError$1(CashAddressEncodingError.unsupportedPayloadLength, "Payload length: ".concat(length, ".")));
  }
  return encodeCashAddressFormat(prefix, encodeCashAddressVersionByte(typeBits, length), payload);
};
/**
 * Encode a payload as a CashAddress.
 *
 * **Note: this function cannot prevent all implementation errors via types.**
 * The function will throw if `payload` is not a valid
 * {@link CashAddressSupportedLength}. Confirm the length of untrusted inputs
 * before providing them to this function.
 *
 * To encode a CashAddress with a custom/unknown prefix or type bit, see
 * {@link encodeCashAddressNonStandard}. For other address standards that
 * closely follow the CashAddress specification (but have alternative version
 * byte requirements), use {@link encodeCashAddressFormat}.
 *
 * @param prefix - the network for which to encode the address
 * (a {@link CashAddressNetworkPrefix})
 * @param type - the address type (a {@link CashAddressType})
 * @param payload - the payload to encode – for P2PKH, the public key hash; for
 * P2SH, the redeem bytecode hash
 */
var encodeCashAddress = function encodeCashAddress(prefix, type, payload) {
  return encodeCashAddressNonStandard(prefix, cashAddressTypeToTypeBits[type], payload);
};
var CashAddressDecodingError;
(function (CashAddressDecodingError) {
  CashAddressDecodingError["improperPadding"] = "Error decoding CashAddress: the payload is improperly padded.";
  CashAddressDecodingError["invalidCharacters"] = "Error decoding CashAddress: the payload contains non-bech32 characters.";
  CashAddressDecodingError["invalidChecksum"] = "Error decoding CashAddress: invalid checksum - please review the address for errors.";
  CashAddressDecodingError["invalidFormat"] = "Error decoding CashAddress: CashAddresses should be of the form \"prefix:payload\".";
  CashAddressDecodingError["mismatchedPayloadLength"] = "Error decoding CashAddress: mismatched payload length for specified address version.";
  CashAddressDecodingError["reservedByte"] = "Error decoding CashAddress: unknown CashAddress version, reserved byte set.";
  CashAddressDecodingError["unknownAddressType"] = "Error decoding CashAddress: unknown CashAddress type.";
})(CashAddressDecodingError || (CashAddressDecodingError = {}));
/**
 * Decode and validate a string using the CashAddress format. This is more
 * lenient than {@link decodeCashAddress}, which also validates the contents of
 * the version byte.
 *
 * Note, this method requires `address` to include a network prefix. To
 * decode a string with an unknown prefix, try
 * {@link decodeCashAddressFormatWithoutPrefix}.
 *
 * @param address - the CashAddress-like string to decode
 */
// eslint-disable-next-line complexity
var decodeCashAddressFormat = function decodeCashAddressFormat(address) {
  var parts = address.toLowerCase().split(':');
  // eslint-disable-next-line @typescript-eslint/no-magic-numbers
  if (parts.length !== 2 || parts[0] === '' || parts[1] === '') {
    return CashAddressDecodingError.invalidFormat;
  }
  var _parts = _slicedToArray(parts, 2),
    prefix = _parts[0],
    payload = _parts[1];
  if (!isBech32CharacterSet(payload)) {
    return CashAddressDecodingError.invalidCharacters;
  }
  var decodedPayload = decodeBech32(payload);
  var polynomial = [].concat(_toConsumableArray(maskCashAddressPrefix(prefix)), [0 /* Constants.payloadSeparator */], _toConsumableArray(decodedPayload));
  if (cashAddressPolynomialModulo(polynomial) !== 0) {
    return CashAddressDecodingError.invalidChecksum;
  }
  var checksum40BitPlaceholderLength = 8;
  var payloadContents = regroupBits({
    allowPadding: false,
    bin: decodedPayload.slice(0, -checksum40BitPlaceholderLength),
    resultWordLength: 8 /* Constants.base256WordLength */,
    sourceWordLength: 5 /* Constants.base32WordLength */
  });

  if (typeof payloadContents === 'string') {
    return CashAddressDecodingError.improperPadding;
  }
  var _payloadContents = _toArray(payloadContents),
    version = _payloadContents[0],
    contents = _payloadContents.slice(1);
  var result = Uint8Array.from(contents);
  return {
    payload: result,
    prefix: prefix,
    version: version
  };
};
/**
 * Decode and validate a CashAddress, strictly checking the version byte
 * according to the CashAddress specification. This is important for error
 * detection in CashAddresses.
 *
 * This function is similar to {@link decodeCashAddress} but supports
 * non-standard `type`s.
 *
 * For other address-like standards that closely follow the CashAddress
 * specification (but have alternative version byte requirements), use
 * {@link decodeCashAddressFormat}.
 *
 * Note, this method requires that CashAddresses include a network prefix. To
 * decode an address with an unknown prefix, try
 * {@link decodeCashAddressFormatWithoutPrefix}.
 *
 * @param address - the CashAddress to decode
 */
var decodeCashAddressNonStandard = function decodeCashAddressNonStandard(address) {
  var decoded = decodeCashAddressFormat(address);
  if (typeof decoded === 'string') {
    return decoded;
  }
  var info = decodeCashAddressVersionByte(decoded.version);
  if (info === CashAddressVersionByteDecodingError.reservedBitSet) {
    return CashAddressDecodingError.reservedByte;
  }
  if (decoded.payload.length !== info.length) {
    return CashAddressDecodingError.mismatchedPayloadLength;
  }
  return {
    payload: decoded.payload,
    prefix: decoded.prefix,
    typeBits: info.typeBits
  };
};
/**
 * Decode and validate a CashAddress, strictly checking the version byte
 * according to the CashAddress specification. This is important for error
 * detection in CashAddresses.
 *
 * To decode CashAddresses with non-standard `type`s,
 * see {@link decodeCashAddressNonStandard}.
 *
 * For other address-like standards that closely follow the CashAddress
 * specification (but have alternative version byte requirements), use
 * {@link decodeCashAddressFormat}.
 *
 * Note, this method requires that CashAddresses include a network prefix. To
 * decode an address with an unknown prefix, try
 * {@link decodeCashAddressFormatWithoutPrefix}.
 *
 * @param address - the CashAddress to decode
 */
var decodeCashAddress$1 = function decodeCashAddress(address) {
  var decoded = decodeCashAddressNonStandard(address);
  if (typeof decoded === 'string') {
    return decoded;
  }
  var type = cashAddressTypeBitsToType[decoded.typeBits];
  if (type === undefined) {
    return "".concat(CashAddressDecodingError.unknownAddressType, " Type bit value: ").concat(decoded.typeBits, ".");
  }
  return {
    payload: decoded.payload,
    prefix: decoded.prefix,
    type: type
  };
};
/**
 * Attempt to decode and validate a CashAddress against a list of possible
 * prefixes. If the correct prefix is known, use {@link decodeCashAddress}.
 *
 * @param address - the CashAddress to decode
 * @param possiblePrefixes - the network prefixes to try
 */
// decodeCashAddressWithoutPrefix
var decodeCashAddressFormatWithoutPrefix = function decodeCashAddressFormatWithoutPrefix(address) {
  var possiblePrefixes = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [CashAddressNetworkPrefix.mainnet, CashAddressNetworkPrefix.testnet, CashAddressNetworkPrefix.regtest];
  // eslint-disable-next-line functional/no-loop-statement
  var _iterator = _createForOfIteratorHelper(possiblePrefixes),
    _step;
  try {
    for (_iterator.s(); !(_step = _iterator.n()).done;) {
      var prefix = _step.value;
      var attempt = decodeCashAddressFormat("".concat(prefix, ":").concat(address));
      if (attempt !== CashAddressDecodingError.invalidChecksum) {
        return attempt;
      }
    }
  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }
  return CashAddressDecodingError.invalidChecksum;
};
/**
 * Convert a CashAddress polynomial to CashAddress string format.
 *
 * @remarks
 * CashAddress polynomials take the form:
 *
 * `[lowest 5 bits of each prefix character] 0 [payload + checksum]`
 *
 * This method remaps the 5-bit integers in the prefix location to the matching
 * ASCII lowercase characters, replaces the separator with `:`, and then Bech32
 * encodes the remaining payload and checksum.
 *
 * @param polynomial - an array of 5-bit integers representing the terms of a
 * CashAddress polynomial
 */
var cashAddressPolynomialToCashAddress = function cashAddressPolynomialToCashAddress(polynomial) {
  var separatorPosition = polynomial.indexOf(0);
  var prefix = polynomial.slice(0, separatorPosition).map(function (integer) {
    return String.fromCharCode(96 /* Constants.asciiLowerCaseStart */ + integer);
  }).join('');
  var contents = encodeBech32(polynomial.slice(separatorPosition + 1));
  return "".concat(prefix, ":").concat(contents);
};
var CashAddressCorrectionError;
(function (CashAddressCorrectionError) {
  CashAddressCorrectionError["tooManyErrors"] = "This address has more than 2 errors and cannot be corrected.";
})(CashAddressCorrectionError || (CashAddressCorrectionError = {}));
/**
 * Attempt to correct up to 2 errors in a CashAddress. The CashAddress must be
 * properly formed (include a prefix and only contain Bech32 characters).
 *
 * ## **Improper use of this method carries the risk of lost funds.**
 *
 * It is strongly advised that this method only be used under explicit user
 * control. With enough errors, this method is likely to find a plausible
 * correction for any address (but for which no private key exists). This is
 * effectively equivalent to burning the funds.
 *
 * Only 2 substitution errors can be corrected (or a single swap) – deletions
 * and insertions (errors that shift many other characters and change the
 * length of the payload) can never be safely corrected and will produce an
 * error.
 *
 * Errors can be corrected in both the prefix and the payload, but attempting to
 * correct errors in the prefix prior to this method can improve results, e.g.
 * for `bchtest:qq2azmyyv6dtgczexyalqar70q036yund53jvfde0x`, the string
 * `bchtest:qq2azmyyv6dtgczexyalqar70q036yund53jvfdecc` can be corrected, while
 * `typo:qq2azmyyv6dtgczexyalqar70q036yund53jvfdecc` can not.
 *
 * @param address - the CashAddress on which to attempt error correction
 */
// Derived from: https://github.com/deadalnix/cashaddressed
// eslint-disable-next-line complexity
var attemptCashAddressFormatErrorCorrection = function attemptCashAddressFormatErrorCorrection(address) {
  var parts = address.toLowerCase().split(':');
  // eslint-disable-next-line @typescript-eslint/no-magic-numbers
  if (parts.length !== 2 || parts[0] === '' || parts[1] === '') {
    return CashAddressDecodingError.invalidFormat;
  }
  var _parts2 = _slicedToArray(parts, 2),
    prefix = _parts2[0],
    payload = _parts2[1];
  if (!isBech32CharacterSet(payload)) {
    return CashAddressDecodingError.invalidCharacters;
  }
  var decodedPayload = decodeBech32(payload);
  var polynomial = [].concat(_toConsumableArray(maskCashAddressPrefix(prefix)), [0], _toConsumableArray(decodedPayload));
  var originalChecksum = cashAddressPolynomialModulo(polynomial);
  if (originalChecksum === 0) {
    return {
      address: cashAddressPolynomialToCashAddress(polynomial),
      corrections: []
    };
  }
  var syndromes = {};
  // eslint-disable-next-line functional/no-let, functional/no-loop-statement, no-plusplus
  for (var term = 0; term < polynomial.length; term++) {
    // eslint-disable-next-line functional/no-loop-statement
    for (
    // eslint-disable-next-line functional/no-let
    var errorVector = 1; errorVector < 32 /* Constants.finiteFieldOrder */;
    // eslint-disable-next-line no-plusplus
    errorVector++) {
      // eslint-disable-next-line functional/no-expression-statement, no-bitwise, functional/immutable-data
      polynomial[term] ^= errorVector;
      var correct = cashAddressPolynomialModulo(polynomial);
      if (correct === 0) {
        return {
          address: cashAddressPolynomialToCashAddress(polynomial),
          corrections: [term]
        };
      }
      // eslint-disable-next-line no-bitwise
      var s0 = (BigInt(correct) ^ BigInt(originalChecksum)).toString();
      // eslint-disable-next-line functional/no-expression-statement, functional/immutable-data
      syndromes[s0] = term * 32 /* Constants.finiteFieldOrder */ + errorVector;
      // eslint-disable-next-line functional/no-expression-statement, no-bitwise, functional/immutable-data
      polynomial[term] ^= errorVector;
    }
  }
  // eslint-disable-next-line functional/no-loop-statement
  for (var _i = 0, _Object$entries = Object.entries(syndromes); _i < _Object$entries.length; _i++) {
    var _Object$entries$_i = _slicedToArray(_Object$entries[_i], 2),
      _s = _Object$entries$_i[0],
      pe = _Object$entries$_i[1];
    // eslint-disable-next-line no-bitwise
    var s1Location = (BigInt(_s) ^ BigInt(originalChecksum)).toString();
    var s1 = syndromes[s1Location];
    if (s1 !== undefined) {
      var correctionIndex1 = Math.trunc(pe / 32 /* Constants.finiteFieldOrder */);
      var correctionIndex2 = Math.trunc(s1 / 32 /* Constants.finiteFieldOrder */);
      // eslint-disable-next-line functional/no-expression-statement, no-bitwise, functional/immutable-data
      polynomial[correctionIndex1] ^= pe % 32 /* Constants.finiteFieldOrder */;
      // eslint-disable-next-line functional/no-expression-statement, no-bitwise, functional/immutable-data
      polynomial[correctionIndex2] ^= s1 % 32 /* Constants.finiteFieldOrder */;
      return {
        address: cashAddressPolynomialToCashAddress(polynomial),
        corrections: [correctionIndex1, correctionIndex2].sort(function (a, b) {
          return a - b;
        })
      };
    }
  }
  return CashAddressCorrectionError.tooManyErrors;
};

/**
 * The most common address types used on bitcoin and bitcoin-like networks. Each
 * address type represents a commonly used locking bytecode pattern.
 *
 * @remarks
 * Addresses are strings that encode information about the network and
 * `lockingBytecode` to which a transaction output can pay.
 *
 * Several address formats exist – `Base58Address` was the format used by the
 * original satoshi client, and is still in use on several active chains (see
 * {@link encodeBase58Address}). On Bitcoin Cash, the `CashAddress` standard is
 * most common (See {@link encodeCashAddress}).
 */
var LockingBytecodeType;
(function (LockingBytecodeType) {
  /**
   * Pay to Public Key (P2PK). This address type is uncommon, and primarily
   * occurs in early blocks because the original satoshi implementation mined
   * rewards to P2PK addresses.
   *
   * There are no standardized address formats for representing a P2PK address.
   * Instead, most applications use the `AddressType.p2pkh` format.
   */
  LockingBytecodeType["p2pk"] = "P2PK";
  /**
   * Pay to Public Key Hash (P2PKH). The most common address type. P2PKH
   * addresses lock funds using a single private key.
   */
  LockingBytecodeType["p2pkh"] = "P2PKH";
  /**
   * 20-byte Pay to Script Hash (P2SH20). An address type that locks funds to
   * the 20-byte hash of a script provided in the spending transaction. See
   * BIPs 13 and 16 for details.
   */
  LockingBytecodeType["p2sh20"] = "P2SH20";
  /**
   * 32-byte Pay to Script Hash (P2SH32). An address type that locks funds to
   * the 32-byte hash of a script provided in the spending transaction.
   */
  LockingBytecodeType["p2sh32"] = "P2SH32";
})(LockingBytecodeType || (LockingBytecodeType = {}));
var isPayToPublicKeyUncompressed = function isPayToPublicKeyUncompressed(lockingBytecode) {
  return lockingBytecode.length === 67 /* PayToPublicKeyUncompressed.length */ && lockingBytecode[0] === 65 /* Opcodes.OP_PUSHBYTES_65 */ && lockingBytecode[66 /* PayToPublicKeyUncompressed.lastElement */] === 172;
} /* Opcodes.OP_CHECKSIG */;
var isPayToPublicKeyCompressed = function isPayToPublicKeyCompressed(lockingBytecode) {
  return lockingBytecode.length === 35 /* PayToPublicKeyCompressed.length */ && lockingBytecode[0] === 33 /* Opcodes.OP_PUSHBYTES_33 */ && lockingBytecode[34 /* PayToPublicKeyCompressed.lastElement */] === 172;
} /* Opcodes.OP_CHECKSIG */;
var isPayToPublicKey = function isPayToPublicKey(lockingBytecode) {
  return isPayToPublicKeyCompressed(lockingBytecode) || isPayToPublicKeyUncompressed(lockingBytecode);
};
// eslint-disable-next-line complexity
var isPayToPublicKeyHash = function isPayToPublicKeyHash(lockingBytecode) {
  return lockingBytecode.length === 25 /* PayToPublicKeyHash.length */ && lockingBytecode[0] === 118 /* Opcodes.OP_DUP */ && lockingBytecode[1] === 169 /* Opcodes.OP_HASH160 */ && lockingBytecode[2] === 20 /* Opcodes.OP_PUSHBYTES_20 */ && lockingBytecode[23] === 136 /* Opcodes.OP_EQUALVERIFY */ && lockingBytecode[24] === 172;
} /* Opcodes.OP_CHECKSIG */;
var isPayToScriptHash20 = function isPayToScriptHash20(lockingBytecode) {
  return lockingBytecode.length === 23 /* PayToScriptHash20.length */ && lockingBytecode[0] === 169 /* Opcodes.OP_HASH160 */ && lockingBytecode[1] === 20 /* Opcodes.OP_PUSHBYTES_20 */ && lockingBytecode[22 /* PayToScriptHash20.lastElement */] === 135;
} /* Opcodes.OP_EQUAL */;
var isPayToScriptHash32 = function isPayToScriptHash32(lockingBytecode) {
  return lockingBytecode.length === 35 /* PayToScriptHash32.length */ && lockingBytecode[0] === 170 /* Opcodes.OP_HASH256 */ && lockingBytecode[1] === 32 /* Opcodes.OP_PUSHBYTES_32 */ && lockingBytecode[34 /* PayToScriptHash32.lastElement */] === 135;
} /* Opcodes.OP_EQUAL */;
/**
 * Attempt to match a lockingBytecode to a standard address type for use in
 * address encoding. (See {@link LockingBytecodeType} for details.)
 *
 * For a locking bytecode matching the Pay to Public Key Hash (P2PKH) pattern,
 * the returned `type` is {@link LockingBytecodeType.p2pkh} and `payload` is the
 * `HASH160` of the public key.
 *
 * For a locking bytecode matching the 20-byte Pay to Script Hash (P2SH20)
 * pattern, the returned `type` is {@link LockingBytecodeType.p2sh20} and
 * `payload` is the `HASH160` of the redeeming bytecode, A.K.A. "redeem
 * script hash".
 *
 * For a locking bytecode matching the Pay to Public Key (P2PK) pattern, the
 * returned `type` is {@link LockingBytecodeType.p2pk} and `payload` is the full
 * public key.
 *
 * Any other locking bytecode will return a `type` of
 * {@link LockingBytecodeType.unknown} and a payload of the
 * unmodified `bytecode`.
 *
 * @param bytecode - the locking bytecode to match
 */
// eslint-disable-next-line complexity
var lockingBytecodeToAddressContents = function lockingBytecodeToAddressContents(bytecode) {
  if (isPayToPublicKeyHash(bytecode)) {
    return {
      payload: bytecode.slice(3 /* AddressPayload.p2pkhStart */, 23 /* AddressPayload.p2pkhEnd */),
      type: LockingBytecodeType.p2pkh
    };
  }
  if (isPayToScriptHash20(bytecode)) {
    return {
      payload: bytecode.slice(2 /* AddressPayload.p2sh20Start */, 22 /* AddressPayload.p2sh20End */),
      type: LockingBytecodeType.p2sh20
    };
  }
  if (isPayToScriptHash32(bytecode)) {
    return {
      payload: bytecode.slice(2 /* AddressPayload.p2sh32Start */, 34 /* AddressPayload.p2sh32End */),
      type: LockingBytecodeType.p2sh32
    };
  }
  if (isPayToPublicKeyUncompressed(bytecode)) {
    return {
      payload: bytecode.slice(1 /* AddressPayload.p2pkUncompressedStart */, 66 /* AddressPayload.p2pkUncompressedEnd */),
      type: LockingBytecodeType.p2pk
    };
  }
  if (isPayToPublicKeyCompressed(bytecode)) {
    return {
      payload: bytecode.slice(1 /* AddressPayload.p2pkCompressedStart */, 34 /* AddressPayload.p2pkCompressedEnd */),
      type: LockingBytecodeType.p2pk
    };
  }
  return {
    payload: bytecode.slice(),
    type: 'unknown'
  };
};
/**
 * Given the 20-byte {@link hash160} of a compressed public key, return a P2PKH
 * locking bytecode:
 * `OP_DUP OP_HASH160 OP_PUSHBYTES_20 publicKeyHash OP_EQUALVERIFY OP_CHECKSIG`.
 *
 * This method does not validate `publicKeyHash` in any way; inputs of incorrect
 * lengths will produce incorrect results.
 *
 * @param publicKeyHash - the 20-byte hash of the compressed public key
 * @returns
 */
var encodeLockingBytecodeP2pkh = function encodeLockingBytecodeP2pkh(publicKeyHash) {
  return Uint8Array.from([118 /* Opcodes.OP_DUP */, 169 /* Opcodes.OP_HASH160 */, 20 /* Opcodes.OP_PUSHBYTES_20 */].concat(_toConsumableArray(publicKeyHash), [136 /* Opcodes.OP_EQUALVERIFY */, 172 /* Opcodes.OP_CHECKSIG */]));
};
/**
 * Given the 20-byte {@link hash160} of a P2SH20 redeem bytecode, encode a
 * P2SH20 locking bytecode:
 * `OP_HASH160 OP_PUSHBYTES_20 redeemBytecodeHash OP_EQUAL`.
 *
 * This method does not validate `p2sh20Hash` in any way; inputs of incorrect
 * lengths will produce incorrect results.
 *
 * @param p2sh20Hash - the 20-byte, p2sh20 redeem bytecode hash
 */
var encodeLockingBytecodeP2sh20 = function encodeLockingBytecodeP2sh20(p2sh20Hash) {
  return Uint8Array.from([169 /* Opcodes.OP_HASH160 */, 20 /* Opcodes.OP_PUSHBYTES_20 */].concat(_toConsumableArray(p2sh20Hash), [135 /* Opcodes.OP_EQUAL */]));
};
/**
 * Given the 32-byte {@link hash256} of a P2SH32 redeem bytecode, encode a
 * P2SH32 locking bytecode:
 * `OP_HASH256 OP_PUSHBYTES_32 redeemBytecodeHash OP_EQUAL`.
 *
 * This method does not validate `p2sh32Hash` in any way; inputs of incorrect
 * lengths will produce incorrect results.
 *
 * @param p2sh32Hash - the 32-byte, p2sh32 redeem bytecode hash
 */
var encodeLockingBytecodeP2sh32 = function encodeLockingBytecodeP2sh32(p2sh32Hash) {
  return Uint8Array.from([170 /* Opcodes.OP_HASH256 */, 32 /* Opcodes.OP_PUSHBYTES_32 */].concat(_toConsumableArray(p2sh32Hash), [135 /* Opcodes.OP_EQUAL */]));
};
/**
 * Given a 33-byte compressed or 65-byte uncompressed public key, encode a P2PK
 * locking bytecode: `OP_PUSHBYTES_33 publicKey OP_CHECKSIG` or
 * `OP_PUSHBYTES_65 publicKey OP_CHECKSIG`.
 *
 * This method does not validate `publicKey` in any way; inputs of incorrect
 * lengths will produce incorrect results.
 *
 * @param publicKey - the 33-byte or 65-byte public key
 */
var encodeLockingBytecodeP2pk = function encodeLockingBytecodeP2pk(publicKey) {
  return publicKey.length === 33 /* AddressPayload.compressedPublicKeyLength */ ? Uint8Array.from([33 /* Opcodes.OP_PUSHBYTES_33 */].concat(_toConsumableArray(publicKey), [172 /* Opcodes.OP_CHECKSIG */])) : Uint8Array.from([65 /* Opcodes.OP_PUSHBYTES_65 */].concat(_toConsumableArray(publicKey), [172 /* Opcodes.OP_CHECKSIG */]));
};
/**
 * Get the locking bytecode for a {@link KnownAddressTypeContents}. See
 * {@link lockingBytecodeToAddressContents} for details.
 *
 * @param addressContents - the `AddressContents` to encode
 */
var addressContentsToLockingBytecode = function addressContentsToLockingBytecode(_ref) {
  var payload = _ref.payload,
    type = _ref.type;
  if (type === LockingBytecodeType.p2pkh) {
    return encodeLockingBytecodeP2pkh(payload);
  }
  if (type === LockingBytecodeType.p2sh20) {
    return encodeLockingBytecodeP2sh20(payload);
  }
  if (type === LockingBytecodeType.p2sh32) {
    return encodeLockingBytecodeP2sh32(payload);
  }
  // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
  if (type === LockingBytecodeType.p2pk) {
    return encodeLockingBytecodeP2pk(payload);
  }
  return unknownValue(type, "Unrecognized addressContents type: ".concat(type));
};
/**
 * Encode a locking bytecode as a CashAddress given a network prefix.
 *
 * If `bytecode` matches a standard pattern, it is encoded using the proper
 * address type and returned as a valid CashAddress (string).
 *
 * If `bytecode` cannot be encoded as an address (i.e. because the pattern is
 * not standard), the resulting {@link AddressContents} is returned.
 *
 * @param bytecode - the locking bytecode to encode
 * @param prefix - the network prefix to use, e.g. `bitcoincash`, `bchtest`, or
 * `bchreg`, defaults to `bitcoincash`
 * @param options - an object describing address options, defaults to
 * `{ tokenSupport: false }`
 */
// eslint-disable-next-line complexity
var lockingBytecodeToCashAddress = function lockingBytecodeToCashAddress(bytecode) {
  var prefix = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'bitcoincash';
  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {
    tokenSupport: false
  };
  var contents = lockingBytecodeToAddressContents(bytecode);
  if (contents.type === LockingBytecodeType.p2pkh) {
    return options.tokenSupport ? encodeCashAddress(prefix, CashAddressType.p2pkhWithTokens, contents.payload) : encodeCashAddress(prefix, CashAddressType.p2pkh, contents.payload);
  }
  if (contents.type === LockingBytecodeType.p2sh20 || contents.type === LockingBytecodeType.p2sh32) {
    return options.tokenSupport ? encodeCashAddress(prefix, CashAddressType.p2shWithTokens, contents.payload) : encodeCashAddress(prefix, CashAddressType.p2sh, contents.payload);
  }
  if (contents.type === 'P2PK') {
    return {
      error: CashAddressEncodingError.noTypeBitsValueStandardizedForP2pk
    };
  }
  // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
  if (contents.type === 'unknown') {
    return {
      error: CashAddressEncodingError.unknownLockingBytecodeType
    };
  }
  return unknownValue(contents.type, "Unrecognized locking bytecode type: ".concat(contents.type));
};
var LockingBytecodeGenerationError;
(function (LockingBytecodeGenerationError) {
  LockingBytecodeGenerationError["unsupportedPayloadLength"] = "Error generating locking bytecode: no standard locking bytecode patterns support a payload of this length.";
})(LockingBytecodeGenerationError || (LockingBytecodeGenerationError = {}));
/**
 * Convert a CashAddress to its respective locking bytecode.
 *
 * This method returns the locking bytecode and network prefix. If an error
 * occurs, an error message is returned as a string.
 *
 * @param address - the CashAddress to convert
 */
// eslint-disable-next-line complexity
var cashAddressToLockingBytecode = function cashAddressToLockingBytecode(address) {
  var decoded = decodeCashAddress$1(address);
  if (typeof decoded === 'string') return decoded;
  if (decoded.payload.length !== 20 /* AddressPayload.p2sh20Length */ && decoded.payload.length !== 32 /* AddressPayload.p2sh32Length */) {
    return formatError$1(LockingBytecodeGenerationError.unsupportedPayloadLength, "Payload length: ".concat(decoded.payload.length));
  }
  if (decoded.type === CashAddressType.p2pkh || decoded.type === CashAddressType.p2pkhWithTokens) {
    return {
      bytecode: addressContentsToLockingBytecode({
        payload: decoded.payload,
        type: LockingBytecodeType.p2pkh
      }),
      options: {
        tokenSupport: decoded.type === CashAddressType.p2pkhWithTokens
      },
      prefix: decoded.prefix
    };
  }
  if (decoded.type === CashAddressType.p2sh ||
  // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
  decoded.type === CashAddressType.p2shWithTokens) {
    return {
      bytecode: addressContentsToLockingBytecode({
        payload: decoded.payload,
        type: decoded.payload.length === 32 /* AddressPayload.p2sh32Length */ ? LockingBytecodeType.p2sh32 : LockingBytecodeType.p2sh20
      }),
      options: {
        tokenSupport: decoded.type === CashAddressType.p2shWithTokens
      },
      prefix: decoded.prefix
    };
  }
  return unknownValue(decoded.type, "Unrecognized address type: ".concat(decoded.type));
};
/**
 * Encode a locking bytecode as a Base58Address for a given network.
 *
 * If `bytecode` matches a standard pattern, it is encoded using the proper
 * address type and returned as a valid Base58Address (string).
 *
 * If `bytecode` cannot be encoded as an address (i.e. because the pattern is
 * not standard), the resulting {@link AddressContents} is returned.
 *
 * Note, Base58Addresses cannot accept tokens; to accept tokens,
 * use {@link lockingBytecodeToCashAddress} with `options.tokenSupport` set
 * to `true`.
 *
 * @param bytecode - the locking bytecode to encode
 * @param network - the network for which to encode the address (`mainnet`,
 * `testnet`, or 'copayBCH'), defaults to `mainnet`
 * @param sha256 - an implementation of sha256 (defaults to the internal WASM
 * implementation)
 */
var lockingBytecodeToBase58Address = function lockingBytecodeToBase58Address(bytecode) {
  var network = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'mainnet';
  var sha256 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : sha256$1;
  var contents = lockingBytecodeToAddressContents(bytecode);
  if (contents.type === LockingBytecodeType.p2pkh) {
    return encodeBase58AddressFormat({
      copayBCH: Base58AddressFormatVersion.p2pkhCopayBCH,
      mainnet: Base58AddressFormatVersion.p2pkh,
      testnet: Base58AddressFormatVersion.p2pkhTestnet
    }[network], contents.payload, sha256);
  }
  if (contents.type === LockingBytecodeType.p2sh20) {
    return encodeBase58AddressFormat({
      copayBCH: Base58AddressFormatVersion.p2sh20CopayBCH,
      mainnet: Base58AddressFormatVersion.p2sh20,
      testnet: Base58AddressFormatVersion.p2sh20Testnet
    }[network], contents.payload, sha256);
  }
  return contents;
};
/**
 * Convert a Base58Address to its respective locking bytecode.
 *
 * This method returns the locking bytecode and network version. If an error
 * occurs, an error message is returned as a string.
 *
 * @param address - the CashAddress to convert
 */
var base58AddressToLockingBytecode = function base58AddressToLockingBytecode(address) {
  var sha256 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : sha256$1;
  var decoded = decodeBase58Address$1(address, sha256);
  if (typeof decoded === 'string') return decoded;
  return {
    bytecode: addressContentsToLockingBytecode({
      payload: decoded.payload,
      type: [Base58AddressFormatVersion.p2pkh, Base58AddressFormatVersion.p2pkhCopayBCH, Base58AddressFormatVersion.p2pkhTestnet].includes(decoded.version) ? LockingBytecodeType.p2pkh : LockingBytecodeType.p2sh20
    }),
    version: decoded.version
  };
};

/**
 * Verify that a private key is valid for the Secp256k1 curve. Returns `true`
 * for success, or `false` on failure.
 *
 * Private keys are 256-bit numbers encoded as a 32-byte, big-endian Uint8Array.
 * Nearly every 256-bit number is a valid secp256k1 private key. Specifically,
 * any 256-bit number greater than `0x01` and less than
 * `0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364140`
 * is a valid private key. This range is part of the definition of the
 * secp256k1 elliptic curve parameters.
 *
 * This method does not require a `Secp256k1` implementation.
 */
var validateSecp256k1PrivateKey = function validateSecp256k1PrivateKey(privateKey) {
  var privateKeyLength = 32;
  if (privateKey.length !== privateKeyLength || privateKey.every(function (value) {
    return value === 0;
  })) {
    return false;
  }
  /**
   * The largest possible Secp256k1 private key – equal to the order of the
   * Secp256k1 curve minus one.
   */
  // prettier-ignore
  var maximumSecp256k1PrivateKey = [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 254, 186, 174, 220, 230, 175, 72, 160, 59, 191, 210, 94, 140, 208, 54, 65, 63]; // eslint-disable-line @typescript-eslint/no-magic-numbers
  var firstDifference = privateKey.findIndex(function (value, i) {
    return value !== maximumSecp256k1PrivateKey[i];
  });
  if (firstDifference === -1 ||
  // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
  privateKey[firstDifference] < maximumSecp256k1PrivateKey[firstDifference]) {
    return true;
  }
  return false;
};
/**
 * Securely generate a valid Secp256k1 private key given a secure source of
 * randomness.
 *
 * **Node.js Usage**
 * ```ts
 * import { randomBytes } from 'crypto';
 * import { generatePrivateKey } from '@bitauth/libauth';
 *
 * const key = generatePrivateKey(() => randomBytes(32));
 * ```
 *
 * **Browser Usage**
 * ```ts
 * import { generatePrivateKey } from '@bitauth/libauth';
 *
 * const key = generatePrivateKey(() =>
 *   window.crypto.getRandomValues(new Uint8Array(32))
 * );
 * ```
 *
 * @param secureRandom - a method that returns a securely-random 32-byte
 * Uint8Array
 */
var generatePrivateKey = function generatePrivateKey(secureRandom) {
  // eslint-disable-next-line functional/no-let, @typescript-eslint/init-declarations
  var maybeKey;
  // eslint-disable-next-line functional/no-loop-statement
  do {
    // eslint-disable-next-line functional/no-expression-statement
    maybeKey = secureRandom();
  } while (!validateSecp256k1PrivateKey(maybeKey));
  return maybeKey;
};

/**
 * The HMAC SHA-512 key used by BIP32, "Bitcoin seed"
 * (`utf8ToBin('Bitcoin seed')`)
 */
var bip32HmacSha512Key = Uint8Array.from([
// eslint-disable-next-line @typescript-eslint/no-magic-numbers
66, 105, 116, 99, 111, 105, 110, 32, 115, 101, 101, 100]);
var halfHmacSha512Length = 32;
/**
 * Derive an {@link HdPrivateNode} from the provided seed following the BIP32
 * specification. A seed should include between 16 bytes and 64 bytes of
 * entropy (recommended: 32 bytes).
 *
 * @param seed - the entropy from which to derive the {@link HdPrivateNode}
 * @param assumeValidity - if set, the derived private key will not be checked
 * for validity, and will be assumed valid if `true` or invalid if `false` (this
 * is useful for testing)
 * @param crypto - an optional object containing an implementation of sha512
 * to use
 */
var deriveHdPrivateNodeFromSeed = function deriveHdPrivateNodeFromSeed(seed, assumeValidity) {
  var crypto = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {
    sha512: sha512$1
  };
  var mac = hmacSha512(bip32HmacSha512Key, seed, crypto.sha512);
  var privateKey = mac.slice(0, halfHmacSha512Length);
  var chainCode = mac.slice(halfHmacSha512Length);
  var depth = 0;
  var childIndex = 0;
  var parentFingerprint = Uint8Array.from([0, 0, 0, 0]);
  var valid = assumeValidity !== null && assumeValidity !== void 0 ? assumeValidity : validateSecp256k1PrivateKey(privateKey);
  return valid ? {
    chainCode: chainCode,
    childIndex: childIndex,
    depth: depth,
    parentFingerprint: parentFingerprint,
    privateKey: privateKey,
    valid: valid
  } : {
    chainCode: chainCode,
    childIndex: childIndex,
    depth: depth,
    invalidPrivateKey: privateKey,
    parentFingerprint: parentFingerprint,
    valid: valid
  };
};
/**
 * Derive the public identifier for a given {@link HdPrivateNode}. This is used
 * to uniquely identify HD nodes in software. The first 4 bytes of this
 * identifier are considered its "fingerprint".
 *
 * @param hdPrivateNode - the {@link HdPrivateNode} from which to derive the
 * public identifier (not require to be valid)
 * @param crypto - an optional object containing implementations implementations
 * of sha256, ripemd160, and secp256k1 compressed public key derivation to use
 */
var deriveHdPrivateNodeIdentifier = function deriveHdPrivateNodeIdentifier(hdPrivateNode) {
  var crypto = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {
    ripemd160: ripemd160$1,
    secp256k1: secp256k1,
    sha256: sha256$1
  };
  var publicKey = crypto.secp256k1.derivePublicKeyCompressed(hdPrivateNode.privateKey);
  if (typeof publicKey === 'string') return publicKey;
  return crypto.ripemd160.hash(crypto.sha256.hash(publicKey));
};
/**
 * Derive the public identifier for a given {@link HdPublicNode}. This is used
 * to uniquely identify HD nodes in software. The first 4 bytes of this
 * identifier are considered its fingerprint.
 *
 * @param node - the {@link HdPublicNode} from which to derive the identifier
 * @param crypto - an optional object containing implementations of sha256 and
 * ripemd160 to use
 */
var deriveHdPublicNodeIdentifier = function deriveHdPublicNodeIdentifier(node) {
  var crypto = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {
    ripemd160: ripemd160$1,
    sha256: sha256$1
  };
  return crypto.ripemd160.hash(crypto.sha256.hash(node.publicKey));
};
/**
 * The 4-byte version indicating the network and type of an {@link HdPrivateKey}
 * or {@link HdPublicKey}.
 */
var HdKeyVersion;
(function (HdKeyVersion) {
  /**
   * Version indicating the HD key is an {@link HdPrivateKey} intended for use
   * on the main network. Base58 encoding at the expected length of an HD key
   * results in a prefix of `xprv`.
   *
   * Hex: `0x0488ade4`
   */
  HdKeyVersion[HdKeyVersion["mainnetPrivateKey"] = 76066276] = "mainnetPrivateKey";
  /**
   * Version indicating the HD key is an {@link HdPrivateKey} intended for use
   * on the main network. Base58 encoding at the expected length of an HD key
   * results in a prefix of `xpub`.
   *
   * Hex: `0x0488b21e`
   */
  HdKeyVersion[HdKeyVersion["mainnetPublicKey"] = 76067358] = "mainnetPublicKey";
  /**
   * Version indicating the HD key is an {@link HdPrivateKey} intended for use
   * on the test network. Base58 encoding at the expected length of an HD key
   * results in a prefix of `tprv`.
   *
   * Hex: `0x04358394`
   */
  HdKeyVersion[HdKeyVersion["testnetPrivateKey"] = 70615956] = "testnetPrivateKey";
  /**
   * Version indicating the HD key is an {@link HdPrivateKey} intended for use
   * on the test network. Base58 encoding at the expected length of an HD key
   * results in a prefix of `tpub`.
   *
   * Hex: `0x043587cf`
   */
  HdKeyVersion[HdKeyVersion["testnetPublicKey"] = 70617039] = "testnetPublicKey";
})(HdKeyVersion || (HdKeyVersion = {}));
/**
 * An error in the decoding of an HD public or private key.
 */
var HdKeyDecodingError;
(function (HdKeyDecodingError) {
  HdKeyDecodingError["incorrectLength"] = "HD key decoding error: length is incorrect (must encode 82 bytes).";
  HdKeyDecodingError["invalidChecksum"] = "HD key decoding error: checksum is invalid.";
  HdKeyDecodingError["invalidPrivateNode"] = "HD key decoding error: the key for this HD private node is not a valid Secp256k1 private key.";
  HdKeyDecodingError["missingPrivateKeyPaddingByte"] = "HD key decoding error: version indicates a private key, but the key data is missing a padding byte.";
  HdKeyDecodingError["privateKeyExpected"] = "HD key decoding error: expected an HD private key, but encountered an HD public key.";
  HdKeyDecodingError["publicKeyExpected"] = "HD key decoding error: expected an HD public key, but encountered an HD private key.";
  HdKeyDecodingError["unknownCharacter"] = "HD key decoding error: key includes a non-base58 character.";
  HdKeyDecodingError["unknownVersion"] = "HD key decoding error: key uses an unknown version.";
})(HdKeyDecodingError || (HdKeyDecodingError = {}));
/**
 * Decode an HD private key as defined by BIP32, returning a `node` and a
 * `network`. Decoding errors are returned as strings.
 *
 * If the type of the key is known, use {@link decodeHdPrivateKey} or
 * {@link decodeHdPublicKey}.
 *
 * @param hdKey - a BIP32 HD private key or HD public key
 * @param crypto -  an optional object containing an implementation of sha256
 * to use
 */
// eslint-disable-next-line complexity
var decodeHdKey = function decodeHdKey(hdKey) {
  var crypto = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {
    sha256: sha256$1
  };
  var decoded = base58ToBin(hdKey);
  if (decoded === BaseConversionError.unknownCharacter) return HdKeyDecodingError.unknownCharacter;
  var expectedLength = 82;
  if (decoded.length !== expectedLength) return HdKeyDecodingError.incorrectLength;
  var checksumIndex = 78;
  var payload = decoded.slice(0, checksumIndex);
  var checksumBits = decoded.slice(checksumIndex);
  var checksum = crypto.sha256.hash(crypto.sha256.hash(payload));
  if (!checksumBits.every(function (value, i) {
    return value === checksum[i];
  })) {
    return HdKeyDecodingError.invalidChecksum;
  }
  var depthIndex = 4;
  var fingerprintIndex = 5;
  var childIndexIndex = 9;
  var chainCodeIndex = 13;
  var keyDataIndex = 45;
  var version = new DataView(decoded.buffer, decoded.byteOffset, depthIndex).getUint32(0);
  var depth = decoded[depthIndex];
  var parentFingerprint = decoded.slice(fingerprintIndex, childIndexIndex);
  var childIndex = new DataView(decoded.buffer, decoded.byteOffset + childIndexIndex, decoded.byteOffset + chainCodeIndex).getUint32(0);
  var chainCode = decoded.slice(chainCodeIndex, keyDataIndex);
  var keyData = decoded.slice(keyDataIndex, checksumIndex);
  var isPrivateKey = version === HdKeyVersion.mainnetPrivateKey || version === HdKeyVersion.testnetPrivateKey;
  if (isPrivateKey && keyData[0] !== 0x00) {
    return HdKeyDecodingError.missingPrivateKeyPaddingByte;
  }
  if (isPrivateKey) {
    var privateKey = keyData.slice(1);
    var valid = validateSecp256k1PrivateKey(privateKey);
    return {
      node: valid ? {
        chainCode: chainCode,
        childIndex: childIndex,
        depth: depth,
        parentFingerprint: parentFingerprint,
        privateKey: privateKey,
        valid: true
      } : {
        chainCode: chainCode,
        childIndex: childIndex,
        depth: depth,
        invalidPrivateKey: privateKey,
        parentFingerprint: parentFingerprint,
        valid: false
      },
      version: version
    };
  }
  var isPublicKey = version === HdKeyVersion.mainnetPublicKey || version === HdKeyVersion.testnetPublicKey;
  if (!isPublicKey) {
    return HdKeyDecodingError.unknownVersion;
  }
  return {
    node: {
      chainCode: chainCode,
      childIndex: childIndex,
      depth: depth,
      parentFingerprint: parentFingerprint,
      publicKey: keyData
    },
    version: version
  };
};
/**
 * Decode an HD private key as defined by BIP32.
 *
 * This method is similar to {@link decodeHdKey} but ensures that the result is
 * a valid HD private node. Decoding error messages are returned as strings.
 *
 * @param hdPrivateKey - a BIP32 HD private key
 * @param crypto -  an optional object containing an implementation of sha256
 * to use
 */
var decodeHdPrivateKey = function decodeHdPrivateKey(hdPrivateKey) {
  var crypto = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {
    sha256: sha256$1
  };
  var decoded = decodeHdKey(hdPrivateKey, crypto);
  if (typeof decoded === 'string') return decoded;
  if ('publicKey' in decoded.node) {
    return HdKeyDecodingError.privateKeyExpected;
  }
  if (!decoded.node.valid) {
    return HdKeyDecodingError.invalidPrivateNode;
  }
  if (decoded.version === HdKeyVersion.mainnetPrivateKey) {
    return {
      network: 'mainnet',
      node: decoded.node
    };
  }
  return {
    network: 'testnet',
    node: decoded.node
  };
};
/**
 * Decode an HD public key as defined by BIP32.
 *
 * This method is similar to {@link decodeHdKey} but ensures that the result is
 * an HD public node. Decoding error messages are returned as strings.
 *
 * @param hdPublicKey - a BIP32 HD public key
 * @param crypto - an optional object containing an implementation of sha256
 * to use
 */
var decodeHdPublicKey = function decodeHdPublicKey(hdPublicKey) {
  var crypto = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {
    sha256: sha256$1
  };
  var decoded = decodeHdKey(hdPublicKey, crypto);
  if (typeof decoded === 'string') return decoded;
  if (decoded.version === HdKeyVersion.mainnetPublicKey) {
    return {
      network: 'mainnet',
      node: decoded.node
    };
  }
  if (decoded.version === HdKeyVersion.testnetPublicKey) {
    return {
      network: 'testnet',
      node: decoded.node
    };
  }
  return HdKeyDecodingError.publicKeyExpected;
};
/**
 * Decode the provided HD private key and compute its identifier. Error messages
 * are returned as a string.
 */
var hdPrivateKeyToIdentifier = function hdPrivateKeyToIdentifier(hdPrivateKey) {
  var crypto = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {
    sha256: sha256$1
  };
  var privateKeyParams = decodeHdPrivateKey(hdPrivateKey, crypto);
  if (typeof privateKeyParams === 'string') {
    return privateKeyParams;
  }
  return deriveHdPrivateNodeIdentifier(privateKeyParams.node);
};
/**
 * Decode the provided HD public key and compute its identifier. Error messages
 * are returned as a string.
 */
var hdPublicKeyToIdentifier = function hdPublicKeyToIdentifier(hdPublicKey) {
  var crypto = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {
    sha256: sha256$1
  };
  var publicKeyParams = decodeHdPublicKey(hdPublicKey, crypto);
  if (typeof publicKeyParams === 'string') {
    return publicKeyParams;
  }
  return deriveHdPublicNodeIdentifier(publicKeyParams.node);
};
/**
 * Encode an HD private key (as defined by BIP32) given a valid
 * {@link HdPrivateNode} and network.
 *
 * @param keyParameters - a valid HD private node and the network for which to
 * encode the key
 * @param crypto - an optional object containing an implementation of sha256
 * to use
 */
var encodeHdPrivateKey = function encodeHdPrivateKey(keyParameters) {
  var crypto = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {
    sha256: sha256$1
  };
  var version = numberToBinUint32BE(keyParameters.network === 'mainnet' ? HdKeyVersion.mainnetPrivateKey : HdKeyVersion.testnetPrivateKey);
  var depth = Uint8Array.of(keyParameters.node.depth);
  var childIndex = numberToBinUint32BE(keyParameters.node.childIndex);
  var isPrivateKey = Uint8Array.of(0x00);
  var payload = flattenBinArray([version, depth, keyParameters.node.parentFingerprint, childIndex, keyParameters.node.chainCode, isPrivateKey, keyParameters.node.privateKey]);
  var checksumLength = 4;
  var checksum = crypto.sha256.hash(crypto.sha256.hash(payload)).slice(0, checksumLength);
  return binToBase58(flattenBinArray([payload, checksum]));
};
/**
 * Encode an HD public key (as defined by BIP32) given an HD public node.
 *
 * @param keyParameters - an HD public node and the network for which to encode
 * the key
 * @param crypto - an optional object containing an implementation of sha256
 * to use
 */
var encodeHdPublicKey = function encodeHdPublicKey(keyParameters) {
  var crypto = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {
    sha256: sha256$1
  };
  var version = numberToBinUint32BE(keyParameters.network === 'mainnet' ? HdKeyVersion.mainnetPublicKey : HdKeyVersion.testnetPublicKey);
  var depth = Uint8Array.of(keyParameters.node.depth);
  var childIndex = numberToBinUint32BE(keyParameters.node.childIndex);
  var payload = flattenBinArray([version, depth, keyParameters.node.parentFingerprint, childIndex, keyParameters.node.chainCode, keyParameters.node.publicKey]);
  var checksumLength = 4;
  var checksum = crypto.sha256.hash(crypto.sha256.hash(payload)).slice(0, checksumLength);
  return binToBase58(flattenBinArray([payload, checksum]));
};
/**
 * Derive the HD public node of an HD private node.
 *
 * Though private keys cannot be derived from HD public keys, sharing HD public
 * keys still carries risk. Along with allowing an attacker to associate wallet
 * addresses together (breaking privacy), should an attacker gain knowledge of a
 * single child private key, **it's possible to derive all parent HD private
 * keys**. See {@link crackHdPrivateNodeFromHdPublicNodeAndChildPrivateNode} for
 * details.
 *
 * @param node - a valid HD private node
 * @param crypto - an optional object containing an implementation of secp256k1
 * compressed public key derivation to use
 */
var deriveHdPublicNode = function deriveHdPublicNode(node) {
  var crypto = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {
    secp256k1: secp256k1
  };
  return _objectSpread2(_objectSpread2({
    chainCode: node.chainCode,
    childIndex: node.childIndex,
    depth: node.depth,
    parentFingerprint: node.parentFingerprint
  }, node.parentIdentifier === undefined ? {} : {
    parentIdentifier: node.parentIdentifier
  }), {}, {
    publicKey: crypto.secp256k1.derivePublicKeyCompressed(node.privateKey)
  });
};
/**
 * An error in the derivation of child HD public or private nodes.
 */
var HdNodeDerivationError;
(function (HdNodeDerivationError) {
  HdNodeDerivationError["childIndexExceedsMaximum"] = "HD key derivation error: child index exceeds maximum (4294967295).";
  HdNodeDerivationError["nextChildIndexRequiresHardenedAlgorithm"] = "HD key derivation error: an incredibly rare HMAC-SHA512 result occurred, and incrementing the child index would require switching to the hardened algorithm.";
  HdNodeDerivationError["hardenedDerivationRequiresPrivateNode"] = "HD key derivation error: derivation for hardened child indexes (indexes greater than or equal to 2147483648) requires an HD private node.";
  HdNodeDerivationError["invalidDerivationPath"] = "HD key derivation error: invalid derivation path - paths must begin with \"m\" or \"M\" and contain only forward slashes (\"/\"), apostrophes (\"'\"), or positive child index numbers.";
  HdNodeDerivationError["invalidPrivateDerivationPrefix"] = "HD key derivation error: private derivation paths must begin with \"m\".";
  HdNodeDerivationError["invalidPublicDerivationPrefix"] = "HD key derivation error: public derivation paths must begin with \"M\".";
})(HdNodeDerivationError || (HdNodeDerivationError = {}));
/**
 * Derive a child HD private node from an HD private node.
 *
 * To derive a child HD public node, use {@link deriveHdPublicNode} on the
 * result of this method. If the child uses a non-hardened index, it's also
 * possible to use {@link deriveHdPublicNodeChild}.
 *
 * @privateRemarks
 * The {@link Secp256k1.addTweakPrivateKey} method throws if the tweak is out of
 * range or if the resulting private key would be invalid. The procedure to
 * handle this error is standardized by BIP32: return the HD node at the next
 * child index. (Regardless, this scenario is incredibly unlikely without a
 * weakness in HMAC-SHA512.)
 *
 * @param node - the valid HD private node from which to derive the child node
 * @param index - the index at which to derive the child node - indexes greater
 * than or equal to the hardened index offset (`0x80000000`/`2147483648`) are
 * derived using the "hardened" derivation algorithm
 * @param crypto - an optional object containing implementations of sha256,
 * ripemd160, secp256k1 compressed public key derivation, and secp256k1 private
 * key "tweak addition" (application of the EC group operation)
 */
// eslint-disable-next-line complexity
var deriveHdPrivateNodeChild = function deriveHdPrivateNodeChild(node, index) {
  var crypto = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {
    ripemd160: ripemd160$1,
    secp256k1: secp256k1,
    sha256: sha256$1,
    sha512: sha512$1
  };
  var maximumIndex = 0xffffffff;
  if (index > maximumIndex) {
    return HdNodeDerivationError.childIndexExceedsMaximum;
  }
  var hardenedIndexOffset = 0x80000000;
  var useHardenedAlgorithm = index >= hardenedIndexOffset;
  var keyMaterial = useHardenedAlgorithm ? node.privateKey : crypto.secp256k1.derivePublicKeyCompressed(node.privateKey);
  var serialization = Uint8Array.from([].concat(_toConsumableArray(useHardenedAlgorithm ? [0x00] : []), _toConsumableArray(keyMaterial), _toConsumableArray(numberToBinUint32BE(index))));
  var derivation = hmacSha512(node.chainCode, serialization, crypto.sha512);
  var tweakValueLength = 32;
  var tweakValue = derivation.slice(0, tweakValueLength);
  var nextChainCode = derivation.slice(tweakValueLength);
  var nextPrivateKey = crypto.secp256k1.addTweakPrivateKey(node.privateKey, tweakValue);
  if (typeof nextPrivateKey === 'string') {
    if (index === hardenedIndexOffset - 1) {
      return HdNodeDerivationError.nextChildIndexRequiresHardenedAlgorithm;
    }
    return deriveHdPrivateNodeChild(node, index + 1, crypto);
  }
  var parentIdentifier = deriveHdPrivateNodeIdentifier(node, crypto);
  var parentFingerprintLength = 4;
  return {
    chainCode: nextChainCode,
    childIndex: index,
    depth: node.depth + 1,
    parentFingerprint: parentIdentifier.slice(0, parentFingerprintLength),
    parentIdentifier: parentIdentifier,
    privateKey: nextPrivateKey,
    valid: true
  };
};
/**
 * Derive a non-hardened child HD public node from an HD public node.
 *
 * Because hardened derivation also requires knowledge of the parent private
 * node, it's not possible to use an HD public node to derive a hardened child
 * HD public node.
 *
 * Though private keys cannot be derived from HD public keys, sharing HD public
 * keys still carries risk. Along with allowing an attacker to associate wallet
 * addresses together (breaking privacy), should an attacker gain knowledge of a
 * single child private key, **it's possible to derive all parent HD private
 * keys**. See {@link crackHdPrivateNodeFromHdPublicNodeAndChildPrivateNode}
 * for details.
 *
 * @privateRemarks
 * The {@link secp256k1.addTweakPublicKeyCompressed} method returns an error as
 * a string if the tweak is out of range or if the resulting public key would be
 * invalid. The procedure to handle this error is standardized by BIP32: return
 * the HD node at the next child index. (Regardless, this scenario is incredibly
 * unlikely without a weakness in HMAC-SHA512.)
 *
 * @param node - the HD public node from which to derive the child public node
 * @param index - the index at which to derive the child node
 * @param crypto - an optional object containing implementations of sha256,
 * sha512, ripemd160, and secp256k1 compressed public key "tweak addition"
 * (application of the EC group operation)
 */
var deriveHdPublicNodeChild = function deriveHdPublicNodeChild(node, index) {
  var crypto = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {
    ripemd160: ripemd160$1,
    secp256k1: secp256k1,
    sha256: sha256$1,
    sha512: sha512$1
  };
  var hardenedIndexOffset = 0x80000000;
  if (index >= hardenedIndexOffset) {
    return HdNodeDerivationError.hardenedDerivationRequiresPrivateNode;
  }
  var serialization = Uint8Array.from([].concat(_toConsumableArray(node.publicKey), _toConsumableArray(numberToBinUint32BE(index))));
  var derivation = hmacSha512(node.chainCode, serialization, crypto.sha512);
  var tweakValueLength = 32;
  var tweakValue = derivation.slice(0, tweakValueLength);
  var nextChainCode = derivation.slice(tweakValueLength);
  var nextPublicKey = crypto.secp256k1.addTweakPublicKeyCompressed(node.publicKey, tweakValue);
  if (typeof nextPublicKey === 'string') {
    if (index === hardenedIndexOffset - 1) {
      return HdNodeDerivationError.nextChildIndexRequiresHardenedAlgorithm;
    }
    return deriveHdPublicNodeChild(node, index + 1, crypto);
  }
  var parentIdentifier = deriveHdPublicNodeIdentifier(node, crypto);
  var parentFingerprintLength = 4;
  return {
    chainCode: nextChainCode,
    childIndex: index,
    depth: node.depth + 1,
    parentFingerprint: parentIdentifier.slice(0, parentFingerprintLength),
    parentIdentifier: parentIdentifier,
    publicKey: nextPublicKey
  };
};
/**
 * Derive a child HD node from a parent node given a derivation path. The
 * resulting node is the same type as the parent node (private nodes return
 * private nodes, public nodes return public nodes).
 *
 * @remarks
 * The derivation path uses the notation specified in BIP32:
 *
 * The first character must be either `m` for private derivation or `M` for
 * public derivation, followed by sets of `/` and a number representing the
 * child index used in the derivation at that depth. Hardened derivation is
 * represented by a trailing `'`, and may only appear in private derivation
 * paths (hardened derivation requires knowledge of the private key). Hardened
 * child indexes are represented with the hardened index offset (`2147483648`)
 * subtracted.
 *
 * For example, `m/0/1'/2` uses private derivation (`m`), with child indexes in
 * the following order:
 *
 * `derivePrivate(derivePrivate(derivePrivate(node, 0), 2147483648 + 1), 2)`
 *
 * Likewise, `M/3/4/5` uses public derivation (`M`), with child indexes in the
 * following order:
 *
 * `derivePublic(derivePublic(derivePublic(node, 3), 4), 5)`
 *
 * Because hardened derivation requires a private node, paths that specify
 * public derivation (`M`) using hardened derivation (`'`) will return an error.
 * To derive the public node associated with a child private node that requires
 * hardened derivation, begin with private derivation, then provide the result
 * to `deriveHdPublicNode`.
 *
 * @param node - the HD node from which to begin the derivation (for paths
 * beginning with `m`, an {@link HdPrivateNodeValid}; for paths beginning with
 * `M`, an {@link HdPublicNode})
 * @param path - the BIP32 derivation path, e.g. `m/0/1'/2` or `M/3/4/5`
 * @param crypto - an optional object containing implementations of sha256,
 * sha512, ripemd160, and secp256k1 derivation functions
 */
// eslint-disable-next-line complexity
var deriveHdPath = function deriveHdPath(node, path) {
  var crypto = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {
    ripemd160: ripemd160$1,
    secp256k1: secp256k1,
    sha256: sha256$1,
    sha512: sha512$1
  };
  var validDerivationPath = /^[Mm](?:\/[0-9]+'?)*$/;
  if (!validDerivationPath.test(path)) {
    return HdNodeDerivationError.invalidDerivationPath;
  }
  var parsed = path.split('/');
  var isPrivateDerivation = ('privateKey' in node);
  if (isPrivateDerivation && parsed[0] !== 'm') {
    return HdNodeDerivationError.invalidPrivateDerivationPrefix;
  }
  if (!isPrivateDerivation && parsed[0] !== 'M') {
    return HdNodeDerivationError.invalidPublicDerivationPrefix;
  }
  var base = 10;
  var hardenedIndexOffset = 0x80000000;
  var indexes = parsed.slice(1).map(function (index) {
    return index.endsWith("'") ? parseInt(index.slice(0, -1), base) + hardenedIndexOffset : parseInt(index, base);
  });
  return isPrivateDerivation ? indexes.reduce(function (result, nextIndex) {
    return typeof result === 'string' ? result : deriveHdPrivateNodeChild(result, nextIndex, crypto);
  }, node // eslint-disable-line @typescript-eslint/prefer-reduce-type-parameter
  ) : indexes.reduce(function (result, nextIndex) {
    return typeof result === 'string' ? result : deriveHdPublicNodeChild(result, nextIndex, crypto);
  }, node // eslint-disable-line @typescript-eslint/prefer-reduce-type-parameter
  );
};

var HdNodeCrackingError;
(function (HdNodeCrackingError) {
  HdNodeCrackingError["cannotCrackHardenedDerivation"] = "HD node cracking error: cannot crack an HD parent node using hardened child node.";
})(HdNodeCrackingError || (HdNodeCrackingError = {}));
/**
 * Derive the HD private node from a HD public node, given any non-hardened
 * child private node.
 *
 * @remarks
 * This exploits the "non-hardened" BIP32 derivation algorithm. Because
 * non-hardened derivation only requires knowledge of the "chain code" (rather
 * than requiring knowledge of the parent private key) it's possible to
 * calculate the value by which the parent private key is "tweaked" to arrive at
 * the child private key. Since we have the child private key, we simply
 * subtract this "tweaked" amount to get back to the parent private key.
 *
 * The BIP32 "hardened" derivation algorithm is designed to address this
 * weakness. Using hardened derivation, child private nodes can be shared
 * without risk of leaking the parent private node, but this comes at the cost
 * of public node derivation. Given only a parent public node, it is not
 * possible to derive hardened child public keys, so applications must choose
 * between support for HD public node derivation or support for sharing child
 * private nodes.
 *
 * @param parentPublicNode - the parent HD public node for which to derive a
 * private node
 * @param childPrivateNode - any non-hardened child private node of the parent
 * node (only the `privateKey` and the `childIndex` are required)
 * * @param crypto - an optional object containing an implementation of sha512
 */
var crackHdPrivateNodeFromHdPublicNodeAndChildPrivateNode = function crackHdPrivateNodeFromHdPublicNodeAndChildPrivateNode(parentPublicNode, childPrivateNode) {
  var crypto = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {
    sha512: sha512$1
  };
  var hardenedIndexOffset = 0x80000000;
  if (childPrivateNode.childIndex >= hardenedIndexOffset) {
    return HdNodeCrackingError.cannotCrackHardenedDerivation;
  }
  var serialization = Uint8Array.from([].concat(_toConsumableArray(parentPublicNode.publicKey), _toConsumableArray(numberToBinUint32BE(childPrivateNode.childIndex))));
  var derivation = hmacSha512(parentPublicNode.chainCode, serialization, crypto.sha512);
  var tweakValueLength = 32;
  var tweakValue = binToBigIntUint256BE(derivation.slice(0, tweakValueLength));
  var childPrivateValue = binToBigIntUint256BE(childPrivateNode.privateKey);
  var secp256k1OrderN = 0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141n;
  var trueMod = function trueMod(n, m) {
    return (n % m + m) % m;
  };
  var parentPrivateValue = trueMod(childPrivateValue - tweakValue, secp256k1OrderN);
  var privateKey = bigIntToBinUint256BEClamped(parentPrivateValue);
  return _objectSpread2(_objectSpread2({
    chainCode: parentPublicNode.chainCode,
    childIndex: parentPublicNode.childIndex,
    depth: parentPublicNode.depth,
    parentFingerprint: parentPublicNode.parentFingerprint
  }, parentPublicNode.parentIdentifier === undefined ? {} : {
    parentIdentifier: parentPublicNode.parentIdentifier
  }), {}, {
    privateKey: privateKey,
    valid: true
  });
};

var WalletImportFormatError;
(function (WalletImportFormatError) {
  WalletImportFormatError["incorrectLength"] = "The WIF private key payload is not the correct length.";
})(WalletImportFormatError || (WalletImportFormatError = {}));
/**
 * Encode a private key using Wallet Import Format (WIF).
 *
 * WIF encodes the 32-byte private key, a 4-byte checksum, and a `type`
 * indicating the intended usage for the private key. See
 * {@link WalletImportFormatType} for details.
 *
 * @remarks
 * WIF-encoding uses the Base58Address format with version
 * {@link Base58AddressFormatVersion.wif} (`128`/`0x80`) or
 * {@link Base58AddressFormatVersion.wifTestnet} (`239`/`0xef`), respectively.
 *
 * To indicate that the private key is intended for use in a P2PKH address using
 * the compressed form of its derived public key, a `0x01` is appended to the
 * payload prior to encoding. For the uncompressed construction, the extra byte
 * is omitted.
 *
 * @param privateKey - a 32-byte Secp256k1 ECDSA private key
 * @param type - the intended usage of the private key (e.g. `mainnet` or
 * `testnet`)
 * @param sha256 - an implementation of sha256
 */
var encodePrivateKeyWif = function encodePrivateKeyWif(privateKey, type) {
  var sha256 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : sha256$1;
  var compressedByte = 0x01;
  var mainnet = type === 'mainnet' || type === 'mainnetUncompressed';
  var compressed = type === 'mainnet' || type === 'testnet';
  var payload = compressed ? Uint8Array.from([].concat(_toConsumableArray(privateKey), [compressedByte])) : privateKey;
  return encodeBase58AddressFormat(mainnet ? Base58AddressFormatVersion.wif : Base58AddressFormatVersion.wifTestnet, payload, sha256);
};
/**
 * Decode a private key using Wallet Import Format (WIF). See
 * {@link encodePrivateKeyWif} for details.
 *
 * @param wifKey - the private key to decode (in Wallet Import Format)
 * @param sha256 - an implementation of sha256
 */
// eslint-disable-next-line complexity
var decodePrivateKeyWif = function decodePrivateKeyWif(wifKey) {
  var sha256 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : sha256$1;
  var compressedPayloadLength = 33;
  var decoded = decodeBase58AddressFormat(wifKey, sha256);
  if (typeof decoded === 'string') return decoded;
  var mainnet = decoded.version === Base58AddressFormatVersion.wif;
  var compressed = decoded.payload.length === compressedPayloadLength;
  var privateKey = compressed ? decoded.payload.slice(0, -1) : decoded.payload;
  var type = mainnet ? compressed ? 'mainnet' : 'mainnetUncompressed' : compressed ? 'testnet' : 'testnetUncompressed';
  return {
    privateKey: privateKey,
    type: type
  };
};

var OpcodeDescriptionsXEC;
(function (OpcodeDescriptionsXEC) {
  OpcodeDescriptionsXEC["OP_0"] = "Push the VM Number 0 onto the stack.";
  OpcodeDescriptionsXEC["OP_PUSHBYTES_1"] = "Push the next byte onto the stack.";
  OpcodeDescriptionsXEC["OP_PUSHBYTES_2"] = "Push the next 2 bytes onto the stack.";
  OpcodeDescriptionsXEC["OP_PUSHBYTES_3"] = "Push the next 3 bytes onto the stack.";
  OpcodeDescriptionsXEC["OP_PUSHBYTES_4"] = "Push the next 4 bytes onto the stack.";
  OpcodeDescriptionsXEC["OP_PUSHBYTES_5"] = "Push the next 5 bytes onto the stack.";
  OpcodeDescriptionsXEC["OP_PUSHBYTES_6"] = "Push the next 6 bytes onto the stack.";
  OpcodeDescriptionsXEC["OP_PUSHBYTES_7"] = "Push the next 7 bytes onto the stack.";
  OpcodeDescriptionsXEC["OP_PUSHBYTES_8"] = "Push the next 8 bytes onto the stack.";
  OpcodeDescriptionsXEC["OP_PUSHBYTES_9"] = "Push the next 9 bytes onto the stack.";
  OpcodeDescriptionsXEC["OP_PUSHBYTES_10"] = "Push the next 10 bytes onto the stack.";
  OpcodeDescriptionsXEC["OP_PUSHBYTES_11"] = "Push the next 11 bytes onto the stack.";
  OpcodeDescriptionsXEC["OP_PUSHBYTES_12"] = "Push the next 12 bytes onto the stack.";
  OpcodeDescriptionsXEC["OP_PUSHBYTES_13"] = "Push the next 13 bytes onto the stack.";
  OpcodeDescriptionsXEC["OP_PUSHBYTES_14"] = "Push the next 14 bytes onto the stack.";
  OpcodeDescriptionsXEC["OP_PUSHBYTES_15"] = "Push the next 15 bytes onto the stack.";
  OpcodeDescriptionsXEC["OP_PUSHBYTES_16"] = "Push the next 16 bytes onto the stack.";
  OpcodeDescriptionsXEC["OP_PUSHBYTES_17"] = "Push the next 17 bytes onto the stack.";
  OpcodeDescriptionsXEC["OP_PUSHBYTES_18"] = "Push the next 18 bytes onto the stack.";
  OpcodeDescriptionsXEC["OP_PUSHBYTES_19"] = "Push the next 19 bytes onto the stack.";
  OpcodeDescriptionsXEC["OP_PUSHBYTES_20"] = "Push the next 20 bytes onto the stack.";
  OpcodeDescriptionsXEC["OP_PUSHBYTES_21"] = "Push the next 21 bytes onto the stack.";
  OpcodeDescriptionsXEC["OP_PUSHBYTES_22"] = "Push the next 22 bytes onto the stack.";
  OpcodeDescriptionsXEC["OP_PUSHBYTES_23"] = "Push the next 23 bytes onto the stack.";
  OpcodeDescriptionsXEC["OP_PUSHBYTES_24"] = "Push the next 24 bytes onto the stack.";
  OpcodeDescriptionsXEC["OP_PUSHBYTES_25"] = "Push the next 25 bytes onto the stack.";
  OpcodeDescriptionsXEC["OP_PUSHBYTES_26"] = "Push the next 26 bytes onto the stack.";
  OpcodeDescriptionsXEC["OP_PUSHBYTES_27"] = "Push the next 27 bytes onto the stack.";
  OpcodeDescriptionsXEC["OP_PUSHBYTES_28"] = "Push the next 28 bytes onto the stack.";
  OpcodeDescriptionsXEC["OP_PUSHBYTES_29"] = "Push the next 29 bytes onto the stack.";
  OpcodeDescriptionsXEC["OP_PUSHBYTES_30"] = "Push the next 30 bytes onto the stack.";
  OpcodeDescriptionsXEC["OP_PUSHBYTES_31"] = "Push the next 31 bytes onto the stack.";
  OpcodeDescriptionsXEC["OP_PUSHBYTES_32"] = "Push the next 32 bytes onto the stack.";
  OpcodeDescriptionsXEC["OP_PUSHBYTES_33"] = "Push the next 33 bytes onto the stack.";
  OpcodeDescriptionsXEC["OP_PUSHBYTES_34"] = "Push the next 34 bytes onto the stack.";
  OpcodeDescriptionsXEC["OP_PUSHBYTES_35"] = "Push the next 35 bytes onto the stack.";
  OpcodeDescriptionsXEC["OP_PUSHBYTES_36"] = "Push the next 36 bytes onto the stack.";
  OpcodeDescriptionsXEC["OP_PUSHBYTES_37"] = "Push the next 37 bytes onto the stack.";
  OpcodeDescriptionsXEC["OP_PUSHBYTES_38"] = "Push the next 38 bytes onto the stack.";
  OpcodeDescriptionsXEC["OP_PUSHBYTES_39"] = "Push the next 39 bytes onto the stack.";
  OpcodeDescriptionsXEC["OP_PUSHBYTES_40"] = "Push the next 40 bytes onto the stack.";
  OpcodeDescriptionsXEC["OP_PUSHBYTES_41"] = "Push the next 41 bytes onto the stack.";
  OpcodeDescriptionsXEC["OP_PUSHBYTES_42"] = "Push the next 42 bytes onto the stack.";
  OpcodeDescriptionsXEC["OP_PUSHBYTES_43"] = "Push the next 43 bytes onto the stack.";
  OpcodeDescriptionsXEC["OP_PUSHBYTES_44"] = "Push the next 44 bytes onto the stack.";
  OpcodeDescriptionsXEC["OP_PUSHBYTES_45"] = "Push the next 45 bytes onto the stack.";
  OpcodeDescriptionsXEC["OP_PUSHBYTES_46"] = "Push the next 46 bytes onto the stack.";
  OpcodeDescriptionsXEC["OP_PUSHBYTES_47"] = "Push the next 47 bytes onto the stack.";
  OpcodeDescriptionsXEC["OP_PUSHBYTES_48"] = "Push the next 48 bytes onto the stack.";
  OpcodeDescriptionsXEC["OP_PUSHBYTES_49"] = "Push the next 49 bytes onto the stack.";
  OpcodeDescriptionsXEC["OP_PUSHBYTES_50"] = "Push the next 50 bytes onto the stack.";
  OpcodeDescriptionsXEC["OP_PUSHBYTES_51"] = "Push the next 51 bytes onto the stack.";
  OpcodeDescriptionsXEC["OP_PUSHBYTES_52"] = "Push the next 52 bytes onto the stack.";
  OpcodeDescriptionsXEC["OP_PUSHBYTES_53"] = "Push the next 53 bytes onto the stack.";
  OpcodeDescriptionsXEC["OP_PUSHBYTES_54"] = "Push the next 54 bytes onto the stack.";
  OpcodeDescriptionsXEC["OP_PUSHBYTES_55"] = "Push the next 55 bytes onto the stack.";
  OpcodeDescriptionsXEC["OP_PUSHBYTES_56"] = "Push the next 56 bytes onto the stack.";
  OpcodeDescriptionsXEC["OP_PUSHBYTES_57"] = "Push the next 57 bytes onto the stack.";
  OpcodeDescriptionsXEC["OP_PUSHBYTES_58"] = "Push the next 58 bytes onto the stack.";
  OpcodeDescriptionsXEC["OP_PUSHBYTES_59"] = "Push the next 59 bytes onto the stack.";
  OpcodeDescriptionsXEC["OP_PUSHBYTES_60"] = "Push the next 60 bytes onto the stack.";
  OpcodeDescriptionsXEC["OP_PUSHBYTES_61"] = "Push the next 61 bytes onto the stack.";
  OpcodeDescriptionsXEC["OP_PUSHBYTES_62"] = "Push the next 62 bytes onto the stack.";
  OpcodeDescriptionsXEC["OP_PUSHBYTES_63"] = "Push the next 63 bytes onto the stack.";
  OpcodeDescriptionsXEC["OP_PUSHBYTES_64"] = "Push the next 64 bytes onto the stack.";
  OpcodeDescriptionsXEC["OP_PUSHBYTES_65"] = "Push the next 65 bytes onto the stack.";
  OpcodeDescriptionsXEC["OP_PUSHBYTES_66"] = "Push the next 66 bytes onto the stack.";
  OpcodeDescriptionsXEC["OP_PUSHBYTES_67"] = "Push the next 67 bytes onto the stack.";
  OpcodeDescriptionsXEC["OP_PUSHBYTES_68"] = "Push the next 68 bytes onto the stack.";
  OpcodeDescriptionsXEC["OP_PUSHBYTES_69"] = "Push the next 69 bytes onto the stack.";
  OpcodeDescriptionsXEC["OP_PUSHBYTES_70"] = "Push the next 70 bytes onto the stack.";
  OpcodeDescriptionsXEC["OP_PUSHBYTES_71"] = "Push the next 71 bytes onto the stack.";
  OpcodeDescriptionsXEC["OP_PUSHBYTES_72"] = "Push the next 72 bytes onto the stack.";
  OpcodeDescriptionsXEC["OP_PUSHBYTES_73"] = "Push the next 73 bytes onto the stack.";
  OpcodeDescriptionsXEC["OP_PUSHBYTES_74"] = "Push the next 74 bytes onto the stack.";
  OpcodeDescriptionsXEC["OP_PUSHBYTES_75"] = "Push the next 75 bytes onto the stack.";
  OpcodeDescriptionsXEC["OP_PUSHDATA_1"] = "Read the next Uint8 and push that number of bytes onto the stack.";
  OpcodeDescriptionsXEC["OP_PUSHDATA_2"] = "Read the next little-endian Uint16 and push that number of bytes onto the stack.";
  OpcodeDescriptionsXEC["OP_PUSHDATA_4"] = "Read the next little-endian Uint32 and push that number of bytes onto the stack.";
  OpcodeDescriptionsXEC["OP_1NEGATE"] = "Push the VM Number -1 onto the stack.";
  OpcodeDescriptionsXEC["OP_RESERVED"] = "Error unless found in an unexecuted conditional branch. Note: OP_RESERVED does not count toward the opcode limit.";
  OpcodeDescriptionsXEC["OP_1"] = "Push a 1 (VM Number) onto the stack.";
  OpcodeDescriptionsXEC["OP_2"] = "Push a 2 (VM Number) onto the stack.";
  OpcodeDescriptionsXEC["OP_3"] = "Push a 3 (VM Number) onto the stack.";
  OpcodeDescriptionsXEC["OP_4"] = "Push a 4 (VM Number) onto the stack.";
  OpcodeDescriptionsXEC["OP_5"] = "Push a 5 (VM Number) onto the stack.";
  OpcodeDescriptionsXEC["OP_6"] = "Push a 6 (VM Number) onto the stack.";
  OpcodeDescriptionsXEC["OP_7"] = "Push a 7 (VM Number) onto the stack.";
  OpcodeDescriptionsXEC["OP_8"] = "Push a 8 (VM Number) onto the stack.";
  OpcodeDescriptionsXEC["OP_9"] = "Push a 9 (VM Number) onto the stack.";
  OpcodeDescriptionsXEC["OP_10"] = "Push a 10 (VM Number) onto the stack.";
  OpcodeDescriptionsXEC["OP_11"] = "Push a 11 (VM Number) onto the stack.";
  OpcodeDescriptionsXEC["OP_12"] = "Push a 12 (VM Number) onto the stack.";
  OpcodeDescriptionsXEC["OP_13"] = "Push a 13 (VM Number) onto the stack.";
  OpcodeDescriptionsXEC["OP_14"] = "Push a 14 (VM Number) onto the stack.";
  OpcodeDescriptionsXEC["OP_15"] = "Push a 15 (VM Number) onto the stack.";
  OpcodeDescriptionsXEC["OP_16"] = "Push a 16 (VM Number) onto the stack.";
  OpcodeDescriptionsXEC["OP_NOP"] = "No operation. Note: OP_NOP counts toward the opcode limit.";
  OpcodeDescriptionsXEC["OP_VER"] = "Error unless found in an unexecuted conditional branch. Note: OP_VER counts toward the opcode limit. (Historically, this pushed a protocol version number to the stack.)";
  OpcodeDescriptionsXEC["OP_IF"] = "Pop the top item from the stack. If it is not \"truthy\", skip evaluation until a matching OP_ELSE or OP_ENDIF.";
  OpcodeDescriptionsXEC["OP_NOTIF"] = "Pop the top item from the stack. If it is \"truthy\", skip evaluation until a matching OP_ELSE or OP_ENDIF.";
  OpcodeDescriptionsXEC["OP_VERIF"] = "Error, even when found in an unexecuted conditional branch. (Historically, this was a combination of OP_VER and OP_IF.)";
  OpcodeDescriptionsXEC["OP_VERNOTIF"] = "Error, even when found in an unexecuted conditional branch. (Historically, this was a combination of OP_VER and OP_NOTIF.)";
  OpcodeDescriptionsXEC["OP_ELSE"] = "Invert conditional evaluation within the current OP_IF ... OP_ENDIF block. (If evaluation is enabled, disable it, if it is disabled, enable it.)";
  OpcodeDescriptionsXEC["OP_ENDIF"] = "End the current OP_IF/OP_NOTIF ... OP_ENDIF block.";
  OpcodeDescriptionsXEC["OP_VERIFY"] = "Pop the top item from the stack and error if it isn't \"truthy\".";
  OpcodeDescriptionsXEC["OP_RETURN"] = "Error when executed.";
  OpcodeDescriptionsXEC["OP_TOALTSTACK"] = "Pop the top item from the stack and push it onto the alternate stack.";
  OpcodeDescriptionsXEC["OP_FROMALTSTACK"] = "Pop the top item from the alternate stack and push it onto the stack.";
  OpcodeDescriptionsXEC["OP_2DROP"] = "Pop the top 2 items from the stack and discard them.";
  OpcodeDescriptionsXEC["OP_2DUP"] = "Duplicate the top 2 items on the stack. (E.g. [a, b] -> [a, b, a, b])";
  OpcodeDescriptionsXEC["OP_3DUP"] = "Duplicate the top 3 items on the stack. (E.g. [a, b, c] -> [a, b, c, a, b, c])";
  OpcodeDescriptionsXEC["OP_2OVER"] = "Duplicate the 2 items beginning at a depth of 2 on the stack. (E.g. [a, b, c, d] -> [a, b, c, d, a, b])";
  OpcodeDescriptionsXEC["OP_2ROT"] = "Rotate the top 6 items on the stack, bringing the fifth and sixth items to the top. (E.g. [a, b, c, d, e, f] -> [c, d, e, f, a, b])";
  OpcodeDescriptionsXEC["OP_2SWAP"] = "Swap the positions of the top two pairs of items on the stack. (E.g. [a, b, c, d] -> [c, d, a, b])";
  OpcodeDescriptionsXEC["OP_IFDUP"] = "If the top item on the stack is \"truthy\", duplicate it.";
  OpcodeDescriptionsXEC["OP_DEPTH"] = "Push the current number of stack items as a VM Number.";
  OpcodeDescriptionsXEC["OP_DROP"] = "Pop the top item from the stack and discard it. (E.g. [a] -> [])";
  OpcodeDescriptionsXEC["OP_DUP"] = "Duplicate the top item on the stack. (E.g. [a] -> [a, a])";
  OpcodeDescriptionsXEC["OP_NIP"] = "Remove the second-to-top item from the stack. (E.g. [a, b] -> [b])";
  OpcodeDescriptionsXEC["OP_OVER"] = "Duplicate the second-to-top item on the stack. (E.g. [a, b] -> [a, b, a])";
  OpcodeDescriptionsXEC["OP_PICK"] = "Pop the top item from the stack as a VM Number. Duplicate the item at that depth (zero-indexed), placing it on top of the stack. (E.g. [a, b, c, 2] -> [a, b, c, a])";
  OpcodeDescriptionsXEC["OP_ROLL"] = "Pop the top item from the stack as a VM Number. Move the item at that depth (zero-indexed) to the top of the stack. (E.g. [a, b, c, 2] -> [b, c, a])";
  OpcodeDescriptionsXEC["OP_ROT"] = "Rotate the top 3 items on the stack, bringing the third item to the top. (E.g. [a, b, c] -> [b, c, a])";
  OpcodeDescriptionsXEC["OP_SWAP"] = "Swap the top two items on the stack. (E.g. [a, b] -> [b, a])";
  OpcodeDescriptionsXEC["OP_TUCK"] = "Duplicate the item at the top of the stack, inserting it below the second-to-top item. (E.g. [a, b] -> [b, a, b])";
  OpcodeDescriptionsXEC["OP_CAT"] = "Pop the top 2 items from the stack and concatenate them, pushing the result.";
  OpcodeDescriptionsXEC["OP_SPLIT"] = "Pop the top item from the stack as an index (VM Number) and the next item as a byte array. Split the byte array into two stack items at the index (zero-based), pushing the results.";
  OpcodeDescriptionsXEC["OP_NUM2BIN"] = "Pop the top item from the stack as an item length (VM Number) and the next item as a VM Number (without encoding restrictions). Re-encode the number using a byte array of the provided length, filling any unused bytes with zeros, then push the result. (If the requested length is too short to encode the number, error.)";
  OpcodeDescriptionsXEC["OP_BIN2NUM"] = "Pop the top item from the stack as a VM Number without encoding restrictions. Minimally-encode the number and push the result. (If the number can't be encoded in 4 bytes or less, error.)";
  OpcodeDescriptionsXEC["OP_SIZE"] = "Push the byte-length of the top stack item as a VM Number.";
  OpcodeDescriptionsXEC["OP_INVERT"] = "Error, even when found in an unexecuted conditional branch. (Historically, this flipped all the bits in a stack item.)";
  OpcodeDescriptionsXEC["OP_AND"] = "Pop the top 2 items from the stack and perform a bitwise AND on each byte, pushing the result. If the length of the items are not equal, error.";
  OpcodeDescriptionsXEC["OP_OR"] = "Pop the top 2 items from the stack and perform a bitwise OR on each byte, pushing the result. If the length of the items are not equal, error.";
  OpcodeDescriptionsXEC["OP_XOR"] = "Pop the top 2 items from the stack and perform a bitwise XOR on each byte, pushing the result. If the length of the items are not equal, error.";
  OpcodeDescriptionsXEC["OP_EQUAL"] = "Pop the top two items from the stack and compare them byte-by-byte. If they are the same, push a 1 (VM Number), otherwise push a 0 (VM Number).";
  OpcodeDescriptionsXEC["OP_EQUALVERIFY"] = "Pop the top two items from the stack and compare them byte-by-byte. If the values are different, error. (This operation is a combination of OP_EQUAL followed by OP_VERIFY.)";
  OpcodeDescriptionsXEC["OP_RESERVED1"] = "Error unless found in an unexecuted conditional branch. Note: OP_RESERVED1 counts toward the opcode limit.";
  OpcodeDescriptionsXEC["OP_RESERVED2"] = "Error unless found in an unexecuted conditional branch. Note: OP_RESERVED2 counts toward the opcode limit.";
  OpcodeDescriptionsXEC["OP_1ADD"] = "Pop the top item from the stack as a VM Number, add 1, then push the result.";
  OpcodeDescriptionsXEC["OP_1SUB"] = "Pop the top item from the stack as a VM Number, subtract 1, then push the result.";
  OpcodeDescriptionsXEC["OP_2MUL"] = "Error, even when found in an unexecuted conditional branch. (Historically, this multiplied a VM Number by 2.)";
  OpcodeDescriptionsXEC["OP_2DIV"] = "Error, even when found in an unexecuted conditional branch. (Historically, this divided a VM Number by 2.)";
  OpcodeDescriptionsXEC["OP_NEGATE"] = "Pop the top item from the stack as a VM Number, negate it, then push the result.";
  OpcodeDescriptionsXEC["OP_ABS"] = "Pop the top item from the stack as a VM Number, take its absolute value, then push the result.";
  OpcodeDescriptionsXEC["OP_NOT"] = "Pop the top item from the stack as a VM Number. If its value is 0, push a 1 (VM Number), otherwise, push a 0 (VM Number).";
  OpcodeDescriptionsXEC["OP_0NOTEQUAL"] = "Pop the top item from the stack as a VM Number. If its value is not 0, push a 1 (VM Number), otherwise, push a 0 (VM Number).";
  OpcodeDescriptionsXEC["OP_ADD"] = "Pop the top two items from the stack as VM Numbers. Add them, then push the result.";
  OpcodeDescriptionsXEC["OP_SUB"] = "Pop the top two items from the stack as VM Numbers. Subtract the top item from the second item, then push the result.";
  OpcodeDescriptionsXEC["OP_MUL"] = "Pop the top two items from the stack as VM Numbers. Multiply them, then push the result.";
  OpcodeDescriptionsXEC["OP_DIV"] = "Pop the top item from the stack as a denominator (VM Number) and the next as a numerator (VM Number). Divide and push the result to the stack.";
  OpcodeDescriptionsXEC["OP_MOD"] = "Pop the top item from the stack as a denominator (VM Number) and the next as a numerator (VM Number). Divide and push the remainder to the stack.";
  OpcodeDescriptionsXEC["OP_LSHIFT"] = "Error, even when found in an unexecuted conditional branch. (Historically, this performed a sign-preserving, left bit shift.)";
  OpcodeDescriptionsXEC["OP_RSHIFT"] = "Error, even when found in an unexecuted conditional branch. (Historically, this performed a sign-preserving, right bit shift.)";
  OpcodeDescriptionsXEC["OP_BOOLAND"] = "Pop the top two items from the stack as VM Numbers. If neither value is a 0 (VM Number), push a 1 (VM Number). Otherwise, push a 0 (VM Number).";
  OpcodeDescriptionsXEC["OP_BOOLOR"] = "Pop the top two items from the stack as VM Numbers. If either value is a 1 (VM Number), push a 1 (VM Number). Otherwise, push a 0 (VM Number).";
  OpcodeDescriptionsXEC["OP_NUMEQUAL"] = "Pop the top two items from the stack as VM Numbers. If the values are equal, push a 1 (VM Number). Otherwise, push a 0 (VM Number).";
  OpcodeDescriptionsXEC["OP_NUMEQUALVERIFY"] = "Pop the top two items from the stack as VM Numbers. If the values are different, error. (This operation is a combination of OP_NUMEQUAL followed by OP_VERIFY.)";
  OpcodeDescriptionsXEC["OP_NUMNOTEQUAL"] = "Pop the top two items from the stack as VM Numbers. If the values are not equal, push a 1 (VM Number). Otherwise, push a 0 (VM Number).";
  OpcodeDescriptionsXEC["OP_LESSTHAN"] = "Pop the top two items from the stack as VM Numbers. If the second item is less than top item, push a 1 (VM Number). Otherwise, push a 0 (VM Number).";
  OpcodeDescriptionsXEC["OP_GREATERTHAN"] = "Pop the top two items from the stack as VM Numbers. If the second item is greater than top item, push a 1 (VM Number). Otherwise, push a 0 (VM Number).";
  OpcodeDescriptionsXEC["OP_LESSTHANOREQUAL"] = "Pop the top two items from the stack as VM Numbers. If the second item is less than or equal to the top item, push a 1 (VM Number). Otherwise, push a 0 (VM Number).";
  OpcodeDescriptionsXEC["OP_GREATERTHANOREQUAL"] = "Pop the top two items from the stack as VM Numbers. If the second item is greater than or equal to the top item, push a 1 (VM Number). Otherwise, push a 0 (VM Number).";
  OpcodeDescriptionsXEC["OP_MIN"] = "Pop the top two items from the stack as VM Numbers. Push the smaller of the two numbers.";
  OpcodeDescriptionsXEC["OP_MAX"] = "Pop the top two items from the stack as VM Numbers. Push the larger of the two numbers.";
  OpcodeDescriptionsXEC["OP_WITHIN"] = "Pop the top three items from the stack as VM Numbers. If the top number is within the range defined by the following two numbers (left-inclusive), push a 1 (VM Number). Otherwise, push a 0 (VM Number). (E.g. for [a, b, c]: if (b <= a), and (a < c), [1]. Else [0].)";
  OpcodeDescriptionsXEC["OP_RIPEMD160"] = "Pop the top item from the stack and pass it through ripemd160, pushing the result onto the stack.";
  OpcodeDescriptionsXEC["OP_SHA1"] = "Pop the top item from the stack and pass it through sha1, pushing the result onto the stack.";
  OpcodeDescriptionsXEC["OP_SHA256"] = "Pop the top item from the stack and pass it through sha256, pushing the result onto the stack.";
  OpcodeDescriptionsXEC["OP_HASH160"] = "Pop the top item from the stack and pass it through sha256, then ripemd160, pushing the result onto the stack.";
  OpcodeDescriptionsXEC["OP_HASH256"] = "Pop the top item from the stack and pass it through sha256 twice, pushing the result onto the stack.";
  OpcodeDescriptionsXEC["OP_CODESEPARATOR"] = "Update the value of lastCodeSeparator to the instruction pointer's current value. (This reduces the coverage of signing serializations used in signature verification operations.)";
  OpcodeDescriptionsXEC["OP_CHECKSIG"] = "Pop the top two items from the stack. Treat the top as a signature and the second as a public key. If the signature is valid, push a 1 (VM Number), otherwise push a 0 (VM Number).";
  OpcodeDescriptionsXEC["OP_CHECKSIGVERIFY"] = "Pop the top two items from the stack. Treat the top as a signature and the second as a public key. If the signature is not valid, error. (This operation is a combination of OP_CHECKSIG followed by OP_VERIFY.)";
  OpcodeDescriptionsXEC["OP_CHECKMULTISIG"] = "Pop items from the stack: first pop the VM Number of public keys, then pop each of those public keys. Next, pop the VM Number of required signatures, then pop each of those signatures. Finally, pop a final VM Number that must be 0 due to a protocol bug. Checking each signature against each public key in order, if all signatures are valid \u2013 and the required number of signatures have been provided \u2013 push a 1 (VM Number), otherwise push a 0 (VM Number).";
  OpcodeDescriptionsXEC["OP_CHECKMULTISIGVERIFY"] = "Pop items from the stack: first pop the VM Number of public keys, then pop each of those public keys. Next, pop the VM Number of required signatures, then pop each of those signatures. Finally, (due to a protocol bug) pop an unused final VM Number that must be 0. Checking each signature against each public key in order, if any signatures are invalid \u2013 or the required number of signatures have not been provided \u2013 error. (This operation is a combination of OP_CHECKMULTISIG followed by OP_VERIFY.)";
  OpcodeDescriptionsXEC["OP_NOP1"] = "No operation (reserved for future expansion). Note: OP_NOP1 counts toward the opcode limit.";
  OpcodeDescriptionsXEC["OP_CHECKLOCKTIMEVERIFY"] = "Verify the transaction occurs after an absolute block time or height: read the top item on the stack as a VM Number (without removing it), and compare it to the transaction's locktime. If the required locktime has not passed, or if locktime has been disabled for this input by a maximized sequence number, error.";
  OpcodeDescriptionsXEC["OP_CHECKSEQUENCEVERIFY"] = "Verify the transaction occurs after the output being spent has \"aged\" by a relative block time or block height since it was created: read the top item on the stack as a VM Number (without removing it), and compare it to the age encoded in the input's sequence number. If the required relative locktime has not passed, or if relative locktime has been disabled by the sequence number or the transaction version, error.";
  OpcodeDescriptionsXEC["OP_NOP4"] = "No operation (reserved for future expansion). Note: OP_NOP4 counts toward the opcode limit.";
  OpcodeDescriptionsXEC["OP_NOP6"] = "No operation (reserved for future expansion). Note: OP_NOP6 counts toward the opcode limit.";
  OpcodeDescriptionsXEC["OP_NOP5"] = "No operation (reserved for future expansion). Note: OP_NOP5 counts toward the opcode limit.";
  OpcodeDescriptionsXEC["OP_NOP7"] = "No operation (reserved for future expansion). Note: OP_NOP7 counts toward the opcode limit.";
  OpcodeDescriptionsXEC["OP_NOP8"] = "No operation (reserved for future expansion). Note: OP_NOP8 counts toward the opcode limit.";
  OpcodeDescriptionsXEC["OP_NOP9"] = "No operation (reserved for future expansion). Note: OP_NOP9 counts toward the opcode limit.";
  OpcodeDescriptionsXEC["OP_NOP10"] = "No operation (reserved for future expansion). Note: OP_NOP10 counts toward the opcode limit.";
  OpcodeDescriptionsXEC["OP_CHECKDATASIG"] = "Pop the top 3 items from the stack. Treat the top as a public key, the second as a message, and the third as a signature. If the signature is valid, push a 1 (VM Number), otherwise push a 0 (VM Number).";
  OpcodeDescriptionsXEC["OP_CHECKDATASIGVERIFY"] = "Pop the top 3 items from the stack. Treat the top as a public key, the second as a message, and the third as a signature. If the signature is not valid, error. (This operation is a combination of OP_CHECKDATASIG followed by OP_VERIFY.)";
  OpcodeDescriptionsXEC["OP_REVERSEBYTES"] = "Pop the top item from the stack and reverse it, pushing the result.";
})(OpcodeDescriptionsXEC || (OpcodeDescriptionsXEC = {}));

var ReadBytesError;
(function (ReadBytesError) {
  ReadBytesError["insufficientLength"] = "Error reading bytes: insufficient length.";
})(ReadBytesError || (ReadBytesError = {}));
/**
 * Returns a function that reads the requested number of bytes from a
 * {@link ReadPosition}, returning either an error message (as a string) or an
 * object containing the `Uint8Array` and the next {@link ReadPosition}.
 *
 * @param length - the number of bytes to read
 */
var readBytes = function readBytes(length) {
  return function (
  /**
   * the {@link ReadPosition} at which to start reading the bytes.
   */
  position) {
    var nextPosition = {
      bin: position.bin,
      index: position.index + length
    };
    var result = position.bin.slice(position.index, nextPosition.index);
    if (result.length !== length) {
      return formatError$1(ReadBytesError.insufficientLength, "Provided length: ".concat(result.length));
    }
    return {
      position: nextPosition,
      result: result
    };
  };
};
var ReadUint32LEError;
(function (ReadUint32LEError) {
  ReadUint32LEError["insufficientBytes"] = "Error reading Uint32LE: requires 4 bytes.";
})(ReadUint32LEError || (ReadUint32LEError = {}));
/**
 * Read a 4-byte, Uint32LE from the provided {@link ReadPosition},
 * returning either an error message (as a string) or an object containing the
 * number and the next {@link ReadPosition}.
 *
 * @param position - the {@link ReadPosition} at which to start reading
 */
var readUint32LE = function readUint32LE(position) {
  var nextPosition = {
    bin: position.bin,
    index: position.index + 4 /* ReadConstants.bytesPerUint32 */
  };

  var uint32LEBin = position.bin.subarray(position.index, nextPosition.index);
  if (uint32LEBin.length !== 4 /* ReadConstants.bytesPerUint32 */) {
    return formatError$1(ReadUint32LEError.insufficientBytes, "Provided length: ".concat(uint32LEBin.length));
  }
  var result = binToNumberUint32LE(uint32LEBin);
  return {
    position: nextPosition,
    result: result
  };
};
var ReadUint64LEError;
(function (ReadUint64LEError) {
  ReadUint64LEError["insufficientBytes"] = "Error reading Uint64LE: requires 8 bytes.";
})(ReadUint64LEError || (ReadUint64LEError = {}));
/**
 * Read {@link Output.valueSatoshis} from the provided {@link ReadPosition},
 * returning either an error message (as a string) or an object containing the
 * {@link Output.valueSatoshis} and the next {@link ReadPosition}.
 * @param position - the {@link ReadPosition} at which to start reading
 * {@link Output.valueSatoshis}
 */
var readUint64LE = function readUint64LE(position) {
  var nextPosition = {
    bin: position.bin,
    index: position.index + 8 /* ReadConstants.bytesPerUint64 */
  };

  var uint64LEBin = position.bin.subarray(position.index, nextPosition.index);
  if (uint64LEBin.length !== 8 /* ReadConstants.bytesPerUint64 */) {
    return formatError$1(ReadUint64LEError.insufficientBytes, "Provided length: ".concat(uint64LEBin.length));
  }
  var result = binToBigIntUint64LE(uint64LEBin);
  return {
    position: nextPosition,
    result: result
  };
};
var CompactSizePrefixedBinError;
(function (CompactSizePrefixedBinError) {
  CompactSizePrefixedBinError["invalidCompactSize"] = "Error reading CompactSize-prefixed bin: invalid CompactSize.";
  CompactSizePrefixedBinError["insufficientBytes"] = "Error reading CompactSize-prefixed bin: insufficient bytes.";
})(CompactSizePrefixedBinError || (CompactSizePrefixedBinError = {}));
/**
 * Read a bin (`Uint8Array`) that is prefixed by a minimally-encoded
 * `CompactSize` starting at the provided {@link ReadPosition}, returning either
 * an error message (as a string) or an object containing the `Uint8Array` and
 * the next {@link ReadPosition}. (In the transaction format,
 * `CompactSize`-prefixes are used to indicate the length of unlocking bytecode,
 * locking bytecode, and non-fungible token commitments.)
 *
 * @param position - the {@link ReadPosition} at which to start reading the
 * `CompactSize`-prefixed bin (`Uint8Array`)
 */
var readCompactSizePrefixedBin = function readCompactSizePrefixedBin(position) {
  var read = readCompactSizeMinimal(position);
  if (typeof read === 'string') {
    return formatError$1(CompactSizePrefixedBinError.invalidCompactSize, read);
  }
  var result = read.result,
    p2 = read.position;
  var length = Number(result);
  var nextPosition = {
    bin: position.bin,
    index: p2.index + length
  };
  var contents = position.bin.slice(p2.index, nextPosition.index);
  if (contents.length !== length) {
    return formatError$1(CompactSizePrefixedBinError.insufficientBytes, "Required bytes: ".concat(length, ", remaining bytes: ").concat(contents.length));
  }
  return {
    position: nextPosition,
    result: contents
  };
};
/**
 * Read the remaining bytes from the provided {@link ReadPosition}, returning
 * an object containing the `Uint8Array` and the next {@link ReadPosition}
 * (with `index === bin.length`).
 *
 * @param position - the {@link ReadPosition} at which to start reading the
 * remaining bytes
 */
var readRemainingBytes = function readRemainingBytes(position) {
  var nextPosition = {
    bin: position.bin,
    index: position.bin.length
  };
  var result = position.bin.subarray(position.index, nextPosition.index);
  return {
    position: nextPosition,
    result: result
  };
};

/**
 * The capability assigned to a particular non-fungible token.
 */
var NonFungibleTokenCapability;
(function (NonFungibleTokenCapability) {
  /**
   * No capability, i.e. the token is an **immutable token**.
   */
  NonFungibleTokenCapability["none"] = "none";
  /**
   * The mutable capability (`0x01`), i.e. the token is a **mutable token**.
   */
  NonFungibleTokenCapability["mutable"] = "mutable";
  /**
   * The minting capability (`0x02`), i.e. the token is a **minting token**.
   */
  NonFungibleTokenCapability["minting"] = "minting";
})(NonFungibleTokenCapability || (NonFungibleTokenCapability = {}));
/**
 * The maximum uint64 value – an impossibly large, intentionally invalid value
 * for `valueSatoshis`. See {@link Transaction.valueSatoshis} for details.
 */
// prettier-ignore
// eslint-disable-next-line @typescript-eslint/no-magic-numbers
var excessiveSatoshis = Uint8Array.from([255, 255, 255, 255, 255, 255, 255, 255]);

var _nftCapabilityLabelTo;
/**
 * Encode a single input for inclusion in an encoded transaction.
 *
 * @param input - the input to encode
 */
var encodeTransactionInput = function encodeTransactionInput(input) {
  return flattenBinArray([input.outpointTransactionHash.slice().reverse(), numberToBinUint32LE(input.outpointIndex), bigIntToCompactSize(BigInt(input.unlockingBytecode.length)), input.unlockingBytecode, numberToBinUint32LE(input.sequenceNumber)]);
};
var TransactionDecodingError;
(function (TransactionDecodingError) {
  TransactionDecodingError["transaction"] = "Error reading transaction.";
  TransactionDecodingError["endsWithUnexpectedBytes"] = "Error decoding transaction: the provided input includes unexpected bytes after the encoded transaction.";
  TransactionDecodingError["input"] = "Error reading transaction input.";
  TransactionDecodingError["inputs"] = "Error reading transaction inputs.";
  TransactionDecodingError["output"] = "Error reading transaction output.";
  TransactionDecodingError["outputs"] = "Error reading transaction outputs.";
  TransactionDecodingError["lockingBytecodeLength"] = "Error reading locking bytecode length.";
})(TransactionDecodingError || (TransactionDecodingError = {}));
/**
 * Read a transaction {@link Input} from the provided {@link ReadPosition},
 * returning either an error message (as a string) or an object containing the
 * {@link Input} and the next {@link ReadPosition}.
 * @param position - the {@link ReadPosition} at which to start reading the
 * transaction output
 */
var readTransactionInput = function readTransactionInput(position) {
  var inputRead = readMultiple(position, [readBytes(32 /* TransactionConstants.outpointTransactionHashLength */), readUint32LE, readCompactSizePrefixedBin, readUint32LE]);
  if (typeof inputRead === 'string') {
    return formatError$1(TransactionDecodingError.input, inputRead);
  }
  var nextPosition = inputRead.position,
    _inputRead$result = _slicedToArray(inputRead.result, 4),
    outpointTransactionHash = _inputRead$result[0],
    outpointIndex = _inputRead$result[1],
    unlockingBytecode = _inputRead$result[2],
    sequenceNumber = _inputRead$result[3];
  return {
    position: nextPosition,
    result: {
      outpointIndex: outpointIndex,
      outpointTransactionHash: outpointTransactionHash.reverse(),
      sequenceNumber: sequenceNumber,
      unlockingBytecode: unlockingBytecode
    }
  };
};
/**
 * Encode a set of {@link Input}s for inclusion in an encoded transaction
 * including the prefixed number of inputs.
 *
 * Format: [CompactSize: input count] [encoded inputs]
 *
 * @param inputs - the set of inputs to encode
 */
var encodeTransactionInputs = function encodeTransactionInputs(inputs) {
  return flattenBinArray([bigIntToCompactSize(BigInt(inputs.length))].concat(_toConsumableArray(inputs.map(encodeTransactionInput))));
};
/**
 * Read a set of transaction {@link Input}s beginning at {@link ReadPosition}.
 * A CompactSize will be read to determine the number of inputs, and that
 * number of transaction inputs will be read and returned. Returns either an
 * error message (as a string) or an object containing the array of inputs and
 * the next {@link ReadPosition}.
 *
 * @param position - the {@link ReadPosition} at which to start reading the
 * transaction inputs
 */
var readTransactionInputs = function readTransactionInputs(position) {
  var inputsRead = readItemCount(position, readTransactionInput);
  if (typeof inputsRead === 'string') {
    return formatError$1(TransactionDecodingError.inputs, inputsRead);
  }
  return inputsRead;
};
var maximumTokenAmount = 9223372036854775807n;
var nftCapabilityNumberToLabel = [NonFungibleTokenCapability.none, NonFungibleTokenCapability.mutable, NonFungibleTokenCapability.minting];
var nftCapabilityLabelToNumber = (_nftCapabilityLabelTo = {}, _defineProperty(_nftCapabilityLabelTo, NonFungibleTokenCapability.none, 0), _defineProperty(_nftCapabilityLabelTo, NonFungibleTokenCapability.mutable, 1), _defineProperty(_nftCapabilityLabelTo, NonFungibleTokenCapability.minting, 2), _nftCapabilityLabelTo);
var CashTokenDecodingError;
(function (CashTokenDecodingError) {
  CashTokenDecodingError["invalidPrefix"] = "Error reading token prefix.";
  CashTokenDecodingError["insufficientLength"] = "Invalid token prefix: insufficient length.";
  CashTokenDecodingError["reservedBit"] = "Invalid token prefix: reserved bit is set.";
  CashTokenDecodingError["invalidCapability"] = "Invalid token prefix: capability must be none (0), mutable (1), or minting (2).";
  CashTokenDecodingError["commitmentWithoutNft"] = "Invalid token prefix: commitment requires an NFT.";
  CashTokenDecodingError["capabilityWithoutNft"] = "Invalid token prefix: capability requires an NFT.";
  CashTokenDecodingError["commitmentLengthZero"] = "Invalid token prefix: if encoded, commitment length must be greater than 0.";
  CashTokenDecodingError["invalidCommitment"] = "Invalid token prefix: invalid non-fungible token commitment.";
  CashTokenDecodingError["invalidAmountEncoding"] = "Invalid token prefix: invalid fungible token amount encoding.";
  CashTokenDecodingError["zeroAmount"] = "Invalid token prefix: if encoded, fungible token amount must be greater than 0.";
  CashTokenDecodingError["excessiveAmount"] = "Invalid token prefix: exceeds maximum fungible token amount of 9223372036854775807.";
  CashTokenDecodingError["noTokens"] = "Invalid token prefix: must encode at least one token.";
})(CashTokenDecodingError || (CashTokenDecodingError = {}));
/**
 * Read a token amount from the provided {@link ReadPosition}, returning either
 * an error message (as a string) or an object containing the value and the next
 * {@link ReadPosition}.
 *
 * @param position - the {@link ReadPosition} at which to start reading the
 * token amount.
 */
var readTokenAmount = function readTokenAmount(position) {
  var amountRead = readCompactSizeMinimal(position);
  if (typeof amountRead === 'string') {
    return formatError$1(CashTokenDecodingError.invalidAmountEncoding, amountRead);
  }
  if (amountRead.result > maximumTokenAmount) {
    return formatError$1(CashTokenDecodingError.excessiveAmount, "Encoded amount: ".concat(amountRead.result));
  }
  if (amountRead.result === 0n) {
    return formatError$1(CashTokenDecodingError.zeroAmount);
  }
  return amountRead;
};
/**
 * Attempt to read a transaction {@link Output}'s token prefix from the provided
 * {@link ReadPosition}, returning either an error message (as a string) or an
 * object containing the (optional) token information and the
 * next {@link ReadPosition}.
 *
 * Rather than using this function directly, most applications
 * should use {@link readLockingBytecodeWithPrefix}.
 *
 * @param position - the {@link ReadPosition} at which to start reading the
 * token prefix
 */
// eslint-disable-next-line complexity
var readTokenPrefix = function readTokenPrefix(position) {
  var bin = position.bin,
    index = position.index;
  if (bin[index] !== 239 /* CashTokens.PREFIX_TOKEN */) {
    return {
      position: position,
      result: {}
    };
  }
  if (bin.length < index + 34 /* CashTokens.minimumPrefixLength */) {
    return formatError$1(CashTokenDecodingError.insufficientLength, "The minimum possible length is ".concat(34 /* CashTokens.minimumPrefixLength */, ". Missing bytes: ", 34 /* CashTokens.minimumPrefixLength */ - (bin.length - index)));
  }
  var category = bin.slice(index + 1, index + 33 /* CashTokens.tokenBitfieldIndex */).reverse();
  var tokenBitfield = bin[index + 33 /* CashTokens.tokenBitfieldIndex */]; // eslint-disable-line @typescript-eslint/no-non-null-assertion
  /* eslint-disable no-bitwise */
  var prefixStructure = tokenBitfield & 240 /* CashTokens.tokenFormatMask */;
  if ((prefixStructure & 128 /* CashTokens.RESERVED_BIT */) !== 0) {
    return formatError$1(CashTokenDecodingError.reservedBit, "Bitfield: 0b".concat(tokenBitfield.toString(2 /* CashTokens.useBinaryOutput */)));
  }

  var nftCapabilityInt = tokenBitfield & 15 /* CashTokens.nftCapabilityMask */;
  if (nftCapabilityInt > 2 /* CashTokens.maximumCapability */) {
    return formatError$1(CashTokenDecodingError.invalidCapability, "Capability value: ".concat(nftCapabilityInt));
  }
  var capability = nftCapabilityNumberToLabel[nftCapabilityInt]; // eslint-disable-line @typescript-eslint/no-non-null-assertion
  var hasNft = (prefixStructure & 32 /* CashTokens.HAS_NFT */) !== 0;
  var hasCommitmentLength = (prefixStructure & 64 /* CashTokens.HAS_COMMITMENT_LENGTH */) !== 0;
  if (hasCommitmentLength && !hasNft) {
    return formatError$1(CashTokenDecodingError.commitmentWithoutNft, "Bitfield: 0b".concat(tokenBitfield.toString(2 /* CashTokens.useBinaryOutput */)));
  }

  var hasAmount = (prefixStructure & 16 /* CashTokens.HAS_AMOUNT */) !== 0;
  /* eslint-enable no-bitwise */
  var nextPosition = {
    bin: bin,
    index: index + 33 /* CashTokens.tokenBitfieldIndex */ + 1
  };
  if (hasNft) {
    var commitmentRead = hasCommitmentLength ? readCompactSizePrefixedBin(nextPosition) : {
      position: nextPosition,
      result: Uint8Array.of()
    };
    if (typeof commitmentRead === 'string') {
      return formatError$1(CashTokenDecodingError.invalidCommitment, commitmentRead);
    }
    if (hasCommitmentLength && commitmentRead.result.length === 0) {
      return formatError$1(CashTokenDecodingError.commitmentLengthZero);
    }
    var _amountRead = hasAmount ? readTokenAmount(commitmentRead.position) : {
      position: commitmentRead.position,
      result: 0n
    };
    if (typeof _amountRead === 'string') {
      return _amountRead;
    }
    return {
      position: _amountRead.position,
      result: {
        token: {
          amount: _amountRead.result,
          category: category,
          nft: {
            capability: capability,
            commitment: commitmentRead.result
          }
        }
      }
    };
  }
  if (capability !== NonFungibleTokenCapability.none) {
    return formatError$1(CashTokenDecodingError.capabilityWithoutNft, "Bitfield: 0b".concat(tokenBitfield.toString(2 /* CashTokens.useBinaryOutput */)));
  }

  if (!hasAmount) {
    return formatError$1(CashTokenDecodingError.noTokens, "Bitfield: 0b".concat(tokenBitfield.toString(2 /* CashTokens.useBinaryOutput */)));
  }

  var amountRead = readTokenAmount(nextPosition);
  if (typeof amountRead === 'string') {
    return amountRead;
  }
  return {
    position: amountRead.position,
    result: {
      token: {
        amount: amountRead.result,
        category: category
      }
    }
  };
};
/**
 * Read the locking bytecode and token prefix (if present) of a transaction
 * {@link Output}, beginning at the `CompactSize` indicating the
 * combined length.
 * @param position - the {@link ReadPosition} at which to start reading the
 * optional token prefix and locking bytecode
 */
var readLockingBytecodeWithPrefix = function readLockingBytecodeWithPrefix(position) {
  var bytecodeRead = readCompactSizePrefixedBin(position);
  if (typeof bytecodeRead === 'string') {
    return formatError$1(TransactionDecodingError.lockingBytecodeLength, bytecodeRead);
  }
  var contents = bytecodeRead.result,
    nextPosition = bytecodeRead.position;
  var contentsRead = readMultiple({
    bin: contents,
    index: 0
  }, [readTokenPrefix, readRemainingBytes]);
  if (typeof contentsRead === 'string') {
    return formatError$1(CashTokenDecodingError.invalidPrefix, contentsRead);
  }
  var _contentsRead$result = _slicedToArray(contentsRead.result, 2),
    token = _contentsRead$result[0].token,
    lockingBytecode = _contentsRead$result[1];
  return {
    position: nextPosition,
    result: _objectSpread2({
      lockingBytecode: lockingBytecode
    }, token === undefined ? {} : {
      token: token
    })
  };
};
/**
 * Read a transaction {@link Output} from the provided {@link ReadPosition},
 * returning either an error message (as a string) or an object containing the
 * {@link Output} and the next {@link ReadPosition}.
 *
 * @param position - the {@link ReadPosition} at which to start reading the
 * transaction output
 */
var readTransactionOutput = function readTransactionOutput(position) {
  var outputRead = readMultiple(position, [readUint64LE, readLockingBytecodeWithPrefix]);
  if (typeof outputRead === 'string') {
    return formatError$1(TransactionDecodingError.output, outputRead);
  }
  var nextPosition = outputRead.position,
    _outputRead$result = _slicedToArray(outputRead.result, 2),
    valueSatoshis = _outputRead$result[0],
    _outputRead$result$ = _outputRead$result[1],
    lockingBytecode = _outputRead$result$.lockingBytecode,
    token = _outputRead$result$.token;
  return {
    position: nextPosition,
    result: _objectSpread2(_objectSpread2({
      lockingBytecode: lockingBytecode
    }, token === undefined ? {} : {
      token: token
    }), {}, {
      valueSatoshis: valueSatoshis
    })
  };
};
/**
 * Given {@link Output.token} data, encode a token prefix.
 *
 * This function does not fail, but returns an empty Uint8Array if the token
 * data does not encode any tokens (even if `token.category` is set).
 *
 * @param token - the token data to encode
 */
// eslint-disable-next-line complexity
var encodeTokenPrefix = function encodeTokenPrefix(token) {
  if (token === undefined || token.nft === undefined && token.amount < 1n) {
    return Uint8Array.of();
  }
  var hasNft = token.nft === undefined ? 0 : 32 /* CashTokens.HAS_NFT */;
  var capabilityInt = token.nft === undefined ? 0 : nftCapabilityLabelToNumber[token.nft.capability];
  var hasCommitmentLength = token.nft !== undefined && token.nft.commitment.length > 0 ? 64 /* CashTokens.HAS_COMMITMENT_LENGTH */ : 0;
  var hasAmount = token.amount > 0n ? 16 /* CashTokens.HAS_AMOUNT */ : 0;
  var tokenBitfield =
  // eslint-disable-next-line no-bitwise
  hasNft | hasCommitmentLength | hasAmount | capabilityInt;
  return flattenBinArray([Uint8Array.of(239 /* CashTokens.PREFIX_TOKEN */), token.category.slice().reverse(), Uint8Array.of(tokenBitfield)].concat(_toConsumableArray(hasCommitmentLength === 0 ? [] : [
  // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
  bigIntToCompactSize(BigInt(token.nft.commitment.length)),
  // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
  token.nft.commitment]), _toConsumableArray(hasAmount === 0 ? [] : [bigIntToCompactSize(token.amount)])));
};
/**
 * Encode a single {@link Output} for inclusion in an encoded transaction.
 *
 * @param output - the output to encode
 */
var encodeTransactionOutput = function encodeTransactionOutput(output) {
  var lockingBytecodeField = flattenBinArray([encodeTokenPrefix(output.token), output.lockingBytecode]);
  return flattenBinArray([valueSatoshisToBin(output.valueSatoshis), bigIntToCompactSize(BigInt(lockingBytecodeField.length)), lockingBytecodeField]);
};
/**
 * Read a set of transaction {@link Output}s beginning at {@link ReadPosition}.
 * A CompactSize will be read to determine the number of outputs, and that
 * number of transaction outputs will be read and returned. Returns either an
 * error message (as a string) or an object containing the array of outputs and
 * the next {@link ReadPosition}.
 *
 * @param position - the {@link ReadPosition} at which to start reading the
 * transaction outputs
 */
var readTransactionOutputs = function readTransactionOutputs(position) {
  var outputsRead = readItemCount(position, readTransactionOutput);
  if (typeof outputsRead === 'string') {
    return formatError$1(TransactionDecodingError.outputs, outputsRead);
  }
  return outputsRead;
};
/**
 * Encode a set of {@link Output}s for inclusion in an encoded transaction
 * including the prefixed number of outputs. Note, this encoding differs from
 * {@link encodeTransactionOutputsForSigning} (used for signing serializations).
 *
 * Format: [CompactSize: output count] [encoded outputs]
 *
 * @param outputs - the set of outputs to encode
 */
var encodeTransactionOutputs = function encodeTransactionOutputs(outputs) {
  return flattenBinArray([bigIntToCompactSize(BigInt(outputs.length))].concat(_toConsumableArray(outputs.map(encodeTransactionOutput))));
};
/**
 * Read a version 1 or 2 transaction beginning at {@link ReadPosition},
 * returning either an error message (as a string) or an object containing the
 * {@link Transaction} and the next {@link ReadPosition}. Rather than using this
 * function directly, most applications should
 * use {@link decodeTransactionCommon}.
 *
 * @param position - the {@link ReadPosition} at which to start reading the
 * {@link TransactionCommon}
 */
var readTransactionCommon = function readTransactionCommon(position) {
  var transactionRead = readMultiple(position, [readUint32LE, readTransactionInputs, readTransactionOutputs, readUint32LE]);
  if (typeof transactionRead === 'string') {
    return formatError$1(TransactionDecodingError.transaction, transactionRead);
  }
  var nextPosition = transactionRead.position,
    _transactionRead$resu = _slicedToArray(transactionRead.result, 4),
    version = _transactionRead$resu[0],
    inputs = _transactionRead$resu[1],
    outputs = _transactionRead$resu[2],
    locktime = _transactionRead$resu[3];
  return {
    position: nextPosition,
    result: {
      inputs: inputs,
      locktime: locktime,
      outputs: outputs,
      version: version
    }
  };
};
var readTransaction = readTransactionCommon;
var readTransactionOutputNonTokenAware = function readTransactionOutputNonTokenAware(pos) {
  var outputRead = readMultiple(pos, [readUint64LE, readCompactSizePrefixedBin]);
  if (typeof outputRead === 'string') {
    return formatError$1(TransactionDecodingError.output, outputRead);
  }
  var nextPosition = outputRead.position,
    _outputRead$result2 = _slicedToArray(outputRead.result, 2),
    valueSatoshis = _outputRead$result2[0],
    lockingBytecode = _outputRead$result2[1];
  return {
    position: nextPosition,
    result: {
      lockingBytecode: lockingBytecode,
      valueSatoshis: valueSatoshis
    }
  };
};
var readTransactionOutputsNonTokenAware = function readTransactionOutputsNonTokenAware(pos) {
  var outputsRead = readItemCount(pos, readTransactionOutputNonTokenAware);
  if (typeof outputsRead === 'string') {
    return formatError$1(TransactionDecodingError.outputs, outputsRead);
  }
  return outputsRead;
};
/**
 * Read a version 1 or 2 transaction beginning at a {@link ReadPosition} as if
 * CHIP-2022-02-CashTokens were not deployed, returning either an error message
 * (as a string) or an object containing the {@link Transaction} and the next
 * {@link ReadPosition}.
 *
 * This function emulates legacy transaction parsing to test behavior prior to
 * deployment of CHIP-2022-02-CashTokens; most applications should instead
 * use {@link readTransactionCommon}.
 *
 * @param position - the {@link ReadPosition} at which to start reading the
 * {@link TransactionCommon}
 */
var readTransactionNonTokenAware = function readTransactionNonTokenAware(position) {
  var transactionRead = readMultiple(position, [readUint32LE, readTransactionInputs, readTransactionOutputsNonTokenAware, readUint32LE]);
  if (typeof transactionRead === 'string') {
    return formatError$1(TransactionDecodingError.transaction, transactionRead);
  }
  var nextPosition = transactionRead.position,
    _transactionRead$resu2 = _slicedToArray(transactionRead.result, 4),
    version = _transactionRead$resu2[0],
    inputs = _transactionRead$resu2[1],
    outputs = _transactionRead$resu2[2],
    locktime = _transactionRead$resu2[3];
  return {
    position: nextPosition,
    result: {
      inputs: inputs,
      locktime: locktime,
      outputs: outputs,
      version: version
    }
  };
};
/**
 * Decode a {@link TransactionCommon} according to the version 1/2 P2P network
 * transaction format.
 *
 * This function verifies that the provided `bin` contains only one transaction
 * and no additional data. To read a transaction from a specific location within
 * a `Uint8Array`, use {@link readTransactionCommon}.
 *
 * @param bin - the encoded transaction to decode
 */
var decodeTransactionCommon = function decodeTransactionCommon(bin) {
  var transactionRead = readTransactionCommon({
    bin: bin,
    index: 0
  });
  if (typeof transactionRead === 'string') {
    return transactionRead;
  }
  if (transactionRead.position.index !== bin.length) {
    return formatError$1(TransactionDecodingError.endsWithUnexpectedBytes, "Encoded transaction ends at index ".concat(transactionRead.position.index - 1, ", leaving ").concat(bin.length - transactionRead.position.index, " remaining bytes."));
  }
  return transactionRead.result;
};
var decodeTransactionBCH = decodeTransactionCommon;
var decodeTransaction = decodeTransactionBCH;
/**
 * Decode a {@link TransactionCommon} from a trusted source according to the
 * version 1/2 P2P network transaction format.
 *
 * Note: this method throws runtime errors when attempting to decode messages
 * which do not properly follow the transaction format. If the input is
 * untrusted, use {@link decodeTransactionCommon}.
 *
 * @param bin - the raw message to decode
 */
var decodeTransactionUnsafeCommon = function decodeTransactionUnsafeCommon(bin) {
  var result = decodeTransactionCommon(bin);
  if (typeof result === 'string') {
    // eslint-disable-next-line functional/no-throw-statement
    throw new Error(result);
  }
  return result;
};
var decodeTransactionUnsafeBCH = decodeTransactionUnsafeCommon;
var decodeTransactionUnsafe = decodeTransactionUnsafeBCH;
/**
 * Encode a {@link Transaction} using the standard P2P network format. This
 * serialization is also used when computing the transaction's hash (A.K.A.
 * "transaction ID" or "TXID").
 */
var encodeTransactionCommon = function encodeTransactionCommon(tx) {
  return flattenBinArray([numberToBinUint32LE(tx.version), encodeTransactionInputs(tx.inputs), encodeTransactionOutputs(tx.outputs), numberToBinUint32LE(tx.locktime)]);
};
var encodeTransactionBCH = encodeTransactionCommon;
var encodeTransaction = encodeTransactionBCH;
var cloneTransactionInputsCommon = function cloneTransactionInputsCommon(inputs) {
  return inputs.map(function (input) {
    return {
      outpointIndex: input.outpointIndex,
      outpointTransactionHash: input.outpointTransactionHash.slice(),
      sequenceNumber: input.sequenceNumber,
      unlockingBytecode: input.unlockingBytecode.slice()
    };
  });
};
var cloneTransactionOutputsCommon = function cloneTransactionOutputsCommon(outputs) {
  return outputs.map(function (output) {
    return _objectSpread2(_objectSpread2({
      lockingBytecode: output.lockingBytecode.slice()
    }, output.token === undefined ? {} : {
      token: _objectSpread2({
        amount: output.token.amount,
        category: output.token.category.slice()
      }, output.token.nft === undefined ? {} : {
        nft: {
          capability: output.token.nft.capability,
          commitment: output.token.nft.commitment.slice()
        }
      })
    }), {}, {
      valueSatoshis: output.valueSatoshis
    });
  });
};
var cloneTransactionCommon = function cloneTransactionCommon(transaction) {
  return {
    inputs: cloneTransactionInputsCommon(transaction.inputs),
    locktime: transaction.locktime,
    outputs: cloneTransactionOutputsCommon(transaction.outputs),
    version: transaction.version
  };
};
/**
 * Compute a transaction hash (A.K.A. "transaction ID" or "TXID") from an
 * encoded transaction in P2P network message order. This is the byte order
 * produced by most sha256 libraries and used by encoded P2P network messages.
 * It is also the byte order produced by `OP_SHA256` and `OP_HASH256` in the
 * virtual machine.
 *
 * @returns the transaction hash in P2P network message byte order
 *
 * @param transaction - the encoded transaction
 * @param sha256 - an implementation of sha256
 */
var hashTransactionP2pOrder = function hashTransactionP2pOrder(transaction) {
  var sha256 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : sha256$1;
  return hash256(transaction, sha256);
};
/**
 * Compute a transaction hash (A.K.A. "transaction ID" or "TXID") from an
 * encoded transaction in user interface byte order. This is the byte order
 * typically used by block explorers, wallets, and other user interfaces.
 *
 * To return this result as a `string`, use {@link hashTransaction}.
 *
 * @returns the transaction hash in User Interface byte order
 *
 * @param transaction - the encoded transaction
 * @param sha256 - an implementation of sha256
 */
var hashTransactionUiOrder = function hashTransactionUiOrder(transaction) {
  var sha256 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : sha256$1;
  return hashTransactionP2pOrder(transaction, sha256).reverse();
};
/**
 * Return an encoded {@link Transaction}'s hash/ID as a string in user interface
 * byte order (typically used by wallets and block explorers).
 *
 * To return this result as a `Uint8Array`, use {@link hashTransactionUiOrder}.
 *
 * @param transaction - the encoded transaction
 */
var hashTransaction = function hashTransaction(transaction) {
  return binToHex(hashTransactionUiOrder(transaction));
};
/**
 * Encode all outpoints in a series of transaction inputs. (For use in
 * {@link hashTransactionOutpoints}.)
 *
 * @param inputs - the series of inputs from which to extract the outpoints
 */
var encodeTransactionOutpoints = function encodeTransactionOutpoints(inputs) {
  return flattenBinArray(inputs.map(function (i) {
    return flattenBinArray([i.outpointTransactionHash.slice().reverse(), numberToBinUint32LE(i.outpointIndex)]);
  }));
};
/**
 * Encode an array of transaction {@link Output}s for use in transaction signing
 * serializations. Note, this encoding differs from
 * {@link encodeTransactionOutputs} (used for encoding full transactions).
 *
 * @param outputs - the array of outputs to encode
 */
var encodeTransactionOutputsForSigning = function encodeTransactionOutputsForSigning(outputs) {
  return flattenBinArray(outputs.map(encodeTransactionOutput));
};
/**
 * Encode the sequence numbers of an array of transaction inputs for use in
 * transaction signing serializations.
 *
 * @param inputs - the array of inputs from which to extract the sequence
 * numbers
 */
var encodeTransactionInputSequenceNumbersForSigning = function encodeTransactionInputSequenceNumbersForSigning(inputs) {
  return flattenBinArray(inputs.map(function (i) {
    return numberToBinUint32LE(i.sequenceNumber);
  }));
};

/**
 * A.K.A. `sighash` flags
 */
var SigningSerializationFlag;
(function (SigningSerializationFlag) {
  /**
   * A.K.A. `SIGHASH_ALL`
   */
  SigningSerializationFlag[SigningSerializationFlag["allOutputs"] = 1] = "allOutputs";
  /**
   * A.K.A `SIGHASH_NONE`
   */
  SigningSerializationFlag[SigningSerializationFlag["noOutputs"] = 2] = "noOutputs";
  /**
   * A.K.A. `SIGHASH_SINGLE`
   */
  SigningSerializationFlag[SigningSerializationFlag["correspondingOutput"] = 3] = "correspondingOutput";
  /**
   * A.K.A. `SIGHASH_UTXOS`
   */
  SigningSerializationFlag[SigningSerializationFlag["utxos"] = 32] = "utxos";
  SigningSerializationFlag[SigningSerializationFlag["forkId"] = 64] = "forkId";
  /**
   * A.K.A `ANYONE_CAN_PAY`/`SIGHASH_ANYONECANPAY`
   */
  SigningSerializationFlag[SigningSerializationFlag["singleInput"] = 128] = "singleInput";
})(SigningSerializationFlag || (SigningSerializationFlag = {}));
/* eslint-disable no-bitwise, @typescript-eslint/prefer-literal-enum-member */
var SigningSerializationType;
(function (SigningSerializationType) {
  SigningSerializationType[SigningSerializationType["allOutputs"] = 65] = "allOutputs";
  SigningSerializationType[SigningSerializationType["allOutputsAllUtxos"] = 97] = "allOutputsAllUtxos";
  SigningSerializationType[SigningSerializationType["allOutputsSingleInput"] = 193] = "allOutputsSingleInput";
  SigningSerializationType[SigningSerializationType["correspondingOutput"] = 67] = "correspondingOutput";
  SigningSerializationType[SigningSerializationType["correspondingOutputAllUtxos"] = 99] = "correspondingOutputAllUtxos";
  SigningSerializationType[SigningSerializationType["correspondingOutputSingleInput"] = 195] = "correspondingOutputSingleInput";
  SigningSerializationType[SigningSerializationType["noOutputs"] = 66] = "noOutputs";
  SigningSerializationType[SigningSerializationType["noOutputsAllUtxos"] = 98] = "noOutputsAllUtxos";
  SigningSerializationType[SigningSerializationType["noOutputsSingleInput"] = 194] = "noOutputsSingleInput";
})(SigningSerializationType || (SigningSerializationType = {}));
/* eslint-enable no-bitwise, @typescript-eslint/prefer-literal-enum-member */
// eslint-disable-next-line @typescript-eslint/naming-convention
var SigningSerializationTypeBCH = SigningSerializationType;
var match = function match(type, flag) {
  return (
    // eslint-disable-next-line no-bitwise, @typescript-eslint/no-non-null-assertion
    (type[0] & flag) !== 0
  );
};
var equals = function equals(type, flag
// eslint-disable-next-line no-bitwise, @typescript-eslint/no-non-null-assertion
) {
  return (type[0] & 31 /* Internal.mask5Bits */) === flag;
};
var shouldSerializeSingleInput = function shouldSerializeSingleInput(type) {
  return match(type, SigningSerializationFlag.singleInput);
};
var shouldSerializeCorrespondingOutput = function shouldSerializeCorrespondingOutput(type) {
  return equals(type, SigningSerializationFlag.correspondingOutput);
};
var shouldSerializeNoOutputs = function shouldSerializeNoOutputs(type) {
  return equals(type, SigningSerializationFlag.noOutputs);
};
var shouldSerializeUtxos = function shouldSerializeUtxos(type) {
  return match(type, SigningSerializationFlag.utxos);
};
var emptyHash = function emptyHash() {
  return new Uint8Array(32 /* Internal.sha256HashByteLength */).fill(0);
};
/**
 * Return the proper `hashPrevouts` value for a given a signing serialization
 * type.
 */
var hashPrevouts = function hashPrevouts(_ref) {
  var signingSerializationType = _ref.signingSerializationType,
    transactionOutpoints = _ref.transactionOutpoints;
  var sha256 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : sha256$1;
  return shouldSerializeSingleInput(signingSerializationType) ? emptyHash() : hash256(transactionOutpoints, sha256);
};
/**
 * Return the proper `hashUtxos` value for a given a signing serialization
 * type.
 */
var hashUtxos = function hashUtxos(_ref2) {
  var signingSerializationType = _ref2.signingSerializationType,
    transactionUtxos = _ref2.transactionUtxos;
  var sha256 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : sha256$1;
  return shouldSerializeUtxos(signingSerializationType) ? hash256(transactionUtxos, sha256) : Uint8Array.of();
};
/**
 * Return the proper `hashSequence` value for a given a signing serialization
 * type.
 */
var hashSequence = function hashSequence(_ref3) {
  var signingSerializationType = _ref3.signingSerializationType,
    transactionSequenceNumbers = _ref3.transactionSequenceNumbers;
  var sha256 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : sha256$1;
  return !shouldSerializeSingleInput(signingSerializationType) && !shouldSerializeCorrespondingOutput(signingSerializationType) && !shouldSerializeNoOutputs(signingSerializationType) ? hash256(transactionSequenceNumbers, sha256) : emptyHash();
};
/**
 * Return the proper `hashOutputs` value for a given a signing serialization
 * type.
 */
var hashOutputs = function hashOutputs(_ref4) {
  var correspondingOutput = _ref4.correspondingOutput,
    signingSerializationType = _ref4.signingSerializationType,
    transactionOutputs = _ref4.transactionOutputs;
  var sha256 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : sha256$1;
  return !shouldSerializeCorrespondingOutput(signingSerializationType) && !shouldSerializeNoOutputs(signingSerializationType) ? hash256(transactionOutputs, sha256) : shouldSerializeCorrespondingOutput(signingSerializationType) ? correspondingOutput === undefined ? emptyHash() : hash256(correspondingOutput, sha256) : emptyHash();
};
/**
 * Encode the signature-protected properties of a transaction following the
 * algorithm required by the `signingSerializationType` of a signature.
 *
 * Note: When validating transactions with multiple signatures,
 * performance-critical applications should use a memoized sha256 implementation
 * to avoid re-computing hashes.
 */
var encodeSigningSerializationBCH = function encodeSigningSerializationBCH(_ref5) {
  var correspondingOutput = _ref5.correspondingOutput,
    coveredBytecode = _ref5.coveredBytecode,
    _ref5$forkId = _ref5.forkId,
    forkId = _ref5$forkId === void 0 ? new Uint8Array([0, 0, 0]) : _ref5$forkId,
    locktime = _ref5.locktime,
    outpointIndex = _ref5.outpointIndex,
    outpointTransactionHash = _ref5.outpointTransactionHash,
    outputTokenPrefix = _ref5.outputTokenPrefix,
    outputValue = _ref5.outputValue,
    sequenceNumber = _ref5.sequenceNumber,
    signingSerializationType = _ref5.signingSerializationType,
    transactionOutpoints = _ref5.transactionOutpoints,
    transactionOutputs = _ref5.transactionOutputs,
    transactionSequenceNumbers = _ref5.transactionSequenceNumbers,
    transactionUtxos = _ref5.transactionUtxos,
    version = _ref5.version;
  var sha256 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : sha256$1;
  return flattenBinArray([numberToBinUint32LE(version), hashPrevouts({
    signingSerializationType: signingSerializationType,
    transactionOutpoints: transactionOutpoints
  }, sha256), hashUtxos({
    signingSerializationType: signingSerializationType,
    transactionUtxos: transactionUtxos
  }, sha256), hashSequence({
    signingSerializationType: signingSerializationType,
    transactionSequenceNumbers: transactionSequenceNumbers
  }, sha256), outpointTransactionHash.slice().reverse(), numberToBinUint32LE(outpointIndex), outputTokenPrefix, bigIntToCompactSize(BigInt(coveredBytecode.length)), coveredBytecode, outputValue, numberToBinUint32LE(sequenceNumber), hashOutputs({
    correspondingOutput: correspondingOutput,
    signingSerializationType: signingSerializationType,
    transactionOutputs: transactionOutputs
  }, sha256), numberToBinUint32LE(locktime), signingSerializationType, forkId]);
};
/**
 * Generate the encoded components of a BCH signing serialization from
 * compilation context.
 */
var generateSigningSerializationComponentsBCH = function generateSigningSerializationComponentsBCH(context) {
  return {
    correspondingOutput: context.inputIndex < context.transaction.outputs.length ? encodeTransactionOutput(
    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
    context.transaction.outputs[context.inputIndex]) : undefined,
    locktime: context.transaction.locktime,
    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
    outpointIndex: context.transaction.inputs[context.inputIndex].outpointIndex,
    outpointTransactionHash:
    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
    context.transaction.inputs[context.inputIndex].outpointTransactionHash,
    outputTokenPrefix: encodeTokenPrefix(
    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
    context.sourceOutputs[context.inputIndex].token),
    outputValue: valueSatoshisToBin(
    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
    context.sourceOutputs[context.inputIndex].valueSatoshis),
    sequenceNumber:
    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
    context.transaction.inputs[context.inputIndex].sequenceNumber,
    transactionOutpoints: encodeTransactionOutpoints(context.transaction.inputs),
    transactionOutputs: encodeTransactionOutputsForSigning(context.transaction.outputs),
    transactionSequenceNumbers: encodeTransactionInputSequenceNumbersForSigning(context.transaction.inputs),
    transactionUtxos: encodeTransactionOutputsForSigning(context.sourceOutputs),
    version: context.transaction.version
  };
};
/**
 * Generate the signing serialization for a particular transaction input
 * following the algorithm required by the provided `signingSerializationType`.
 *
 * Note: When validating transactions with multiple signatures,
 * performance-critical applications should use a memoized sha256 implementation
 * to avoid re-computing hashes.
 */
var generateSigningSerializationBCH = function generateSigningSerializationBCH(context, _ref6) {
  var coveredBytecode = _ref6.coveredBytecode,
    signingSerializationType = _ref6.signingSerializationType;
  var sha256 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : sha256$1;
  return encodeSigningSerializationBCH(_objectSpread2(_objectSpread2({}, generateSigningSerializationComponentsBCH(context)), {}, {
    coveredBytecode: coveredBytecode,
    signingSerializationType: signingSerializationType
  }), sha256);
};
/**
 * @param signingSerializationType - the 32-bit number indicating the signing
 * serialization algorithm to use
 */
var isLegacySigningSerialization = function isLegacySigningSerialization(signingSerializationType) {
  // eslint-disable-next-line no-bitwise, @typescript-eslint/no-magic-numbers
  var forkValue = signingSerializationType >> 8;
  // eslint-disable-next-line no-bitwise, @typescript-eslint/no-magic-numbers
  var newForkValue = forkValue ^ 0xdead | 0xff0000;
  // eslint-disable-next-line no-bitwise, @typescript-eslint/no-magic-numbers
  var sighashType = newForkValue << 8 | signingSerializationType & 0xff;
  // eslint-disable-next-line no-bitwise
  return (sighashType & SigningSerializationFlag.forkId) === 0;
};

/**
 * Consensus settings for the `BCH_2022_05` instruction set.
 */
var ConsensusCommon;
(function (ConsensusCommon) {
  /**
   * A.K.A. `MAX_SCRIPT_SIZE`
   */
  ConsensusCommon[ConsensusCommon["maximumBytecodeLength"] = 10000] = "maximumBytecodeLength";
  /**
   * A.K.A. `MAX_OP_RETURN_RELAY`, `nMaxDatacarrierBytes`
   */
  ConsensusCommon[ConsensusCommon["maximumDataCarrierBytes"] = 223] = "maximumDataCarrierBytes";
  /**
   * A.K.A. `MAX_OPS_PER_SCRIPT`
   */
  ConsensusCommon[ConsensusCommon["maximumOperationCount"] = 201] = "maximumOperationCount";
  /**
   * A.K.A. `MAX_STACK_SIZE`
   */
  ConsensusCommon[ConsensusCommon["maximumStackDepth"] = 1000] = "maximumStackDepth";
  /**
   * A.K.A. `MAX_SCRIPT_ELEMENT_SIZE`
   */
  ConsensusCommon[ConsensusCommon["maximumStackItemLength"] = 520] = "maximumStackItemLength";
  /**
   * A.K.A. `MAX_STANDARD_VERSION`
   */
  ConsensusCommon[ConsensusCommon["maximumStandardVersion"] = 2] = "maximumStandardVersion";
  /**
   * A.K.A. `MAX_TX_IN_SCRIPT_SIG_SIZE`
   */
  ConsensusCommon[ConsensusCommon["maximumStandardUnlockingBytecodeLength"] = 1650] = "maximumStandardUnlockingBytecodeLength";
  /**
   * A.K.A. `MIN_TX_SIZE`
   */
  ConsensusCommon[ConsensusCommon["minimumTransactionSize"] = 100] = "minimumTransactionSize";
  /**
   * A.K.A. `MAX_STANDARD_TX_SIZE`
   */
  ConsensusCommon[ConsensusCommon["maximumStandardTransactionSize"] = 100000] = "maximumStandardTransactionSize";
  /**
   * A.K.A. `MAX_TX_SIZE`
   */
  ConsensusCommon[ConsensusCommon["maximumTransactionSize"] = 1000000] = "maximumTransactionSize";
  /**
   * A.K.A. `MAXIMUM_ELEMENT_SIZE_64_BIT`
   */
  ConsensusCommon[ConsensusCommon["maximumVmNumberLength"] = 8] = "maximumVmNumberLength";
  ConsensusCommon["minVmNumber"] = "-9223372036854775807";
  ConsensusCommon["maxVmNumber"] = "9223372036854775807";
  ConsensusCommon[ConsensusCommon["schnorrSignatureLength"] = 64] = "schnorrSignatureLength";
})(ConsensusCommon || (ConsensusCommon = {}));
// eslint-disable-next-line @typescript-eslint/naming-convention
var SigningSerializationTypesCommon = [SigningSerializationTypeBCH.allOutputs, SigningSerializationTypeBCH.allOutputsSingleInput, SigningSerializationTypeBCH.correspondingOutput, SigningSerializationTypeBCH.correspondingOutputSingleInput, SigningSerializationTypeBCH.noOutputs, SigningSerializationTypeBCH.noOutputsSingleInput];
// eslint-disable-next-line @typescript-eslint/naming-convention
var SigningSerializationTypesBCH = SigningSerializationTypesCommon;
// eslint-disable-next-line @typescript-eslint/naming-convention
var ConsensusBCH = ConsensusCommon;

var AuthenticationErrorCommon;
(function (AuthenticationErrorCommon) {
  AuthenticationErrorCommon["calledReserved"] = "Program called an unassigned, reserved operation.";
  AuthenticationErrorCommon["calledReturn"] = "Program called an OP_RETURN operation.";
  AuthenticationErrorCommon["calledUpgradableNop"] = "Program called a disallowed upgradable non-operation (OP_NOP1-OP_NOP10).";
  AuthenticationErrorCommon["checkSequenceUnavailable"] = "Program called an OP_CHECKSEQUENCEVERIFY operation, but OP_CHECKSEQUENCEVERIFY requires transaction version 2 or higher.";
  AuthenticationErrorCommon["disabledOpcode"] = "Program contains a disabled opcode.";
  AuthenticationErrorCommon["divisionByZero"] = "Program attempted to divide a number by zero.";
  AuthenticationErrorCommon["emptyAlternateStack"] = "Tried to read from an empty alternate stack.";
  AuthenticationErrorCommon["emptyStack"] = "Tried to read from an empty stack.";
  AuthenticationErrorCommon["exceededMaximumBytecodeLengthLocking"] = "The provided locking bytecode exceeds the maximum bytecode length (10,000 bytes).";
  AuthenticationErrorCommon["exceededMaximumBytecodeLengthUnlocking"] = "The provided unlocking bytecode exceeds the maximum bytecode length (10,000 bytes).";
  AuthenticationErrorCommon["exceededMaximumVmNumberLength"] = "Program attempted an OP_BIN2NUM operation on a byte sequence that cannot be encoded within the maximum VM Number length.";
  AuthenticationErrorCommon["exceededMaximumStackDepth"] = "Program exceeded the maximum stack depth (1,000 items).";
  AuthenticationErrorCommon["exceededMaximumStackItemLength"] = "Program attempted to push a stack item that exceeded the maximum stack item length (520 bytes).";
  AuthenticationErrorCommon["exceededMaximumOperationCount"] = "Program exceeded the maximum operation count (201 operations).";
  AuthenticationErrorCommon["exceedsMaximumMultisigPublicKeyCount"] = "Program called an OP_CHECKMULTISIG that exceeds the maximum public key count (20 public keys).";
  AuthenticationErrorCommon["failedVerify"] = "Program failed an OP_VERIFY operation.";
  AuthenticationErrorCommon["invalidStackIndex"] = "Tried to read from an invalid stack index.";
  AuthenticationErrorCommon["incompatibleLocktimeType"] = "Program called an OP_CHECKLOCKTIMEVERIFY operation with an incompatible locktime type. The transaction locktime and required locktime must both refer to either a block height or a block time.";
  AuthenticationErrorCommon["incompatibleSequenceType"] = "Program called an OP_CHECKSEQUENCEVERIFY operation with an incompatible sequence type flag. The input sequence number and required sequence number must both use the same sequence locktime type.";
  AuthenticationErrorCommon["insufficientLength"] = "Program called an OP_NUM2BIN operation with an insufficient byte length to re-encode the provided number.";
  AuthenticationErrorCommon["insufficientPublicKeys"] = "Program called an OP_CHECKMULTISIG operation that requires signatures from more public keys than are provided.";
  AuthenticationErrorCommon["invalidNaturalNumber"] = "Invalid input: the key/signature count inputs for OP_CHECKMULTISIG require a natural number (n > 0).";
  AuthenticationErrorCommon["invalidProtocolBugValue"] = "The OP_CHECKMULTISIG protocol bug value must be a VM Number 0 (to comply with the \"NULLDUMMY\" rule).";
  AuthenticationErrorCommon["invalidPublicKeyEncoding"] = "Encountered an improperly encoded public key.";
  AuthenticationErrorCommon["invalidVmNumber"] = "Invalid input: this operation requires a valid VM Number.";
  AuthenticationErrorCommon["invalidSignatureEncoding"] = "Encountered an improperly encoded signature.";
  AuthenticationErrorCommon["invalidSplitIndex"] = "Program called an OP_SPLIT operation with an invalid index.";
  AuthenticationErrorCommon["invalidTransactionInputIndex"] = "Program attempted to read from an invalid transaction input index.";
  AuthenticationErrorCommon["invalidTransactionOutputIndex"] = "Program attempted to read from an invalid transaction output index.";
  AuthenticationErrorCommon["invalidTransactionUtxoIndex"] = "Program attempted to read from an invalid transaction UTXO index.";
  AuthenticationErrorCommon["locktimeDisabled"] = "Program called an OP_CHECKLOCKTIMEVERIFY operation, but locktime is disabled for this transaction.";
  AuthenticationErrorCommon["mismatchedBitwiseOperandLength"] = "Program attempted a bitwise operation on operands of different lengths.";
  AuthenticationErrorCommon["malformedLockingBytecode"] = "The provided locking bytecode is malformed.";
  AuthenticationErrorCommon["malformedP2shBytecode"] = "Redeem bytecode was malformed prior to P2SH evaluation.";
  AuthenticationErrorCommon["malformedPush"] = "Program must be long enough to push the requested number of bytes.";
  AuthenticationErrorCommon["malformedUnlockingBytecode"] = "The provided unlocking bytecode is malformed.";
  AuthenticationErrorCommon["negativeLocktime"] = "Program called an OP_CHECKLOCKTIMEVERIFY or OP_CHECKSEQUENCEVERIFY operation with a negative locktime.";
  AuthenticationErrorCommon["nonEmptyControlStack"] = "The active bytecode completed with a non-empty control stack (missing `OP_ENDIF`).";
  AuthenticationErrorCommon["nonMinimalPush"] = "Push operations must use the smallest possible encoding.";
  AuthenticationErrorCommon["nonNullSignatureFailure"] = "Program failed a signature verification with a non-null signature (violating the \"NULLFAIL\" rule).";
  AuthenticationErrorCommon["overflowsVmNumberRange"] = "Program attempted an arithmetic operation which exceeds the range of VM Numbers.";
  AuthenticationErrorCommon["requiresCleanStack"] = "Program completed with an unexpected number of items on the stack (must be exactly 1).";
  AuthenticationErrorCommon["requiresPushOnly"] = "Unlocking bytecode may contain only push operations.";
  AuthenticationErrorCommon["schnorrSizedSignatureInCheckMultiSig"] = "Program used a schnorr-sized signature (65 bytes) in an OP_CHECKMULTISIG operation.";
  AuthenticationErrorCommon["unexpectedElse"] = "Encountered an OP_ELSE outside of an OP_IF ... OP_ENDIF block.";
  AuthenticationErrorCommon["unexpectedEndIf"] = "Encountered an OP_ENDIF that is not following a matching OP_IF.";
  AuthenticationErrorCommon["unknownOpcode"] = "Called an unknown opcode.";
  AuthenticationErrorCommon["unmatchedSequenceDisable"] = "Program called an OP_CHECKSEQUENCEVERIFY operation requiring the disable flag, but the input's sequence number is missing the disable flag.";
  AuthenticationErrorCommon["unsatisfiedLocktime"] = "Program called an OP_CHECKLOCKTIMEVERIFY operation that requires a locktime greater than the transaction's locktime.";
  AuthenticationErrorCommon["unsatisfiedSequenceNumber"] = "Program called an OP_CHECKSEQUENCEVERIFY operation that requires a sequence number greater than the input's sequence number.";
  AuthenticationErrorCommon["unsuccessfulEvaluation"] = "Unsuccessful evaluation: completed with a non-truthy value on top of the stack.";
})(AuthenticationErrorCommon || (AuthenticationErrorCommon = {}));
/**
 * Applies the `error` to a `state`.
 *
 * @remarks
 * If the state already has an error, this method does not override it.
 * (Evaluation should end after the first encountered error, so further errors
 * aren't relevant.)
 */
var applyError = function applyError(state, errorType, errorDetails) {
  return _objectSpread2(_objectSpread2({}, state), {}, {
    error: state.error === undefined ? formatError$1(errorType, errorDetails) : state.error
  });
};

/**
 * The `BCH_2023_05` instruction set.
 */
var OpcodesBCH2023;
(function (OpcodesBCH2023) {
  /**
   * A.K.A. `OP_FALSE` or `OP_PUSHBYTES_0`
   */
  OpcodesBCH2023[OpcodesBCH2023["OP_0"] = 0] = "OP_0";
  OpcodesBCH2023[OpcodesBCH2023["OP_PUSHBYTES_1"] = 1] = "OP_PUSHBYTES_1";
  OpcodesBCH2023[OpcodesBCH2023["OP_PUSHBYTES_2"] = 2] = "OP_PUSHBYTES_2";
  OpcodesBCH2023[OpcodesBCH2023["OP_PUSHBYTES_3"] = 3] = "OP_PUSHBYTES_3";
  OpcodesBCH2023[OpcodesBCH2023["OP_PUSHBYTES_4"] = 4] = "OP_PUSHBYTES_4";
  OpcodesBCH2023[OpcodesBCH2023["OP_PUSHBYTES_5"] = 5] = "OP_PUSHBYTES_5";
  OpcodesBCH2023[OpcodesBCH2023["OP_PUSHBYTES_6"] = 6] = "OP_PUSHBYTES_6";
  OpcodesBCH2023[OpcodesBCH2023["OP_PUSHBYTES_7"] = 7] = "OP_PUSHBYTES_7";
  OpcodesBCH2023[OpcodesBCH2023["OP_PUSHBYTES_8"] = 8] = "OP_PUSHBYTES_8";
  OpcodesBCH2023[OpcodesBCH2023["OP_PUSHBYTES_9"] = 9] = "OP_PUSHBYTES_9";
  OpcodesBCH2023[OpcodesBCH2023["OP_PUSHBYTES_10"] = 10] = "OP_PUSHBYTES_10";
  OpcodesBCH2023[OpcodesBCH2023["OP_PUSHBYTES_11"] = 11] = "OP_PUSHBYTES_11";
  OpcodesBCH2023[OpcodesBCH2023["OP_PUSHBYTES_12"] = 12] = "OP_PUSHBYTES_12";
  OpcodesBCH2023[OpcodesBCH2023["OP_PUSHBYTES_13"] = 13] = "OP_PUSHBYTES_13";
  OpcodesBCH2023[OpcodesBCH2023["OP_PUSHBYTES_14"] = 14] = "OP_PUSHBYTES_14";
  OpcodesBCH2023[OpcodesBCH2023["OP_PUSHBYTES_15"] = 15] = "OP_PUSHBYTES_15";
  OpcodesBCH2023[OpcodesBCH2023["OP_PUSHBYTES_16"] = 16] = "OP_PUSHBYTES_16";
  OpcodesBCH2023[OpcodesBCH2023["OP_PUSHBYTES_17"] = 17] = "OP_PUSHBYTES_17";
  OpcodesBCH2023[OpcodesBCH2023["OP_PUSHBYTES_18"] = 18] = "OP_PUSHBYTES_18";
  OpcodesBCH2023[OpcodesBCH2023["OP_PUSHBYTES_19"] = 19] = "OP_PUSHBYTES_19";
  OpcodesBCH2023[OpcodesBCH2023["OP_PUSHBYTES_20"] = 20] = "OP_PUSHBYTES_20";
  OpcodesBCH2023[OpcodesBCH2023["OP_PUSHBYTES_21"] = 21] = "OP_PUSHBYTES_21";
  OpcodesBCH2023[OpcodesBCH2023["OP_PUSHBYTES_22"] = 22] = "OP_PUSHBYTES_22";
  OpcodesBCH2023[OpcodesBCH2023["OP_PUSHBYTES_23"] = 23] = "OP_PUSHBYTES_23";
  OpcodesBCH2023[OpcodesBCH2023["OP_PUSHBYTES_24"] = 24] = "OP_PUSHBYTES_24";
  OpcodesBCH2023[OpcodesBCH2023["OP_PUSHBYTES_25"] = 25] = "OP_PUSHBYTES_25";
  OpcodesBCH2023[OpcodesBCH2023["OP_PUSHBYTES_26"] = 26] = "OP_PUSHBYTES_26";
  OpcodesBCH2023[OpcodesBCH2023["OP_PUSHBYTES_27"] = 27] = "OP_PUSHBYTES_27";
  OpcodesBCH2023[OpcodesBCH2023["OP_PUSHBYTES_28"] = 28] = "OP_PUSHBYTES_28";
  OpcodesBCH2023[OpcodesBCH2023["OP_PUSHBYTES_29"] = 29] = "OP_PUSHBYTES_29";
  OpcodesBCH2023[OpcodesBCH2023["OP_PUSHBYTES_30"] = 30] = "OP_PUSHBYTES_30";
  OpcodesBCH2023[OpcodesBCH2023["OP_PUSHBYTES_31"] = 31] = "OP_PUSHBYTES_31";
  OpcodesBCH2023[OpcodesBCH2023["OP_PUSHBYTES_32"] = 32] = "OP_PUSHBYTES_32";
  OpcodesBCH2023[OpcodesBCH2023["OP_PUSHBYTES_33"] = 33] = "OP_PUSHBYTES_33";
  OpcodesBCH2023[OpcodesBCH2023["OP_PUSHBYTES_34"] = 34] = "OP_PUSHBYTES_34";
  OpcodesBCH2023[OpcodesBCH2023["OP_PUSHBYTES_35"] = 35] = "OP_PUSHBYTES_35";
  OpcodesBCH2023[OpcodesBCH2023["OP_PUSHBYTES_36"] = 36] = "OP_PUSHBYTES_36";
  OpcodesBCH2023[OpcodesBCH2023["OP_PUSHBYTES_37"] = 37] = "OP_PUSHBYTES_37";
  OpcodesBCH2023[OpcodesBCH2023["OP_PUSHBYTES_38"] = 38] = "OP_PUSHBYTES_38";
  OpcodesBCH2023[OpcodesBCH2023["OP_PUSHBYTES_39"] = 39] = "OP_PUSHBYTES_39";
  OpcodesBCH2023[OpcodesBCH2023["OP_PUSHBYTES_40"] = 40] = "OP_PUSHBYTES_40";
  OpcodesBCH2023[OpcodesBCH2023["OP_PUSHBYTES_41"] = 41] = "OP_PUSHBYTES_41";
  OpcodesBCH2023[OpcodesBCH2023["OP_PUSHBYTES_42"] = 42] = "OP_PUSHBYTES_42";
  OpcodesBCH2023[OpcodesBCH2023["OP_PUSHBYTES_43"] = 43] = "OP_PUSHBYTES_43";
  OpcodesBCH2023[OpcodesBCH2023["OP_PUSHBYTES_44"] = 44] = "OP_PUSHBYTES_44";
  OpcodesBCH2023[OpcodesBCH2023["OP_PUSHBYTES_45"] = 45] = "OP_PUSHBYTES_45";
  OpcodesBCH2023[OpcodesBCH2023["OP_PUSHBYTES_46"] = 46] = "OP_PUSHBYTES_46";
  OpcodesBCH2023[OpcodesBCH2023["OP_PUSHBYTES_47"] = 47] = "OP_PUSHBYTES_47";
  OpcodesBCH2023[OpcodesBCH2023["OP_PUSHBYTES_48"] = 48] = "OP_PUSHBYTES_48";
  OpcodesBCH2023[OpcodesBCH2023["OP_PUSHBYTES_49"] = 49] = "OP_PUSHBYTES_49";
  OpcodesBCH2023[OpcodesBCH2023["OP_PUSHBYTES_50"] = 50] = "OP_PUSHBYTES_50";
  OpcodesBCH2023[OpcodesBCH2023["OP_PUSHBYTES_51"] = 51] = "OP_PUSHBYTES_51";
  OpcodesBCH2023[OpcodesBCH2023["OP_PUSHBYTES_52"] = 52] = "OP_PUSHBYTES_52";
  OpcodesBCH2023[OpcodesBCH2023["OP_PUSHBYTES_53"] = 53] = "OP_PUSHBYTES_53";
  OpcodesBCH2023[OpcodesBCH2023["OP_PUSHBYTES_54"] = 54] = "OP_PUSHBYTES_54";
  OpcodesBCH2023[OpcodesBCH2023["OP_PUSHBYTES_55"] = 55] = "OP_PUSHBYTES_55";
  OpcodesBCH2023[OpcodesBCH2023["OP_PUSHBYTES_56"] = 56] = "OP_PUSHBYTES_56";
  OpcodesBCH2023[OpcodesBCH2023["OP_PUSHBYTES_57"] = 57] = "OP_PUSHBYTES_57";
  OpcodesBCH2023[OpcodesBCH2023["OP_PUSHBYTES_58"] = 58] = "OP_PUSHBYTES_58";
  OpcodesBCH2023[OpcodesBCH2023["OP_PUSHBYTES_59"] = 59] = "OP_PUSHBYTES_59";
  OpcodesBCH2023[OpcodesBCH2023["OP_PUSHBYTES_60"] = 60] = "OP_PUSHBYTES_60";
  OpcodesBCH2023[OpcodesBCH2023["OP_PUSHBYTES_61"] = 61] = "OP_PUSHBYTES_61";
  OpcodesBCH2023[OpcodesBCH2023["OP_PUSHBYTES_62"] = 62] = "OP_PUSHBYTES_62";
  OpcodesBCH2023[OpcodesBCH2023["OP_PUSHBYTES_63"] = 63] = "OP_PUSHBYTES_63";
  OpcodesBCH2023[OpcodesBCH2023["OP_PUSHBYTES_64"] = 64] = "OP_PUSHBYTES_64";
  OpcodesBCH2023[OpcodesBCH2023["OP_PUSHBYTES_65"] = 65] = "OP_PUSHBYTES_65";
  OpcodesBCH2023[OpcodesBCH2023["OP_PUSHBYTES_66"] = 66] = "OP_PUSHBYTES_66";
  OpcodesBCH2023[OpcodesBCH2023["OP_PUSHBYTES_67"] = 67] = "OP_PUSHBYTES_67";
  OpcodesBCH2023[OpcodesBCH2023["OP_PUSHBYTES_68"] = 68] = "OP_PUSHBYTES_68";
  OpcodesBCH2023[OpcodesBCH2023["OP_PUSHBYTES_69"] = 69] = "OP_PUSHBYTES_69";
  OpcodesBCH2023[OpcodesBCH2023["OP_PUSHBYTES_70"] = 70] = "OP_PUSHBYTES_70";
  OpcodesBCH2023[OpcodesBCH2023["OP_PUSHBYTES_71"] = 71] = "OP_PUSHBYTES_71";
  OpcodesBCH2023[OpcodesBCH2023["OP_PUSHBYTES_72"] = 72] = "OP_PUSHBYTES_72";
  OpcodesBCH2023[OpcodesBCH2023["OP_PUSHBYTES_73"] = 73] = "OP_PUSHBYTES_73";
  OpcodesBCH2023[OpcodesBCH2023["OP_PUSHBYTES_74"] = 74] = "OP_PUSHBYTES_74";
  OpcodesBCH2023[OpcodesBCH2023["OP_PUSHBYTES_75"] = 75] = "OP_PUSHBYTES_75";
  OpcodesBCH2023[OpcodesBCH2023["OP_PUSHDATA_1"] = 76] = "OP_PUSHDATA_1";
  OpcodesBCH2023[OpcodesBCH2023["OP_PUSHDATA_2"] = 77] = "OP_PUSHDATA_2";
  OpcodesBCH2023[OpcodesBCH2023["OP_PUSHDATA_4"] = 78] = "OP_PUSHDATA_4";
  OpcodesBCH2023[OpcodesBCH2023["OP_1NEGATE"] = 79] = "OP_1NEGATE";
  OpcodesBCH2023[OpcodesBCH2023["OP_RESERVED"] = 80] = "OP_RESERVED";
  /**
   * A.K.A. `OP_TRUE`
   */
  OpcodesBCH2023[OpcodesBCH2023["OP_1"] = 81] = "OP_1";
  OpcodesBCH2023[OpcodesBCH2023["OP_2"] = 82] = "OP_2";
  OpcodesBCH2023[OpcodesBCH2023["OP_3"] = 83] = "OP_3";
  OpcodesBCH2023[OpcodesBCH2023["OP_4"] = 84] = "OP_4";
  OpcodesBCH2023[OpcodesBCH2023["OP_5"] = 85] = "OP_5";
  OpcodesBCH2023[OpcodesBCH2023["OP_6"] = 86] = "OP_6";
  OpcodesBCH2023[OpcodesBCH2023["OP_7"] = 87] = "OP_7";
  OpcodesBCH2023[OpcodesBCH2023["OP_8"] = 88] = "OP_8";
  OpcodesBCH2023[OpcodesBCH2023["OP_9"] = 89] = "OP_9";
  OpcodesBCH2023[OpcodesBCH2023["OP_10"] = 90] = "OP_10";
  OpcodesBCH2023[OpcodesBCH2023["OP_11"] = 91] = "OP_11";
  OpcodesBCH2023[OpcodesBCH2023["OP_12"] = 92] = "OP_12";
  OpcodesBCH2023[OpcodesBCH2023["OP_13"] = 93] = "OP_13";
  OpcodesBCH2023[OpcodesBCH2023["OP_14"] = 94] = "OP_14";
  OpcodesBCH2023[OpcodesBCH2023["OP_15"] = 95] = "OP_15";
  OpcodesBCH2023[OpcodesBCH2023["OP_16"] = 96] = "OP_16";
  OpcodesBCH2023[OpcodesBCH2023["OP_NOP"] = 97] = "OP_NOP";
  OpcodesBCH2023[OpcodesBCH2023["OP_VER"] = 98] = "OP_VER";
  OpcodesBCH2023[OpcodesBCH2023["OP_IF"] = 99] = "OP_IF";
  OpcodesBCH2023[OpcodesBCH2023["OP_NOTIF"] = 100] = "OP_NOTIF";
  OpcodesBCH2023[OpcodesBCH2023["OP_VERIF"] = 101] = "OP_VERIF";
  OpcodesBCH2023[OpcodesBCH2023["OP_VERNOTIF"] = 102] = "OP_VERNOTIF";
  OpcodesBCH2023[OpcodesBCH2023["OP_ELSE"] = 103] = "OP_ELSE";
  OpcodesBCH2023[OpcodesBCH2023["OP_ENDIF"] = 104] = "OP_ENDIF";
  OpcodesBCH2023[OpcodesBCH2023["OP_VERIFY"] = 105] = "OP_VERIFY";
  OpcodesBCH2023[OpcodesBCH2023["OP_RETURN"] = 106] = "OP_RETURN";
  OpcodesBCH2023[OpcodesBCH2023["OP_TOALTSTACK"] = 107] = "OP_TOALTSTACK";
  OpcodesBCH2023[OpcodesBCH2023["OP_FROMALTSTACK"] = 108] = "OP_FROMALTSTACK";
  OpcodesBCH2023[OpcodesBCH2023["OP_2DROP"] = 109] = "OP_2DROP";
  OpcodesBCH2023[OpcodesBCH2023["OP_2DUP"] = 110] = "OP_2DUP";
  OpcodesBCH2023[OpcodesBCH2023["OP_3DUP"] = 111] = "OP_3DUP";
  OpcodesBCH2023[OpcodesBCH2023["OP_2OVER"] = 112] = "OP_2OVER";
  OpcodesBCH2023[OpcodesBCH2023["OP_2ROT"] = 113] = "OP_2ROT";
  OpcodesBCH2023[OpcodesBCH2023["OP_2SWAP"] = 114] = "OP_2SWAP";
  OpcodesBCH2023[OpcodesBCH2023["OP_IFDUP"] = 115] = "OP_IFDUP";
  OpcodesBCH2023[OpcodesBCH2023["OP_DEPTH"] = 116] = "OP_DEPTH";
  OpcodesBCH2023[OpcodesBCH2023["OP_DROP"] = 117] = "OP_DROP";
  OpcodesBCH2023[OpcodesBCH2023["OP_DUP"] = 118] = "OP_DUP";
  OpcodesBCH2023[OpcodesBCH2023["OP_NIP"] = 119] = "OP_NIP";
  OpcodesBCH2023[OpcodesBCH2023["OP_OVER"] = 120] = "OP_OVER";
  OpcodesBCH2023[OpcodesBCH2023["OP_PICK"] = 121] = "OP_PICK";
  OpcodesBCH2023[OpcodesBCH2023["OP_ROLL"] = 122] = "OP_ROLL";
  OpcodesBCH2023[OpcodesBCH2023["OP_ROT"] = 123] = "OP_ROT";
  OpcodesBCH2023[OpcodesBCH2023["OP_SWAP"] = 124] = "OP_SWAP";
  OpcodesBCH2023[OpcodesBCH2023["OP_TUCK"] = 125] = "OP_TUCK";
  OpcodesBCH2023[OpcodesBCH2023["OP_CAT"] = 126] = "OP_CAT";
  OpcodesBCH2023[OpcodesBCH2023["OP_SPLIT"] = 127] = "OP_SPLIT";
  OpcodesBCH2023[OpcodesBCH2023["OP_NUM2BIN"] = 128] = "OP_NUM2BIN";
  OpcodesBCH2023[OpcodesBCH2023["OP_BIN2NUM"] = 129] = "OP_BIN2NUM";
  OpcodesBCH2023[OpcodesBCH2023["OP_SIZE"] = 130] = "OP_SIZE";
  OpcodesBCH2023[OpcodesBCH2023["OP_INVERT"] = 131] = "OP_INVERT";
  OpcodesBCH2023[OpcodesBCH2023["OP_AND"] = 132] = "OP_AND";
  OpcodesBCH2023[OpcodesBCH2023["OP_OR"] = 133] = "OP_OR";
  OpcodesBCH2023[OpcodesBCH2023["OP_XOR"] = 134] = "OP_XOR";
  OpcodesBCH2023[OpcodesBCH2023["OP_EQUAL"] = 135] = "OP_EQUAL";
  OpcodesBCH2023[OpcodesBCH2023["OP_EQUALVERIFY"] = 136] = "OP_EQUALVERIFY";
  OpcodesBCH2023[OpcodesBCH2023["OP_RESERVED1"] = 137] = "OP_RESERVED1";
  OpcodesBCH2023[OpcodesBCH2023["OP_RESERVED2"] = 138] = "OP_RESERVED2";
  OpcodesBCH2023[OpcodesBCH2023["OP_1ADD"] = 139] = "OP_1ADD";
  OpcodesBCH2023[OpcodesBCH2023["OP_1SUB"] = 140] = "OP_1SUB";
  OpcodesBCH2023[OpcodesBCH2023["OP_2MUL"] = 141] = "OP_2MUL";
  OpcodesBCH2023[OpcodesBCH2023["OP_2DIV"] = 142] = "OP_2DIV";
  OpcodesBCH2023[OpcodesBCH2023["OP_NEGATE"] = 143] = "OP_NEGATE";
  OpcodesBCH2023[OpcodesBCH2023["OP_ABS"] = 144] = "OP_ABS";
  OpcodesBCH2023[OpcodesBCH2023["OP_NOT"] = 145] = "OP_NOT";
  OpcodesBCH2023[OpcodesBCH2023["OP_0NOTEQUAL"] = 146] = "OP_0NOTEQUAL";
  OpcodesBCH2023[OpcodesBCH2023["OP_ADD"] = 147] = "OP_ADD";
  OpcodesBCH2023[OpcodesBCH2023["OP_SUB"] = 148] = "OP_SUB";
  OpcodesBCH2023[OpcodesBCH2023["OP_MUL"] = 149] = "OP_MUL";
  OpcodesBCH2023[OpcodesBCH2023["OP_DIV"] = 150] = "OP_DIV";
  OpcodesBCH2023[OpcodesBCH2023["OP_MOD"] = 151] = "OP_MOD";
  OpcodesBCH2023[OpcodesBCH2023["OP_LSHIFT"] = 152] = "OP_LSHIFT";
  OpcodesBCH2023[OpcodesBCH2023["OP_RSHIFT"] = 153] = "OP_RSHIFT";
  OpcodesBCH2023[OpcodesBCH2023["OP_BOOLAND"] = 154] = "OP_BOOLAND";
  OpcodesBCH2023[OpcodesBCH2023["OP_BOOLOR"] = 155] = "OP_BOOLOR";
  OpcodesBCH2023[OpcodesBCH2023["OP_NUMEQUAL"] = 156] = "OP_NUMEQUAL";
  OpcodesBCH2023[OpcodesBCH2023["OP_NUMEQUALVERIFY"] = 157] = "OP_NUMEQUALVERIFY";
  OpcodesBCH2023[OpcodesBCH2023["OP_NUMNOTEQUAL"] = 158] = "OP_NUMNOTEQUAL";
  OpcodesBCH2023[OpcodesBCH2023["OP_LESSTHAN"] = 159] = "OP_LESSTHAN";
  OpcodesBCH2023[OpcodesBCH2023["OP_GREATERTHAN"] = 160] = "OP_GREATERTHAN";
  OpcodesBCH2023[OpcodesBCH2023["OP_LESSTHANOREQUAL"] = 161] = "OP_LESSTHANOREQUAL";
  OpcodesBCH2023[OpcodesBCH2023["OP_GREATERTHANOREQUAL"] = 162] = "OP_GREATERTHANOREQUAL";
  OpcodesBCH2023[OpcodesBCH2023["OP_MIN"] = 163] = "OP_MIN";
  OpcodesBCH2023[OpcodesBCH2023["OP_MAX"] = 164] = "OP_MAX";
  OpcodesBCH2023[OpcodesBCH2023["OP_WITHIN"] = 165] = "OP_WITHIN";
  OpcodesBCH2023[OpcodesBCH2023["OP_RIPEMD160"] = 166] = "OP_RIPEMD160";
  OpcodesBCH2023[OpcodesBCH2023["OP_SHA1"] = 167] = "OP_SHA1";
  OpcodesBCH2023[OpcodesBCH2023["OP_SHA256"] = 168] = "OP_SHA256";
  OpcodesBCH2023[OpcodesBCH2023["OP_HASH160"] = 169] = "OP_HASH160";
  OpcodesBCH2023[OpcodesBCH2023["OP_HASH256"] = 170] = "OP_HASH256";
  OpcodesBCH2023[OpcodesBCH2023["OP_CODESEPARATOR"] = 171] = "OP_CODESEPARATOR";
  OpcodesBCH2023[OpcodesBCH2023["OP_CHECKSIG"] = 172] = "OP_CHECKSIG";
  OpcodesBCH2023[OpcodesBCH2023["OP_CHECKSIGVERIFY"] = 173] = "OP_CHECKSIGVERIFY";
  OpcodesBCH2023[OpcodesBCH2023["OP_CHECKMULTISIG"] = 174] = "OP_CHECKMULTISIG";
  OpcodesBCH2023[OpcodesBCH2023["OP_CHECKMULTISIGVERIFY"] = 175] = "OP_CHECKMULTISIGVERIFY";
  OpcodesBCH2023[OpcodesBCH2023["OP_NOP1"] = 176] = "OP_NOP1";
  OpcodesBCH2023[OpcodesBCH2023["OP_CHECKLOCKTIMEVERIFY"] = 177] = "OP_CHECKLOCKTIMEVERIFY";
  OpcodesBCH2023[OpcodesBCH2023["OP_CHECKSEQUENCEVERIFY"] = 178] = "OP_CHECKSEQUENCEVERIFY";
  OpcodesBCH2023[OpcodesBCH2023["OP_NOP4"] = 179] = "OP_NOP4";
  OpcodesBCH2023[OpcodesBCH2023["OP_NOP5"] = 180] = "OP_NOP5";
  OpcodesBCH2023[OpcodesBCH2023["OP_NOP6"] = 181] = "OP_NOP6";
  OpcodesBCH2023[OpcodesBCH2023["OP_NOP7"] = 182] = "OP_NOP7";
  OpcodesBCH2023[OpcodesBCH2023["OP_NOP8"] = 183] = "OP_NOP8";
  OpcodesBCH2023[OpcodesBCH2023["OP_NOP9"] = 184] = "OP_NOP9";
  OpcodesBCH2023[OpcodesBCH2023["OP_NOP10"] = 185] = "OP_NOP10";
  OpcodesBCH2023[OpcodesBCH2023["OP_CHECKDATASIG"] = 186] = "OP_CHECKDATASIG";
  OpcodesBCH2023[OpcodesBCH2023["OP_CHECKDATASIGVERIFY"] = 187] = "OP_CHECKDATASIGVERIFY";
  OpcodesBCH2023[OpcodesBCH2023["OP_REVERSEBYTES"] = 188] = "OP_REVERSEBYTES";
  /**
   * First codepoint left undefined before nullary introspection operations.
   */
  OpcodesBCH2023[OpcodesBCH2023["OP_UNKNOWN189"] = 189] = "OP_UNKNOWN189";
  OpcodesBCH2023[OpcodesBCH2023["OP_UNKNOWN190"] = 190] = "OP_UNKNOWN190";
  /**
   * Last codepoint left undefined before nullary introspection operations.
   */
  OpcodesBCH2023[OpcodesBCH2023["OP_UNKNOWN191"] = 191] = "OP_UNKNOWN191";
  OpcodesBCH2023[OpcodesBCH2023["OP_INPUTINDEX"] = 192] = "OP_INPUTINDEX";
  OpcodesBCH2023[OpcodesBCH2023["OP_ACTIVEBYTECODE"] = 193] = "OP_ACTIVEBYTECODE";
  OpcodesBCH2023[OpcodesBCH2023["OP_TXVERSION"] = 194] = "OP_TXVERSION";
  OpcodesBCH2023[OpcodesBCH2023["OP_TXINPUTCOUNT"] = 195] = "OP_TXINPUTCOUNT";
  OpcodesBCH2023[OpcodesBCH2023["OP_TXOUTPUTCOUNT"] = 196] = "OP_TXOUTPUTCOUNT";
  OpcodesBCH2023[OpcodesBCH2023["OP_TXLOCKTIME"] = 197] = "OP_TXLOCKTIME";
  OpcodesBCH2023[OpcodesBCH2023["OP_UTXOVALUE"] = 198] = "OP_UTXOVALUE";
  OpcodesBCH2023[OpcodesBCH2023["OP_UTXOBYTECODE"] = 199] = "OP_UTXOBYTECODE";
  OpcodesBCH2023[OpcodesBCH2023["OP_OUTPOINTTXHASH"] = 200] = "OP_OUTPOINTTXHASH";
  OpcodesBCH2023[OpcodesBCH2023["OP_OUTPOINTINDEX"] = 201] = "OP_OUTPOINTINDEX";
  OpcodesBCH2023[OpcodesBCH2023["OP_INPUTBYTECODE"] = 202] = "OP_INPUTBYTECODE";
  OpcodesBCH2023[OpcodesBCH2023["OP_INPUTSEQUENCENUMBER"] = 203] = "OP_INPUTSEQUENCENUMBER";
  OpcodesBCH2023[OpcodesBCH2023["OP_OUTPUTVALUE"] = 204] = "OP_OUTPUTVALUE";
  OpcodesBCH2023[OpcodesBCH2023["OP_OUTPUTBYTECODE"] = 205] = "OP_OUTPUTBYTECODE";
  OpcodesBCH2023[OpcodesBCH2023["OP_UTXOTOKENCATEGORY"] = 206] = "OP_UTXOTOKENCATEGORY";
  OpcodesBCH2023[OpcodesBCH2023["OP_UTXOTOKENCOMMITMENT"] = 207] = "OP_UTXOTOKENCOMMITMENT";
  OpcodesBCH2023[OpcodesBCH2023["OP_UTXOTOKENAMOUNT"] = 208] = "OP_UTXOTOKENAMOUNT";
  OpcodesBCH2023[OpcodesBCH2023["OP_OUTPUTTOKENCATEGORY"] = 209] = "OP_OUTPUTTOKENCATEGORY";
  OpcodesBCH2023[OpcodesBCH2023["OP_OUTPUTTOKENCOMMITMENT"] = 210] = "OP_OUTPUTTOKENCOMMITMENT";
  OpcodesBCH2023[OpcodesBCH2023["OP_OUTPUTTOKENAMOUNT"] = 211] = "OP_OUTPUTTOKENAMOUNT";
  OpcodesBCH2023[OpcodesBCH2023["OP_UNKNOWN212"] = 212] = "OP_UNKNOWN212";
  OpcodesBCH2023[OpcodesBCH2023["OP_UNKNOWN213"] = 213] = "OP_UNKNOWN213";
  OpcodesBCH2023[OpcodesBCH2023["OP_UNKNOWN214"] = 214] = "OP_UNKNOWN214";
  OpcodesBCH2023[OpcodesBCH2023["OP_UNKNOWN215"] = 215] = "OP_UNKNOWN215";
  OpcodesBCH2023[OpcodesBCH2023["OP_UNKNOWN216"] = 216] = "OP_UNKNOWN216";
  OpcodesBCH2023[OpcodesBCH2023["OP_UNKNOWN217"] = 217] = "OP_UNKNOWN217";
  OpcodesBCH2023[OpcodesBCH2023["OP_UNKNOWN218"] = 218] = "OP_UNKNOWN218";
  OpcodesBCH2023[OpcodesBCH2023["OP_UNKNOWN219"] = 219] = "OP_UNKNOWN219";
  OpcodesBCH2023[OpcodesBCH2023["OP_UNKNOWN220"] = 220] = "OP_UNKNOWN220";
  OpcodesBCH2023[OpcodesBCH2023["OP_UNKNOWN221"] = 221] = "OP_UNKNOWN221";
  OpcodesBCH2023[OpcodesBCH2023["OP_UNKNOWN222"] = 222] = "OP_UNKNOWN222";
  OpcodesBCH2023[OpcodesBCH2023["OP_UNKNOWN223"] = 223] = "OP_UNKNOWN223";
  OpcodesBCH2023[OpcodesBCH2023["OP_UNKNOWN224"] = 224] = "OP_UNKNOWN224";
  OpcodesBCH2023[OpcodesBCH2023["OP_UNKNOWN225"] = 225] = "OP_UNKNOWN225";
  OpcodesBCH2023[OpcodesBCH2023["OP_UNKNOWN226"] = 226] = "OP_UNKNOWN226";
  OpcodesBCH2023[OpcodesBCH2023["OP_UNKNOWN227"] = 227] = "OP_UNKNOWN227";
  OpcodesBCH2023[OpcodesBCH2023["OP_UNKNOWN228"] = 228] = "OP_UNKNOWN228";
  OpcodesBCH2023[OpcodesBCH2023["OP_UNKNOWN229"] = 229] = "OP_UNKNOWN229";
  OpcodesBCH2023[OpcodesBCH2023["OP_UNKNOWN230"] = 230] = "OP_UNKNOWN230";
  OpcodesBCH2023[OpcodesBCH2023["OP_UNKNOWN231"] = 231] = "OP_UNKNOWN231";
  OpcodesBCH2023[OpcodesBCH2023["OP_UNKNOWN232"] = 232] = "OP_UNKNOWN232";
  OpcodesBCH2023[OpcodesBCH2023["OP_UNKNOWN233"] = 233] = "OP_UNKNOWN233";
  OpcodesBCH2023[OpcodesBCH2023["OP_UNKNOWN234"] = 234] = "OP_UNKNOWN234";
  OpcodesBCH2023[OpcodesBCH2023["OP_UNKNOWN235"] = 235] = "OP_UNKNOWN235";
  OpcodesBCH2023[OpcodesBCH2023["OP_UNKNOWN236"] = 236] = "OP_UNKNOWN236";
  OpcodesBCH2023[OpcodesBCH2023["OP_UNKNOWN237"] = 237] = "OP_UNKNOWN237";
  OpcodesBCH2023[OpcodesBCH2023["OP_UNKNOWN238"] = 238] = "OP_UNKNOWN238";
  OpcodesBCH2023[OpcodesBCH2023["OP_UNKNOWN239"] = 239] = "OP_UNKNOWN239";
  /**
   * A.K.A. `OP_PREFIX_BEGIN`
   */
  OpcodesBCH2023[OpcodesBCH2023["OP_UNKNOWN240"] = 240] = "OP_UNKNOWN240";
  OpcodesBCH2023[OpcodesBCH2023["OP_UNKNOWN241"] = 241] = "OP_UNKNOWN241";
  OpcodesBCH2023[OpcodesBCH2023["OP_UNKNOWN242"] = 242] = "OP_UNKNOWN242";
  OpcodesBCH2023[OpcodesBCH2023["OP_UNKNOWN243"] = 243] = "OP_UNKNOWN243";
  OpcodesBCH2023[OpcodesBCH2023["OP_UNKNOWN244"] = 244] = "OP_UNKNOWN244";
  OpcodesBCH2023[OpcodesBCH2023["OP_UNKNOWN245"] = 245] = "OP_UNKNOWN245";
  OpcodesBCH2023[OpcodesBCH2023["OP_UNKNOWN246"] = 246] = "OP_UNKNOWN246";
  /**
   * A.K.A. `OP_PREFIX_END`
   */
  OpcodesBCH2023[OpcodesBCH2023["OP_UNKNOWN247"] = 247] = "OP_UNKNOWN247";
  OpcodesBCH2023[OpcodesBCH2023["OP_UNKNOWN248"] = 248] = "OP_UNKNOWN248";
  OpcodesBCH2023[OpcodesBCH2023["OP_UNKNOWN249"] = 249] = "OP_UNKNOWN249";
  OpcodesBCH2023[OpcodesBCH2023["OP_UNKNOWN250"] = 250] = "OP_UNKNOWN250";
  OpcodesBCH2023[OpcodesBCH2023["OP_UNKNOWN251"] = 251] = "OP_UNKNOWN251";
  OpcodesBCH2023[OpcodesBCH2023["OP_UNKNOWN252"] = 252] = "OP_UNKNOWN252";
  OpcodesBCH2023[OpcodesBCH2023["OP_UNKNOWN253"] = 253] = "OP_UNKNOWN253";
  OpcodesBCH2023[OpcodesBCH2023["OP_UNKNOWN254"] = 254] = "OP_UNKNOWN254";
  OpcodesBCH2023[OpcodesBCH2023["OP_UNKNOWN255"] = 255] = "OP_UNKNOWN255";
})(OpcodesBCH2023 || (OpcodesBCH2023 = {}));
// eslint-disable-next-line @typescript-eslint/naming-convention
var OpcodesBCH = OpcodesBCH2023;
// eslint-disable-next-line @typescript-eslint/naming-convention
var Opcodes = OpcodesBCH;

/**
 *  `OpcodesBTC` currently represents the `BTC_2017_08` instruction set.
 */
var OpcodesBTC;
(function (OpcodesBTC) {
  OpcodesBTC[OpcodesBTC["OP_0"] = 0] = "OP_0";
  OpcodesBTC[OpcodesBTC["OP_PUSHBYTES_1"] = 1] = "OP_PUSHBYTES_1";
  OpcodesBTC[OpcodesBTC["OP_PUSHBYTES_2"] = 2] = "OP_PUSHBYTES_2";
  OpcodesBTC[OpcodesBTC["OP_PUSHBYTES_3"] = 3] = "OP_PUSHBYTES_3";
  OpcodesBTC[OpcodesBTC["OP_PUSHBYTES_4"] = 4] = "OP_PUSHBYTES_4";
  OpcodesBTC[OpcodesBTC["OP_PUSHBYTES_5"] = 5] = "OP_PUSHBYTES_5";
  OpcodesBTC[OpcodesBTC["OP_PUSHBYTES_6"] = 6] = "OP_PUSHBYTES_6";
  OpcodesBTC[OpcodesBTC["OP_PUSHBYTES_7"] = 7] = "OP_PUSHBYTES_7";
  OpcodesBTC[OpcodesBTC["OP_PUSHBYTES_8"] = 8] = "OP_PUSHBYTES_8";
  OpcodesBTC[OpcodesBTC["OP_PUSHBYTES_9"] = 9] = "OP_PUSHBYTES_9";
  OpcodesBTC[OpcodesBTC["OP_PUSHBYTES_10"] = 10] = "OP_PUSHBYTES_10";
  OpcodesBTC[OpcodesBTC["OP_PUSHBYTES_11"] = 11] = "OP_PUSHBYTES_11";
  OpcodesBTC[OpcodesBTC["OP_PUSHBYTES_12"] = 12] = "OP_PUSHBYTES_12";
  OpcodesBTC[OpcodesBTC["OP_PUSHBYTES_13"] = 13] = "OP_PUSHBYTES_13";
  OpcodesBTC[OpcodesBTC["OP_PUSHBYTES_14"] = 14] = "OP_PUSHBYTES_14";
  OpcodesBTC[OpcodesBTC["OP_PUSHBYTES_15"] = 15] = "OP_PUSHBYTES_15";
  OpcodesBTC[OpcodesBTC["OP_PUSHBYTES_16"] = 16] = "OP_PUSHBYTES_16";
  OpcodesBTC[OpcodesBTC["OP_PUSHBYTES_17"] = 17] = "OP_PUSHBYTES_17";
  OpcodesBTC[OpcodesBTC["OP_PUSHBYTES_18"] = 18] = "OP_PUSHBYTES_18";
  OpcodesBTC[OpcodesBTC["OP_PUSHBYTES_19"] = 19] = "OP_PUSHBYTES_19";
  OpcodesBTC[OpcodesBTC["OP_PUSHBYTES_20"] = 20] = "OP_PUSHBYTES_20";
  OpcodesBTC[OpcodesBTC["OP_PUSHBYTES_21"] = 21] = "OP_PUSHBYTES_21";
  OpcodesBTC[OpcodesBTC["OP_PUSHBYTES_22"] = 22] = "OP_PUSHBYTES_22";
  OpcodesBTC[OpcodesBTC["OP_PUSHBYTES_23"] = 23] = "OP_PUSHBYTES_23";
  OpcodesBTC[OpcodesBTC["OP_PUSHBYTES_24"] = 24] = "OP_PUSHBYTES_24";
  OpcodesBTC[OpcodesBTC["OP_PUSHBYTES_25"] = 25] = "OP_PUSHBYTES_25";
  OpcodesBTC[OpcodesBTC["OP_PUSHBYTES_26"] = 26] = "OP_PUSHBYTES_26";
  OpcodesBTC[OpcodesBTC["OP_PUSHBYTES_27"] = 27] = "OP_PUSHBYTES_27";
  OpcodesBTC[OpcodesBTC["OP_PUSHBYTES_28"] = 28] = "OP_PUSHBYTES_28";
  OpcodesBTC[OpcodesBTC["OP_PUSHBYTES_29"] = 29] = "OP_PUSHBYTES_29";
  OpcodesBTC[OpcodesBTC["OP_PUSHBYTES_30"] = 30] = "OP_PUSHBYTES_30";
  OpcodesBTC[OpcodesBTC["OP_PUSHBYTES_31"] = 31] = "OP_PUSHBYTES_31";
  OpcodesBTC[OpcodesBTC["OP_PUSHBYTES_32"] = 32] = "OP_PUSHBYTES_32";
  OpcodesBTC[OpcodesBTC["OP_PUSHBYTES_33"] = 33] = "OP_PUSHBYTES_33";
  OpcodesBTC[OpcodesBTC["OP_PUSHBYTES_34"] = 34] = "OP_PUSHBYTES_34";
  OpcodesBTC[OpcodesBTC["OP_PUSHBYTES_35"] = 35] = "OP_PUSHBYTES_35";
  OpcodesBTC[OpcodesBTC["OP_PUSHBYTES_36"] = 36] = "OP_PUSHBYTES_36";
  OpcodesBTC[OpcodesBTC["OP_PUSHBYTES_37"] = 37] = "OP_PUSHBYTES_37";
  OpcodesBTC[OpcodesBTC["OP_PUSHBYTES_38"] = 38] = "OP_PUSHBYTES_38";
  OpcodesBTC[OpcodesBTC["OP_PUSHBYTES_39"] = 39] = "OP_PUSHBYTES_39";
  OpcodesBTC[OpcodesBTC["OP_PUSHBYTES_40"] = 40] = "OP_PUSHBYTES_40";
  OpcodesBTC[OpcodesBTC["OP_PUSHBYTES_41"] = 41] = "OP_PUSHBYTES_41";
  OpcodesBTC[OpcodesBTC["OP_PUSHBYTES_42"] = 42] = "OP_PUSHBYTES_42";
  OpcodesBTC[OpcodesBTC["OP_PUSHBYTES_43"] = 43] = "OP_PUSHBYTES_43";
  OpcodesBTC[OpcodesBTC["OP_PUSHBYTES_44"] = 44] = "OP_PUSHBYTES_44";
  OpcodesBTC[OpcodesBTC["OP_PUSHBYTES_45"] = 45] = "OP_PUSHBYTES_45";
  OpcodesBTC[OpcodesBTC["OP_PUSHBYTES_46"] = 46] = "OP_PUSHBYTES_46";
  OpcodesBTC[OpcodesBTC["OP_PUSHBYTES_47"] = 47] = "OP_PUSHBYTES_47";
  OpcodesBTC[OpcodesBTC["OP_PUSHBYTES_48"] = 48] = "OP_PUSHBYTES_48";
  OpcodesBTC[OpcodesBTC["OP_PUSHBYTES_49"] = 49] = "OP_PUSHBYTES_49";
  OpcodesBTC[OpcodesBTC["OP_PUSHBYTES_50"] = 50] = "OP_PUSHBYTES_50";
  OpcodesBTC[OpcodesBTC["OP_PUSHBYTES_51"] = 51] = "OP_PUSHBYTES_51";
  OpcodesBTC[OpcodesBTC["OP_PUSHBYTES_52"] = 52] = "OP_PUSHBYTES_52";
  OpcodesBTC[OpcodesBTC["OP_PUSHBYTES_53"] = 53] = "OP_PUSHBYTES_53";
  OpcodesBTC[OpcodesBTC["OP_PUSHBYTES_54"] = 54] = "OP_PUSHBYTES_54";
  OpcodesBTC[OpcodesBTC["OP_PUSHBYTES_55"] = 55] = "OP_PUSHBYTES_55";
  OpcodesBTC[OpcodesBTC["OP_PUSHBYTES_56"] = 56] = "OP_PUSHBYTES_56";
  OpcodesBTC[OpcodesBTC["OP_PUSHBYTES_57"] = 57] = "OP_PUSHBYTES_57";
  OpcodesBTC[OpcodesBTC["OP_PUSHBYTES_58"] = 58] = "OP_PUSHBYTES_58";
  OpcodesBTC[OpcodesBTC["OP_PUSHBYTES_59"] = 59] = "OP_PUSHBYTES_59";
  OpcodesBTC[OpcodesBTC["OP_PUSHBYTES_60"] = 60] = "OP_PUSHBYTES_60";
  OpcodesBTC[OpcodesBTC["OP_PUSHBYTES_61"] = 61] = "OP_PUSHBYTES_61";
  OpcodesBTC[OpcodesBTC["OP_PUSHBYTES_62"] = 62] = "OP_PUSHBYTES_62";
  OpcodesBTC[OpcodesBTC["OP_PUSHBYTES_63"] = 63] = "OP_PUSHBYTES_63";
  OpcodesBTC[OpcodesBTC["OP_PUSHBYTES_64"] = 64] = "OP_PUSHBYTES_64";
  OpcodesBTC[OpcodesBTC["OP_PUSHBYTES_65"] = 65] = "OP_PUSHBYTES_65";
  OpcodesBTC[OpcodesBTC["OP_PUSHBYTES_66"] = 66] = "OP_PUSHBYTES_66";
  OpcodesBTC[OpcodesBTC["OP_PUSHBYTES_67"] = 67] = "OP_PUSHBYTES_67";
  OpcodesBTC[OpcodesBTC["OP_PUSHBYTES_68"] = 68] = "OP_PUSHBYTES_68";
  OpcodesBTC[OpcodesBTC["OP_PUSHBYTES_69"] = 69] = "OP_PUSHBYTES_69";
  OpcodesBTC[OpcodesBTC["OP_PUSHBYTES_70"] = 70] = "OP_PUSHBYTES_70";
  OpcodesBTC[OpcodesBTC["OP_PUSHBYTES_71"] = 71] = "OP_PUSHBYTES_71";
  OpcodesBTC[OpcodesBTC["OP_PUSHBYTES_72"] = 72] = "OP_PUSHBYTES_72";
  OpcodesBTC[OpcodesBTC["OP_PUSHBYTES_73"] = 73] = "OP_PUSHBYTES_73";
  OpcodesBTC[OpcodesBTC["OP_PUSHBYTES_74"] = 74] = "OP_PUSHBYTES_74";
  OpcodesBTC[OpcodesBTC["OP_PUSHBYTES_75"] = 75] = "OP_PUSHBYTES_75";
  OpcodesBTC[OpcodesBTC["OP_PUSHDATA_1"] = 76] = "OP_PUSHDATA_1";
  OpcodesBTC[OpcodesBTC["OP_PUSHDATA_2"] = 77] = "OP_PUSHDATA_2";
  OpcodesBTC[OpcodesBTC["OP_PUSHDATA_4"] = 78] = "OP_PUSHDATA_4";
  OpcodesBTC[OpcodesBTC["OP_1NEGATE"] = 79] = "OP_1NEGATE";
  OpcodesBTC[OpcodesBTC["OP_RESERVED"] = 80] = "OP_RESERVED";
  OpcodesBTC[OpcodesBTC["OP_1"] = 81] = "OP_1";
  OpcodesBTC[OpcodesBTC["OP_2"] = 82] = "OP_2";
  OpcodesBTC[OpcodesBTC["OP_3"] = 83] = "OP_3";
  OpcodesBTC[OpcodesBTC["OP_4"] = 84] = "OP_4";
  OpcodesBTC[OpcodesBTC["OP_5"] = 85] = "OP_5";
  OpcodesBTC[OpcodesBTC["OP_6"] = 86] = "OP_6";
  OpcodesBTC[OpcodesBTC["OP_7"] = 87] = "OP_7";
  OpcodesBTC[OpcodesBTC["OP_8"] = 88] = "OP_8";
  OpcodesBTC[OpcodesBTC["OP_9"] = 89] = "OP_9";
  OpcodesBTC[OpcodesBTC["OP_10"] = 90] = "OP_10";
  OpcodesBTC[OpcodesBTC["OP_11"] = 91] = "OP_11";
  OpcodesBTC[OpcodesBTC["OP_12"] = 92] = "OP_12";
  OpcodesBTC[OpcodesBTC["OP_13"] = 93] = "OP_13";
  OpcodesBTC[OpcodesBTC["OP_14"] = 94] = "OP_14";
  OpcodesBTC[OpcodesBTC["OP_15"] = 95] = "OP_15";
  OpcodesBTC[OpcodesBTC["OP_16"] = 96] = "OP_16";
  OpcodesBTC[OpcodesBTC["OP_NOP"] = 97] = "OP_NOP";
  OpcodesBTC[OpcodesBTC["OP_VER"] = 98] = "OP_VER";
  OpcodesBTC[OpcodesBTC["OP_IF"] = 99] = "OP_IF";
  OpcodesBTC[OpcodesBTC["OP_NOTIF"] = 100] = "OP_NOTIF";
  OpcodesBTC[OpcodesBTC["OP_VERIF"] = 101] = "OP_VERIF";
  OpcodesBTC[OpcodesBTC["OP_VERNOTIF"] = 102] = "OP_VERNOTIF";
  OpcodesBTC[OpcodesBTC["OP_ELSE"] = 103] = "OP_ELSE";
  OpcodesBTC[OpcodesBTC["OP_ENDIF"] = 104] = "OP_ENDIF";
  OpcodesBTC[OpcodesBTC["OP_VERIFY"] = 105] = "OP_VERIFY";
  OpcodesBTC[OpcodesBTC["OP_RETURN"] = 106] = "OP_RETURN";
  OpcodesBTC[OpcodesBTC["OP_TOALTSTACK"] = 107] = "OP_TOALTSTACK";
  OpcodesBTC[OpcodesBTC["OP_FROMALTSTACK"] = 108] = "OP_FROMALTSTACK";
  OpcodesBTC[OpcodesBTC["OP_2DROP"] = 109] = "OP_2DROP";
  OpcodesBTC[OpcodesBTC["OP_2DUP"] = 110] = "OP_2DUP";
  OpcodesBTC[OpcodesBTC["OP_3DUP"] = 111] = "OP_3DUP";
  OpcodesBTC[OpcodesBTC["OP_2OVER"] = 112] = "OP_2OVER";
  OpcodesBTC[OpcodesBTC["OP_2ROT"] = 113] = "OP_2ROT";
  OpcodesBTC[OpcodesBTC["OP_2SWAP"] = 114] = "OP_2SWAP";
  OpcodesBTC[OpcodesBTC["OP_IFDUP"] = 115] = "OP_IFDUP";
  OpcodesBTC[OpcodesBTC["OP_DEPTH"] = 116] = "OP_DEPTH";
  OpcodesBTC[OpcodesBTC["OP_DROP"] = 117] = "OP_DROP";
  OpcodesBTC[OpcodesBTC["OP_DUP"] = 118] = "OP_DUP";
  OpcodesBTC[OpcodesBTC["OP_NIP"] = 119] = "OP_NIP";
  OpcodesBTC[OpcodesBTC["OP_OVER"] = 120] = "OP_OVER";
  OpcodesBTC[OpcodesBTC["OP_PICK"] = 121] = "OP_PICK";
  OpcodesBTC[OpcodesBTC["OP_ROLL"] = 122] = "OP_ROLL";
  OpcodesBTC[OpcodesBTC["OP_ROT"] = 123] = "OP_ROT";
  OpcodesBTC[OpcodesBTC["OP_SWAP"] = 124] = "OP_SWAP";
  OpcodesBTC[OpcodesBTC["OP_TUCK"] = 125] = "OP_TUCK";
  OpcodesBTC[OpcodesBTC["OP_CAT"] = 126] = "OP_CAT";
  OpcodesBTC[OpcodesBTC["OP_SUBSTR"] = 127] = "OP_SUBSTR";
  OpcodesBTC[OpcodesBTC["OP_LEFT"] = 128] = "OP_LEFT";
  OpcodesBTC[OpcodesBTC["OP_RIGHT"] = 129] = "OP_RIGHT";
  OpcodesBTC[OpcodesBTC["OP_SIZE"] = 130] = "OP_SIZE";
  OpcodesBTC[OpcodesBTC["OP_INVERT"] = 131] = "OP_INVERT";
  OpcodesBTC[OpcodesBTC["OP_AND"] = 132] = "OP_AND";
  OpcodesBTC[OpcodesBTC["OP_OR"] = 133] = "OP_OR";
  OpcodesBTC[OpcodesBTC["OP_XOR"] = 134] = "OP_XOR";
  OpcodesBTC[OpcodesBTC["OP_EQUAL"] = 135] = "OP_EQUAL";
  OpcodesBTC[OpcodesBTC["OP_EQUALVERIFY"] = 136] = "OP_EQUALVERIFY";
  OpcodesBTC[OpcodesBTC["OP_RESERVED1"] = 137] = "OP_RESERVED1";
  OpcodesBTC[OpcodesBTC["OP_RESERVED2"] = 138] = "OP_RESERVED2";
  OpcodesBTC[OpcodesBTC["OP_1ADD"] = 139] = "OP_1ADD";
  OpcodesBTC[OpcodesBTC["OP_1SUB"] = 140] = "OP_1SUB";
  OpcodesBTC[OpcodesBTC["OP_2MUL"] = 141] = "OP_2MUL";
  OpcodesBTC[OpcodesBTC["OP_2DIV"] = 142] = "OP_2DIV";
  OpcodesBTC[OpcodesBTC["OP_NEGATE"] = 143] = "OP_NEGATE";
  OpcodesBTC[OpcodesBTC["OP_ABS"] = 144] = "OP_ABS";
  OpcodesBTC[OpcodesBTC["OP_NOT"] = 145] = "OP_NOT";
  OpcodesBTC[OpcodesBTC["OP_0NOTEQUAL"] = 146] = "OP_0NOTEQUAL";
  OpcodesBTC[OpcodesBTC["OP_ADD"] = 147] = "OP_ADD";
  OpcodesBTC[OpcodesBTC["OP_SUB"] = 148] = "OP_SUB";
  OpcodesBTC[OpcodesBTC["OP_MUL"] = 149] = "OP_MUL";
  OpcodesBTC[OpcodesBTC["OP_DIV"] = 150] = "OP_DIV";
  OpcodesBTC[OpcodesBTC["OP_MOD"] = 151] = "OP_MOD";
  OpcodesBTC[OpcodesBTC["OP_LSHIFT"] = 152] = "OP_LSHIFT";
  OpcodesBTC[OpcodesBTC["OP_RSHIFT"] = 153] = "OP_RSHIFT";
  OpcodesBTC[OpcodesBTC["OP_BOOLAND"] = 154] = "OP_BOOLAND";
  OpcodesBTC[OpcodesBTC["OP_BOOLOR"] = 155] = "OP_BOOLOR";
  OpcodesBTC[OpcodesBTC["OP_NUMEQUAL"] = 156] = "OP_NUMEQUAL";
  OpcodesBTC[OpcodesBTC["OP_NUMEQUALVERIFY"] = 157] = "OP_NUMEQUALVERIFY";
  OpcodesBTC[OpcodesBTC["OP_NUMNOTEQUAL"] = 158] = "OP_NUMNOTEQUAL";
  OpcodesBTC[OpcodesBTC["OP_LESSTHAN"] = 159] = "OP_LESSTHAN";
  OpcodesBTC[OpcodesBTC["OP_GREATERTHAN"] = 160] = "OP_GREATERTHAN";
  OpcodesBTC[OpcodesBTC["OP_LESSTHANOREQUAL"] = 161] = "OP_LESSTHANOREQUAL";
  OpcodesBTC[OpcodesBTC["OP_GREATERTHANOREQUAL"] = 162] = "OP_GREATERTHANOREQUAL";
  OpcodesBTC[OpcodesBTC["OP_MIN"] = 163] = "OP_MIN";
  OpcodesBTC[OpcodesBTC["OP_MAX"] = 164] = "OP_MAX";
  OpcodesBTC[OpcodesBTC["OP_WITHIN"] = 165] = "OP_WITHIN";
  OpcodesBTC[OpcodesBTC["OP_RIPEMD160"] = 166] = "OP_RIPEMD160";
  OpcodesBTC[OpcodesBTC["OP_SHA1"] = 167] = "OP_SHA1";
  OpcodesBTC[OpcodesBTC["OP_SHA256"] = 168] = "OP_SHA256";
  OpcodesBTC[OpcodesBTC["OP_HASH160"] = 169] = "OP_HASH160";
  OpcodesBTC[OpcodesBTC["OP_HASH256"] = 170] = "OP_HASH256";
  OpcodesBTC[OpcodesBTC["OP_CODESEPARATOR"] = 171] = "OP_CODESEPARATOR";
  OpcodesBTC[OpcodesBTC["OP_CHECKSIG"] = 172] = "OP_CHECKSIG";
  OpcodesBTC[OpcodesBTC["OP_CHECKSIGVERIFY"] = 173] = "OP_CHECKSIGVERIFY";
  OpcodesBTC[OpcodesBTC["OP_CHECKMULTISIG"] = 174] = "OP_CHECKMULTISIG";
  OpcodesBTC[OpcodesBTC["OP_CHECKMULTISIGVERIFY"] = 175] = "OP_CHECKMULTISIGVERIFY";
  OpcodesBTC[OpcodesBTC["OP_NOP1"] = 176] = "OP_NOP1";
  OpcodesBTC[OpcodesBTC["OP_CHECKLOCKTIMEVERIFY"] = 177] = "OP_CHECKLOCKTIMEVERIFY";
  OpcodesBTC[OpcodesBTC["OP_CHECKSEQUENCEVERIFY"] = 178] = "OP_CHECKSEQUENCEVERIFY";
  OpcodesBTC[OpcodesBTC["OP_NOP4"] = 179] = "OP_NOP4";
  OpcodesBTC[OpcodesBTC["OP_NOP5"] = 180] = "OP_NOP5";
  OpcodesBTC[OpcodesBTC["OP_NOP6"] = 181] = "OP_NOP6";
  OpcodesBTC[OpcodesBTC["OP_NOP7"] = 182] = "OP_NOP7";
  OpcodesBTC[OpcodesBTC["OP_NOP8"] = 183] = "OP_NOP8";
  OpcodesBTC[OpcodesBTC["OP_NOP9"] = 184] = "OP_NOP9";
  OpcodesBTC[OpcodesBTC["OP_NOP10"] = 185] = "OP_NOP10";
  OpcodesBTC[OpcodesBTC["OP_UNKNOWN186"] = 186] = "OP_UNKNOWN186";
  OpcodesBTC[OpcodesBTC["OP_UNKNOWN187"] = 187] = "OP_UNKNOWN187";
  OpcodesBTC[OpcodesBTC["OP_UNKNOWN188"] = 188] = "OP_UNKNOWN188";
  OpcodesBTC[OpcodesBTC["OP_UNKNOWN189"] = 189] = "OP_UNKNOWN189";
  OpcodesBTC[OpcodesBTC["OP_UNKNOWN190"] = 190] = "OP_UNKNOWN190";
  OpcodesBTC[OpcodesBTC["OP_UNKNOWN191"] = 191] = "OP_UNKNOWN191";
  OpcodesBTC[OpcodesBTC["OP_UNKNOWN192"] = 192] = "OP_UNKNOWN192";
  OpcodesBTC[OpcodesBTC["OP_UNKNOWN193"] = 193] = "OP_UNKNOWN193";
  OpcodesBTC[OpcodesBTC["OP_UNKNOWN194"] = 194] = "OP_UNKNOWN194";
  OpcodesBTC[OpcodesBTC["OP_UNKNOWN195"] = 195] = "OP_UNKNOWN195";
  OpcodesBTC[OpcodesBTC["OP_UNKNOWN196"] = 196] = "OP_UNKNOWN196";
  OpcodesBTC[OpcodesBTC["OP_UNKNOWN197"] = 197] = "OP_UNKNOWN197";
  OpcodesBTC[OpcodesBTC["OP_UNKNOWN198"] = 198] = "OP_UNKNOWN198";
  OpcodesBTC[OpcodesBTC["OP_UNKNOWN199"] = 199] = "OP_UNKNOWN199";
  OpcodesBTC[OpcodesBTC["OP_UNKNOWN200"] = 200] = "OP_UNKNOWN200";
  OpcodesBTC[OpcodesBTC["OP_UNKNOWN201"] = 201] = "OP_UNKNOWN201";
  OpcodesBTC[OpcodesBTC["OP_UNKNOWN202"] = 202] = "OP_UNKNOWN202";
  OpcodesBTC[OpcodesBTC["OP_UNKNOWN203"] = 203] = "OP_UNKNOWN203";
  OpcodesBTC[OpcodesBTC["OP_UNKNOWN204"] = 204] = "OP_UNKNOWN204";
  OpcodesBTC[OpcodesBTC["OP_UNKNOWN205"] = 205] = "OP_UNKNOWN205";
  OpcodesBTC[OpcodesBTC["OP_UNKNOWN206"] = 206] = "OP_UNKNOWN206";
  OpcodesBTC[OpcodesBTC["OP_UNKNOWN207"] = 207] = "OP_UNKNOWN207";
  OpcodesBTC[OpcodesBTC["OP_UNKNOWN208"] = 208] = "OP_UNKNOWN208";
  OpcodesBTC[OpcodesBTC["OP_UNKNOWN209"] = 209] = "OP_UNKNOWN209";
  OpcodesBTC[OpcodesBTC["OP_UNKNOWN210"] = 210] = "OP_UNKNOWN210";
  OpcodesBTC[OpcodesBTC["OP_UNKNOWN211"] = 211] = "OP_UNKNOWN211";
  OpcodesBTC[OpcodesBTC["OP_UNKNOWN212"] = 212] = "OP_UNKNOWN212";
  OpcodesBTC[OpcodesBTC["OP_UNKNOWN213"] = 213] = "OP_UNKNOWN213";
  OpcodesBTC[OpcodesBTC["OP_UNKNOWN214"] = 214] = "OP_UNKNOWN214";
  OpcodesBTC[OpcodesBTC["OP_UNKNOWN215"] = 215] = "OP_UNKNOWN215";
  OpcodesBTC[OpcodesBTC["OP_UNKNOWN216"] = 216] = "OP_UNKNOWN216";
  OpcodesBTC[OpcodesBTC["OP_UNKNOWN217"] = 217] = "OP_UNKNOWN217";
  OpcodesBTC[OpcodesBTC["OP_UNKNOWN218"] = 218] = "OP_UNKNOWN218";
  OpcodesBTC[OpcodesBTC["OP_UNKNOWN219"] = 219] = "OP_UNKNOWN219";
  OpcodesBTC[OpcodesBTC["OP_UNKNOWN220"] = 220] = "OP_UNKNOWN220";
  OpcodesBTC[OpcodesBTC["OP_UNKNOWN221"] = 221] = "OP_UNKNOWN221";
  OpcodesBTC[OpcodesBTC["OP_UNKNOWN222"] = 222] = "OP_UNKNOWN222";
  OpcodesBTC[OpcodesBTC["OP_UNKNOWN223"] = 223] = "OP_UNKNOWN223";
  OpcodesBTC[OpcodesBTC["OP_UNKNOWN224"] = 224] = "OP_UNKNOWN224";
  OpcodesBTC[OpcodesBTC["OP_UNKNOWN225"] = 225] = "OP_UNKNOWN225";
  OpcodesBTC[OpcodesBTC["OP_UNKNOWN226"] = 226] = "OP_UNKNOWN226";
  OpcodesBTC[OpcodesBTC["OP_UNKNOWN227"] = 227] = "OP_UNKNOWN227";
  OpcodesBTC[OpcodesBTC["OP_UNKNOWN228"] = 228] = "OP_UNKNOWN228";
  OpcodesBTC[OpcodesBTC["OP_UNKNOWN229"] = 229] = "OP_UNKNOWN229";
  OpcodesBTC[OpcodesBTC["OP_UNKNOWN230"] = 230] = "OP_UNKNOWN230";
  OpcodesBTC[OpcodesBTC["OP_UNKNOWN231"] = 231] = "OP_UNKNOWN231";
  OpcodesBTC[OpcodesBTC["OP_UNKNOWN232"] = 232] = "OP_UNKNOWN232";
  OpcodesBTC[OpcodesBTC["OP_UNKNOWN233"] = 233] = "OP_UNKNOWN233";
  OpcodesBTC[OpcodesBTC["OP_UNKNOWN234"] = 234] = "OP_UNKNOWN234";
  OpcodesBTC[OpcodesBTC["OP_UNKNOWN235"] = 235] = "OP_UNKNOWN235";
  OpcodesBTC[OpcodesBTC["OP_UNKNOWN236"] = 236] = "OP_UNKNOWN236";
  OpcodesBTC[OpcodesBTC["OP_UNKNOWN237"] = 237] = "OP_UNKNOWN237";
  OpcodesBTC[OpcodesBTC["OP_UNKNOWN238"] = 238] = "OP_UNKNOWN238";
  OpcodesBTC[OpcodesBTC["OP_UNKNOWN239"] = 239] = "OP_UNKNOWN239";
  OpcodesBTC[OpcodesBTC["OP_UNKNOWN240"] = 240] = "OP_UNKNOWN240";
  OpcodesBTC[OpcodesBTC["OP_UNKNOWN241"] = 241] = "OP_UNKNOWN241";
  OpcodesBTC[OpcodesBTC["OP_UNKNOWN242"] = 242] = "OP_UNKNOWN242";
  OpcodesBTC[OpcodesBTC["OP_UNKNOWN243"] = 243] = "OP_UNKNOWN243";
  OpcodesBTC[OpcodesBTC["OP_UNKNOWN244"] = 244] = "OP_UNKNOWN244";
  OpcodesBTC[OpcodesBTC["OP_UNKNOWN245"] = 245] = "OP_UNKNOWN245";
  OpcodesBTC[OpcodesBTC["OP_UNKNOWN246"] = 246] = "OP_UNKNOWN246";
  OpcodesBTC[OpcodesBTC["OP_UNKNOWN247"] = 247] = "OP_UNKNOWN247";
  OpcodesBTC[OpcodesBTC["OP_UNKNOWN248"] = 248] = "OP_UNKNOWN248";
  OpcodesBTC[OpcodesBTC["OP_UNKNOWN249"] = 249] = "OP_UNKNOWN249";
  /**
   * Used internally in the C++ implementation.
   */
  OpcodesBTC[OpcodesBTC["OP_SMALLINTEGER"] = 250] = "OP_SMALLINTEGER";
  /**
   * Used internally in the C++ implementation.
   */
  OpcodesBTC[OpcodesBTC["OP_PUBKEYS"] = 251] = "OP_PUBKEYS";
  OpcodesBTC[OpcodesBTC["OP_UNKNOWN252"] = 252] = "OP_UNKNOWN252";
  /**
   * Used internally in the C++ implementation.
   */
  OpcodesBTC[OpcodesBTC["OP_PUBKEYHASH"] = 253] = "OP_PUBKEYHASH";
  /**
   * Used internally in the C++ implementation.
   */
  OpcodesBTC[OpcodesBTC["OP_PUBKEY"] = 254] = "OP_PUBKEY";
  /**
   * Used internally in the C++ implementation.
   */
  OpcodesBTC[OpcodesBTC["OP_INVALIDOPCODE"] = 255] = "OP_INVALIDOPCODE";
})(OpcodesBTC || (OpcodesBTC = {}));

/**
 * A type-guard that checks if the provided instruction is malformed.
 * @param instruction - the instruction to check
 */
var authenticationInstructionIsMalformed = function authenticationInstructionIsMalformed(instruction) {
  return 'malformed' in instruction;
};
/**
 * A type-guard that checks if the final instruction in the provided array of
 * instructions is malformed. (Only the final instruction can be malformed.)
 * @param instructions - the array of instructions to check
 */
var authenticationInstructionsAreMalformed = function authenticationInstructionsAreMalformed(instructions) {
  return instructions.length > 0 &&
  // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
  authenticationInstructionIsMalformed(instructions[instructions.length - 1]);
};
var authenticationInstructionsArePushInstructions = function authenticationInstructionsArePushInstructions(instructions) {
  return instructions.every(function (instruction) {
    return 'data' in instruction;
  });
};
var uint8Bytes = 1;
var uint16Bytes = 2;
var uint32Bytes = 4;
/**
 * Decode a little endian number of `length` from virtual machine `bytecode`
 * beginning at `index`.
 */
var decodeLittleEndianNumber = function decodeLittleEndianNumber(bytecode, index, length) {
  var view = new DataView(bytecode.buffer, index, length);
  var readAsLittleEndian = true;
  return length === uint8Bytes ? view.getUint8(0) : length === uint16Bytes ? view.getUint16(0, readAsLittleEndian) : view.getUint32(0, readAsLittleEndian);
};
/**
 * Returns the number of bytes used to indicate the length of the push in this
 * operation.
 * @param opcode - an opcode between 0x00 and 0xff
 */
var opcodeToPushLength = function opcodeToPushLength(opcode) {
  var _$77$78$opcode, _$77$78$opcode2;
  return (_$77$78$opcode = (_$77$78$opcode2 = {}, _defineProperty(_$77$78$opcode2, 76 /* CommonPushOpcodes.OP_PUSHDATA_1 */, uint8Bytes), _defineProperty(_$77$78$opcode2, 77 /* CommonPushOpcodes.OP_PUSHDATA_2 */, uint16Bytes), _defineProperty(_$77$78$opcode2, 78 /* CommonPushOpcodes.OP_PUSHDATA_4 */, uint32Bytes), _$77$78$opcode2)[opcode]) !== null && _$77$78$opcode !== void 0 ? _$77$78$opcode : 0;
};
/**
 * Decode one instruction from the provided virtual machine bytecode.
 *
 * Returns an object with an `instruction` referencing a
 * {@link AuthenticationInstructionMaybeMalformed}, and a `nextIndex` indicating
 * the next index from which to read. If the next index is greater than or equal
 * to the length of the bytecode, the bytecode has been fully decoded.
 *
 * The final {@link AuthenticationInstructionMaybeMalformed} in the bytecode may
 * be malformed if 1) the final operation is a push and 2) too few bytes remain
 * for the push operation to complete.
 *
 * @param bytecode - the virtual machine bytecode from which to read the next
 * instruction
 * @param index - the index from which to begin reading
 */
// eslint-disable-next-line complexity
var decodeAuthenticationInstruction = function decodeAuthenticationInstruction(bytecode, index) {
  // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
  var opcode = bytecode[index];
  if (opcode > 78 /* CommonPushOpcodes.OP_PUSHDATA_4 */) {
    return {
      instruction: {
        opcode: opcode
      },
      nextIndex: index + 1
    };
  }
  var lengthBytes = opcodeToPushLength(opcode);
  if (lengthBytes !== 0 && index + lengthBytes >= bytecode.length) {
    var sliceStart = index + 1;
    var sliceEnd = sliceStart + lengthBytes;
    return {
      instruction: {
        expectedLengthBytes: lengthBytes,
        length: bytecode.slice(sliceStart, sliceEnd),
        malformed: true,
        opcode: opcode
      },
      nextIndex: sliceEnd
    };
  }
  var dataBytes = lengthBytes === 0 ? opcode : decodeLittleEndianNumber(bytecode, index + 1, lengthBytes);
  var dataStart = index + 1 + lengthBytes;
  var dataEnd = dataStart + dataBytes;
  return {
    instruction: _objectSpread2(_objectSpread2({
      data: bytecode.slice(dataStart, dataEnd)
    }, dataEnd > bytecode.length ? {
      expectedDataBytes: dataEnd - dataStart,
      malformed: true
    } : undefined), {}, {
      opcode: opcode
    }),
    nextIndex: dataEnd
  };
};
/**
 * @param instruction - the {@link AuthenticationInstruction} to clone.
 * @returns A copy of the provided {@link AuthenticationInstruction}.
 */
var cloneAuthenticationInstruction = function cloneAuthenticationInstruction(instruction) {
  return _objectSpread2(_objectSpread2({}, 'data' in instruction ? {
    data: instruction.data
  } : {}), {}, {
    opcode: instruction.opcode
  });
};
/**
 * Decode authentication virtual machine bytecode (`lockingBytecode` or
 * `unlockingBytecode`) into {@link AuthenticationInstructionsMaybeMalformed}.
 * The method {@link authenticationInstructionsAreMalformed} can be used to
 * check if these instructions include a malformed instruction. If not, they are
 * valid {@link AuthenticationInstructions}.
 *
 * @param bytecode - the authentication virtual machine bytecode to decode
 */
var decodeAuthenticationInstructions = function decodeAuthenticationInstructions(bytecode) {
  var instructions = [];
  // eslint-disable-next-line functional/no-let
  var i = 0;
  // eslint-disable-next-line functional/no-loop-statement
  while (i < bytecode.length) {
    var _decodeAuthentication = decodeAuthenticationInstruction(bytecode, i),
      instruction = _decodeAuthentication.instruction,
      nextIndex = _decodeAuthentication.nextIndex;
    // eslint-disable-next-line functional/no-expression-statement
    i = nextIndex;
    // eslint-disable-next-line functional/no-expression-statement, functional/immutable-data
    instructions.push(instruction);
  }
  return instructions;
};
/**
 * OP_0 is the only single-word push. All other push instructions will
 * disassemble to multiple ASM words. (OP_1-OP_16 are handled like normal
 * operations.)
 */
var isMultiWordPush = function isMultiWordPush(opcode) {
  return opcode !== 0;
} /* CommonPushOpcodes.OP_0 */;
var formatAsmPushHex = function formatAsmPushHex(data) {
  return data.length > 0 ? "0x".concat(binToHex(data)) : '';
};
var formatMissingBytesAsm = function formatMissingBytesAsm(missing) {
  return "[missing ".concat(missing, " byte").concat(missing === 1 ? '' : 's', "]");
};
var hasMalformedLength = function hasMalformedLength(instruction) {
  return 'length' in instruction;
};
var isPushData = function isPushData(pushOpcode) {
  return pushOpcode >= 76;
} /* CommonPushOpcodes.OP_PUSHDATA_1 */;
/**
 * Disassemble a malformed authentication instruction into a string description.
 * @param opcodes - a mapping of possible opcodes to their string representation
 * @param instruction - the {@link AuthenticationInstructionMalformed} to
 * disassemble
 */
var disassembleAuthenticationInstructionMalformed = function disassembleAuthenticationInstructionMalformed(opcodes, instruction) {
  var _opcodes$instruction$;
  return "".concat((_opcodes$instruction$ = opcodes[instruction.opcode]) !== null && _opcodes$instruction$ !== void 0 ? _opcodes$instruction$ : 'OP_UNKNOWN', " ").concat(hasMalformedLength(instruction) ? "".concat(formatAsmPushHex(instruction.length)).concat(formatMissingBytesAsm(instruction.expectedLengthBytes - instruction.length.length)) : "".concat(isPushData(instruction.opcode) ? "".concat(instruction.expectedDataBytes, " ") : '').concat(formatAsmPushHex(instruction.data)).concat(formatMissingBytesAsm(instruction.expectedDataBytes - instruction.data.length)));
};
/**
 * Disassemble a properly-formed authentication instruction into a string
 * description.
 * @param opcodes - a mapping of possible opcodes to their string representation
 * @param instruction - the instruction to disassemble
 */
var disassembleAuthenticationInstruction = function disassembleAuthenticationInstruction(opcodes, instruction) {
  var _opcodes$instruction$2;
  return "".concat((_opcodes$instruction$2 = opcodes[instruction.opcode]) !== null && _opcodes$instruction$2 !== void 0 ? _opcodes$instruction$2 : 'OP_UNKNOWN').concat('data' in instruction && isMultiWordPush(instruction.opcode) ? " ".concat(isPushData(instruction.opcode) ? "".concat(instruction.data.length, " ") : '').concat(formatAsmPushHex(instruction.data)) : '');
};
/**
 * Disassemble a single {@link AuthenticationInstructionMaybeMalformed} into its
 * ASM representation.
 *
 * @param opcodes - a mapping of possible opcodes to their string representation
 * @param instruction - the instruction to disassemble
 */
var disassembleAuthenticationInstructionMaybeMalformed = function disassembleAuthenticationInstructionMaybeMalformed(opcodes, instruction) {
  return authenticationInstructionIsMalformed(instruction) ? disassembleAuthenticationInstructionMalformed(opcodes, instruction) : disassembleAuthenticationInstruction(opcodes, instruction);
};
/**
 * Disassemble an array of {@link AuthenticationInstructionMaybeMalformed}
 * (including potentially malformed instructions) into its ASM representation.
 *
 * This method supports disassembling an array including multiple
 * {@link AuthenticationInstructionMaybeMalformed}s, rather than the more
 * constrained {@link AuthenticationInstructionsMaybeMalformed} (may only
 * include one malformed instruction as the last item in the array).
 *
 * @param opcodes - a mapping of possible opcodes to their string representation
 * @param instructions - the array of instructions to disassemble
 */
var disassembleAuthenticationInstructionsMaybeMalformed = function disassembleAuthenticationInstructionsMaybeMalformed(opcodes, instructions) {
  return instructions.map(function (instruction) {
    return disassembleAuthenticationInstructionMaybeMalformed(opcodes, instruction);
  }).join(' ');
};
/**
 * Disassemble authentication bytecode into a lossless ASM representation. (All
 * push operations are represented with the same opcodes used in the bytecode,
 * even when non-minimally encoded.)
 *
 * @param opcodes - a mapping of possible opcodes to their string representation
 * @param bytecode - the authentication bytecode to disassemble
 */
var disassembleBytecode = function disassembleBytecode(opcodes, bytecode) {
  return disassembleAuthenticationInstructionsMaybeMalformed(opcodes, decodeAuthenticationInstructions(bytecode));
};
/**
 * Disassemble BCH authentication bytecode into its ASM representation.
 *
 * Note, this method automatically uses the latest BCH instruction set. To
 * manually select an instruction set, use {@link disassembleBytecode}.
 *
 * @param bytecode - the virtual machine bytecode to disassemble
 */
var disassembleBytecodeBCH = function disassembleBytecodeBCH(bytecode) {
  return disassembleAuthenticationInstructionsMaybeMalformed(OpcodesBCH, decodeAuthenticationInstructions(bytecode));
};
/**
 * Disassemble BTC authentication bytecode into its ASM representation.
 *
 * Note, this method automatically uses the latest BTC instruction set. To
 * manually select an instruction set, use {@link disassembleBytecode}.
 *
 * @param bytecode - the virtual machine bytecode to disassemble
 */
var disassembleBytecodeBTC = function disassembleBytecodeBTC(bytecode) {
  return disassembleAuthenticationInstructionsMaybeMalformed(OpcodesBTC, decodeAuthenticationInstructions(bytecode));
};
/**
 * Create an object where each key is an opcode identifier and each value is
 * the bytecode value (`Uint8Array`) it represents.
 * @param opcodes - An opcode enum, e.g. {@link OpcodesBCH}
 */
var generateBytecodeMap = function generateBytecodeMap(opcodes) {
  return Object.entries(opcodes).filter(function (entry) {
    return typeof entry[1] === 'number';
  }).reduce(function (identifiers, pair) {
    return _objectSpread2(_objectSpread2({}, identifiers), {}, _defineProperty({}, pair[0], Uint8Array.of(pair[1])));
  }, {});
};
var getInstructionLengthBytes = function getInstructionLengthBytes(instruction) {
  var opcode = instruction.opcode;
  var expectedLength = opcodeToPushLength(opcode);
  return expectedLength === uint8Bytes ? Uint8Array.of(instruction.data.length) : expectedLength === uint16Bytes ? numberToBinUint16LE(instruction.data.length) : numberToBinUint32LE(instruction.data.length);
};
/**
 * Re-encode a valid authentication instruction.
 * @param instruction - the instruction to encode
 */
var encodeAuthenticationInstruction = function encodeAuthenticationInstruction(instruction) {
  return Uint8Array.from([instruction.opcode].concat(_toConsumableArray('data' in instruction ? [].concat(_toConsumableArray(isPushData(instruction.opcode) ? getInstructionLengthBytes(instruction) : []), _toConsumableArray(instruction.data)) : [])));
};
/**
 * Re-encode a malformed authentication instruction.
 * @param instruction - the {@link AuthenticationInstructionMalformed} to encode
 */
var encodeAuthenticationInstructionMalformed = function encodeAuthenticationInstructionMalformed(instruction) {
  var opcode = instruction.opcode;
  if (hasMalformedLength(instruction)) {
    return Uint8Array.from([opcode].concat(_toConsumableArray(instruction.length)));
  }
  if (isPushData(opcode)) {
    return Uint8Array.from([opcode].concat(_toConsumableArray(opcode === 76 /* CommonPushOpcodes.OP_PUSHDATA_1 */ ? Uint8Array.of(instruction.expectedDataBytes) : opcode === 77 /* CommonPushOpcodes.OP_PUSHDATA_2 */ ? numberToBinUint16LE(instruction.expectedDataBytes) : numberToBinUint32LE(instruction.expectedDataBytes)), _toConsumableArray(instruction.data)));
  }
  return Uint8Array.from([opcode].concat(_toConsumableArray(instruction.data)));
};
/**
 * Re-encode a potentially-malformed authentication instruction.
 * @param instruction - the {@link AuthenticationInstructionMaybeMalformed}
 * to encode
 */
var encodeAuthenticationInstructionMaybeMalformed = function encodeAuthenticationInstructionMaybeMalformed(instruction) {
  return authenticationInstructionIsMalformed(instruction) ? encodeAuthenticationInstructionMalformed(instruction) : encodeAuthenticationInstruction(instruction);
};
/**
 * Re-encode an array of valid authentication instructions.
 * @param instructions - the array of valid instructions to encode
 */
var encodeAuthenticationInstructions = function encodeAuthenticationInstructions(instructions) {
  return flattenBinArray(instructions.map(encodeAuthenticationInstruction));
};
/**
 * Re-encode an array of potentially-malformed authentication instructions.
 * @param instructions - the array of
 * {@link AuthenticationInstructionMaybeMalformed}s to encode
 */
var encodeAuthenticationInstructionsMaybeMalformed = function encodeAuthenticationInstructionsMaybeMalformed(instructions) {
  return flattenBinArray(instructions.map(encodeAuthenticationInstructionMaybeMalformed));
};
var VmNumberError;
(function (VmNumberError) {
  VmNumberError["outOfRange"] = "Failed to decode VM Number: overflows VM Number range.";
  VmNumberError["requiresMinimal"] = "Failed to decode VM Number: the number is not minimally-encoded.";
})(VmNumberError || (VmNumberError = {}));
var isVmNumberError = function isVmNumberError(value) {
  return value === VmNumberError.outOfRange || value === VmNumberError.requiresMinimal;
};
var typicalMaximumVmNumberByteLength$1 = 8;
/**
 * This method attempts to decode a VM Number, a format in which numeric values
 * are represented on the stack. (The Satoshi implementation calls this
 * `CScriptNum`.)
 *
 * If `bytes` is a valid VM Number, this method returns the represented number
 * in BigInt format. If `bytes` is not valid, a {@link VmNumberError}
 * is returned.
 *
 * All common operations accepting numeric parameters or pushing numeric values
 * to the stack currently use the VM Number format. The binary format of numbers
 * wouldn't be important if they could only be operated on by arithmetic
 * operators, but since the results of these operations may become input to
 * other operations (e.g. hashing), the specific representation is consensus-
 * critical.
 *
 * @param bytes - a Uint8Array from the stack
 */
// eslint-disable-next-line complexity
var vmNumberToBigInt = function vmNumberToBigInt(bytes) {
  var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {
      maximumVmNumberByteLength: typicalMaximumVmNumberByteLength$1,
      requireMinimalEncoding: true
    },
    _ref$maximumVmNumberB = _ref.maximumVmNumberByteLength,
    maximumVmNumberByteLength = _ref$maximumVmNumberB === void 0 ? typicalMaximumVmNumberByteLength$1 : _ref$maximumVmNumberB,
    _ref$requireMinimalEn = _ref.requireMinimalEncoding,
    requireMinimalEncoding = _ref$requireMinimalEn === void 0 ? true : _ref$requireMinimalEn;
  if (bytes.length === 0) {
    return 0n;
  }
  if (bytes.length > maximumVmNumberByteLength) {
    return VmNumberError.outOfRange;
  }
  // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
  var mostSignificantByte = bytes[bytes.length - 1];
  var secondMostSignificantByte = bytes[bytes.length - 1 - 1];
  var allButTheSignBit = 127;
  var justTheSignBit = 128;
  if (requireMinimalEncoding &&
  // eslint-disable-next-line no-bitwise
  (mostSignificantByte & allButTheSignBit) === 0 && (
  // eslint-disable-next-line no-bitwise, @typescript-eslint/no-non-null-assertion
  bytes.length <= 1 || (secondMostSignificantByte & justTheSignBit) === 0)) {
    return VmNumberError.requiresMinimal;
  }
  var bitsPerByte = 8;
  var signFlippingByte = 0x80;
  // eslint-disable-next-line functional/no-let
  var result = 0n;
  // eslint-disable-next-line functional/no-let, functional/no-loop-statement, no-plusplus
  for (var byte = 0; byte < bytes.length; byte++) {
    // eslint-disable-next-line functional/no-expression-statement,  no-bitwise, @typescript-eslint/no-non-null-assertion
    result |= BigInt(bytes[byte]) << BigInt(byte * bitsPerByte);
  }
  /* eslint-disable no-bitwise */
  // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
  var isNegative = (bytes[bytes.length - 1] & signFlippingByte) !== 0;
  return isNegative ? -(result & ~(BigInt(signFlippingByte) << BigInt(bitsPerByte * (bytes.length - 1)))) : result;
  /* eslint-enable no-bitwise */
};
/**
 * Convert a BigInt into the VM Number format. See {@link vmNumberToBigInt} for
 * more information.
 *
 * @param integer - the BigInt to encode as a VM Number
 */
// eslint-disable-next-line complexity
var bigIntToVmNumber = function bigIntToVmNumber(integer) {
  if (integer === 0n) {
    return new Uint8Array();
  }
  var bytes = [];
  var isNegative = integer < 0;
  var byteStates = 0xff;
  var bitsPerByte = 8;
  // eslint-disable-next-line functional/no-let
  var remaining = isNegative ? -integer : integer;
  // eslint-disable-next-line functional/no-loop-statement
  while (remaining > 0) {
    // eslint-disable-next-line functional/no-expression-statement, functional/immutable-data, no-bitwise
    bytes.push(Number(remaining & BigInt(byteStates)));
    // eslint-disable-next-line functional/no-expression-statement, no-bitwise
    remaining >>= BigInt(bitsPerByte);
  }
  var signFlippingByte = 0x80;
  // eslint-disable-next-line no-bitwise, functional/no-conditional-statement, @typescript-eslint/no-non-null-assertion
  if ((bytes[bytes.length - 1] & signFlippingByte) > 0) {
    // eslint-disable-next-line functional/no-expression-statement, functional/immutable-data
    bytes.push(isNegative ? signFlippingByte : 0x00);
    // eslint-disable-next-line functional/no-conditional-statement
  } else if (isNegative) {
    // eslint-disable-next-line functional/no-expression-statement, functional/immutable-data, no-bitwise
    bytes[bytes.length - 1] |= signFlippingByte;
  }
  return new Uint8Array(bytes);
};
/**
 * Returns true if the provided stack item is "truthy" in the sense required
 * by several operations (anything but zero and "negative zero").
 *
 * The Satoshi implementation calls this method `CastToBool`.
 *
 * @param item - the stack item to check for truthiness
 */
var stackItemIsTruthy = function stackItemIsTruthy(item) {
  var signFlippingByte = 0x80;
  // eslint-disable-next-line functional/no-let, functional/no-loop-statement, no-plusplus
  for (var i = 0; i < item.length; i++) {
    if (item[i] !== 0) {
      if (i === item.length - 1 && item[i] === signFlippingByte) {
        return false;
      }
      return true;
    }
  }
  return false;
};
/**
 * Convert a boolean into VM Number format (the type used to express
 * boolean values emitted by several operations).
 *
 * @param value - the boolean value to convert
 */
var booleanToVmNumber = function booleanToVmNumber(value) {
  return value ? bigIntToVmNumber(1n) : bigIntToVmNumber(0n);
};
/**
 * From C++ implementation:
 * Note that IsPushOnly() *does* consider OP_RESERVED to be a push-type
 * opcode, however execution of OP_RESERVED fails, so it's not relevant to
 * P2SH/BIP62 as the scriptSig would fail prior to the P2SH special
 * validation code being executed.
 */
var isPushOperation = function isPushOperation(opcode) {
  return opcode <= 96;
} /* Opcodes.OP_16 */;
var isPushOnly = function isPushOnly(bytecode) {
  var instructions = decodeAuthenticationInstructions(bytecode);
  return instructions.every(function (instruction) {
    return isPushOperation(instruction.opcode);
  });
};
var isPushOnlyAccurate = function isPushOnlyAccurate(bytecode) {
  var instructions = decodeAuthenticationInstructions(bytecode);
  return !authenticationInstructionsAreMalformed(instructions) && authenticationInstructionsArePushInstructions(instructions);
};
/**
 * Test if the provided locking bytecode is an arbitrary data output.
 * A.K.A. `TX_NULL_DATA`, "data carrier", OP_RETURN output
 * @param lockingBytecode - the locking bytecode to test
 */
var isArbitraryDataOutput = function isArbitraryDataOutput(lockingBytecode) {
  return lockingBytecode.length >= 1 && lockingBytecode[0] === 106 /* Opcodes.OP_RETURN */ && isPushOnly(lockingBytecode.slice(1));
};
/**
 * Given a number of bytes and a fee rate in satoshis-per-kilobyte, return the
 * minimum required fee. This calculation in important for standardness in dust
 * threshold calculation.
 *
 * @param length - the number of bytes for which the fee is to be paid
 * @param feeRateSatsPerKb - the fee rate in satoshis per 1000 bytes
 */
var getMinimumFee = function getMinimumFee(length, feeRateSatsPerKb) {
  if (length < 1n) return 0n;
  var truncated = length * feeRateSatsPerKb / BigInt(1000 /* Dust.bytesPerKb */);
  return truncated === 0n ? 1n : truncated;
};
/**
 * Given an {@link Output} and (optionally) a dust relay fee in
 * satoshis-per-kilobyte, return the minimum satoshi value for this output to
 * not be considered a "dust output". **For nodes to relay or mine a transaction
 * with this output, the output must have a satoshi value greater than or equal
 * to this threshold.**
 *
 * By standardness, if an output is expected to cost more than 1/3 of it's value
 * in fees to spend, it is considered dust. When calculating the expected fee,
 * the input size is assumed to be (at least) the size of a typical P2PKH input
 * spent using a 72-byte ECDSA signature, 148 bytes:
 * - Outpoint transaction hash: 32 bytes
 * - Outpoint index: 4 bytes
 * - Unlocking bytecode length: 1 byte
 * - Push of 72-byte ECDSA signature: 72 + 1 byte
 * - Push of public key: 33 + 1 byte
 * - Sequence number: 4 bytes
 *
 * The encoded length of the serialized output is added to 148 bytes, and the
 * dust threshold for the output is 3 times the minimum fee for the total bytes.
 * For a P2PKH output (34 bytes) and the standard 1000 sat/Kb dust relay fee,
 * this results in a dust limit of `546` satoshis (`(34+148)*3*1000/1000`).
 *
 * Note, arbitrary data outputs are not required to meet the dust limit as
 * they are provably unspendable and can be pruned from the UTXO set.
 *
 * @param output - the output to test
 * @param dustRelayFeeSatPerKb - the "dust relay fee", defaults to `1000n`
 */
var getDustThreshold = function getDustThreshold(output) {
  var dustRelayFeeSatPerKb = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : BigInt(1000 /* Dust.standardDustRelayFee */);
  if (isArbitraryDataOutput(output.lockingBytecode)) {
    return 0n;
  }
  var encodedOutputLength = encodeTransactionOutput(output).length;
  var expectedTotalLength = encodedOutputLength + 148 /* Dust.p2pkhInputLength */;
  return BigInt(3 /* Dust.minimumFeeMultiple */) * getMinimumFee(BigInt(expectedTotalLength), dustRelayFeeSatPerKb);
};
/**
 * Given an {@link Output} and (optionally) a dust relay fee in
 * satoshis-per-kilobyte, return `true` if the provided output is considered
 * a "dust output", or `false` otherwise.
 *
 * @param output - the output to test
 * @param dustRelayFeeSatPerKb - the "dust relay fee", defaults to `1000n`
 */
var isDustOutput = function isDustOutput(output) {
  var dustRelayFeeSatPerKb = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : BigInt(1000 /* Dust.standardDustRelayFee */);
  return output.valueSatoshis < getDustThreshold(output, dustRelayFeeSatPerKb);
};
var isValidUncompressedPublicKeyEncoding = function isValidUncompressedPublicKeyEncoding(publicKey) {
  return publicKey.length === 65 /* PublicKey.uncompressedByteLength */ && publicKey[0] === 4;
} /* PublicKey.uncompressedHeaderByte */;
var isValidCompressedPublicKeyEncoding = function isValidCompressedPublicKeyEncoding(publicKey) {
  return publicKey.length === 33 /* PublicKey.compressedByteLength */ && (publicKey[0] === 2 /* PublicKey.compressedHeaderByteEven */ || publicKey[0] === 3 /* PublicKey.compressedHeaderByteOdd */);
};
var isValidPublicKeyEncoding = function isValidPublicKeyEncoding(publicKey) {
  return isValidCompressedPublicKeyEncoding(publicKey) || isValidUncompressedPublicKeyEncoding(publicKey);
};
// eslint-disable-next-line complexity
var pushNumberOpcodeToNumber = function pushNumberOpcodeToNumber(opcode) {
  if (opcode === 0 /* Opcodes.OP_0 */) {
    return 0;
  }
  if (opcode === 79 /* Opcodes.OP_1NEGATE */) {
    return -1;
  }
  if (!Number.isInteger(opcode) || opcode < 81 /* Opcodes.OP_1 */ || opcode > 96 /* Opcodes.OP_16 */) {
    return false;
  }
  return opcode - 80 /* Opcodes.OP_RESERVED */;
};
// eslint-disable-next-line complexity
var isSimpleMultisig = function isSimpleMultisig(lockingBytecode) {
  var instructions = decodeAuthenticationInstructions(lockingBytecode);
  if (authenticationInstructionsAreMalformed(instructions)) {
    return false;
  }
  var lastIndex = instructions.length - 1;
  if (instructions.length < 4 /* Multisig.minimumInstructions */ ||
  // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
  instructions[lastIndex].opcode !== 174 /* Opcodes.OP_CHECKMULTISIG */) {
    return false;
  }
  /**
   * The required count of signers (the `m` in `m-of-n`).
   */
  // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
  var m = pushNumberOpcodeToNumber(instructions[0].opcode);
  /**
   * The total count of signers (the `n` in `m-of-n`).
   */
  var n = pushNumberOpcodeToNumber(
  // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
  instructions[lastIndex - 1].opcode);
  if (n === false || m === false) {
    return false;
  }
  var publicKeyInstructions = instructions.slice(1 /* Multisig.keyStart */, -2 /* Multisig.keyEnd */);
  if (!authenticationInstructionsArePushInstructions(publicKeyInstructions)) {
    return false;
  }
  var publicKeys = publicKeyInstructions.map(function (instruction) {
    return instruction.data;
  });
  if (publicKeys.some(function (key) {
    return !isValidPublicKeyEncoding(key);
  })) {
    return false;
  }
  return {
    m: m,
    n: n,
    publicKeys: publicKeys
  };
};
// eslint-disable-next-line complexity
var isStandardMultisig = function isStandardMultisig(lockingBytecode) {
  var multisigProperties = isSimpleMultisig(lockingBytecode);
  if (multisigProperties === false) {
    return false;
  }
  var m = multisigProperties.m,
    n = multisigProperties.n;
  if (n < 1 || n > 3 /* Multisig.maximumStandardN */ || m < 1 || m > n) {
    return false;
  }
  return true;
};
var isStandardOutputBytecode = function isStandardOutputBytecode(lockingBytecode) {
  return isPayToPublicKeyHash(lockingBytecode) || isPayToScriptHash20(lockingBytecode) || isPayToPublicKey(lockingBytecode) || isArbitraryDataOutput(lockingBytecode) || isStandardMultisig(lockingBytecode);
};
// eslint-disable-next-line complexity
var isStandardOutputBytecode2023 = function isStandardOutputBytecode2023(lockingBytecode) {
  return isPayToPublicKeyHash(lockingBytecode) || isPayToScriptHash20(lockingBytecode) || isPayToScriptHash32(lockingBytecode) || isPayToPublicKey(lockingBytecode) || isArbitraryDataOutput(lockingBytecode) || isStandardMultisig(lockingBytecode);
};
/**
 * Test a stack item for the SegWit Recovery Rules activated in `BCH_2019_05`.
 *
 * @param bytecode - the stack item to test
 */
// eslint-disable-next-line complexity
var isWitnessProgram = function isWitnessProgram(bytecode) {
  var correctLength = bytecode.length >= 4 /* SegWit.minimumLength */ && bytecode.length <= 42 /* SegWit.maximumLength */;
  var validVersionPush = bytecode[0] === 0 /* SegWit.OP_0 */ ||
  // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
  bytecode[0] >= 81 /* SegWit.OP_1 */ && bytecode[0] <= 96 /* SegWit.OP_16 */;
  var correctLengthByte =
  // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
  bytecode[1] + 2 /* SegWit.versionAndLengthBytes */ === bytecode.length;
  return correctLength && validVersionPush && correctLengthByte;
};

var incrementOperationCount = function incrementOperationCount(operation) {
  return function (state) {
    var nextState = operation(state);
    // eslint-disable-next-line functional/no-expression-statement, functional/immutable-data
    nextState.operationCount += 1;
    return nextState;
  };
};
var conditionallyEvaluate = function conditionallyEvaluate(operation) {
  return function (state) {
    return state.controlStack.every(function (item) {
      return item;
    }) ? operation(state) : state;
  };
};
/**
 * Map a function over each operation in an {@link InstructionSet.operations}
 * object, assigning the result to the same `opcode` in the resulting object.
 * @param operationMap - an operations map from an {@link InstructionSet}
 * @param combinators - a list of functions to apply (in order) to
 * each operation
 */
var mapOverOperations = function mapOverOperations(combinators, operationMap) {
  return Object.keys(operationMap).reduce(function (result, opcode) {
    return _objectSpread2(_objectSpread2({}, result), {}, _defineProperty({}, opcode, combinators.reduce(function (op, combinator) {
      return combinator(op);
    },
    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
    operationMap[Number(opcode)])));
  }, {});
};
/**
 * Pop one stack item off of `state.stack` and provide that item to `operation`.
 */
var useOneStackItem = function useOneStackItem(state, operation) {
  // eslint-disable-next-line functional/immutable-data
  var item = state.stack.pop();
  if (item === undefined) {
    return applyError(state, AuthenticationErrorCommon.emptyStack);
  }
  return operation(state, [item]);
};
var useTwoStackItems = function useTwoStackItems(state, operation) {
  return useOneStackItem(state, function (nextState, _ref) {
    var _ref2 = _slicedToArray(_ref, 1),
      valueTwo = _ref2[0];
    return useOneStackItem(nextState, function (lastState, _ref3) {
      var _ref4 = _slicedToArray(_ref3, 1),
        valueTop = _ref4[0];
      return operation(lastState, [valueTop, valueTwo]);
    });
  });
};
var useThreeStackItems = function useThreeStackItems(state, operation) {
  return useOneStackItem(state, function (nextState, _ref5) {
    var _ref6 = _slicedToArray(_ref5, 1),
      valueThree = _ref6[0];
    return useTwoStackItems(nextState, function (lastState, _ref7) {
      var _ref8 = _slicedToArray(_ref7, 2),
        valueTop = _ref8[0],
        valueTwo = _ref8[1];
      return operation(lastState, [valueTop, valueTwo, valueThree]);
    });
  });
};
var useFourStackItems = function useFourStackItems(state, operation) {
  return useTwoStackItems(state, function (nextState, _ref9) {
    var _ref10 = _slicedToArray(_ref9, 2),
      valueThree = _ref10[0],
      valueFour = _ref10[1];
    return useTwoStackItems(nextState, function (lastState, _ref11) {
      var _ref12 = _slicedToArray(_ref11, 2),
        valueTop = _ref12[0],
        valueTwo = _ref12[1];
      return operation(lastState, [valueTop, valueTwo, valueThree, valueFour]);
    });
  });
};
var useSixStackItems = function useSixStackItems(state, operation) {
  return useFourStackItems(state, function (nextState, _ref13) {
    var _ref14 = _slicedToArray(_ref13, 4),
      valueThree = _ref14[0],
      valueFour = _ref14[1],
      valueFive = _ref14[2],
      valueSix = _ref14[3];
    return useTwoStackItems(nextState, function (lastState, _ref15) {
      var _ref16 = _slicedToArray(_ref15, 2),
        valueTop = _ref16[0],
        valueTwo = _ref16[1];
      return operation(lastState, [valueTop, valueTwo, valueThree, valueFour, valueFive, valueSix]);
    });
  });
};
var typicalMaximumVmNumberByteLength = 8;
var useOneVmNumber = function useOneVmNumber(state, operation) {
  var _ref17 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {
      maximumVmNumberByteLength: typicalMaximumVmNumberByteLength,
      requireMinimalEncoding: true
    },
    _ref17$maximumVmNumbe = _ref17.maximumVmNumberByteLength,
    maximumVmNumberByteLength = _ref17$maximumVmNumbe === void 0 ? typicalMaximumVmNumberByteLength : _ref17$maximumVmNumbe,
    _ref17$requireMinimal = _ref17.requireMinimalEncoding,
    requireMinimalEncoding = _ref17$requireMinimal === void 0 ? true : _ref17$requireMinimal;
  return useOneStackItem(state, function (nextState, _ref18) {
    var _ref19 = _slicedToArray(_ref18, 1),
      item = _ref19[0];
    var value = vmNumberToBigInt(item, {
      maximumVmNumberByteLength: maximumVmNumberByteLength,
      requireMinimalEncoding: requireMinimalEncoding
    });
    if (isVmNumberError(value)) {
      return applyError(state, AuthenticationErrorCommon.invalidVmNumber);
    }
    return operation(nextState, [value]);
  });
};
var useTwoVmNumbers = function useTwoVmNumbers(state, operation) {
  var _ref20 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {
      maximumVmNumberByteLength: typicalMaximumVmNumberByteLength,
      requireMinimalEncoding: true
    },
    _ref20$maximumVmNumbe = _ref20.maximumVmNumberByteLength,
    maximumVmNumberByteLength = _ref20$maximumVmNumbe === void 0 ? typicalMaximumVmNumberByteLength : _ref20$maximumVmNumbe,
    _ref20$requireMinimal = _ref20.requireMinimalEncoding,
    requireMinimalEncoding = _ref20$requireMinimal === void 0 ? true : _ref20$requireMinimal;
  return useOneVmNumber(state, function (nextState, _ref21) {
    var _ref22 = _slicedToArray(_ref21, 1),
      secondValue = _ref22[0];
    return useOneVmNumber(nextState, function (lastState, _ref23) {
      var _ref24 = _slicedToArray(_ref23, 1),
        firstValue = _ref24[0];
      return operation(lastState, [firstValue, secondValue]);
    }, {
      maximumVmNumberByteLength: maximumVmNumberByteLength,
      requireMinimalEncoding: requireMinimalEncoding
    });
  }, {
    maximumVmNumberByteLength: maximumVmNumberByteLength,
    requireMinimalEncoding: requireMinimalEncoding
  });
};
var useThreeVmNumbers = function useThreeVmNumbers(state, operation) {
  var _ref25 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {
      maximumVmNumberByteLength: typicalMaximumVmNumberByteLength,
      requireMinimalEncoding: true
    },
    _ref25$maximumVmNumbe = _ref25.maximumVmNumberByteLength,
    maximumVmNumberByteLength = _ref25$maximumVmNumbe === void 0 ? typicalMaximumVmNumberByteLength : _ref25$maximumVmNumbe,
    _ref25$requireMinimal = _ref25.requireMinimalEncoding,
    requireMinimalEncoding = _ref25$requireMinimal === void 0 ? true : _ref25$requireMinimal;
  return useTwoVmNumbers(state, function (nextState, _ref26) {
    var _ref27 = _slicedToArray(_ref26, 2),
      secondValue = _ref27[0],
      thirdValue = _ref27[1];
    return useOneVmNumber(nextState, function (lastState, _ref28) {
      var _ref29 = _slicedToArray(_ref28, 1),
        firstValue = _ref29[0];
      return operation(lastState, [firstValue, secondValue, thirdValue]);
    }, {
      maximumVmNumberByteLength: maximumVmNumberByteLength,
      requireMinimalEncoding: requireMinimalEncoding
    });
  }, {
    maximumVmNumberByteLength: maximumVmNumberByteLength,
    requireMinimalEncoding: requireMinimalEncoding
  });
};
/**
 * Return the provided state with the provided value pushed to its stack.
 * @param state - the state to update and return
 * @param data - the value to push to the stack
 */
var pushToStack = function pushToStack(state) {
  var _state$stack;
  for (var _len = arguments.length, data = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    data[_key - 1] = arguments[_key];
  }
  // eslint-disable-next-line functional/no-expression-statement, functional/immutable-data
  (_state$stack = state.stack).push.apply(_state$stack, data);
  return state;
};
/**
 * If the provided item exceeds the maximum stack item length, apply an error.
 * Otherwise, return the provided state with the item pushed to its stack.
 * @param state - the state to update and return
 * @param item - the value to push to the stack
 */
var pushToStackChecked = function pushToStackChecked(state, item) {
  var maximumLength = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : ConsensusCommon.maximumStackItemLength;
  if (item.length > maximumLength) {
    return applyError(state, "".concat(AuthenticationErrorCommon.exceededMaximumStackItemLength, " Item length: ").concat(item.length, " bytes."));
  }
  // eslint-disable-next-line functional/no-expression-statement, functional/immutable-data
  state.stack.push(item);
  return state;
};
/**
 * Return the provided state with the VM number pushed to its stack.
 * @param state - the state to update and return
 * @param vmNumber - the number to push to the stack
 */
var pushToStackVmNumber = function pushToStackVmNumber(state, vmNumber) {
  return pushToStack(state, bigIntToVmNumber(vmNumber));
};
/**
 * If the provided number is outside the VM number range, apply an error.
 * Otherwise, return the provided state with the VM number pushed to its stack.
 * @param state - the state to update and return
 * @param vmNumber - the VM number to push to the stack
 */
var pushToStackVmNumberChecked = function pushToStackVmNumberChecked(state, vmNumber) {
  var minVmNumber = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : BigInt(ConsensusCommon.minVmNumber);
  var maxVmNumber = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : BigInt(ConsensusCommon.maxVmNumber);
  if (vmNumber > maxVmNumber || vmNumber < minVmNumber) {
    return applyError(state, AuthenticationErrorCommon.overflowsVmNumberRange);
  }
  return pushToStackVmNumber(state, vmNumber);
};
var combineOperations = function combineOperations(firstOperation, secondOperation) {
  return function (state) {
    return secondOperation(firstOperation(state));
  };
};

var opVerify = function opVerify(state) {
  return useOneStackItem(state, function (nextState, _ref) {
    var _ref2 = _slicedToArray(_ref, 1),
      item = _ref2[0];
    return stackItemIsTruthy(item) ? nextState : applyError(nextState, AuthenticationErrorCommon.failedVerify);
  });
};
var reservedOperation = function reservedOperation(state) {
  return applyError(state, AuthenticationErrorCommon.calledReserved);
};
var opReturn = function opReturn(state) {
  return applyError(state, AuthenticationErrorCommon.calledReturn);
};
var opIf = function opIf(state) {
  if (state.controlStack.every(function (item) {
    return item;
  })) {
    return useOneStackItem(state, function (nextState, _ref3) {
      var _ref4 = _slicedToArray(_ref3, 1),
        item = _ref4[0];
      // eslint-disable-next-line functional/no-expression-statement, functional/immutable-data
      nextState.controlStack.push(stackItemIsTruthy(item));
      return state;
    });
  }
  // eslint-disable-next-line functional/no-expression-statement, functional/immutable-data
  state.controlStack.push(false);
  return state;
};
/**
 * Note, `OP_NOTIF` is not completely equivalent to `OP_NOT OP_IF`. `OP_NOT`
 * operates on a VM Number (as the inverse of `OP_0NOTEQUAL`), while `OP_NOTIF`
 * checks the "truthy-ness" of a stack item like `OP_IF`.
 */
var opNotIf = function opNotIf(state) {
  if (state.controlStack.every(function (item) {
    return item;
  })) {
    return useOneStackItem(state, function (nextState, _ref5) {
      var _ref6 = _slicedToArray(_ref5, 1),
        item = _ref6[0];
      // eslint-disable-next-line functional/no-expression-statement, functional/immutable-data
      nextState.controlStack.push(!stackItemIsTruthy(item));
      return state;
    });
  }
  // eslint-disable-next-line functional/no-expression-statement, functional/immutable-data
  state.controlStack.push(false);
  return state;
};
var opEndIf = function opEndIf(state) {
  // eslint-disable-next-line functional/immutable-data
  var element = state.controlStack.pop();
  if (element === undefined) {
    return applyError(state, AuthenticationErrorCommon.unexpectedEndIf);
  }
  return state;
};
var opElse = function opElse(state) {
  var top = state.controlStack[state.controlStack.length - 1];
  if (top === undefined) {
    return applyError(state, AuthenticationErrorCommon.unexpectedElse);
  }
  // eslint-disable-next-line functional/no-expression-statement, functional/immutable-data
  state.controlStack[state.controlStack.length - 1] = !top;
  return state;
};

var op1Add = function op1Add(state) {
  return useOneVmNumber(state, function (nextState, _ref) {
    var _ref2 = _slicedToArray(_ref, 1),
      value = _ref2[0];
    return pushToStackVmNumberChecked(nextState, value + 1n);
  });
};
var op1Sub = function op1Sub(state) {
  return useOneVmNumber(state, function (nextState, _ref3) {
    var _ref4 = _slicedToArray(_ref3, 1),
      value = _ref4[0];
    return pushToStack(nextState, bigIntToVmNumber(value - 1n));
  });
};
var opNegate = function opNegate(state) {
  return useOneVmNumber(state, function (nextState, _ref5) {
    var _ref6 = _slicedToArray(_ref5, 1),
      value = _ref6[0];
    return pushToStack(nextState, bigIntToVmNumber(-value));
  });
};
var opAbs = function opAbs(state) {
  return useOneVmNumber(state, function (nextState, _ref7) {
    var _ref8 = _slicedToArray(_ref7, 1),
      value = _ref8[0];
    return pushToStack(nextState, bigIntToVmNumber(value < 0 ? -value : value));
  });
};
var opNot = function opNot(state) {
  return useOneVmNumber(state, function (nextState, _ref9) {
    var _ref10 = _slicedToArray(_ref9, 1),
      value = _ref10[0];
    return pushToStack(nextState, value === 0n ? bigIntToVmNumber(1n) : bigIntToVmNumber(0n));
  });
};
var op0NotEqual = function op0NotEqual(state) {
  return useOneVmNumber(state, function (nextState, _ref11) {
    var _ref12 = _slicedToArray(_ref11, 1),
      value = _ref12[0];
    return pushToStack(nextState, value === 0n ? bigIntToVmNumber(0n) : bigIntToVmNumber(1n));
  });
};
var opAdd = function opAdd(state) {
  return useTwoVmNumbers(state, function (nextState, _ref13) {
    var _ref14 = _slicedToArray(_ref13, 2),
      firstValue = _ref14[0],
      secondValue = _ref14[1];
    return pushToStackVmNumberChecked(nextState, firstValue + secondValue);
  });
};
var opSub = function opSub(state) {
  return useTwoVmNumbers(state, function (nextState, _ref15) {
    var _ref16 = _slicedToArray(_ref15, 2),
      firstValue = _ref16[0],
      secondValue = _ref16[1];
    return pushToStack(nextState, bigIntToVmNumber(firstValue - secondValue));
  });
};
var opBoolAnd = function opBoolAnd(state) {
  return useTwoVmNumbers(state, function (nextState, _ref17) {
    var _ref18 = _slicedToArray(_ref17, 2),
      firstValue = _ref18[0],
      secondValue = _ref18[1];
    return pushToStack(nextState, booleanToVmNumber(firstValue !== 0n && secondValue !== 0n));
  });
};
var opBoolOr = function opBoolOr(state) {
  return useTwoVmNumbers(state, function (nextState, _ref19) {
    var _ref20 = _slicedToArray(_ref19, 2),
      firstValue = _ref20[0],
      secondValue = _ref20[1];
    return pushToStack(nextState, booleanToVmNumber(firstValue !== 0n || secondValue !== 0n));
  });
};
var opNumEqual = function opNumEqual(state) {
  return useTwoVmNumbers(state, function (nextState, _ref21) {
    var _ref22 = _slicedToArray(_ref21, 2),
      firstValue = _ref22[0],
      secondValue = _ref22[1];
    return pushToStack(nextState, booleanToVmNumber(firstValue === secondValue));
  });
};
var opNumEqualVerify = combineOperations(opNumEqual, opVerify);
var opNumNotEqual = function opNumNotEqual(state) {
  return useTwoVmNumbers(state, function (nextState, _ref23) {
    var _ref24 = _slicedToArray(_ref23, 2),
      firstValue = _ref24[0],
      secondValue = _ref24[1];
    return pushToStack(nextState, booleanToVmNumber(firstValue !== secondValue));
  });
};
var opLessThan = function opLessThan(state) {
  return useTwoVmNumbers(state, function (nextState, _ref25) {
    var _ref26 = _slicedToArray(_ref25, 2),
      firstValue = _ref26[0],
      secondValue = _ref26[1];
    return pushToStack(nextState, booleanToVmNumber(firstValue < secondValue));
  });
};
var opLessThanOrEqual = function opLessThanOrEqual(state) {
  return useTwoVmNumbers(state, function (nextState, _ref27) {
    var _ref28 = _slicedToArray(_ref27, 2),
      firstValue = _ref28[0],
      secondValue = _ref28[1];
    return pushToStack(nextState, booleanToVmNumber(firstValue <= secondValue));
  });
};
var opGreaterThan = function opGreaterThan(state) {
  return useTwoVmNumbers(state, function (nextState, _ref29) {
    var _ref30 = _slicedToArray(_ref29, 2),
      firstValue = _ref30[0],
      secondValue = _ref30[1];
    return pushToStack(nextState, booleanToVmNumber(firstValue > secondValue));
  });
};
var opGreaterThanOrEqual = function opGreaterThanOrEqual(state) {
  return useTwoVmNumbers(state, function (nextState, _ref31) {
    var _ref32 = _slicedToArray(_ref31, 2),
      firstValue = _ref32[0],
      secondValue = _ref32[1];
    return pushToStack(nextState, booleanToVmNumber(firstValue >= secondValue));
  });
};
var opMin = function opMin(state) {
  return useTwoVmNumbers(state, function (nextState, _ref33) {
    var _ref34 = _slicedToArray(_ref33, 2),
      firstValue = _ref34[0],
      secondValue = _ref34[1];
    return pushToStack(nextState, bigIntToVmNumber(firstValue < secondValue ? firstValue : secondValue));
  });
};
var opMax = function opMax(state) {
  return useTwoVmNumbers(state, function (nextState, _ref35) {
    var _ref36 = _slicedToArray(_ref35, 2),
      firstValue = _ref36[0],
      secondValue = _ref36[1];
    return pushToStack(nextState, bigIntToVmNumber(firstValue > secondValue ? firstValue : secondValue));
  });
};
var opWithin = function opWithin(state) {
  return useThreeVmNumbers(state, function (nextState, _ref37) {
    var _ref38 = _slicedToArray(_ref37, 3),
      firstValue = _ref38[0],
      secondValue = _ref38[1],
      thirdValue = _ref38[2];
    return pushToStack(nextState, booleanToVmNumber(secondValue <= firstValue && firstValue < thirdValue));
  });
};
var opMul = function opMul(state) {
  return useTwoVmNumbers(state, function (nextState, _ref39) {
    var _ref40 = _slicedToArray(_ref39, 2),
      firstValue = _ref40[0],
      secondValue = _ref40[1];
    return pushToStackVmNumberChecked(nextState, firstValue * secondValue);
  });
};
var opDiv = function opDiv(state) {
  return useTwoVmNumbers(state, function (nextState, _ref41) {
    var _ref42 = _slicedToArray(_ref41, 2),
      firstValue = _ref42[0],
      secondValue = _ref42[1];
    return secondValue === 0n ? applyError(nextState, AuthenticationErrorCommon.divisionByZero) : pushToStack(nextState, bigIntToVmNumber(firstValue / secondValue));
  });
};
var opMod = function opMod(state) {
  return useTwoVmNumbers(state, function (nextState, _ref43) {
    var _ref44 = _slicedToArray(_ref43, 2),
      firstValue = _ref44[0],
      secondValue = _ref44[1];
    return secondValue === 0n ? applyError(nextState, AuthenticationErrorCommon.divisionByZero) : pushToStack(nextState, bigIntToVmNumber(firstValue % secondValue));
  });
};

var opEqual = function opEqual(state) {
  return useTwoStackItems(state, function (nextState, _ref) {
    var _ref2 = _slicedToArray(_ref, 2),
      element1 = _ref2[0],
      element2 = _ref2[1];
    return pushToStack(nextState, booleanToVmNumber(binsAreEqual(element1, element2)));
  });
};
var opEqualVerify = combineOperations(opEqual, opVerify);
var bitwiseOperation = function bitwiseOperation(combine) {
  return function (state) {
    return useTwoStackItems(state, function (nextState, _ref3) {
      var _ref4 = _slicedToArray(_ref3, 2),
        a = _ref4[0],
        b = _ref4[1];
      return a.length === b.length ? pushToStack(nextState, combine(a, b)) : applyError(nextState, AuthenticationErrorCommon.mismatchedBitwiseOperandLength);
    });
  };
};
// eslint-disable-next-line no-bitwise, @typescript-eslint/no-non-null-assertion
var opAnd = bitwiseOperation(function (a, b) {
  return a.map(function (v, i) {
    return v & b[i];
  });
});
// eslint-disable-next-line no-bitwise, @typescript-eslint/no-non-null-assertion
var opOr = bitwiseOperation(function (a, b) {
  return a.map(function (v, i) {
    return v | b[i];
  });
});
// eslint-disable-next-line no-bitwise, @typescript-eslint/no-non-null-assertion
var opXor = bitwiseOperation(function (a, b) {
  return a.map(function (v, i) {
    return v ^ b[i];
  });
});

var undefinedOperation = conditionallyEvaluate(function (state) {
  return applyError(state, AuthenticationErrorCommon.unknownOpcode);
});
var checkLimitsCommon = function checkLimitsCommon(operation) {
  return function (state) {
    var nextState = operation(state);
    return nextState.stack.length + nextState.alternateStack.length > ConsensusCommon.maximumStackDepth ? applyError(nextState, AuthenticationErrorCommon.exceededMaximumStackDepth) : nextState.operationCount > ConsensusCommon.maximumOperationCount ? applyError(nextState, AuthenticationErrorCommon.exceededMaximumOperationCount) : nextState;
  };
};
var cloneStack = function cloneStack(stack) {
  return stack.map(function (item) {
    return item.slice();
  });
};
var createAuthenticationProgramStateCommon = function createAuthenticationProgramStateCommon(_ref) {
  var program = _ref.program,
    instructions = _ref.instructions,
    stack = _ref.stack;
  return {
    alternateStack: [],
    controlStack: [],
    instructions: instructions,
    ip: 0,
    lastCodeSeparator: -1,
    operationCount: 0,
    program: program,
    signatureOperationsCount: 0,
    signedMessages: [],
    stack: stack
  };
};
var cloneAuthenticationProgramCommon = function cloneAuthenticationProgramCommon(program) {
  return {
    inputIndex: program.inputIndex,
    sourceOutputs: cloneTransactionOutputsCommon(program.sourceOutputs),
    transaction: cloneTransactionCommon(program.transaction)
  };
};
var cloneAuthenticationProgramStateCommon = function cloneAuthenticationProgramStateCommon(state) {
  return _objectSpread2(_objectSpread2({}, state.error === undefined ? {} : {
    error: state.error
  }), {}, {
    alternateStack: cloneStack(state.alternateStack),
    controlStack: state.controlStack.slice(),
    instructions: state.instructions.map(cloneAuthenticationInstruction),
    ip: state.ip,
    lastCodeSeparator: state.lastCodeSeparator,
    operationCount: state.operationCount,
    program: cloneAuthenticationProgramCommon(state.program),
    signatureOperationsCount: state.signatureOperationsCount,
    signedMessages: state.signedMessages.map(function (item) {
      return _objectSpread2({
        digest: item.digest.slice()
      }, 'serialization' in item ? {
        serialization: item.serialization.slice()
      } : {
        message: item.message.slice()
      });
    }),
    stack: cloneStack(state.stack)
  });
};
var cloneAuthenticationProgramStateBCH = cloneAuthenticationProgramStateCommon;
var cloneAuthenticationProgramState = cloneAuthenticationProgramStateBCH;
var sha256HashLength = 32;
/**
 * This is a meaningless but complete {@link CompilationContextCommon} that uses
 * a different value for each property. This is useful for testing
 * and debugging.
 */
// eslint-disable-next-line complexity
var createCompilationContextCommonTesting = function createCompilationContextCommonTesting() {
  var _ref2 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
    sourceOutputs = _ref2.sourceOutputs,
    inputs = _ref2.inputs,
    locktime = _ref2.locktime,
    version = _ref2.version,
    outputs = _ref2.outputs;
  return {
    inputIndex: 0,
    sourceOutputs: sourceOutputs ? sourceOutputs : [{
      lockingBytecode: Uint8Array.from([]),
      valueSatoshis: 0xffffffffffffffffn
    }],
    transaction: {
      inputs: inputs ? inputs : [{
        outpointIndex: 0,
        outpointTransactionHash: new Uint8Array(sha256HashLength).fill(1),
        sequenceNumber: 0,
        unlockingBytecode: undefined
      }],
      locktime: locktime === undefined ? 0 : locktime,
      outputs: outputs === undefined ? [{
        lockingBytecode: Uint8Array.from([]),
        valueSatoshis: 0xffffffffffffffffn
      }] : outputs,
      version: version === undefined ? 0 : version
    }
  };
};

var isNegative = function isNegative(value) {
  return (
    // eslint-disable-next-line no-bitwise, @typescript-eslint/no-non-null-assertion
    (value & 128 /* Mask.negative */) !== 0
  );
};
var hasUnnecessaryPadding = function hasUnnecessaryPadding(length, firstByte, secondByte
// eslint-disable-next-line @typescript-eslint/no-non-null-assertion
) {
  return length > 1 && firstByte === 0 && !isNegative(secondByte);
};
var isValidInteger = function isValidInteger(signature, tagIndex, length, valueIndex
// eslint-disable-next-line max-params
) {
  return signature[tagIndex] === 2 /* ASN1.integerTagType */ && length !== 0 && !isNegative(signature[valueIndex]) && !hasUnnecessaryPadding(length, signature[valueIndex], signature[valueIndex + 1]);
};
/**
 * Validate a DER-encoded signature.
 *
 * @remarks
 * This function is consensus-critical since BIP66, but differs from the BIP66
 * specification in that it does not validate the existence of a signing
 * serialization type byte at the end of the signature (to support
 * OP_CHECKDATASIG). To validate a bitcoin-encoded signature (including null
 * signatures), use {@link isValidSignatureEncodingBCHTransaction}.
 *
 * @privateRemarks
 * From the Bitcoin ABC C++ implementation:
 *
 * Format: 0x30 [total-length] 0x02 [R-length] [R] 0x02 [S-length] [S]
 * total-length: 1-byte length descriptor of everything that follows,
 * excluding the sighash byte.
 * R-length: 1-byte length descriptor of the R value that follows.
 * R: arbitrary-length big-endian encoded R value. It must use the
 * shortest possible encoding for a positive integers (which means no null
 * bytes at the start, except a single one when the next byte has its highest
 * bit set).
 * S-length: 1-byte length descriptor of the S value that follows.
 * S: arbitrary-length big-endian encoded S value. The same rules apply.
 */
// eslint-disable-next-line complexity
var isValidSignatureEncodingDER = function isValidSignatureEncodingDER(signature) {
  var correctLengthRange = signature.length > 8 /* DER.minimumLength */ && signature.length < 72 /* DER.maximumLength */;
  var correctSequenceTagType = signature[0 /* DER.sequenceTagIndex */] === 48 /* ASN1.sequenceTagType */;
  var correctSequenceLength = signature[1 /* DER.sequenceLengthIndex */] === signature.length - 2 /* DER.sequenceMetadataBytes */;
  var rLength = signature[3 /* DER.rLengthIndex */];
  if (rLength === undefined) {
    return false;
  }
  var consistentRLength = rLength <= signature.length - 7 /* DER.minimumNonRValueBytes */;
  var rIsValid = isValidInteger(signature, 2 /* DER.rTagIndex */, rLength, 4 /* DER.rValueIndex */);
  var sTagIndex = 4 /* DER.rValueIndex */ + rLength; // eslint-disable-line @typescript-eslint/restrict-plus-operands
  var sLengthIndex = sTagIndex + 1;
  var sLength = signature[sLengthIndex];
  if (sLength === undefined) {
    return false;
  }
  var sValueIndex = sLengthIndex + 1;
  var consistentSLength = sValueIndex + sLength === signature.length;
  var sIsValid = isValidInteger(signature, sTagIndex, sLength, sValueIndex);
  return correctLengthRange && correctSequenceTagType && correctSequenceLength && consistentRLength && rIsValid && consistentSLength && sIsValid;
};
/**
 * Validate the encoding of a transaction signature, including a signing
 * serialization type byte (A.K.A. "sighash" byte).
 *
 * @param transactionSignature - the full transaction signature
 */
var isValidSignatureEncodingBCHTransaction = function isValidSignatureEncodingBCHTransaction(transactionSignature, validSigningSerializationTypes) {
  return transactionSignature.length === 0 || validSigningSerializationTypes.includes(
  // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
  transactionSignature[transactionSignature.length - 1]) && (transactionSignature.length === ConsensusCommon.schnorrSignatureLength + 1 || isValidSignatureEncodingDER(transactionSignature.slice(0, transactionSignature.length - 1)));
};
/**
 * Split a bitcoin-encoded signature into a signature and signing serialization
 * type.
 *
 * While a bitcoin-encoded signature only includes a single byte to encode the
 * signing serialization type, a 3-byte forkId can be appended to the signing
 * serialization to provide replay-protection between different forks. (See
 * Bitcoin Cash's Replay Protected Sighash spec for details.)
 *
 * @param encodedSignature - a signature that passes
 * {@link isValidSignatureEncodingBCHTransaction}
 */
var decodeBitcoinSignature = function decodeBitcoinSignature(encodedSignature) {
  return {
    signature: encodedSignature.slice(0, -1),
    signingSerializationType: encodedSignature.slice(-1)
  };
};

var opRipemd160 = function opRipemd160() {
  var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {
      ripemd160: ripemd160$1
    },
    ripemd160 = _ref.ripemd160;
  return function (state) {
    return useOneStackItem(state, function (nextState, _ref2) {
      var _ref3 = _slicedToArray(_ref2, 1),
        value = _ref3[0];
      return pushToStack(nextState, ripemd160.hash(value));
    });
  };
};
var opSha1 = function opSha1() {
  var _ref4 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {
      sha1: sha1$1
    },
    sha1 = _ref4.sha1;
  return function (state) {
    return useOneStackItem(state, function (nextState, _ref5) {
      var _ref6 = _slicedToArray(_ref5, 1),
        value = _ref6[0];
      return pushToStack(nextState, sha1.hash(value));
    });
  };
};
var opSha256 = function opSha256() {
  var _ref7 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {
      sha256: sha256$1
    },
    sha256 = _ref7.sha256;
  return function (state) {
    return useOneStackItem(state, function (nextState, _ref8) {
      var _ref9 = _slicedToArray(_ref8, 1),
        value = _ref9[0];
      return pushToStack(nextState, sha256.hash(value));
    });
  };
};
var opHash160 = function opHash160() {
  var _ref10 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {
      ripemd160: ripemd160$1,
      sha256: sha256$1
    },
    ripemd160 = _ref10.ripemd160,
    sha256 = _ref10.sha256;
  return function (state) {
    return useOneStackItem(state, function (nextState, _ref11) {
      var _ref12 = _slicedToArray(_ref11, 1),
        value = _ref12[0];
      return pushToStack(nextState, ripemd160.hash(sha256.hash(value)));
    });
  };
};
var opHash256 = function opHash256() {
  var _ref13 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {
      sha256: sha256$1
    },
    sha256 = _ref13.sha256;
  return function (state) {
    return useOneStackItem(state, function (nextState, _ref14) {
      var _ref15 = _slicedToArray(_ref14, 1),
        value = _ref15[0];
      return pushToStack(nextState, hash256(value, sha256));
    });
  };
};
var opCodeSeparator = function opCodeSeparator(state) {
  // eslint-disable-next-line functional/no-expression-statement, functional/immutable-data
  state.lastCodeSeparator = state.ip;
  return state;
};
var opCheckSig = function opCheckSig() {
  var _ref16 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {
      secp256k1: secp256k1,
      sha256: sha256$1
    },
    secp256k1$1 = _ref16.secp256k1,
    sha256 = _ref16.sha256;
  return function (s) {
    return (
      // eslint-disable-next-line complexity
      useTwoStackItems(s, function (state, _ref17) {
        var _ref18 = _slicedToArray(_ref17, 2),
          bitcoinEncodedSignature = _ref18[0],
          publicKey = _ref18[1];
        if (!isValidPublicKeyEncoding(publicKey)) {
          return applyError(state, AuthenticationErrorCommon.invalidPublicKeyEncoding);
        }
        if (!isValidSignatureEncodingBCHTransaction(bitcoinEncodedSignature, SigningSerializationTypesBCH)) {
          return applyError(state, AuthenticationErrorCommon.invalidSignatureEncoding, "Transaction signature (including signing serialization): ".concat(binToHex(bitcoinEncodedSignature)));
        }
        var coveredBytecode = encodeAuthenticationInstructions(state.instructions).subarray(state.lastCodeSeparator + 1);
        var _decodeBitcoinSignatu = decodeBitcoinSignature(bitcoinEncodedSignature),
          signingSerializationType = _decodeBitcoinSignatu.signingSerializationType,
          signature = _decodeBitcoinSignatu.signature;
        var serialization = generateSigningSerializationBCH(state.program, {
          coveredBytecode: coveredBytecode,
          signingSerializationType: signingSerializationType
        }, sha256);
        var digest = hash256(serialization, sha256);
        // eslint-disable-next-line functional/no-expression-statement, functional/immutable-data
        state.signedMessages.push({
          digest: digest,
          serialization: serialization
        });
        var useSchnorr = signature.length === ConsensusCommon.schnorrSignatureLength;
        var success = useSchnorr ? secp256k1$1.verifySignatureSchnorr(signature, publicKey, digest) : secp256k1$1.verifySignatureDERLowS(signature, publicKey, digest);
        return !success && signature.length !== 0 ? applyError(state, AuthenticationErrorCommon.nonNullSignatureFailure) : pushToStack(state, booleanToVmNumber(success));
      })
    );
  };
};
// TODO: implement schnorr multisig https://gitlab.com/bitcoin-cash-node/bchn-sw/bitcoincash-upgrade-specifications/-/blob/master/spec/2019-11-15-schnorrmultisig.md
var opCheckMultiSig = function opCheckMultiSig() {
  var _ref19 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {
      secp256k1: secp256k1,
      sha256: sha256$1
    },
    secp256k1$1 = _ref19.secp256k1,
    sha256 = _ref19.sha256;
  return function (s) {
    return useOneVmNumber(s, function (state, publicKeysValue) {
      var potentialPublicKeys = Number(publicKeysValue);
      if (potentialPublicKeys < 0) {
        return applyError(state, AuthenticationErrorCommon.invalidNaturalNumber);
      }
      if (potentialPublicKeys > 20 /* Multisig.maximumPublicKeys */) {
        return applyError(state, AuthenticationErrorCommon.exceedsMaximumMultisigPublicKeyCount);
      }
      var publicKeys =
      // eslint-disable-next-line functional/immutable-data
      potentialPublicKeys > 0 ? state.stack.splice(-potentialPublicKeys) : [];
      // eslint-disable-next-line functional/no-expression-statement, functional/immutable-data
      state.operationCount += potentialPublicKeys;
      return state.operationCount > ConsensusCommon.maximumOperationCount ? applyError(state, AuthenticationErrorCommon.exceededMaximumOperationCount) : useOneVmNumber(state, function (nextState, approvingKeys) {
        var requiredApprovingPublicKeys = Number(approvingKeys);
        if (requiredApprovingPublicKeys < 0) {
          return applyError(nextState, AuthenticationErrorCommon.invalidNaturalNumber);
        }
        if (requiredApprovingPublicKeys > potentialPublicKeys) {
          return applyError(nextState, AuthenticationErrorCommon.insufficientPublicKeys);
        }
        var signatures = requiredApprovingPublicKeys > 0 ?
        // eslint-disable-next-line functional/immutable-data
        nextState.stack.splice(-requiredApprovingPublicKeys) : [];
        return useOneStackItem(nextState,
        // eslint-disable-next-line complexity
        function (finalState, _ref20) {
          var _ref21 = _slicedToArray(_ref20, 1),
            protocolBugValue = _ref21[0];
          if (protocolBugValue.length !== 0) {
            return applyError(finalState, AuthenticationErrorCommon.invalidProtocolBugValue);
          }
          var coveredBytecode = encodeAuthenticationInstructions(finalState.instructions).subarray(finalState.lastCodeSeparator + 1);
          var approvingPublicKeys = 0; // eslint-disable-line functional/no-let
          var remainingSignatures = signatures.length; // eslint-disable-line functional/no-let
          var remainingPublicKeys = publicKeys.length; // eslint-disable-line functional/no-let
          // eslint-disable-next-line functional/no-loop-statement
          while (remainingSignatures > 0 && remainingPublicKeys > 0 && approvingPublicKeys + remainingPublicKeys >= remainingSignatures && approvingPublicKeys !== requiredApprovingPublicKeys) {
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            var publicKey = publicKeys[remainingPublicKeys - 1];
            var bitcoinEncodedSignature =
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            signatures[remainingSignatures - 1];
            if (!isValidPublicKeyEncoding(publicKey)) {
              return applyError(finalState, AuthenticationErrorCommon.invalidPublicKeyEncoding);
            }
            if (!isValidSignatureEncodingBCHTransaction(bitcoinEncodedSignature, SigningSerializationTypesBCH)) {
              return applyError(finalState, AuthenticationErrorCommon.invalidSignatureEncoding, "Transaction signature (including signing serialization type): ".concat(binToHex(bitcoinEncodedSignature)));
            }
            var _decodeBitcoinSignatu2 = decodeBitcoinSignature(bitcoinEncodedSignature),
              signingSerializationType = _decodeBitcoinSignatu2.signingSerializationType,
              signature = _decodeBitcoinSignatu2.signature;
            var serialization = generateSigningSerializationBCH(state.program, {
              coveredBytecode: coveredBytecode,
              signingSerializationType: signingSerializationType
            }, sha256);
            var digest = hash256(serialization, sha256);
            // eslint-disable-next-line functional/no-expression-statement, functional/immutable-data
            finalState.signedMessages.push({
              digest: digest,
              serialization: serialization
            });
            if (signature.length === ConsensusCommon.schnorrSignatureLength) {
              return applyError(finalState, AuthenticationErrorCommon.schnorrSizedSignatureInCheckMultiSig);
            }
            var signed = secp256k1$1.verifySignatureDERLowS(signature, publicKey, digest);
            // eslint-disable-next-line functional/no-conditional-statement
            if (signed) {
              approvingPublicKeys += 1; // eslint-disable-line functional/no-expression-statement
              remainingSignatures -= 1; // eslint-disable-line functional/no-expression-statement
            }

            remainingPublicKeys -= 1; // eslint-disable-line functional/no-expression-statement
          }

          var success = approvingPublicKeys === requiredApprovingPublicKeys;
          if (!success && !signatures.every(function (signature) {
            return signature.length === 0;
          })) {
            return applyError(finalState, AuthenticationErrorCommon.nonNullSignatureFailure);
          }
          return pushToStack(finalState, booleanToVmNumber(success));
        });
      });
    });
  };
};
var opCheckSigVerify = function opCheckSigVerify() {
  var _ref22 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {
      secp256k1: secp256k1,
      sha256: sha256$1
    },
    secp256k1$1 = _ref22.secp256k1,
    sha256 = _ref22.sha256;
  return combineOperations(opCheckSig({
    secp256k1: secp256k1$1,
    sha256: sha256
  }), opVerify);
};
var opCheckMultiSigVerify = function opCheckMultiSigVerify(_ref23) {
  var secp256k1 = _ref23.secp256k1,
    sha256 = _ref23.sha256;
  return combineOperations(opCheckMultiSig({
    secp256k1: secp256k1,
    sha256: sha256
  }), opVerify);
};
/**
 * Validate the encoding of a raw signature – a signature without a signing
 * serialization type byte (A.K.A. "sighash" byte).
 *
 * @param signature - the raw signature
 */
var isValidSignatureEncodingBCHRaw = function isValidSignatureEncodingBCHRaw(signature) {
  return signature.length === 0 || signature.length === ConsensusCommon.schnorrSignatureLength || isValidSignatureEncodingDER(signature);
};
var opCheckDataSig = function opCheckDataSig(_ref24) {
  var secp256k1 = _ref24.secp256k1,
    sha256 = _ref24.sha256;
  return function (state) {
    return (
      // eslint-disable-next-line complexity
      useThreeStackItems(state, function (nextState, _ref25) {
        var _ref26 = _slicedToArray(_ref25, 3),
          signature = _ref26[0],
          message = _ref26[1],
          publicKey = _ref26[2];
        if (!isValidSignatureEncodingBCHRaw(signature)) {
          return applyError(nextState, AuthenticationErrorCommon.invalidSignatureEncoding, "Data signature: ".concat(binToHex(signature)));
        }
        if (!isValidPublicKeyEncoding(publicKey)) {
          return applyError(nextState, AuthenticationErrorCommon.invalidPublicKeyEncoding);
        }
        var digest = sha256.hash(message);
        // eslint-disable-next-line functional/no-expression-statement, functional/immutable-data
        nextState.signedMessages.push({
          digest: digest,
          message: message
        });
        var useSchnorr = signature.length === ConsensusCommon.schnorrSignatureLength;
        var success = useSchnorr ? secp256k1.verifySignatureSchnorr(signature, publicKey, digest) : secp256k1.verifySignatureDERLowS(signature, publicKey, digest);
        return !success && signature.length !== 0 ? applyError(nextState, AuthenticationErrorCommon.nonNullSignatureFailure) : pushToStack(nextState, booleanToVmNumber(success));
      })
    );
  };
};
var opCheckDataSigVerify = function opCheckDataSigVerify() {
  var _ref27 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {
      secp256k1: secp256k1,
      sha256: sha256$1
    },
    secp256k1$1 = _ref27.secp256k1,
    sha256 = _ref27.sha256;
  return combineOperations(opCheckDataSig({
    secp256k1: secp256k1$1,
    sha256: sha256
  }), opVerify);
};
var opReverseBytes = function opReverseBytes(state) {
  return useOneStackItem(state, function (nextState, _ref28) {
    var _ref29 = _slicedToArray(_ref28, 1),
      item = _ref29[0];
    return pushToStack(nextState, item.slice().reverse());
  });
};

var opCat = function opCat(state) {
  return useTwoStackItems(state, function (nextState, _ref) {
    var _ref2 = _slicedToArray(_ref, 2),
      a = _ref2[0],
      b = _ref2[1];
    return pushToStackChecked(nextState, flattenBinArray([a, b]));
  });
};
var opSplit = function opSplit(state) {
  return useOneVmNumber(state, function (nextState, value) {
    var index = Number(value);
    return useOneStackItem(nextState, function (finalState, _ref3) {
      var _ref4 = _slicedToArray(_ref3, 1),
        item = _ref4[0];
      return index < 0 || index > item.length ? applyError(finalState, AuthenticationErrorCommon.invalidSplitIndex) : pushToStack(finalState, item.slice(0, index), item.slice(index));
    });
  });
};
/**
 * Pad a minimally-encoded VM number for `OP_NUM2BIN`.
 */
var padMinimallyEncodedVmNumber = function padMinimallyEncodedVmNumber(vmNumber, length) {
  // eslint-disable-next-line functional/no-let
  var signBit = 0 /* Constants.positiveSign */;
  // eslint-disable-next-line functional/no-conditional-statement
  if (vmNumber.length > 0) {
    // eslint-disable-next-line functional/no-expression-statement, no-bitwise, @typescript-eslint/no-non-null-assertion
    signBit = vmNumber[vmNumber.length - 1] & 128 /* Constants.negativeSign */;
    // eslint-disable-next-line functional/no-expression-statement, no-bitwise, functional/immutable-data
    vmNumber[vmNumber.length - 1] &= 128 /* Constants.negativeSign */ - 1;
  }
  var result = Array.from(vmNumber);
  // eslint-disable-next-line functional/no-loop-statement
  while (result.length < length - 1) {
    // eslint-disable-next-line functional/no-expression-statement, functional/immutable-data
    result.push(0);
  }
  // eslint-disable-next-line functional/no-expression-statement, functional/immutable-data
  result.push(signBit);
  return Uint8Array.from(result);
};
var opNum2Bin = function opNum2Bin(state) {
  return useOneVmNumber(state, function (nextState, value) {
    var targetLength = Number(value);
    return targetLength > ConsensusCommon.maximumStackItemLength ? applyError(nextState, "".concat(AuthenticationErrorCommon.exceededMaximumStackItemLength, " Item length: ").concat(targetLength, " bytes.")) : useOneVmNumber(nextState, function (finalState, _ref5) {
      var _ref6 = _slicedToArray(_ref5, 1),
        target = _ref6[0];
      var minimallyEncoded = bigIntToVmNumber(target);
      return minimallyEncoded.length > targetLength ? applyError(finalState, AuthenticationErrorCommon.insufficientLength) : minimallyEncoded.length === targetLength ? pushToStack(finalState, minimallyEncoded) : pushToStack(finalState, padMinimallyEncodedVmNumber(minimallyEncoded, targetLength));
    }, {
      maximumVmNumberByteLength:
      // TODO: is this right?
      ConsensusCommon.maximumStackItemLength,
      requireMinimalEncoding: false
    });
  });
};
var opBin2Num = function opBin2Num(state) {
  return useOneVmNumber(state, function (nextState, _ref7) {
    var _ref8 = _slicedToArray(_ref7, 1),
      target = _ref8[0];
    var minimallyEncoded = bigIntToVmNumber(target);
    return minimallyEncoded.length > ConsensusCommon.maximumVmNumberLength ? applyError(nextState, AuthenticationErrorCommon.exceededMaximumVmNumberLength) : pushToStack(nextState, minimallyEncoded);
  }, {
    // TODO: is this right?
    maximumVmNumberByteLength: ConsensusCommon.maximumStackItemLength,
    requireMinimalEncoding: false
  });
};

var opInputIndex = function opInputIndex(state) {
  return pushToStackVmNumberChecked(state, BigInt(state.program.inputIndex));
};
var opActiveBytecode = function opActiveBytecode(state) {
  return pushToStackChecked(state, encodeAuthenticationInstructions(state.instructions.slice(state.lastCodeSeparator + 1)));
};
var opTxVersion = function opTxVersion(state) {
  return pushToStackVmNumberChecked(state, BigInt(int32UnsignedToSigned(state.program.transaction.version)));
};
var opTxInputCount = function opTxInputCount(state) {
  return pushToStackVmNumberChecked(state, BigInt(state.program.transaction.inputs.length));
};
var opTxOutputCount = function opTxOutputCount(state) {
  return pushToStackVmNumberChecked(state, BigInt(state.program.transaction.outputs.length));
};
var opTxLocktime = function opTxLocktime(state) {
  return pushToStackVmNumberChecked(state, BigInt(state.program.transaction.locktime));
};
var useTransactionUtxo = function useTransactionUtxo(state, operation) {
  return useOneVmNumber(state, function (nextState, _ref) {
    var _ref2 = _slicedToArray(_ref, 1),
      index = _ref2[0];
    var utxo = nextState.program.sourceOutputs[Number(index)];
    if (utxo === undefined) {
      return applyError(nextState, AuthenticationErrorCommon.invalidTransactionUtxoIndex);
    }
    return operation(state, [utxo]);
  });
};
var opUtxoValue = function opUtxoValue(state) {
  return useTransactionUtxo(state, function (nextState, _ref3) {
    var _ref4 = _slicedToArray(_ref3, 1),
      utxo = _ref4[0];
    return pushToStackVmNumberChecked(nextState, utxo.valueSatoshis);
  });
};
var opUtxoBytecode = function opUtxoBytecode(state) {
  return useTransactionUtxo(state, function (nextState, _ref5) {
    var _ref6 = _slicedToArray(_ref5, 1),
      utxo = _ref6[0];
    return pushToStackChecked(nextState, utxo.lockingBytecode.slice());
  });
};
var useTransactionInput = function useTransactionInput(state, operation) {
  return useOneVmNumber(state, function (nextState, _ref7) {
    var _ref8 = _slicedToArray(_ref7, 1),
      index = _ref8[0];
    var input = nextState.program.transaction.inputs[Number(index)];
    if (input === undefined) {
      return applyError(nextState, AuthenticationErrorCommon.invalidTransactionInputIndex);
    }
    return operation(state, [input]);
  });
};
var opOutpointTxHash = function opOutpointTxHash(state) {
  return useTransactionInput(state, function (nextState, _ref9) {
    var _ref10 = _slicedToArray(_ref9, 1),
      input = _ref10[0];
    return pushToStackChecked(nextState, input.outpointTransactionHash.slice().reverse());
  });
};
var opOutpointIndex = function opOutpointIndex(state) {
  return useTransactionInput(state, function (nextState, _ref11) {
    var _ref12 = _slicedToArray(_ref11, 1),
      input = _ref12[0];
    return pushToStackVmNumberChecked(nextState, BigInt(input.outpointIndex));
  });
};
var opInputBytecode = function opInputBytecode(state) {
  return useTransactionInput(state, function (nextState, _ref13) {
    var _ref14 = _slicedToArray(_ref13, 1),
      input = _ref14[0];
    return pushToStackChecked(nextState, input.unlockingBytecode.slice());
  });
};
var opInputSequenceNumber = function opInputSequenceNumber(state) {
  return useTransactionInput(state, function (nextState, _ref15) {
    var _ref16 = _slicedToArray(_ref15, 1),
      input = _ref16[0];
    return pushToStackVmNumberChecked(nextState, BigInt(input.sequenceNumber));
  });
};
var useTransactionOutput = function useTransactionOutput(state, operation) {
  return useOneVmNumber(state, function (nextState, _ref17) {
    var _ref18 = _slicedToArray(_ref17, 1),
      index = _ref18[0];
    var input = nextState.program.transaction.outputs[Number(index)];
    if (input === undefined) {
      return applyError(nextState, AuthenticationErrorCommon.invalidTransactionOutputIndex);
    }
    return operation(state, [input]);
  });
};
var opOutputValue = function opOutputValue(state) {
  return useTransactionOutput(state, function (nextState, _ref19) {
    var _ref20 = _slicedToArray(_ref19, 1),
      output = _ref20[0];
    return pushToStackVmNumberChecked(nextState, output.valueSatoshis);
  });
};
var opOutputBytecode = function opOutputBytecode(state) {
  return useTransactionOutput(state, function (nextState, _ref21) {
    var _ref22 = _slicedToArray(_ref21, 1),
      output = _ref22[0];
    return pushToStackChecked(nextState, output.lockingBytecode.slice());
  });
};

var opNop = function opNop(state) {
  return state;
};
var opNopDisallowed = function opNopDisallowed(state) {
  return applyError(state, AuthenticationErrorCommon.calledUpgradableNop);
};
/**
 * "Disabled" operations are explicitly forbidden from occurring anywhere in VM
 * bytecode, even within an unexecuted branch.
 */
var disabledOperation = function disabledOperation(state) {
  return applyError(state, AuthenticationErrorCommon.unknownOpcode);
};

/**
 * Returns the minimal bytecode required to push the provided `data` to the
 * stack.
 *
 * @remarks
 * This method conservatively encodes a `Uint8Array` as a data push. For VM
 * Numbers that can be pushed using a single opcode (-1 through 16), the
 * equivalent bytecode value is returned. Other `data` values will be prefixed
 * with the proper opcode and push length bytes (if necessary) to create the
 * minimal push instruction.
 *
 * Note, while some single-byte VM Number pushes will be minimally-encoded by
 * this method, all larger inputs will be encoded as-is (it cannot be assumed
 * that inputs are intended to be used as VM Numbers). To encode the push of a
 * VM Number, minimally-encode the number before passing it to this
 * method, e.g.:
 * `encodeDataPush(bigIntToVmNumber(decodeVmNumber(nonMinimalNumber)))`.
 *
 * The maximum `bytecode` length that can be encoded for a push in the Bitcoin
 * system is `4294967295` (~4GB). This method assumes a smaller input – if
 * `bytecode` has the potential to be longer, it should be checked (and the
 * error handled) prior to calling this method.
 *
 * @param data - the Uint8Array to push to the stack
 */
// eslint-disable-next-line complexity
var encodeDataPush = function encodeDataPush(data) {
  return data.length <= 75 /* PushOperationConstants.maximumPushByteOperationSize */ ? data.length === 0 ? Uint8Array.of(0) : data.length === 1 ?
  // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
  data[0] !== 0 && data[0] <= 16 /* PushOperationConstants.pushNumberOpcodes */ ? Uint8Array.of(
  // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
  data[0] + 80 /* PushOperationConstants.pushNumberOpcodesOffset */) : data[0] === 129 /* PushOperationConstants.negativeOne */ ? Uint8Array.of(79 /* PushOperationConstants.OP_1NEGATE */) : Uint8Array.from([1].concat(_toConsumableArray(data))) : Uint8Array.from([data.length].concat(_toConsumableArray(data))) : data.length <= 255 /* PushOperationConstants.maximumPushData1Size */ ? Uint8Array.from([76 /* PushOperationConstants.OP_PUSHDATA_1 */, data.length].concat(_toConsumableArray(data))) : data.length <= 65535 /* PushOperationConstants.maximumPushData2Size */ ? Uint8Array.from([77 /* PushOperationConstants.OP_PUSHDATA_2 */].concat(_toConsumableArray(numberToBinUint16LE(data.length)), _toConsumableArray(data))) : Uint8Array.from([78 /* PushOperationConstants.OP_PUSHDATA_4 */].concat(_toConsumableArray(numberToBinUint32LE(data.length)), _toConsumableArray(data)));
};
/**
 * Returns true if the provided `data` is minimally-encoded by the provided
 * `opcode`.
 * @param opcode - the opcode used to push `data`
 * @param data - the contents of the push
 */
// eslint-disable-next-line complexity
var isMinimalDataPush = function isMinimalDataPush(opcode, data) {
  if (data.length === 0) {
    return opcode === 0 /* PushOperationConstants.OP_0 */;
  }

  if (data.length === 1) {
    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
    if (data[0] >= 1 && data[0] <= 16 /* PushOperationConstants.pushNumberOpcodes */) {
      return (
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        opcode === data[0] + 80 /* PushOperationConstants.pushNumberOpcodesOffset */
      );
    }

    if (data[0] === 129 /* PushOperationConstants.negativeOne */) {
      return opcode === 79 /* PushOperationConstants.OP_1NEGATE */;
    }

    return true;
  }
  if (data.length <= 75 /* PushOperationConstants.maximumPushByteOperationSize */) {
    return opcode === data.length;
  }
  if (data.length <= 255 /* PushOperationConstants.maximumPushData1Size */) {
    return opcode === 76 /* PushOperationConstants.OP_PUSHDATA_1 */;
  }

  if (data.length <= 65535 /* PushOperationConstants.maximumPushData2Size */) {
    return opcode === 77 /* PushOperationConstants.OP_PUSHDATA_2 */;
  }

  if (data.length <= 4294967295 /* PushOperationConstants.maximumPushData4Size */) {
    return opcode === 78 /* PushOperationConstants.OP_PUSHDATA_4 */;
  }

  return false;
};
var executionIsActive$1 = function executionIsActive(state) {
  return state.controlStack.every(function (item) {
    return item;
  });
};
// TODO: add tests that verify the order of operations below (are non-minimal pushes OK inside unexecuted conditionals?)
var pushOperation = function pushOperation() {
  var maximumPushSize = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : ConsensusCommon.maximumStackItemLength;
  return function (state) {
    var instruction = state.instructions[state.ip];
    return instruction.data.length > maximumPushSize ? applyError(state, "".concat(AuthenticationErrorCommon.exceededMaximumStackItemLength, " Item length: ").concat(instruction.data.length, " bytes.")) : executionIsActive$1(state) ? isMinimalDataPush(instruction.opcode, instruction.data) ? pushToStack(state, instruction.data) : applyError(state, AuthenticationErrorCommon.nonMinimalPush) : state;
  };
};
/**
 * @param number - the number that is pushed to the stack by this operation.
 * @returns an operation that pushes a number to the stack.
 */
var pushNumberOperation = function pushNumberOperation(number) {
  var value = bigIntToVmNumber(BigInt(number));
  return function (state) {
    return pushToStack(state, value);
  };
};

var opToAltStack = function opToAltStack(state) {
  return useOneStackItem(state, function (nextState, _ref) {
    var _ref2 = _slicedToArray(_ref, 1),
      item = _ref2[0];
    // eslint-disable-next-line functional/no-expression-statement, functional/immutable-data
    nextState.alternateStack.push(item);
    return nextState;
  });
};
var opFromAltStack = function opFromAltStack(state) {
  // eslint-disable-next-line functional/immutable-data
  var item = state.alternateStack.pop();
  if (item === undefined) {
    return applyError(state, AuthenticationErrorCommon.emptyAlternateStack);
  }
  return pushToStack(state, item);
};
var op2Drop = function op2Drop(state) {
  return useTwoStackItems(state, function (nextState) {
    return nextState;
  });
};
var op2Dup = function op2Dup(state) {
  return useTwoStackItems(state, function (nextState, _ref3) {
    var _ref4 = _slicedToArray(_ref3, 2),
      a = _ref4[0],
      b = _ref4[1];
    return pushToStack(nextState, a, b, a.slice(), b.slice());
  });
};
var op3Dup = function op3Dup(state) {
  return useThreeStackItems(state, function (nextState, _ref5) {
    var _ref6 = _slicedToArray(_ref5, 3),
      a = _ref6[0],
      b = _ref6[1],
      c = _ref6[2];
    return pushToStack(nextState, a, b, c, a.slice(), b.slice(), c.slice());
  });
};
var op2Over = function op2Over(state) {
  return useFourStackItems(state, function (nextState, _ref7) {
    var _ref8 = _slicedToArray(_ref7, 4),
      a = _ref8[0],
      b = _ref8[1],
      c = _ref8[2],
      d = _ref8[3];
    return pushToStack(nextState, a, b, c, d, a.slice(), b.slice());
  });
};
var op2Rot = function op2Rot(state) {
  return useSixStackItems(state, function (nextState, _ref9) {
    var _ref10 = _slicedToArray(_ref9, 6),
      a = _ref10[0],
      b = _ref10[1],
      c = _ref10[2],
      d = _ref10[3],
      e = _ref10[4],
      f = _ref10[5];
    return pushToStack(nextState, c, d, e, f, a, b);
  });
};
var op2Swap = function op2Swap(state) {
  return useFourStackItems(state, function (nextState, _ref11) {
    var _ref12 = _slicedToArray(_ref11, 4),
      a = _ref12[0],
      b = _ref12[1],
      c = _ref12[2],
      d = _ref12[3];
    return pushToStack(nextState, c, d, a, b);
  });
};
var opIfDup = function opIfDup(state) {
  return useOneStackItem(state, function (nextState, _ref13) {
    var _ref14 = _slicedToArray(_ref13, 1),
      item = _ref14[0];
    return pushToStack.apply(void 0, [nextState].concat(_toConsumableArray(stackItemIsTruthy(item) ? [item, item.slice()] : [item])));
  });
};
var opDepth = function opDepth(state) {
  return pushToStack(state, bigIntToVmNumber(BigInt(state.stack.length)));
};
var opDrop = function opDrop(state) {
  return useOneStackItem(state, function (nextState) {
    return nextState;
  });
};
var opDup = function opDup(state) {
  return useOneStackItem(state, function (nextState, _ref15) {
    var _ref16 = _slicedToArray(_ref15, 1),
      item = _ref16[0];
    return pushToStack(nextState, item, item.slice());
  });
};
var opNip = function opNip(state) {
  return useTwoStackItems(state, function (nextState, _ref17) {
    var _ref18 = _slicedToArray(_ref17, 2),
      b = _ref18[1];
    return pushToStack(nextState, b);
  });
};
var opOver = function opOver(state) {
  return useTwoStackItems(state, function (nextState, _ref19) {
    var _ref20 = _slicedToArray(_ref19, 2),
      a = _ref20[0],
      b = _ref20[1];
    return pushToStack(nextState, a, b, a.slice());
  });
};
var opPick = function opPick(state) {
  return useOneVmNumber(state, function (nextState, depth) {
    var item = nextState.stack[nextState.stack.length - 1 - Number(depth)];
    if (item === undefined) {
      return applyError(state, AuthenticationErrorCommon.invalidStackIndex);
    }
    return pushToStack(nextState, item.slice());
  });
};
var opRoll = function opRoll(state) {
  return useOneVmNumber(state, function (nextState, depth) {
    var index = nextState.stack.length - 1 - Number(depth);
    if (index < 0 || index > nextState.stack.length - 1) {
      return applyError(state, AuthenticationErrorCommon.invalidStackIndex);
    }
    // eslint-disable-next-line functional/immutable-data, @typescript-eslint/no-non-null-assertion
    return pushToStack(nextState, nextState.stack.splice(index, 1)[0]);
  });
};
var opRot = function opRot(state) {
  return useThreeStackItems(state, function (nextState, _ref21) {
    var _ref22 = _slicedToArray(_ref21, 3),
      a = _ref22[0],
      b = _ref22[1],
      c = _ref22[2];
    return pushToStack(nextState, b, c, a);
  });
};
var opSwap = function opSwap(state) {
  return useTwoStackItems(state, function (nextState, _ref23) {
    var _ref24 = _slicedToArray(_ref23, 2),
      a = _ref24[0],
      b = _ref24[1];
    return pushToStack(nextState, b, a);
  });
};
var opTuck = function opTuck(state) {
  return useTwoStackItems(state, function (nextState, _ref25) {
    var _ref26 = _slicedToArray(_ref25, 2),
      a = _ref26[0],
      b = _ref26[1];
    return pushToStack(nextState, b.slice(), a, b);
  });
};
var opSize = function opSize(state) {
  return useOneStackItem(state, function (nextState, _ref27) {
    var _ref28 = _slicedToArray(_ref27, 1),
      item = _ref28[0];
    return pushToStack(nextState, item, bigIntToVmNumber(BigInt(item.length)));
  });
};

var useLocktime = function useLocktime(state, operation) {
  var item = state.stack[state.stack.length - 1];
  if (item === undefined) {
    return applyError(state, AuthenticationErrorCommon.emptyStack);
  }
  var decodedLocktime = vmNumberToBigInt(item, {
    maximumVmNumberByteLength: 5 /* Constants.locktimeVmNumberByteLength */,
    requireMinimalEncoding: true
  });
  if (isVmNumberError(decodedLocktime)) {
    return applyError(state, AuthenticationErrorCommon.invalidVmNumber);
  }
  var locktime = Number(decodedLocktime);
  if (locktime < 0) {
    return applyError(state, AuthenticationErrorCommon.negativeLocktime);
  }
  return operation(state, locktime);
};
var locktimeTypesAreCompatible = function locktimeTypesAreCompatible(locktime, requiredLocktime) {
  return locktime < 500000000 /* Constants.locktimeThreshold */ && requiredLocktime < 500000000 /* Constants.locktimeThreshold */ || locktime >= 500000000 /* Constants.locktimeThreshold */ && requiredLocktime >= 500000000 /* Constants.locktimeThreshold */;
};
var opCheckLockTimeVerify = function opCheckLockTimeVerify(state) {
  return useLocktime(state, function (nextState, requiredLocktime) {
    if (!locktimeTypesAreCompatible(nextState.program.transaction.locktime, requiredLocktime)) {
      return applyError(nextState, AuthenticationErrorCommon.incompatibleLocktimeType);
    }
    if (requiredLocktime > nextState.program.transaction.locktime) {
      return applyError(nextState, AuthenticationErrorCommon.unsatisfiedLocktime);
    }
    var sequenceNumber =
    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
    nextState.program.transaction.inputs[nextState.program.inputIndex].sequenceNumber;
    if (sequenceNumber === 4294967295 /* Constants.locktimeDisablingSequenceNumber */) {
      return applyError(nextState, AuthenticationErrorCommon.locktimeDisabled);
    }
    return nextState;
  });
};
// eslint-disable-next-line no-bitwise
var includesFlag = function includesFlag(value, flag) {
  return (value & flag) !== 0;
};
var opCheckSequenceVerify = function opCheckSequenceVerify(state) {
  return useLocktime(state,
  // eslint-disable-next-line complexity
  function (nextState, requiredSequence) {
    var sequenceNumber =
    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
    nextState.program.transaction.inputs[nextState.program.inputIndex].sequenceNumber;
    var sequenceLocktimeDisabled = includesFlag(requiredSequence, 2147483648 /* Constants.sequenceLocktimeDisableFlag */);
    if (sequenceLocktimeDisabled) {
      return nextState;
    }
    if (nextState.program.transaction.version < 2 /* Constants.sequenceLocktimeTransactionVersionMinimum */) {
      return applyError(nextState, AuthenticationErrorCommon.checkSequenceUnavailable);
    }
    if (includesFlag(sequenceNumber, 2147483648 /* Constants.sequenceLocktimeDisableFlag */)) {
      return applyError(nextState, AuthenticationErrorCommon.unmatchedSequenceDisable);
    }
    if (includesFlag(requiredSequence, 4194304 /* Constants.sequenceLocktimeTypeFlag */) !== includesFlag(sequenceNumber, 4194304 /* Constants.sequenceLocktimeTypeFlag */)) {
      return applyError(nextState, AuthenticationErrorCommon.incompatibleSequenceType);
    }
    if (
    // eslint-disable-next-line no-bitwise
    (requiredSequence & 65535 /* Constants.sequenceLocktimeMask */) > (
    // eslint-disable-next-line no-bitwise
    sequenceNumber & 65535 /* Constants.sequenceLocktimeMask */)) {
      return applyError(nextState, AuthenticationErrorCommon.unsatisfiedSequenceNumber);
    }
    return nextState;
  });
};

/**
 * Consensus settings for the `BCH_2023_05` instruction set.
 */
var ConsensusBCH2023;
(function (ConsensusBCH2023) {
  /**
   * A.K.A. `MAX_SCRIPT_SIZE`
   */
  ConsensusBCH2023[ConsensusBCH2023["maximumBytecodeLength"] = 10000] = "maximumBytecodeLength";
  /**
   * A.K.A. `MAX_OP_RETURN_RELAY`, `nMaxDatacarrierBytes`
   */
  ConsensusBCH2023[ConsensusBCH2023["maximumDataCarrierBytes"] = 223] = "maximumDataCarrierBytes";
  /**
   * A.K.A. `MAX_OPS_PER_SCRIPT`
   */
  ConsensusBCH2023[ConsensusBCH2023["maximumOperationCount"] = 201] = "maximumOperationCount";
  /**
   * A.K.A. `MAX_STACK_SIZE`
   */
  ConsensusBCH2023[ConsensusBCH2023["maximumStackDepth"] = 1000] = "maximumStackDepth";
  /**
   * A.K.A. `MAX_SCRIPT_ELEMENT_SIZE`
   */
  ConsensusBCH2023[ConsensusBCH2023["maximumStackItemLength"] = 520] = "maximumStackItemLength";
  /**
   * A.K.A. `MAX_STANDARD_VERSION`
   */
  ConsensusBCH2023[ConsensusBCH2023["maximumStandardVersion"] = 2] = "maximumStandardVersion";
  /**
   * A.K.A. `MAX_TX_IN_SCRIPT_SIG_SIZE`
   */
  ConsensusBCH2023[ConsensusBCH2023["maximumStandardUnlockingBytecodeLength"] = 1650] = "maximumStandardUnlockingBytecodeLength";
  /**
   * Transactions smaller than 65 bytes are forbidden to prevent exploits of the
   * transaction Merkle tree design.
   *
   * A.K.A. `MIN_TX_SIZE`
   */
  ConsensusBCH2023[ConsensusBCH2023["minimumTransactionSize"] = 65] = "minimumTransactionSize";
  /**
   * A.K.A. `MAX_STANDARD_TX_SIZE`
   */
  ConsensusBCH2023[ConsensusBCH2023["maximumStandardTransactionSize"] = 100000] = "maximumStandardTransactionSize";
  /**
   * A.K.A. `MAX_TX_SIZE`
   */
  ConsensusBCH2023[ConsensusBCH2023["maximumTransactionSize"] = 1000000] = "maximumTransactionSize";
  /**
   * A.K.A. `MAXIMUM_ELEMENT_SIZE_64_BIT`
   */
  ConsensusBCH2023[ConsensusBCH2023["maximumVmNumberLength"] = 8] = "maximumVmNumberLength";
  ConsensusBCH2023["minVmNumber"] = "-9223372036854775807";
  ConsensusBCH2023["maxVmNumber"] = "9223372036854775807";
  ConsensusBCH2023[ConsensusBCH2023["schnorrSignatureLength"] = 64] = "schnorrSignatureLength";
  ConsensusBCH2023[ConsensusBCH2023["maximumCommitmentLength"] = 40] = "maximumCommitmentLength";
})(ConsensusBCH2023 || (ConsensusBCH2023 = {}));
// eslint-disable-next-line @typescript-eslint/naming-convention
var SigningSerializationTypesBCH2023 = [].concat(_toConsumableArray(SigningSerializationTypesBCH), [SigningSerializationTypeBCH.allOutputsAllUtxos, SigningSerializationTypeBCH.correspondingOutputAllUtxos, SigningSerializationTypeBCH.noOutputsAllUtxos]);

var opCheckSigBCH2023 = function opCheckSigBCH2023() {
  var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {
      secp256k1: secp256k1,
      sha256: sha256$1
    },
    secp256k1$1 = _ref.secp256k1,
    sha256 = _ref.sha256;
  return function (s) {
    return (
      // eslint-disable-next-line complexity
      useTwoStackItems(s, function (state, _ref2) {
        var _ref3 = _slicedToArray(_ref2, 2),
          bitcoinEncodedSignature = _ref3[0],
          publicKey = _ref3[1];
        if (!isValidPublicKeyEncoding(publicKey)) {
          return applyError(state, AuthenticationErrorCommon.invalidPublicKeyEncoding);
        }
        if (!isValidSignatureEncodingBCHTransaction(bitcoinEncodedSignature, SigningSerializationTypesBCH2023)) {
          return applyError(state, AuthenticationErrorCommon.invalidSignatureEncoding, "Transaction signature (including signing serialization): ".concat(binToHex(bitcoinEncodedSignature)));
        }
        var coveredBytecode = encodeAuthenticationInstructions(state.instructions).subarray(state.lastCodeSeparator + 1);
        var _decodeBitcoinSignatu = decodeBitcoinSignature(bitcoinEncodedSignature),
          signingSerializationType = _decodeBitcoinSignatu.signingSerializationType,
          signature = _decodeBitcoinSignatu.signature;
        var serialization = generateSigningSerializationBCH(state.program, {
          coveredBytecode: coveredBytecode,
          signingSerializationType: signingSerializationType
        }, sha256);
        var digest = hash256(serialization, sha256);
        // eslint-disable-next-line functional/no-expression-statement, functional/immutable-data
        state.signedMessages.push({
          digest: digest,
          serialization: serialization
        });
        var useSchnorr = signature.length === ConsensusCommon.schnorrSignatureLength;
        var success = useSchnorr ? secp256k1$1.verifySignatureSchnorr(signature, publicKey, digest) : secp256k1$1.verifySignatureDERLowS(signature, publicKey, digest);
        return !success && signature.length !== 0 ? applyError(state, AuthenticationErrorCommon.nonNullSignatureFailure) : pushToStack(state, booleanToVmNumber(success));
      })
    );
  };
};
// TODO: implement schnorr multisig https://gitlab.com/bitcoin-cash-node/bchn-sw/bitcoincash-upgrade-specifications/-/blob/master/spec/2019-11-15-schnorrmultisig.md
var opCheckMultiSigBCH2023 = function opCheckMultiSigBCH2023() {
  var _ref4 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {
      secp256k1: secp256k1,
      sha256: sha256$1
    },
    secp256k1$1 = _ref4.secp256k1,
    sha256 = _ref4.sha256;
  return function (s) {
    return useOneVmNumber(s, function (state, publicKeysValue) {
      var potentialPublicKeys = Number(publicKeysValue);
      if (potentialPublicKeys < 0) {
        return applyError(state, AuthenticationErrorCommon.invalidNaturalNumber);
      }
      if (potentialPublicKeys > 20 /* Multisig.maximumPublicKeys */) {
        return applyError(state, AuthenticationErrorCommon.exceedsMaximumMultisigPublicKeyCount);
      }
      var publicKeys =
      // eslint-disable-next-line functional/immutable-data
      potentialPublicKeys > 0 ? state.stack.splice(-potentialPublicKeys) : [];
      // eslint-disable-next-line functional/no-expression-statement, functional/immutable-data
      state.operationCount += potentialPublicKeys;
      return state.operationCount > ConsensusCommon.maximumOperationCount ? applyError(state, AuthenticationErrorCommon.exceededMaximumOperationCount) : useOneVmNumber(state, function (nextState, approvingKeys) {
        var requiredApprovingPublicKeys = Number(approvingKeys);
        if (requiredApprovingPublicKeys < 0) {
          return applyError(nextState, AuthenticationErrorCommon.invalidNaturalNumber);
        }
        if (requiredApprovingPublicKeys > potentialPublicKeys) {
          return applyError(nextState, AuthenticationErrorCommon.insufficientPublicKeys);
        }
        var signatures = requiredApprovingPublicKeys > 0 ?
        // eslint-disable-next-line functional/immutable-data
        nextState.stack.splice(-requiredApprovingPublicKeys) : [];
        return useOneStackItem(nextState,
        // eslint-disable-next-line complexity
        function (finalState, _ref5) {
          var _ref6 = _slicedToArray(_ref5, 1),
            protocolBugValue = _ref6[0];
          if (protocolBugValue.length !== 0) {
            return applyError(finalState, AuthenticationErrorCommon.invalidProtocolBugValue);
          }
          var coveredBytecode = encodeAuthenticationInstructions(finalState.instructions).subarray(finalState.lastCodeSeparator + 1);
          var approvingPublicKeys = 0; // eslint-disable-line functional/no-let
          var remainingSignatures = signatures.length; // eslint-disable-line functional/no-let
          var remainingPublicKeys = publicKeys.length; // eslint-disable-line functional/no-let
          // eslint-disable-next-line functional/no-loop-statement
          while (remainingSignatures > 0 && remainingPublicKeys > 0 && approvingPublicKeys + remainingPublicKeys >= remainingSignatures && approvingPublicKeys !== requiredApprovingPublicKeys) {
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            var publicKey = publicKeys[remainingPublicKeys - 1];
            var bitcoinEncodedSignature =
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            signatures[remainingSignatures - 1];
            if (!isValidPublicKeyEncoding(publicKey)) {
              return applyError(finalState, AuthenticationErrorCommon.invalidPublicKeyEncoding);
            }
            if (!isValidSignatureEncodingBCHTransaction(bitcoinEncodedSignature, SigningSerializationTypesBCH2023)) {
              return applyError(finalState, AuthenticationErrorCommon.invalidSignatureEncoding, "Transaction signature (including signing serialization type): ".concat(binToHex(bitcoinEncodedSignature)));
            }
            var _decodeBitcoinSignatu2 = decodeBitcoinSignature(bitcoinEncodedSignature),
              signingSerializationType = _decodeBitcoinSignatu2.signingSerializationType,
              signature = _decodeBitcoinSignatu2.signature;
            var serialization = generateSigningSerializationBCH(state.program, {
              coveredBytecode: coveredBytecode,
              signingSerializationType: signingSerializationType
            }, sha256);
            var digest = hash256(serialization, sha256);
            // eslint-disable-next-line functional/no-expression-statement, functional/immutable-data
            finalState.signedMessages.push({
              digest: digest,
              serialization: serialization
            });
            if (signature.length === ConsensusCommon.schnorrSignatureLength) {
              return applyError(finalState, AuthenticationErrorCommon.schnorrSizedSignatureInCheckMultiSig);
            }
            var signed = secp256k1$1.verifySignatureDERLowS(signature, publicKey, digest);
            // eslint-disable-next-line functional/no-conditional-statement
            if (signed) {
              approvingPublicKeys += 1; // eslint-disable-line functional/no-expression-statement
              remainingSignatures -= 1; // eslint-disable-line functional/no-expression-statement
            }

            remainingPublicKeys -= 1; // eslint-disable-line functional/no-expression-statement
          }

          var success = approvingPublicKeys === requiredApprovingPublicKeys;
          if (!success && !signatures.every(function (signature) {
            return signature.length === 0;
          })) {
            return applyError(finalState, AuthenticationErrorCommon.nonNullSignatureFailure);
          }
          return pushToStack(finalState, booleanToVmNumber(success));
        });
      });
    });
  };
};
var opCheckSigVerifyBCH2023 = function opCheckSigVerifyBCH2023() {
  var _ref7 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {
      secp256k1: secp256k1,
      sha256: sha256$1
    },
    secp256k1$1 = _ref7.secp256k1,
    sha256 = _ref7.sha256;
  return combineOperations(opCheckSigBCH2023({
    secp256k1: secp256k1$1,
    sha256: sha256
  }), opVerify);
};
var opCheckMultiSigVerifyBCH2023 = function opCheckMultiSigVerifyBCH2023(_ref8) {
  var secp256k1 = _ref8.secp256k1,
    sha256 = _ref8.sha256;
  return combineOperations(opCheckMultiSigBCH2023({
    secp256k1: secp256k1,
    sha256: sha256
  }), opVerify);
};

var OpcodeDescriptionsBCH2023;
(function (OpcodeDescriptionsBCH2023) {
  OpcodeDescriptionsBCH2023["OP_0"] = "Push the VM Number 0 onto the stack.";
  OpcodeDescriptionsBCH2023["OP_PUSHBYTES_1"] = "Push the next byte onto the stack.";
  OpcodeDescriptionsBCH2023["OP_PUSHBYTES_2"] = "Push the next 2 bytes onto the stack.";
  OpcodeDescriptionsBCH2023["OP_PUSHBYTES_3"] = "Push the next 3 bytes onto the stack.";
  OpcodeDescriptionsBCH2023["OP_PUSHBYTES_4"] = "Push the next 4 bytes onto the stack.";
  OpcodeDescriptionsBCH2023["OP_PUSHBYTES_5"] = "Push the next 5 bytes onto the stack.";
  OpcodeDescriptionsBCH2023["OP_PUSHBYTES_6"] = "Push the next 6 bytes onto the stack.";
  OpcodeDescriptionsBCH2023["OP_PUSHBYTES_7"] = "Push the next 7 bytes onto the stack.";
  OpcodeDescriptionsBCH2023["OP_PUSHBYTES_8"] = "Push the next 8 bytes onto the stack.";
  OpcodeDescriptionsBCH2023["OP_PUSHBYTES_9"] = "Push the next 9 bytes onto the stack.";
  OpcodeDescriptionsBCH2023["OP_PUSHBYTES_10"] = "Push the next 10 bytes onto the stack.";
  OpcodeDescriptionsBCH2023["OP_PUSHBYTES_11"] = "Push the next 11 bytes onto the stack.";
  OpcodeDescriptionsBCH2023["OP_PUSHBYTES_12"] = "Push the next 12 bytes onto the stack.";
  OpcodeDescriptionsBCH2023["OP_PUSHBYTES_13"] = "Push the next 13 bytes onto the stack.";
  OpcodeDescriptionsBCH2023["OP_PUSHBYTES_14"] = "Push the next 14 bytes onto the stack.";
  OpcodeDescriptionsBCH2023["OP_PUSHBYTES_15"] = "Push the next 15 bytes onto the stack.";
  OpcodeDescriptionsBCH2023["OP_PUSHBYTES_16"] = "Push the next 16 bytes onto the stack.";
  OpcodeDescriptionsBCH2023["OP_PUSHBYTES_17"] = "Push the next 17 bytes onto the stack.";
  OpcodeDescriptionsBCH2023["OP_PUSHBYTES_18"] = "Push the next 18 bytes onto the stack.";
  OpcodeDescriptionsBCH2023["OP_PUSHBYTES_19"] = "Push the next 19 bytes onto the stack.";
  OpcodeDescriptionsBCH2023["OP_PUSHBYTES_20"] = "Push the next 20 bytes onto the stack.";
  OpcodeDescriptionsBCH2023["OP_PUSHBYTES_21"] = "Push the next 21 bytes onto the stack.";
  OpcodeDescriptionsBCH2023["OP_PUSHBYTES_22"] = "Push the next 22 bytes onto the stack.";
  OpcodeDescriptionsBCH2023["OP_PUSHBYTES_23"] = "Push the next 23 bytes onto the stack.";
  OpcodeDescriptionsBCH2023["OP_PUSHBYTES_24"] = "Push the next 24 bytes onto the stack.";
  OpcodeDescriptionsBCH2023["OP_PUSHBYTES_25"] = "Push the next 25 bytes onto the stack.";
  OpcodeDescriptionsBCH2023["OP_PUSHBYTES_26"] = "Push the next 26 bytes onto the stack.";
  OpcodeDescriptionsBCH2023["OP_PUSHBYTES_27"] = "Push the next 27 bytes onto the stack.";
  OpcodeDescriptionsBCH2023["OP_PUSHBYTES_28"] = "Push the next 28 bytes onto the stack.";
  OpcodeDescriptionsBCH2023["OP_PUSHBYTES_29"] = "Push the next 29 bytes onto the stack.";
  OpcodeDescriptionsBCH2023["OP_PUSHBYTES_30"] = "Push the next 30 bytes onto the stack.";
  OpcodeDescriptionsBCH2023["OP_PUSHBYTES_31"] = "Push the next 31 bytes onto the stack.";
  OpcodeDescriptionsBCH2023["OP_PUSHBYTES_32"] = "Push the next 32 bytes onto the stack.";
  OpcodeDescriptionsBCH2023["OP_PUSHBYTES_33"] = "Push the next 33 bytes onto the stack.";
  OpcodeDescriptionsBCH2023["OP_PUSHBYTES_34"] = "Push the next 34 bytes onto the stack.";
  OpcodeDescriptionsBCH2023["OP_PUSHBYTES_35"] = "Push the next 35 bytes onto the stack.";
  OpcodeDescriptionsBCH2023["OP_PUSHBYTES_36"] = "Push the next 36 bytes onto the stack.";
  OpcodeDescriptionsBCH2023["OP_PUSHBYTES_37"] = "Push the next 37 bytes onto the stack.";
  OpcodeDescriptionsBCH2023["OP_PUSHBYTES_38"] = "Push the next 38 bytes onto the stack.";
  OpcodeDescriptionsBCH2023["OP_PUSHBYTES_39"] = "Push the next 39 bytes onto the stack.";
  OpcodeDescriptionsBCH2023["OP_PUSHBYTES_40"] = "Push the next 40 bytes onto the stack.";
  OpcodeDescriptionsBCH2023["OP_PUSHBYTES_41"] = "Push the next 41 bytes onto the stack.";
  OpcodeDescriptionsBCH2023["OP_PUSHBYTES_42"] = "Push the next 42 bytes onto the stack.";
  OpcodeDescriptionsBCH2023["OP_PUSHBYTES_43"] = "Push the next 43 bytes onto the stack.";
  OpcodeDescriptionsBCH2023["OP_PUSHBYTES_44"] = "Push the next 44 bytes onto the stack.";
  OpcodeDescriptionsBCH2023["OP_PUSHBYTES_45"] = "Push the next 45 bytes onto the stack.";
  OpcodeDescriptionsBCH2023["OP_PUSHBYTES_46"] = "Push the next 46 bytes onto the stack.";
  OpcodeDescriptionsBCH2023["OP_PUSHBYTES_47"] = "Push the next 47 bytes onto the stack.";
  OpcodeDescriptionsBCH2023["OP_PUSHBYTES_48"] = "Push the next 48 bytes onto the stack.";
  OpcodeDescriptionsBCH2023["OP_PUSHBYTES_49"] = "Push the next 49 bytes onto the stack.";
  OpcodeDescriptionsBCH2023["OP_PUSHBYTES_50"] = "Push the next 50 bytes onto the stack.";
  OpcodeDescriptionsBCH2023["OP_PUSHBYTES_51"] = "Push the next 51 bytes onto the stack.";
  OpcodeDescriptionsBCH2023["OP_PUSHBYTES_52"] = "Push the next 52 bytes onto the stack.";
  OpcodeDescriptionsBCH2023["OP_PUSHBYTES_53"] = "Push the next 53 bytes onto the stack.";
  OpcodeDescriptionsBCH2023["OP_PUSHBYTES_54"] = "Push the next 54 bytes onto the stack.";
  OpcodeDescriptionsBCH2023["OP_PUSHBYTES_55"] = "Push the next 55 bytes onto the stack.";
  OpcodeDescriptionsBCH2023["OP_PUSHBYTES_56"] = "Push the next 56 bytes onto the stack.";
  OpcodeDescriptionsBCH2023["OP_PUSHBYTES_57"] = "Push the next 57 bytes onto the stack.";
  OpcodeDescriptionsBCH2023["OP_PUSHBYTES_58"] = "Push the next 58 bytes onto the stack.";
  OpcodeDescriptionsBCH2023["OP_PUSHBYTES_59"] = "Push the next 59 bytes onto the stack.";
  OpcodeDescriptionsBCH2023["OP_PUSHBYTES_60"] = "Push the next 60 bytes onto the stack.";
  OpcodeDescriptionsBCH2023["OP_PUSHBYTES_61"] = "Push the next 61 bytes onto the stack.";
  OpcodeDescriptionsBCH2023["OP_PUSHBYTES_62"] = "Push the next 62 bytes onto the stack.";
  OpcodeDescriptionsBCH2023["OP_PUSHBYTES_63"] = "Push the next 63 bytes onto the stack.";
  OpcodeDescriptionsBCH2023["OP_PUSHBYTES_64"] = "Push the next 64 bytes onto the stack.";
  OpcodeDescriptionsBCH2023["OP_PUSHBYTES_65"] = "Push the next 65 bytes onto the stack.";
  OpcodeDescriptionsBCH2023["OP_PUSHBYTES_66"] = "Push the next 66 bytes onto the stack.";
  OpcodeDescriptionsBCH2023["OP_PUSHBYTES_67"] = "Push the next 67 bytes onto the stack.";
  OpcodeDescriptionsBCH2023["OP_PUSHBYTES_68"] = "Push the next 68 bytes onto the stack.";
  OpcodeDescriptionsBCH2023["OP_PUSHBYTES_69"] = "Push the next 69 bytes onto the stack.";
  OpcodeDescriptionsBCH2023["OP_PUSHBYTES_70"] = "Push the next 70 bytes onto the stack.";
  OpcodeDescriptionsBCH2023["OP_PUSHBYTES_71"] = "Push the next 71 bytes onto the stack.";
  OpcodeDescriptionsBCH2023["OP_PUSHBYTES_72"] = "Push the next 72 bytes onto the stack.";
  OpcodeDescriptionsBCH2023["OP_PUSHBYTES_73"] = "Push the next 73 bytes onto the stack.";
  OpcodeDescriptionsBCH2023["OP_PUSHBYTES_74"] = "Push the next 74 bytes onto the stack.";
  OpcodeDescriptionsBCH2023["OP_PUSHBYTES_75"] = "Push the next 75 bytes onto the stack.";
  OpcodeDescriptionsBCH2023["OP_PUSHDATA_1"] = "Read the next Uint8 and push that number of bytes onto the stack.";
  OpcodeDescriptionsBCH2023["OP_PUSHDATA_2"] = "Read the next little-endian Uint16 and push that number of bytes onto the stack.";
  OpcodeDescriptionsBCH2023["OP_PUSHDATA_4"] = "Read the next little-endian Uint32 and push that number of bytes onto the stack.";
  OpcodeDescriptionsBCH2023["OP_1NEGATE"] = "Push the VM Number -1 onto the stack.";
  OpcodeDescriptionsBCH2023["OP_RESERVED"] = "Error unless found in an unexecuted conditional branch. Note: OP_RESERVED does not count toward the opcode limit.";
  OpcodeDescriptionsBCH2023["OP_1"] = "Push a 1 (VM Number) onto the stack.";
  OpcodeDescriptionsBCH2023["OP_2"] = "Push a 2 (VM Number) onto the stack.";
  OpcodeDescriptionsBCH2023["OP_3"] = "Push a 3 (VM Number) onto the stack.";
  OpcodeDescriptionsBCH2023["OP_4"] = "Push a 4 (VM Number) onto the stack.";
  OpcodeDescriptionsBCH2023["OP_5"] = "Push a 5 (VM Number) onto the stack.";
  OpcodeDescriptionsBCH2023["OP_6"] = "Push a 6 (VM Number) onto the stack.";
  OpcodeDescriptionsBCH2023["OP_7"] = "Push a 7 (VM Number) onto the stack.";
  OpcodeDescriptionsBCH2023["OP_8"] = "Push a 8 (VM Number) onto the stack.";
  OpcodeDescriptionsBCH2023["OP_9"] = "Push a 9 (VM Number) onto the stack.";
  OpcodeDescriptionsBCH2023["OP_10"] = "Push a 10 (VM Number) onto the stack.";
  OpcodeDescriptionsBCH2023["OP_11"] = "Push a 11 (VM Number) onto the stack.";
  OpcodeDescriptionsBCH2023["OP_12"] = "Push a 12 (VM Number) onto the stack.";
  OpcodeDescriptionsBCH2023["OP_13"] = "Push a 13 (VM Number) onto the stack.";
  OpcodeDescriptionsBCH2023["OP_14"] = "Push a 14 (VM Number) onto the stack.";
  OpcodeDescriptionsBCH2023["OP_15"] = "Push a 15 (VM Number) onto the stack.";
  OpcodeDescriptionsBCH2023["OP_16"] = "Push a 16 (VM Number) onto the stack.";
  OpcodeDescriptionsBCH2023["OP_NOP"] = "No operation. Note: OP_NOP counts toward the opcode limit.";
  OpcodeDescriptionsBCH2023["OP_VER"] = "Error unless found in an unexecuted conditional branch. Note: OP_VER counts toward the opcode limit. (Historically, this pushed a protocol version number to the stack.)";
  OpcodeDescriptionsBCH2023["OP_IF"] = "Pop the top item from the stack. If it is not \"truthy\", skip evaluation until a matching OP_ELSE or OP_ENDIF.";
  OpcodeDescriptionsBCH2023["OP_NOTIF"] = "Pop the top item from the stack. If it is \"truthy\", skip evaluation until a matching OP_ELSE or OP_ENDIF.";
  OpcodeDescriptionsBCH2023["OP_VERIF"] = "Error, even when found in an unexecuted conditional branch. (Historically, this was a combination of OP_VER and OP_IF.)";
  OpcodeDescriptionsBCH2023["OP_VERNOTIF"] = "Error, even when found in an unexecuted conditional branch. (Historically, this was a combination of OP_VER and OP_NOTIF.)";
  OpcodeDescriptionsBCH2023["OP_ELSE"] = "Invert conditional evaluation within the current OP_IF ... OP_ENDIF block. (If evaluation is enabled, disable it, if it is disabled, enable it.)";
  OpcodeDescriptionsBCH2023["OP_ENDIF"] = "End the current OP_IF/OP_NOTIF ... OP_ENDIF block.";
  OpcodeDescriptionsBCH2023["OP_VERIFY"] = "Pop the top item from the stack and error if it isn't \"truthy\".";
  OpcodeDescriptionsBCH2023["OP_RETURN"] = "Error when executed.";
  OpcodeDescriptionsBCH2023["OP_TOALTSTACK"] = "Pop the top item from the stack and push it onto the alternate stack.";
  OpcodeDescriptionsBCH2023["OP_FROMALTSTACK"] = "Pop the top item from the alternate stack and push it onto the stack.";
  OpcodeDescriptionsBCH2023["OP_2DROP"] = "Pop the top 2 items from the stack and discard them.";
  OpcodeDescriptionsBCH2023["OP_2DUP"] = "Duplicate the top 2 items on the stack. (E.g. [a, b] -> [a, b, a, b])";
  OpcodeDescriptionsBCH2023["OP_3DUP"] = "Duplicate the top 3 items on the stack. (E.g. [a, b, c] -> [a, b, c, a, b, c])";
  OpcodeDescriptionsBCH2023["OP_2OVER"] = "Duplicate the 2 items beginning at a depth of 2 on the stack. (E.g. [a, b, c, d] -> [a, b, c, d, a, b])";
  OpcodeDescriptionsBCH2023["OP_2ROT"] = "Rotate the top 6 items on the stack, bringing the fifth and sixth items to the top. (E.g. [a, b, c, d, e, f] -> [c, d, e, f, a, b])";
  OpcodeDescriptionsBCH2023["OP_2SWAP"] = "Swap the positions of the top two pairs of items on the stack. (E.g. [a, b, c, d] -> [c, d, a, b])";
  OpcodeDescriptionsBCH2023["OP_IFDUP"] = "If the top item on the stack is \"truthy\", duplicate it.";
  OpcodeDescriptionsBCH2023["OP_DEPTH"] = "Push the current number of stack items as a VM Number.";
  OpcodeDescriptionsBCH2023["OP_DROP"] = "Pop the top item from the stack and discard it. (E.g. [a] -> [])";
  OpcodeDescriptionsBCH2023["OP_DUP"] = "Duplicate the top item on the stack. (E.g. [a] -> [a, a])";
  OpcodeDescriptionsBCH2023["OP_NIP"] = "Remove the second-to-top item from the stack. (E.g. [a, b] -> [b])";
  OpcodeDescriptionsBCH2023["OP_OVER"] = "Duplicate the second-to-top item on the stack. (E.g. [a, b] -> [a, b, a])";
  OpcodeDescriptionsBCH2023["OP_PICK"] = "Pop the top item from the stack as a VM Number. Duplicate the item at that depth (zero-indexed), placing it on top of the stack. (E.g. [a, b, c, 2] -> [a, b, c, a])";
  OpcodeDescriptionsBCH2023["OP_ROLL"] = "Pop the top item from the stack as a VM Number. Move the item at that depth (zero-indexed) to the top of the stack. (E.g. [a, b, c, 2] -> [b, c, a])";
  OpcodeDescriptionsBCH2023["OP_ROT"] = "Rotate the top 3 items on the stack, bringing the third item to the top. (E.g. [a, b, c] -> [b, c, a])";
  OpcodeDescriptionsBCH2023["OP_SWAP"] = "Swap the top two items on the stack. (E.g. [a, b] -> [b, a])";
  OpcodeDescriptionsBCH2023["OP_TUCK"] = "Duplicate the item at the top of the stack, inserting it below the second-to-top item. (E.g. [a, b] -> [b, a, b])";
  OpcodeDescriptionsBCH2023["OP_CAT"] = "Pop the top 2 items from the stack and concatenate them, pushing the result.";
  OpcodeDescriptionsBCH2023["OP_SPLIT"] = "Pop the top item from the stack as an index (VM Number) and the next item as a byte array. Split the byte array into two stack items at the index (zero-based), pushing the results.";
  OpcodeDescriptionsBCH2023["OP_NUM2BIN"] = "Pop the top item from the stack as an item length (VM Number) and the next item as a VM Number (without encoding restrictions). Re-encode the number using a byte array of the provided length, filling any unused bytes with zeros, then push the result. (If the requested length is too short to encode the number, error.)";
  OpcodeDescriptionsBCH2023["OP_BIN2NUM"] = "Pop the top item from the stack as a VM Number without encoding restrictions. Minimally-encode the number and push the result. (If the number can't be encoded in 4 bytes or less, error.)";
  OpcodeDescriptionsBCH2023["OP_SIZE"] = "Push the byte-length of the top stack item as a VM Number.";
  OpcodeDescriptionsBCH2023["OP_INVERT"] = "Error, even when found in an unexecuted conditional branch. (Historically, this flipped all the bits in a stack item.)";
  OpcodeDescriptionsBCH2023["OP_AND"] = "Pop the top 2 items from the stack and perform a bitwise AND on each byte, pushing the result. If the length of the items are not equal, error.";
  OpcodeDescriptionsBCH2023["OP_OR"] = "Pop the top 2 items from the stack and perform a bitwise OR on each byte, pushing the result. If the length of the items are not equal, error.";
  OpcodeDescriptionsBCH2023["OP_XOR"] = "Pop the top 2 items from the stack and perform a bitwise XOR on each byte, pushing the result. If the length of the items are not equal, error.";
  OpcodeDescriptionsBCH2023["OP_EQUAL"] = "Pop the top two items from the stack and compare them byte-by-byte. If they are the same, push a 1 (VM Number), otherwise push a 0 (VM Number).";
  OpcodeDescriptionsBCH2023["OP_EQUALVERIFY"] = "Pop the top two items from the stack and compare them byte-by-byte. If the values are different, error. (This operation is a combination of OP_EQUAL followed by OP_VERIFY.)";
  OpcodeDescriptionsBCH2023["OP_RESERVED1"] = "Error unless found in an unexecuted conditional branch. Note: OP_RESERVED1 counts toward the opcode limit.";
  OpcodeDescriptionsBCH2023["OP_RESERVED2"] = "Error unless found in an unexecuted conditional branch. Note: OP_RESERVED2 counts toward the opcode limit.";
  OpcodeDescriptionsBCH2023["OP_1ADD"] = "Pop the top item from the stack as a VM Number, add 1, then push the result.";
  OpcodeDescriptionsBCH2023["OP_1SUB"] = "Pop the top item from the stack as a VM Number, subtract 1, then push the result.";
  OpcodeDescriptionsBCH2023["OP_2MUL"] = "Error, even when found in an unexecuted conditional branch. (Historically, this multiplied a VM Number by 2.)";
  OpcodeDescriptionsBCH2023["OP_2DIV"] = "Error, even when found in an unexecuted conditional branch. (Historically, this divided a VM Number by 2.)";
  OpcodeDescriptionsBCH2023["OP_NEGATE"] = "Pop the top item from the stack as a VM Number, negate it, then push the result.";
  OpcodeDescriptionsBCH2023["OP_ABS"] = "Pop the top item from the stack as a VM Number, take its absolute value, then push the result.";
  OpcodeDescriptionsBCH2023["OP_NOT"] = "Pop the top item from the stack as a VM Number. If its value is 0, push a 1 (VM Number), otherwise, push a 0 (VM Number).";
  OpcodeDescriptionsBCH2023["OP_0NOTEQUAL"] = "Pop the top item from the stack as a VM Number. If its value is not 0, push a 1 (VM Number), otherwise, push a 0 (VM Number).";
  OpcodeDescriptionsBCH2023["OP_ADD"] = "Pop the top two items from the stack as VM Numbers. Add them, then push the result.";
  OpcodeDescriptionsBCH2023["OP_SUB"] = "Pop the top two items from the stack as VM Numbers. Subtract the top item from the second item, then push the result.";
  OpcodeDescriptionsBCH2023["OP_MUL"] = "Pop the top two items from the stack as VM Numbers. Multiply them, then push the result.";
  OpcodeDescriptionsBCH2023["OP_DIV"] = "Pop the top item from the stack as a denominator (VM Number) and the next as a numerator (VM Number). Divide and push the result to the stack.";
  OpcodeDescriptionsBCH2023["OP_MOD"] = "Pop the top item from the stack as a denominator (VM Number) and the next as a numerator (VM Number). Divide and push the remainder to the stack.";
  OpcodeDescriptionsBCH2023["OP_LSHIFT"] = "Error, even when found in an unexecuted conditional branch. (Historically, this performed a sign-preserving, left bit shift.)";
  OpcodeDescriptionsBCH2023["OP_RSHIFT"] = "Error, even when found in an unexecuted conditional branch. (Historically, this performed a sign-preserving, right bit shift.)";
  OpcodeDescriptionsBCH2023["OP_BOOLAND"] = "Pop the top two items from the stack as VM Numbers. If neither value is a 0 (VM Number), push a 1 (VM Number). Otherwise, push a 0 (VM Number).";
  OpcodeDescriptionsBCH2023["OP_BOOLOR"] = "Pop the top two items from the stack as VM Numbers. If either value is a 1 (VM Number), push a 1 (VM Number). Otherwise, push a 0 (VM Number).";
  OpcodeDescriptionsBCH2023["OP_NUMEQUAL"] = "Pop the top two items from the stack as VM Numbers. If the values are equal, push a 1 (VM Number). Otherwise, push a 0 (VM Number).";
  OpcodeDescriptionsBCH2023["OP_NUMEQUALVERIFY"] = "Pop the top two items from the stack as VM Numbers. If the values are different, error. (This operation is a combination of OP_NUMEQUAL followed by OP_VERIFY.)";
  OpcodeDescriptionsBCH2023["OP_NUMNOTEQUAL"] = "Pop the top two items from the stack as VM Numbers. If the values are not equal, push a 1 (VM Number). Otherwise, push a 0 (VM Number).";
  OpcodeDescriptionsBCH2023["OP_LESSTHAN"] = "Pop the top two items from the stack as VM Numbers. If the second item is less than top item, push a 1 (VM Number). Otherwise, push a 0 (VM Number).";
  OpcodeDescriptionsBCH2023["OP_GREATERTHAN"] = "Pop the top two items from the stack as VM Numbers. If the second item is greater than top item, push a 1 (VM Number). Otherwise, push a 0 (VM Number).";
  OpcodeDescriptionsBCH2023["OP_LESSTHANOREQUAL"] = "Pop the top two items from the stack as VM Numbers. If the second item is less than or equal to the top item, push a 1 (VM Number). Otherwise, push a 0 (VM Number).";
  OpcodeDescriptionsBCH2023["OP_GREATERTHANOREQUAL"] = "Pop the top two items from the stack as VM Numbers. If the second item is greater than or equal to the top item, push a 1 (VM Number). Otherwise, push a 0 (VM Number).";
  OpcodeDescriptionsBCH2023["OP_MIN"] = "Pop the top two items from the stack as VM Numbers. Push the smaller of the two numbers.";
  OpcodeDescriptionsBCH2023["OP_MAX"] = "Pop the top two items from the stack as VM Numbers. Push the larger of the two numbers.";
  OpcodeDescriptionsBCH2023["OP_WITHIN"] = "Pop the top three items from the stack as VM Numbers. If the top number is within the range defined by the following two numbers (left-inclusive), push a 1 (VM Number). Otherwise, push a 0 (VM Number). (E.g. for [a, b, c]: if (b <= a), and (a < c), [1]. Else [0].)";
  OpcodeDescriptionsBCH2023["OP_RIPEMD160"] = "Pop the top item from the stack and pass it through ripemd160, pushing the result onto the stack.";
  OpcodeDescriptionsBCH2023["OP_SHA1"] = "Pop the top item from the stack and pass it through sha1, pushing the result onto the stack.";
  OpcodeDescriptionsBCH2023["OP_SHA256"] = "Pop the top item from the stack and pass it through sha256, pushing the result onto the stack.";
  OpcodeDescriptionsBCH2023["OP_HASH160"] = "Pop the top item from the stack and pass it through sha256, then ripemd160, pushing the result onto the stack.";
  OpcodeDescriptionsBCH2023["OP_HASH256"] = "Pop the top item from the stack and pass it through sha256 twice, pushing the result onto the stack.";
  OpcodeDescriptionsBCH2023["OP_CODESEPARATOR"] = "Update the value of lastCodeSeparator to the instruction pointer's current value. (This reduces the coverage of signing serializations used in signature verification operations.)";
  OpcodeDescriptionsBCH2023["OP_CHECKSIG"] = "Pop the top two items from the stack. Treat the top as a signature and the second as a public key. If the signature is valid, push a 1 (VM Number), otherwise push a 0 (VM Number).";
  OpcodeDescriptionsBCH2023["OP_CHECKSIGVERIFY"] = "Pop the top two items from the stack. Treat the top as a signature and the second as a public key. If the signature is not valid, error. (This operation is a combination of OP_CHECKSIG followed by OP_VERIFY.)";
  OpcodeDescriptionsBCH2023["OP_CHECKMULTISIG"] = "Pop items from the stack: first pop the VM Number of public keys, then pop each of those public keys. Next, pop the VM Number of required signatures, then pop each of those signatures. Finally, pop a final VM Number that must be 0 due to a protocol bug. Checking each signature against each public key in order, if all signatures are valid \u2013 and the required number of signatures have been provided \u2013 push a 1 (VM Number), otherwise push a 0 (VM Number).";
  OpcodeDescriptionsBCH2023["OP_CHECKMULTISIGVERIFY"] = "Pop items from the stack: first pop the VM Number of public keys, then pop each of those public keys. Next, pop the VM Number of required signatures, then pop each of those signatures. Finally, (due to a protocol bug) pop an unused final VM Number that must be 0. Checking each signature against each public key in order, if any signatures are invalid \u2013 or the required number of signatures have not been provided \u2013 error. (This operation is a combination of OP_CHECKMULTISIG followed by OP_VERIFY.)";
  OpcodeDescriptionsBCH2023["OP_NOP1"] = "No operation (reserved for future expansion). Note: OP_NOP1 counts toward the opcode limit.";
  OpcodeDescriptionsBCH2023["OP_CHECKLOCKTIMEVERIFY"] = "Verify the transaction occurs after an absolute block time or height: read the top item on the stack as a VM Number (without removing it), and compare it to the transaction's locktime. If the required locktime has not passed, or if locktime has been disabled for this input by a maximized sequence number, error.";
  OpcodeDescriptionsBCH2023["OP_CHECKSEQUENCEVERIFY"] = "Verify the transaction occurs after the output being spent has \"aged\" by a relative block time or block height since it was created: read the top item on the stack as a VM Number (without removing it), and compare it to the age encoded in the input's sequence number. If the required relative locktime has not passed, or if relative locktime has been disabled by the sequence number or the transaction version, error.";
  OpcodeDescriptionsBCH2023["OP_NOP4"] = "No operation (reserved for future expansion). Note: OP_NOP4 counts toward the opcode limit.";
  OpcodeDescriptionsBCH2023["OP_NOP6"] = "No operation (reserved for future expansion). Note: OP_NOP6 counts toward the opcode limit.";
  OpcodeDescriptionsBCH2023["OP_NOP5"] = "No operation (reserved for future expansion). Note: OP_NOP5 counts toward the opcode limit.";
  OpcodeDescriptionsBCH2023["OP_NOP7"] = "No operation (reserved for future expansion). Note: OP_NOP7 counts toward the opcode limit.";
  OpcodeDescriptionsBCH2023["OP_NOP8"] = "No operation (reserved for future expansion). Note: OP_NOP8 counts toward the opcode limit.";
  OpcodeDescriptionsBCH2023["OP_NOP9"] = "No operation (reserved for future expansion). Note: OP_NOP9 counts toward the opcode limit.";
  OpcodeDescriptionsBCH2023["OP_NOP10"] = "No operation (reserved for future expansion). Note: OP_NOP10 counts toward the opcode limit.";
  OpcodeDescriptionsBCH2023["OP_CHECKDATASIG"] = "Pop the top 3 items from the stack. Treat the top as a public key, the second as a message, and the third as a signature. If the signature is valid, push a 1 (VM Number), otherwise push a 0 (VM Number).";
  OpcodeDescriptionsBCH2023["OP_CHECKDATASIGVERIFY"] = "Pop the top 3 items from the stack. Treat the top as a public key, the second as a message, and the third as a signature. If the signature is not valid, error. (This operation is a combination of OP_CHECKDATASIG followed by OP_VERIFY.)";
  OpcodeDescriptionsBCH2023["OP_REVERSEBYTES"] = "Pop the top item from the stack and reverse it, pushing the result.";
  OpcodeDescriptionsBCH2023["OP_INPUTINDEX"] = "Push the index of the input being evaluated to the stack as a VM Number.";
  OpcodeDescriptionsBCH2023["OP_ACTIVEBYTECODE"] = "Push the bytecode currently being evaluated, beginning after the last executed OP_CODESEPARATOR, to the stack. For Pay-to-Script-Hash (P2SH) evaluations, this is the redeem bytecode of the Unspent Transaction Output (UTXO) being spent; for all other evaluations, this is the locking bytecode of the UTXO being spent.";
  OpcodeDescriptionsBCH2023["OP_TXVERSION"] = "Push the version of the current transaction to the stack as a VM Number.";
  OpcodeDescriptionsBCH2023["OP_TXINPUTCOUNT"] = "Push the count of inputs in the current transaction to the stack as a VM Number.";
  OpcodeDescriptionsBCH2023["OP_TXOUTPUTCOUNT"] = "Push the count of outputs in the current transaction to the stack as a VM Number.";
  OpcodeDescriptionsBCH2023["OP_TXLOCKTIME"] = "Push the locktime of the current transaction to the stack as a VM Number.";
  OpcodeDescriptionsBCH2023["OP_UTXOVALUE"] = "Pop the top item from the stack as an input index (VM Number). Push the value (in satoshis) of the Unspent Transaction Output (UTXO) spent by that input to the stack as a VM Number.";
  OpcodeDescriptionsBCH2023["OP_UTXOBYTECODE"] = "Pop the top item from the stack as an input index (VM Number). Push the full locking bytecode of the Unspent Transaction Output (UTXO) spent by that input to the stack.";
  OpcodeDescriptionsBCH2023["OP_OUTPOINTTXHASH"] = "Pop the top item from the stack as an input index (VM Number). From that input, push the outpoint transaction hash \u2013 the hash of the transaction that created the Unspent Transaction Output (UTXO) that is being spent \u2013 to the stack in OP_HASH256 byte order.";
  OpcodeDescriptionsBCH2023["OP_OUTPOINTINDEX"] = "Pop the top item from the stack as an input index (VM Number). From that input, push the outpoint index \u2013 the index of the output in the transaction that created the Unspent Transaction Output (UTXO) that is being spent \u2013 to the stack as a VM Number.";
  OpcodeDescriptionsBCH2023["OP_INPUTBYTECODE"] = "Pop the top item from the stack as an input index (VM Number). Push the unlocking bytecode of the input at that index to the stack.";
  OpcodeDescriptionsBCH2023["OP_INPUTSEQUENCENUMBER"] = "Pop the top item from the stack as an input index (VM Number). Push the sequence number of the input at that index to the stack as a VM Number.";
  OpcodeDescriptionsBCH2023["OP_OUTPUTVALUE"] = "Pop the top item from the stack as an output index (VM Number). Push the value (in satoshis) of the output at that index to the stack as a VM Number.";
  OpcodeDescriptionsBCH2023["OP_OUTPUTBYTECODE"] = "Pop the top item from the stack as an output index (VM Number). Push the locking bytecode of the output at that index to the stack.";
  OpcodeDescriptionsBCH2023["OP_UTXOTOKENCATEGORY"] = "Pop the top item from the stack as an input index (VM Number). If the Unspent Transaction Output (UTXO) spent by that input includes no tokens, push a 0 (VM Number) to the stack. If the UTXO does not include a non-fungible token with a capability, push the UTXO's token category, otherwise, push the concatenation of the token category and capability, where the mutable capability is represented by 1 (VM Number) and the minting capability is represented by 2 (VM Number).";
  OpcodeDescriptionsBCH2023["OP_UTXOTOKENCOMMITMENT"] = "Pop the top item from the stack as an input index (VM Number). Push the token commitment of the Unspent Transaction Output (UTXO) spent by that input to the stack. If the UTXO does not include a non-fungible token, or if it includes a non-fungible token with a zero-length commitment, push a 0 (VM Number).";
  OpcodeDescriptionsBCH2023["OP_UTXOTOKENAMOUNT"] = "Pop the top item from the stack as an input index (VM Number). Push the fungible token amount of the Unspent Transaction Output (UTXO) spent by that input to the stack as a VM Number. If the UTXO includes no fungible tokens, push a 0 (VM Number).";
  OpcodeDescriptionsBCH2023["OP_OUTPUTTOKENCATEGORY"] = "Pop the top item from the stack as an output index (VM Number). If the output spent by that input includes no tokens, push a 0 (VM Number) to the stack. If the output does not include a non-fungible token with a capability, push the output's token category, otherwise, push the concatenation of the token category and capability, where the mutable capability is represented by 1 (VM Number) and the minting capability is represented by 2 (VM Number).";
  OpcodeDescriptionsBCH2023["OP_OUTPUTTOKENCOMMITMENT"] = "Pop the top item from the stack as an output index (VM Number). Push the token commitment of the output at that index to the stack. If the output does not include a non-fungible token, or if it includes a non-fungible token with a zero-length commitment, push a 0 (VM Number).";
  OpcodeDescriptionsBCH2023["OP_OUTPUTTOKENAMOUNT"] = "Pop the top item from the stack as an output index (VM Number). Push the fungible token amount of the output at that index to the stack as a VM Number. If the output includes no fungible tokens, push a 0 (VM Number).";
})(OpcodeDescriptionsBCH2023 || (OpcodeDescriptionsBCH2023 = {}));
// eslint-disable-next-line @typescript-eslint/naming-convention
var OpcodeDescriptionsBCH = OpcodeDescriptionsBCH2023;
// eslint-disable-next-line @typescript-eslint/naming-convention
var OpcodeDescriptions = OpcodeDescriptionsBCH;

var AuthenticationErrorBCH2023;
(function (AuthenticationErrorBCH2023) {
  AuthenticationErrorBCH2023["exceededMaximumVmNumberLength"] = "Program attempted an OP_BIN2NUM operation on a byte sequence that cannot be encoded within the maximum VM Number length (8 bytes).";
})(AuthenticationErrorBCH2023 || (AuthenticationErrorBCH2023 = {}));
// eslint-disable-next-line @typescript-eslint/naming-convention
var AuthenticationErrorBCH = AuthenticationErrorBCH2023;

/**
 * Given a list of transaction inputs, extract a hex-encoded list of all
 * {@link Input.outpointTransactionHash}es from inputs that spend output `0` of
 * that transaction (i.e. where {@link Input.outpointIndex} is `0`).
 * @param inputs - a list of transaction inputs
 * @returns a hex-encoded list of {@link Input.outpointTransactionHash}es
 */
var extractGenesisCategories = function extractGenesisCategories(inputs) {
  return inputs.reduce(function (agg, input) {
    return input.outpointIndex === 0 ? [].concat(_toConsumableArray(agg), [binToHex(input.outpointTransactionHash)]) : agg;
  }, []);
};
/**
 * Given the resolved list of a transaction's source outputs – the Unspent
 * Transaction Outputs (UTXOs) spent by the transaction, extract all token data
 * for token-aware validation. See CHIP-2022-02-CashTokens for details.
 * @param sourceOutputs - a list of resolved source outputs (UTXOs)
 * @returns an object containing `availableImmutableTokens`,
 * `availableMutableTokensByCategory`, `availableSumsByCategory`, and
 * `inputMintingCategories`. See CHIP-2022-02-CashTokens for details.
 */
var extractSourceOutputTokenData = function extractSourceOutputTokenData(sourceOutputs) {
  return sourceOutputs.reduce(
  // eslint-disable-next-line complexity
  function (agg, sourceOutput) {
    var _sourceOutput$token$n, _sourceOutput$token$n2, _agg$availableMutable, _agg$availableSumsByC, _sourceOutput$token$n3;
    if (sourceOutput.token === undefined) return agg;
    var categoryHex = binToHex(sourceOutput.token.category);
    return {
      availableImmutableTokens: [].concat(_toConsumableArray(agg.availableImmutableTokens), _toConsumableArray(((_sourceOutput$token$n = sourceOutput.token.nft) === null || _sourceOutput$token$n === void 0 ? void 0 : _sourceOutput$token$n.capability) === 'none' ? [{
        categoryHex: binToHex(sourceOutput.token.category),
        commitmentHex: binToHex(sourceOutput.token.nft.commitment)
      }] : [])),
      availableMutableTokensByCategory: ((_sourceOutput$token$n2 = sourceOutput.token.nft) === null || _sourceOutput$token$n2 === void 0 ? void 0 : _sourceOutput$token$n2.capability) === 'mutable' ? _objectSpread2(_objectSpread2({}, agg.availableMutableTokensByCategory), {}, _defineProperty({}, categoryHex, ((_agg$availableMutable = agg.availableMutableTokensByCategory[categoryHex]) !== null && _agg$availableMutable !== void 0 ? _agg$availableMutable : 0) + 1)) : agg.availableMutableTokensByCategory,
      availableSumsByCategory: _objectSpread2(_objectSpread2({}, agg.availableSumsByCategory), {}, _defineProperty({}, categoryHex, ((_agg$availableSumsByC = agg.availableSumsByCategory[categoryHex]) !== null && _agg$availableSumsByC !== void 0 ? _agg$availableSumsByC : 0n) + sourceOutput.token.amount)),
      inputMintingCategories: [].concat(_toConsumableArray(agg.inputMintingCategories), _toConsumableArray(((_sourceOutput$token$n3 = sourceOutput.token.nft) === null || _sourceOutput$token$n3 === void 0 ? void 0 : _sourceOutput$token$n3.capability) === 'minting' ? [binToHex(sourceOutput.token.category)] : []))
    };
  }, {
    availableImmutableTokens: [],
    availableMutableTokensByCategory: {},
    availableSumsByCategory: {},
    inputMintingCategories: []
  });
};
/**
 * Given a transaction's outputs, extract all token data for token-aware
 * validation. See CHIP-2022-02-CashTokens for details.
 * @param outputs - a list of transaction outputs
 * @returns an object containing `outputImmutableTokens`,
 * `outputMintingCategories`, `outputMutableTokensByCategory`, and
 * `outputSumsByCategory`. See CHIP-2022-02-CashTokens for details.
 */
var extractTransactionOutputTokenData = function extractTransactionOutputTokenData(outputs) {
  return outputs.reduce(
  // eslint-disable-next-line complexity
  function (agg, output) {
    var _output$token$nft, _output$token$nft2, _output$token$nft3, _agg$outputMutableTok, _agg$outputSumsByCate;
    if (output.token === undefined) return agg;
    var categoryHex = binToHex(output.token.category);
    return {
      outputImmutableTokens: [].concat(_toConsumableArray(agg.outputImmutableTokens), _toConsumableArray(((_output$token$nft = output.token.nft) === null || _output$token$nft === void 0 ? void 0 : _output$token$nft.capability) === 'none' ? [{
        categoryHex: binToHex(output.token.category),
        commitmentHex: binToHex(output.token.nft.commitment)
      }] : [])),
      outputMintingCategories: [].concat(_toConsumableArray(agg.outputMintingCategories), _toConsumableArray(((_output$token$nft2 = output.token.nft) === null || _output$token$nft2 === void 0 ? void 0 : _output$token$nft2.capability) === 'minting' ? [binToHex(output.token.category)] : [])),
      outputMutableTokensByCategory: ((_output$token$nft3 = output.token.nft) === null || _output$token$nft3 === void 0 ? void 0 : _output$token$nft3.capability) === 'mutable' ? _objectSpread2(_objectSpread2({}, agg.outputMutableTokensByCategory), {}, _defineProperty({}, categoryHex, ((_agg$outputMutableTok = agg.outputMutableTokensByCategory[categoryHex]) !== null && _agg$outputMutableTok !== void 0 ? _agg$outputMutableTok : 0) + 1)) : agg.outputMutableTokensByCategory,
      outputSumsByCategory: _objectSpread2(_objectSpread2({}, agg.outputSumsByCategory), {}, _defineProperty({}, categoryHex, ((_agg$outputSumsByCate = agg.outputSumsByCategory[categoryHex]) !== null && _agg$outputSumsByCate !== void 0 ? _agg$outputSumsByCate : 0n) + output.token.amount))
    };
  }, {
    outputImmutableTokens: [],
    outputMintingCategories: [],
    outputMutableTokensByCategory: {},
    outputSumsByCategory: {}
  });
};
/**
 * Given a transaction and its resolved source outputs – the Unspent Transaction
 * Outputs (UTXOs) it spends – verify that the transaction passes token-aware
 * validation.
 * @param transaction - the transaction to verify
 * @param sourceOutputs - the resolved list of the transaction's source outputs
 * @returns `true` on success, or an error message (string) on failure.
 */
// eslint-disable-next-line complexity
var verifyTransactionTokens = function verifyTransactionTokens(transaction, sourceOutputs) {
  var excessiveCommitment = [].concat(_toConsumableArray(sourceOutputs), _toConsumableArray(transaction.outputs)).find(function (output) {
    var _output$token, _output$token$nft4;
    return ((_output$token = output.token) === null || _output$token === void 0 ? void 0 : (_output$token$nft4 = _output$token.nft) === null || _output$token$nft4 === void 0 ? void 0 : _output$token$nft4.commitment) !== undefined && output.token.nft.commitment.length > ConsensusBCH2023.maximumCommitmentLength;
  });
  if (excessiveCommitment !== undefined) {
    return "Transaction violates token validation: a token commitment exceeds the consensus limit of ".concat(ConsensusBCH2023.maximumCommitmentLength, " bytes. Excessive token commitment length: ").concat(
    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
    excessiveCommitment.token.nft.commitment.length);
  }
  var genesisCategories = extractGenesisCategories(transaction.inputs);
  var _extractSourceOutputT = extractSourceOutputTokenData(sourceOutputs),
    availableSumsByCategory = _extractSourceOutputT.availableSumsByCategory,
    availableMutableTokensByCategory = _extractSourceOutputT.availableMutableTokensByCategory,
    inputMintingCategories = _extractSourceOutputT.inputMintingCategories,
    availableImmutableTokens = _extractSourceOutputT.availableImmutableTokens;
  var _extractTransactionOu = extractTransactionOutputTokenData(transaction.outputs),
    outputSumsByCategory = _extractTransactionOu.outputSumsByCategory,
    outputMutableTokensByCategory = _extractTransactionOu.outputMutableTokensByCategory,
    outputMintingCategories = _extractTransactionOu.outputMintingCategories,
    outputImmutableTokens = _extractTransactionOu.outputImmutableTokens;
  var availableMintingCategories = [].concat(_toConsumableArray(genesisCategories), _toConsumableArray(inputMintingCategories));
  var missingMintingCategory = outputMintingCategories.find(function (category) {
    return !availableMintingCategories.includes(category);
  });
  if (missingMintingCategory !== undefined) {
    return "Transaction violates token validation: the transaction outputs include a minting token that is not substantiated by the transaction's inputs. Invalid output minting token category: ".concat(missingMintingCategory);
  }
  // eslint-disable-next-line functional/no-loop-statement
  for (var _i = 0, _Object$entries = Object.entries(outputSumsByCategory); _i < _Object$entries.length; _i++) {
    var _Object$entries$_i = _slicedToArray(_Object$entries[_i], 2),
      categoryHex = _Object$entries$_i[0],
      sum = _Object$entries$_i[1];
    if (sum > BigInt(ConsensusBCH2023.maxVmNumber)) {
      return "Transaction violates token validation: the transaction outputs include a sum of fungible tokens for a category exceeding the maximum supply (".concat(ConsensusBCH2023.maxVmNumber, "). Category: ").concat(categoryHex, ", total amount: ").concat(sum.toString(), ".");
    }
    var availableSum = availableSumsByCategory[categoryHex];
    if (availableSum === undefined && sum > 0 && !genesisCategories.includes(categoryHex)) {
      return "Transaction violates token validation: the transaction creates new fungible tokens for a category without a matching genesis input. Category: ".concat(categoryHex, ", tokens created: ").concat(sum);
    }
    if (availableSum !== undefined && sum > availableSum) {
      return "Transaction violates token validation: the sum of fungible tokens in the transaction's outputs exceed that of the transactions inputs for a category. Category: ".concat(categoryHex, ", input amount: ").concat(availableSum, ", output amount: ").concat(sum);
    }
  }
  var remainingMutableTokens = Object.entries(outputMutableTokensByCategory).reduce(function (agg, _ref) {
    var _agg$categoryHex;
    var _ref2 = _slicedToArray(_ref, 2),
      categoryHex = _ref2[0],
      sum = _ref2[1];
    if (availableMintingCategories.includes(categoryHex)) {
      return agg;
    }
    return _objectSpread2(_objectSpread2({}, agg), {}, _defineProperty({}, categoryHex, ((_agg$categoryHex = agg[categoryHex]) !== null && _agg$categoryHex !== void 0 ? _agg$categoryHex : 0) - sum));
  }, availableMutableTokensByCategory);
  // eslint-disable-next-line functional/no-loop-statement
  for (var _i2 = 0, _Object$entries2 = Object.entries(remainingMutableTokens); _i2 < _Object$entries2.length; _i2++) {
    var _Object$entries2$_i = _slicedToArray(_Object$entries2[_i2], 2),
      _categoryHex = _Object$entries2$_i[0],
      _sum = _Object$entries2$_i[1];
    if (_sum < 0) {
      return "Transaction violates token validation: the transaction creates more mutable tokens than are available for a category without a matching minting token. Category: ".concat(_categoryHex, ", excess mutable tokens: ").concat(0 - _sum);
    }
  }
  var _outputImmutableToken = outputImmutableTokens.reduce(function (agg, token) {
      var categoryHex = token.categoryHex,
        commitmentHex = token.commitmentHex;
      if (availableMintingCategories.includes(categoryHex)) {
        return agg;
      }
      var firstMatch = availableImmutableTokens.findIndex(function (available) {
        return available.categoryHex === categoryHex && available.commitmentHex === commitmentHex;
      });
      if (firstMatch === -1) {
        return {
          availableImmutableTokens: agg.availableImmutableTokens,
          unmatchedImmutableTokens: [].concat(_toConsumableArray(agg.unmatchedImmutableTokens), [token])
        };
      }
      // eslint-disable-next-line functional/no-expression-statement, functional/immutable-data
      agg.availableImmutableTokens.splice(firstMatch, 1);
      return agg;
    }, {
      availableImmutableTokens: availableImmutableTokens,
      unmatchedImmutableTokens: []
    }),
    unmatchedImmutableTokens = _outputImmutableToken.unmatchedImmutableTokens;
  var requiredMutableTokens = unmatchedImmutableTokens.reduce(function (agg, token) {
    var _agg$token$categoryHe;
    return _objectSpread2(_objectSpread2({}, agg), {}, _defineProperty({}, token.categoryHex, ((_agg$token$categoryHe = agg[token.categoryHex]) !== null && _agg$token$categoryHe !== void 0 ? _agg$token$categoryHe : 0) + 1));
  }, {});
  // eslint-disable-next-line functional/no-loop-statement
  for (var _i3 = 0, _Object$entries3 = Object.entries(requiredMutableTokens); _i3 < _Object$entries3.length; _i3++) {
    var _remainingMutableToke;
    var _Object$entries3$_i = _slicedToArray(_Object$entries3[_i3], 2),
      _categoryHex2 = _Object$entries3$_i[0],
      required = _Object$entries3$_i[1];
    var available = (_remainingMutableToke = remainingMutableTokens[_categoryHex2]) !== null && _remainingMutableToke !== void 0 ? _remainingMutableToke : 0;
    if (available < required) {
      return "Transaction violates token validation: the transaction creates an immutable token for a category without a matching minting token or sufficient mutable tokens. Category ".concat(_categoryHex2, ", available mutable tokens: ").concat(available, ", new immutable tokens: ").concat(required);
    }
  }
  return true;
};
var pushTokenExtendedCategory = function pushTokenExtendedCategory(state, utxo) {
  var _token$nft, _token$nft2;
  var token = utxo.token;
  if (token === undefined) {
    return pushToStackVmNumber(state, 0n);
  }
  var capabilityByte = ((_token$nft = token.nft) === null || _token$nft === void 0 ? void 0 : _token$nft.capability) === 'minting' ? [2 /* Constants.mintingCapabilityByte */] : ((_token$nft2 = token.nft) === null || _token$nft2 === void 0 ? void 0 : _token$nft2.capability) === 'mutable' ? [1 /* Constants.mutableCapabilityByte */] : [];
  var extendedCategory = flattenBinArray([token.category.slice().reverse(), Uint8Array.from(capabilityByte)]);
  return pushToStackChecked(state, extendedCategory);
};
var pushTokenCommitment = function pushTokenCommitment(state, utxo) {
  var token = utxo.token;
  if (token === undefined || token.nft === undefined) {
    return pushToStackVmNumber(state, 0n);
  }
  return pushToStackChecked(state, token.nft.commitment);
};
var pushTokenAmount = function pushTokenAmount(state, utxo) {
  var token = utxo.token;
  if (token === undefined) {
    return pushToStackVmNumber(state, 0n);
  }
  return pushToStackVmNumberChecked(state, token.amount);
};
var opUtxoTokenCategory = function opUtxoTokenCategory(state) {
  return useTransactionUtxo(state, function (nextState, _ref3) {
    var _ref4 = _slicedToArray(_ref3, 1),
      utxo = _ref4[0];
    return pushTokenExtendedCategory(nextState, utxo);
  });
};
var opUtxoTokenCommitment = function opUtxoTokenCommitment(state) {
  return useTransactionUtxo(state, function (nextState, _ref5) {
    var _ref6 = _slicedToArray(_ref5, 1),
      utxo = _ref6[0];
    return pushTokenCommitment(nextState, utxo);
  });
};
var opUtxoTokenAmount = function opUtxoTokenAmount(state) {
  return useTransactionUtxo(state, function (nextState, _ref7) {
    var _ref8 = _slicedToArray(_ref7, 1),
      utxo = _ref8[0];
    return pushTokenAmount(nextState, utxo);
  });
};
var opOutputTokenCategory = function opOutputTokenCategory(state) {
  return useTransactionOutput(state, function (nextState, _ref9) {
    var _ref10 = _slicedToArray(_ref9, 1),
      output = _ref10[0];
    return pushTokenExtendedCategory(nextState, output);
  });
};
var opOutputTokenCommitment = function opOutputTokenCommitment(state) {
  return useTransactionOutput(state, function (nextState, _ref11) {
    var _ref12 = _slicedToArray(_ref11, 1),
      output = _ref12[0];
    return pushTokenCommitment(nextState, output);
  });
};
var opOutputTokenAmount = function opOutputTokenAmount(state) {
  return useTransactionOutput(state, function (nextState, _ref13) {
    var _ref14 = _slicedToArray(_ref13, 1),
      output = _ref14[0];
    return pushTokenAmount(nextState, output);
  });
};

/**
 * create an instance of the BCH 2023 virtual machine instruction set.
 *
 * @param standard - If `true`, the additional `isStandard` validations will be
 * enabled. Transactions that fail these rules are often called "non-standard"
 * and can technically be included by miners in valid blocks, but most network
 * nodes will refuse to relay them. (Default: `true`)
 */
var createInstructionSetBCH2023 = function createInstructionSetBCH2023() {
  var _objectSpread2$1, _objectSpread3, _ref2, _ref3, _objectSpread4;
  var standard = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
  var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {
      ripemd160: ripemd160$1,
      secp256k1: secp256k1,
      sha1: sha1$1,
      sha256: sha256$1
    },
    ripemd160 = _ref.ripemd160,
    secp256k1$1 = _ref.secp256k1,
    sha1 = _ref.sha1,
    sha256 = _ref.sha256;
  var conditionallyPush = pushOperation();
  return {
    clone: cloneAuthenticationProgramStateBCH,
    continue: function _continue(state) {
      return state.error === undefined && state.ip < state.instructions.length;
    },
    // eslint-disable-next-line complexity
    evaluate: function evaluate(program, stateEvaluate) {
      var _p2shStack$pop;
      var unlockingBytecode =
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      program.transaction.inputs[program.inputIndex].unlockingBytecode;
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      var lockingBytecode = program.sourceOutputs[program.inputIndex].lockingBytecode;
      var unlockingInstructions = decodeAuthenticationInstructions(unlockingBytecode);
      var lockingInstructions = decodeAuthenticationInstructions(lockingBytecode);
      var initialState = createAuthenticationProgramStateCommon({
        instructions: unlockingInstructions,
        program: program,
        stack: []
      });
      if (unlockingBytecode.length > ConsensusBCH2023.maximumBytecodeLength) {
        return applyError(initialState, "The provided unlocking bytecode (".concat(unlockingBytecode.length, " bytes) exceeds the maximum bytecode length (").concat(ConsensusBCH2023.maximumBytecodeLength, " bytes)."));
      }
      if (authenticationInstructionsAreMalformed(unlockingInstructions)) {
        return applyError(initialState, AuthenticationErrorCommon.malformedUnlockingBytecode);
      }
      if (!isPushOnly(unlockingBytecode)) {
        return applyError(initialState, AuthenticationErrorCommon.requiresPushOnly);
      }
      if (lockingBytecode.length > ConsensusBCH2023.maximumBytecodeLength) {
        return applyError(initialState, AuthenticationErrorCommon.exceededMaximumBytecodeLengthLocking);
      }
      if (authenticationInstructionsAreMalformed(lockingInstructions)) {
        return applyError(initialState, AuthenticationErrorCommon.malformedLockingBytecode);
      }
      var unlockingResult = stateEvaluate(initialState);
      if (unlockingResult.error !== undefined) {
        return unlockingResult;
      }
      if (unlockingResult.controlStack.length !== 0) {
        return applyError(initialState, AuthenticationErrorCommon.nonEmptyControlStack);
      }
      var lockingResult = stateEvaluate(createAuthenticationProgramStateCommon({
        instructions: lockingInstructions,
        program: program,
        stack: unlockingResult.stack
      }));
      var p2sh20 = isPayToScriptHash20(lockingBytecode);
      var p2sh32 = isPayToScriptHash32(lockingBytecode);
      if (!p2sh20 && !p2sh32) {
        return lockingResult;
      }
      var p2shStack = cloneStack(unlockingResult.stack);
      // eslint-disable-next-line functional/immutable-data
      var p2shScript = (_p2shStack$pop = p2shStack.pop()) !== null && _p2shStack$pop !== void 0 ? _p2shStack$pop : Uint8Array.of();
      if (p2sh20 && p2shStack.length === 0 && isWitnessProgram(p2shScript)) {
        return lockingResult;
      }
      var p2shInstructions = decodeAuthenticationInstructions(p2shScript);
      return authenticationInstructionsAreMalformed(p2shInstructions) ? _objectSpread2(_objectSpread2({}, lockingResult), {}, {
        error: AuthenticationErrorCommon.malformedP2shBytecode
      }) : stateEvaluate(createAuthenticationProgramStateCommon({
        instructions: p2shInstructions,
        program: program,
        stack: p2shStack
      }));
    },
    every: function every(state) {
      return (
        // TODO: implement sigchecks https://gitlab.com/bitcoin-cash-node/bchn-sw/bitcoincash-upgrade-specifications/-/blob/master/spec/2020-05-15-sigchecks.md
        state.stack.length + state.alternateStack.length > ConsensusBCH2023.maximumStackDepth ? applyError(state, AuthenticationErrorCommon.exceededMaximumStackDepth) : state.operationCount > ConsensusBCH2023.maximumOperationCount ? applyError(state, AuthenticationErrorCommon.exceededMaximumOperationCount) : state
      );
    },
    operations: _objectSpread2((_objectSpread2$1 = {}, _defineProperty(_objectSpread2$1, OpcodesBCH2023.OP_0, conditionallyPush), _defineProperty(_objectSpread2$1, OpcodesBCH2023.OP_PUSHBYTES_1, conditionallyPush), _defineProperty(_objectSpread2$1, OpcodesBCH2023.OP_PUSHBYTES_2, conditionallyPush), _defineProperty(_objectSpread2$1, OpcodesBCH2023.OP_PUSHBYTES_3, conditionallyPush), _defineProperty(_objectSpread2$1, OpcodesBCH2023.OP_PUSHBYTES_4, conditionallyPush), _defineProperty(_objectSpread2$1, OpcodesBCH2023.OP_PUSHBYTES_5, conditionallyPush), _defineProperty(_objectSpread2$1, OpcodesBCH2023.OP_PUSHBYTES_6, conditionallyPush), _defineProperty(_objectSpread2$1, OpcodesBCH2023.OP_PUSHBYTES_7, conditionallyPush), _defineProperty(_objectSpread2$1, OpcodesBCH2023.OP_PUSHBYTES_8, conditionallyPush), _defineProperty(_objectSpread2$1, OpcodesBCH2023.OP_PUSHBYTES_9, conditionallyPush), _defineProperty(_objectSpread2$1, OpcodesBCH2023.OP_PUSHBYTES_10, conditionallyPush), _defineProperty(_objectSpread2$1, OpcodesBCH2023.OP_PUSHBYTES_11, conditionallyPush), _defineProperty(_objectSpread2$1, OpcodesBCH2023.OP_PUSHBYTES_12, conditionallyPush), _defineProperty(_objectSpread2$1, OpcodesBCH2023.OP_PUSHBYTES_13, conditionallyPush), _defineProperty(_objectSpread2$1, OpcodesBCH2023.OP_PUSHBYTES_14, conditionallyPush), _defineProperty(_objectSpread2$1, OpcodesBCH2023.OP_PUSHBYTES_15, conditionallyPush), _defineProperty(_objectSpread2$1, OpcodesBCH2023.OP_PUSHBYTES_16, conditionallyPush), _defineProperty(_objectSpread2$1, OpcodesBCH2023.OP_PUSHBYTES_17, conditionallyPush), _defineProperty(_objectSpread2$1, OpcodesBCH2023.OP_PUSHBYTES_18, conditionallyPush), _defineProperty(_objectSpread2$1, OpcodesBCH2023.OP_PUSHBYTES_19, conditionallyPush), _defineProperty(_objectSpread2$1, OpcodesBCH2023.OP_PUSHBYTES_20, conditionallyPush), _defineProperty(_objectSpread2$1, OpcodesBCH2023.OP_PUSHBYTES_21, conditionallyPush), _defineProperty(_objectSpread2$1, OpcodesBCH2023.OP_PUSHBYTES_22, conditionallyPush), _defineProperty(_objectSpread2$1, OpcodesBCH2023.OP_PUSHBYTES_23, conditionallyPush), _defineProperty(_objectSpread2$1, OpcodesBCH2023.OP_PUSHBYTES_24, conditionallyPush), _defineProperty(_objectSpread2$1, OpcodesBCH2023.OP_PUSHBYTES_25, conditionallyPush), _defineProperty(_objectSpread2$1, OpcodesBCH2023.OP_PUSHBYTES_26, conditionallyPush), _defineProperty(_objectSpread2$1, OpcodesBCH2023.OP_PUSHBYTES_27, conditionallyPush), _defineProperty(_objectSpread2$1, OpcodesBCH2023.OP_PUSHBYTES_28, conditionallyPush), _defineProperty(_objectSpread2$1, OpcodesBCH2023.OP_PUSHBYTES_29, conditionallyPush), _defineProperty(_objectSpread2$1, OpcodesBCH2023.OP_PUSHBYTES_30, conditionallyPush), _defineProperty(_objectSpread2$1, OpcodesBCH2023.OP_PUSHBYTES_31, conditionallyPush), _defineProperty(_objectSpread2$1, OpcodesBCH2023.OP_PUSHBYTES_32, conditionallyPush), _defineProperty(_objectSpread2$1, OpcodesBCH2023.OP_PUSHBYTES_33, conditionallyPush), _defineProperty(_objectSpread2$1, OpcodesBCH2023.OP_PUSHBYTES_34, conditionallyPush), _defineProperty(_objectSpread2$1, OpcodesBCH2023.OP_PUSHBYTES_35, conditionallyPush), _defineProperty(_objectSpread2$1, OpcodesBCH2023.OP_PUSHBYTES_36, conditionallyPush), _defineProperty(_objectSpread2$1, OpcodesBCH2023.OP_PUSHBYTES_37, conditionallyPush), _defineProperty(_objectSpread2$1, OpcodesBCH2023.OP_PUSHBYTES_38, conditionallyPush), _defineProperty(_objectSpread2$1, OpcodesBCH2023.OP_PUSHBYTES_39, conditionallyPush), _defineProperty(_objectSpread2$1, OpcodesBCH2023.OP_PUSHBYTES_40, conditionallyPush), _defineProperty(_objectSpread2$1, OpcodesBCH2023.OP_PUSHBYTES_41, conditionallyPush), _defineProperty(_objectSpread2$1, OpcodesBCH2023.OP_PUSHBYTES_42, conditionallyPush), _defineProperty(_objectSpread2$1, OpcodesBCH2023.OP_PUSHBYTES_43, conditionallyPush), _defineProperty(_objectSpread2$1, OpcodesBCH2023.OP_PUSHBYTES_44, conditionallyPush), _defineProperty(_objectSpread2$1, OpcodesBCH2023.OP_PUSHBYTES_45, conditionallyPush), _defineProperty(_objectSpread2$1, OpcodesBCH2023.OP_PUSHBYTES_46, conditionallyPush), _defineProperty(_objectSpread2$1, OpcodesBCH2023.OP_PUSHBYTES_47, conditionallyPush), _defineProperty(_objectSpread2$1, OpcodesBCH2023.OP_PUSHBYTES_48, conditionallyPush), _defineProperty(_objectSpread2$1, OpcodesBCH2023.OP_PUSHBYTES_49, conditionallyPush), _defineProperty(_objectSpread2$1, OpcodesBCH2023.OP_PUSHBYTES_50, conditionallyPush), _defineProperty(_objectSpread2$1, OpcodesBCH2023.OP_PUSHBYTES_51, conditionallyPush), _defineProperty(_objectSpread2$1, OpcodesBCH2023.OP_PUSHBYTES_52, conditionallyPush), _defineProperty(_objectSpread2$1, OpcodesBCH2023.OP_PUSHBYTES_53, conditionallyPush), _defineProperty(_objectSpread2$1, OpcodesBCH2023.OP_PUSHBYTES_54, conditionallyPush), _defineProperty(_objectSpread2$1, OpcodesBCH2023.OP_PUSHBYTES_55, conditionallyPush), _defineProperty(_objectSpread2$1, OpcodesBCH2023.OP_PUSHBYTES_56, conditionallyPush), _defineProperty(_objectSpread2$1, OpcodesBCH2023.OP_PUSHBYTES_57, conditionallyPush), _defineProperty(_objectSpread2$1, OpcodesBCH2023.OP_PUSHBYTES_58, conditionallyPush), _defineProperty(_objectSpread2$1, OpcodesBCH2023.OP_PUSHBYTES_59, conditionallyPush), _defineProperty(_objectSpread2$1, OpcodesBCH2023.OP_PUSHBYTES_60, conditionallyPush), _defineProperty(_objectSpread2$1, OpcodesBCH2023.OP_PUSHBYTES_61, conditionallyPush), _defineProperty(_objectSpread2$1, OpcodesBCH2023.OP_PUSHBYTES_62, conditionallyPush), _defineProperty(_objectSpread2$1, OpcodesBCH2023.OP_PUSHBYTES_63, conditionallyPush), _defineProperty(_objectSpread2$1, OpcodesBCH2023.OP_PUSHBYTES_64, conditionallyPush), _defineProperty(_objectSpread2$1, OpcodesBCH2023.OP_PUSHBYTES_65, conditionallyPush), _defineProperty(_objectSpread2$1, OpcodesBCH2023.OP_PUSHBYTES_66, conditionallyPush), _defineProperty(_objectSpread2$1, OpcodesBCH2023.OP_PUSHBYTES_67, conditionallyPush), _defineProperty(_objectSpread2$1, OpcodesBCH2023.OP_PUSHBYTES_68, conditionallyPush), _defineProperty(_objectSpread2$1, OpcodesBCH2023.OP_PUSHBYTES_69, conditionallyPush), _defineProperty(_objectSpread2$1, OpcodesBCH2023.OP_PUSHBYTES_70, conditionallyPush), _defineProperty(_objectSpread2$1, OpcodesBCH2023.OP_PUSHBYTES_71, conditionallyPush), _defineProperty(_objectSpread2$1, OpcodesBCH2023.OP_PUSHBYTES_72, conditionallyPush), _defineProperty(_objectSpread2$1, OpcodesBCH2023.OP_PUSHBYTES_73, conditionallyPush), _defineProperty(_objectSpread2$1, OpcodesBCH2023.OP_PUSHBYTES_74, conditionallyPush), _defineProperty(_objectSpread2$1, OpcodesBCH2023.OP_PUSHBYTES_75, conditionallyPush), _defineProperty(_objectSpread2$1, OpcodesBCH2023.OP_PUSHDATA_1, conditionallyPush), _defineProperty(_objectSpread2$1, OpcodesBCH2023.OP_PUSHDATA_2, conditionallyPush), _defineProperty(_objectSpread2$1, OpcodesBCH2023.OP_PUSHDATA_4, conditionallyPush), _defineProperty(_objectSpread2$1, OpcodesBCH2023.OP_1NEGATE, conditionallyEvaluate(pushNumberOperation(-1))), _defineProperty(_objectSpread2$1, OpcodesBCH2023.OP_RESERVED, conditionallyEvaluate(reservedOperation)), _defineProperty(_objectSpread2$1, OpcodesBCH2023.OP_1, conditionallyEvaluate(pushNumberOperation(1))), _defineProperty(_objectSpread2$1, OpcodesBCH2023.OP_2, conditionallyEvaluate(pushNumberOperation(2))), _defineProperty(_objectSpread2$1, OpcodesBCH2023.OP_3, conditionallyEvaluate(pushNumberOperation(3))), _defineProperty(_objectSpread2$1, OpcodesBCH2023.OP_4, conditionallyEvaluate(pushNumberOperation(4))), _defineProperty(_objectSpread2$1, OpcodesBCH2023.OP_5, conditionallyEvaluate(pushNumberOperation(5))), _defineProperty(_objectSpread2$1, OpcodesBCH2023.OP_6, conditionallyEvaluate(pushNumberOperation(6))), _defineProperty(_objectSpread2$1, OpcodesBCH2023.OP_7, conditionallyEvaluate(pushNumberOperation(7))), _defineProperty(_objectSpread2$1, OpcodesBCH2023.OP_8, conditionallyEvaluate(pushNumberOperation(8))), _defineProperty(_objectSpread2$1, OpcodesBCH2023.OP_9, conditionallyEvaluate(pushNumberOperation(9))), _defineProperty(_objectSpread2$1, OpcodesBCH2023.OP_10, conditionallyEvaluate(pushNumberOperation(10))), _defineProperty(_objectSpread2$1, OpcodesBCH2023.OP_11, conditionallyEvaluate(pushNumberOperation(11))), _defineProperty(_objectSpread2$1, OpcodesBCH2023.OP_12, conditionallyEvaluate(pushNumberOperation(12))), _defineProperty(_objectSpread2$1, OpcodesBCH2023.OP_13, conditionallyEvaluate(pushNumberOperation(13))), _defineProperty(_objectSpread2$1, OpcodesBCH2023.OP_14, conditionallyEvaluate(pushNumberOperation(14))), _defineProperty(_objectSpread2$1, OpcodesBCH2023.OP_15, conditionallyEvaluate(pushNumberOperation(15))), _defineProperty(_objectSpread2$1, OpcodesBCH2023.OP_16, conditionallyEvaluate(pushNumberOperation(16))), _objectSpread2$1), mapOverOperations([incrementOperationCount], _objectSpread2(_objectSpread2((_objectSpread3 = {}, _defineProperty(_objectSpread3, OpcodesBCH2023.OP_NOP, conditionallyEvaluate(opNop)), _defineProperty(_objectSpread3, OpcodesBCH2023.OP_VER, conditionallyEvaluate(reservedOperation)), _defineProperty(_objectSpread3, OpcodesBCH2023.OP_IF, opIf), _defineProperty(_objectSpread3, OpcodesBCH2023.OP_NOTIF, opNotIf), _defineProperty(_objectSpread3, OpcodesBCH2023.OP_VERIF, reservedOperation), _defineProperty(_objectSpread3, OpcodesBCH2023.OP_VERNOTIF, reservedOperation), _defineProperty(_objectSpread3, OpcodesBCH2023.OP_ELSE, opElse), _defineProperty(_objectSpread3, OpcodesBCH2023.OP_ENDIF, opEndIf), _defineProperty(_objectSpread3, OpcodesBCH2023.OP_VERIFY, conditionallyEvaluate(opVerify)), _defineProperty(_objectSpread3, OpcodesBCH2023.OP_RETURN, conditionallyEvaluate(opReturn)), _defineProperty(_objectSpread3, OpcodesBCH2023.OP_TOALTSTACK, conditionallyEvaluate(opToAltStack)), _defineProperty(_objectSpread3, OpcodesBCH2023.OP_FROMALTSTACK, conditionallyEvaluate(opFromAltStack)), _defineProperty(_objectSpread3, OpcodesBCH2023.OP_2DROP, conditionallyEvaluate(op2Drop)), _defineProperty(_objectSpread3, OpcodesBCH2023.OP_2DUP, conditionallyEvaluate(op2Dup)), _defineProperty(_objectSpread3, OpcodesBCH2023.OP_3DUP, conditionallyEvaluate(op3Dup)), _defineProperty(_objectSpread3, OpcodesBCH2023.OP_2OVER, conditionallyEvaluate(op2Over)), _defineProperty(_objectSpread3, OpcodesBCH2023.OP_2ROT, conditionallyEvaluate(op2Rot)), _defineProperty(_objectSpread3, OpcodesBCH2023.OP_2SWAP, conditionallyEvaluate(op2Swap)), _defineProperty(_objectSpread3, OpcodesBCH2023.OP_IFDUP, conditionallyEvaluate(opIfDup)), _defineProperty(_objectSpread3, OpcodesBCH2023.OP_DEPTH, conditionallyEvaluate(opDepth)), _defineProperty(_objectSpread3, OpcodesBCH2023.OP_DROP, conditionallyEvaluate(opDrop)), _defineProperty(_objectSpread3, OpcodesBCH2023.OP_DUP, conditionallyEvaluate(opDup)), _defineProperty(_objectSpread3, OpcodesBCH2023.OP_NIP, conditionallyEvaluate(opNip)), _defineProperty(_objectSpread3, OpcodesBCH2023.OP_OVER, conditionallyEvaluate(opOver)), _defineProperty(_objectSpread3, OpcodesBCH2023.OP_PICK, conditionallyEvaluate(opPick)), _defineProperty(_objectSpread3, OpcodesBCH2023.OP_ROLL, conditionallyEvaluate(opRoll)), _defineProperty(_objectSpread3, OpcodesBCH2023.OP_ROT, conditionallyEvaluate(opRot)), _defineProperty(_objectSpread3, OpcodesBCH2023.OP_SWAP, conditionallyEvaluate(opSwap)), _defineProperty(_objectSpread3, OpcodesBCH2023.OP_TUCK, conditionallyEvaluate(opTuck)), _defineProperty(_objectSpread3, OpcodesBCH2023.OP_CAT, conditionallyEvaluate(opCat)), _defineProperty(_objectSpread3, OpcodesBCH2023.OP_SPLIT, conditionallyEvaluate(opSplit)), _defineProperty(_objectSpread3, OpcodesBCH2023.OP_NUM2BIN, conditionallyEvaluate(opNum2Bin)), _defineProperty(_objectSpread3, OpcodesBCH2023.OP_BIN2NUM, conditionallyEvaluate(opBin2Num)), _defineProperty(_objectSpread3, OpcodesBCH2023.OP_SIZE, conditionallyEvaluate(opSize)), _defineProperty(_objectSpread3, OpcodesBCH2023.OP_INVERT, disabledOperation), _defineProperty(_objectSpread3, OpcodesBCH2023.OP_AND, conditionallyEvaluate(opAnd)), _defineProperty(_objectSpread3, OpcodesBCH2023.OP_OR, conditionallyEvaluate(opOr)), _defineProperty(_objectSpread3, OpcodesBCH2023.OP_XOR, conditionallyEvaluate(opXor)), _defineProperty(_objectSpread3, OpcodesBCH2023.OP_EQUAL, conditionallyEvaluate(opEqual)), _defineProperty(_objectSpread3, OpcodesBCH2023.OP_EQUALVERIFY, conditionallyEvaluate(opEqualVerify)), _defineProperty(_objectSpread3, OpcodesBCH2023.OP_RESERVED1, conditionallyEvaluate(reservedOperation)), _defineProperty(_objectSpread3, OpcodesBCH2023.OP_RESERVED2, conditionallyEvaluate(reservedOperation)), _defineProperty(_objectSpread3, OpcodesBCH2023.OP_1ADD, conditionallyEvaluate(op1Add)), _defineProperty(_objectSpread3, OpcodesBCH2023.OP_1SUB, conditionallyEvaluate(op1Sub)), _defineProperty(_objectSpread3, OpcodesBCH2023.OP_2MUL, disabledOperation), _defineProperty(_objectSpread3, OpcodesBCH2023.OP_2DIV, disabledOperation), _defineProperty(_objectSpread3, OpcodesBCH2023.OP_NEGATE, conditionallyEvaluate(opNegate)), _defineProperty(_objectSpread3, OpcodesBCH2023.OP_ABS, conditionallyEvaluate(opAbs)), _defineProperty(_objectSpread3, OpcodesBCH2023.OP_NOT, conditionallyEvaluate(opNot)), _defineProperty(_objectSpread3, OpcodesBCH2023.OP_0NOTEQUAL, conditionallyEvaluate(op0NotEqual)), _defineProperty(_objectSpread3, OpcodesBCH2023.OP_ADD, conditionallyEvaluate(opAdd)), _defineProperty(_objectSpread3, OpcodesBCH2023.OP_SUB, conditionallyEvaluate(opSub)), _defineProperty(_objectSpread3, OpcodesBCH2023.OP_MUL, conditionallyEvaluate(opMul)), _defineProperty(_objectSpread3, OpcodesBCH2023.OP_DIV, conditionallyEvaluate(opDiv)), _defineProperty(_objectSpread3, OpcodesBCH2023.OP_MOD, conditionallyEvaluate(opMod)), _defineProperty(_objectSpread3, OpcodesBCH2023.OP_LSHIFT, disabledOperation), _defineProperty(_objectSpread3, OpcodesBCH2023.OP_RSHIFT, disabledOperation), _defineProperty(_objectSpread3, OpcodesBCH2023.OP_BOOLAND, conditionallyEvaluate(opBoolAnd)), _defineProperty(_objectSpread3, OpcodesBCH2023.OP_BOOLOR, conditionallyEvaluate(opBoolOr)), _defineProperty(_objectSpread3, OpcodesBCH2023.OP_NUMEQUAL, conditionallyEvaluate(opNumEqual)), _defineProperty(_objectSpread3, OpcodesBCH2023.OP_NUMEQUALVERIFY, conditionallyEvaluate(opNumEqualVerify)), _defineProperty(_objectSpread3, OpcodesBCH2023.OP_NUMNOTEQUAL, conditionallyEvaluate(opNumNotEqual)), _defineProperty(_objectSpread3, OpcodesBCH2023.OP_LESSTHAN, conditionallyEvaluate(opLessThan)), _defineProperty(_objectSpread3, OpcodesBCH2023.OP_GREATERTHAN, conditionallyEvaluate(opGreaterThan)), _defineProperty(_objectSpread3, OpcodesBCH2023.OP_LESSTHANOREQUAL, conditionallyEvaluate(opLessThanOrEqual)), _defineProperty(_objectSpread3, OpcodesBCH2023.OP_GREATERTHANOREQUAL, conditionallyEvaluate(opGreaterThanOrEqual)), _defineProperty(_objectSpread3, OpcodesBCH2023.OP_MIN, conditionallyEvaluate(opMin)), _defineProperty(_objectSpread3, OpcodesBCH2023.OP_MAX, conditionallyEvaluate(opMax)), _defineProperty(_objectSpread3, OpcodesBCH2023.OP_WITHIN, conditionallyEvaluate(opWithin)), _defineProperty(_objectSpread3, OpcodesBCH2023.OP_RIPEMD160, conditionallyEvaluate(opRipemd160({
      ripemd160: ripemd160
    }))), _defineProperty(_objectSpread3, OpcodesBCH2023.OP_SHA1, conditionallyEvaluate(opSha1({
      sha1: sha1
    }))), _defineProperty(_objectSpread3, OpcodesBCH2023.OP_SHA256, conditionallyEvaluate(opSha256({
      sha256: sha256
    }))), _defineProperty(_objectSpread3, OpcodesBCH2023.OP_HASH160, conditionallyEvaluate(opHash160({
      ripemd160: ripemd160,
      sha256: sha256
    }))), _defineProperty(_objectSpread3, OpcodesBCH2023.OP_HASH256, conditionallyEvaluate(opHash256({
      sha256: sha256
    }))), _defineProperty(_objectSpread3, OpcodesBCH2023.OP_CODESEPARATOR, conditionallyEvaluate(opCodeSeparator)), _defineProperty(_objectSpread3, OpcodesBCH2023.OP_CHECKSIG, conditionallyEvaluate(opCheckSigBCH2023({
      secp256k1: secp256k1$1,
      sha256: sha256
    }))), _defineProperty(_objectSpread3, OpcodesBCH2023.OP_CHECKSIGVERIFY, conditionallyEvaluate(opCheckSigVerifyBCH2023({
      secp256k1: secp256k1$1,
      sha256: sha256
    }))), _defineProperty(_objectSpread3, OpcodesBCH2023.OP_CHECKMULTISIG, conditionallyEvaluate(opCheckMultiSigBCH2023({
      secp256k1: secp256k1$1,
      sha256: sha256
    }))), _defineProperty(_objectSpread3, OpcodesBCH2023.OP_CHECKMULTISIGVERIFY, conditionallyEvaluate(opCheckMultiSigVerifyBCH2023({
      secp256k1: secp256k1$1,
      sha256: sha256
    }))), _objectSpread3), standard ? (_ref2 = {}, _defineProperty(_ref2, OpcodesBCH2023.OP_NOP1, conditionallyEvaluate(opNopDisallowed)), _defineProperty(_ref2, OpcodesBCH2023.OP_CHECKLOCKTIMEVERIFY, conditionallyEvaluate(opCheckLockTimeVerify)), _defineProperty(_ref2, OpcodesBCH2023.OP_CHECKSEQUENCEVERIFY, conditionallyEvaluate(opCheckSequenceVerify)), _defineProperty(_ref2, OpcodesBCH2023.OP_NOP4, conditionallyEvaluate(opNopDisallowed)), _defineProperty(_ref2, OpcodesBCH2023.OP_NOP5, conditionallyEvaluate(opNopDisallowed)), _defineProperty(_ref2, OpcodesBCH2023.OP_NOP6, conditionallyEvaluate(opNopDisallowed)), _defineProperty(_ref2, OpcodesBCH2023.OP_NOP7, conditionallyEvaluate(opNopDisallowed)), _defineProperty(_ref2, OpcodesBCH2023.OP_NOP8, conditionallyEvaluate(opNopDisallowed)), _defineProperty(_ref2, OpcodesBCH2023.OP_NOP9, conditionallyEvaluate(opNopDisallowed)), _defineProperty(_ref2, OpcodesBCH2023.OP_NOP10, conditionallyEvaluate(opNopDisallowed)), _ref2) : (_ref3 = {}, _defineProperty(_ref3, OpcodesBCH2023.OP_NOP1, conditionallyEvaluate(opNop)), _defineProperty(_ref3, OpcodesBCH2023.OP_CHECKLOCKTIMEVERIFY, conditionallyEvaluate(opCheckLockTimeVerify)), _defineProperty(_ref3, OpcodesBCH2023.OP_CHECKSEQUENCEVERIFY, conditionallyEvaluate(opCheckSequenceVerify)), _defineProperty(_ref3, OpcodesBCH2023.OP_NOP4, conditionallyEvaluate(opNop)), _defineProperty(_ref3, OpcodesBCH2023.OP_NOP5, conditionallyEvaluate(opNop)), _defineProperty(_ref3, OpcodesBCH2023.OP_NOP6, conditionallyEvaluate(opNop)), _defineProperty(_ref3, OpcodesBCH2023.OP_NOP7, conditionallyEvaluate(opNop)), _defineProperty(_ref3, OpcodesBCH2023.OP_NOP8, conditionallyEvaluate(opNop)), _defineProperty(_ref3, OpcodesBCH2023.OP_NOP9, conditionallyEvaluate(opNop)), _defineProperty(_ref3, OpcodesBCH2023.OP_NOP10, conditionallyEvaluate(opNop)), _ref3)), {}, (_objectSpread4 = {}, _defineProperty(_objectSpread4, OpcodesBCH2023.OP_CHECKDATASIG, conditionallyEvaluate(opCheckDataSig({
      secp256k1: secp256k1$1,
      sha256: sha256
    }))), _defineProperty(_objectSpread4, OpcodesBCH2023.OP_CHECKDATASIGVERIFY, conditionallyEvaluate(opCheckDataSigVerify({
      secp256k1: secp256k1$1,
      sha256: sha256
    }))), _defineProperty(_objectSpread4, OpcodesBCH2023.OP_REVERSEBYTES, conditionallyEvaluate(opReverseBytes)), _defineProperty(_objectSpread4, OpcodesBCH2023.OP_INPUTINDEX, conditionallyEvaluate(opInputIndex)), _defineProperty(_objectSpread4, OpcodesBCH2023.OP_ACTIVEBYTECODE, conditionallyEvaluate(opActiveBytecode)), _defineProperty(_objectSpread4, OpcodesBCH2023.OP_TXVERSION, conditionallyEvaluate(opTxVersion)), _defineProperty(_objectSpread4, OpcodesBCH2023.OP_TXINPUTCOUNT, conditionallyEvaluate(opTxInputCount)), _defineProperty(_objectSpread4, OpcodesBCH2023.OP_TXOUTPUTCOUNT, conditionallyEvaluate(opTxOutputCount)), _defineProperty(_objectSpread4, OpcodesBCH2023.OP_TXLOCKTIME, conditionallyEvaluate(opTxLocktime)), _defineProperty(_objectSpread4, OpcodesBCH2023.OP_UTXOVALUE, conditionallyEvaluate(opUtxoValue)), _defineProperty(_objectSpread4, OpcodesBCH2023.OP_UTXOBYTECODE, conditionallyEvaluate(opUtxoBytecode)), _defineProperty(_objectSpread4, OpcodesBCH2023.OP_OUTPOINTTXHASH, conditionallyEvaluate(opOutpointTxHash)), _defineProperty(_objectSpread4, OpcodesBCH2023.OP_OUTPOINTINDEX, conditionallyEvaluate(opOutpointIndex)), _defineProperty(_objectSpread4, OpcodesBCH2023.OP_INPUTBYTECODE, conditionallyEvaluate(opInputBytecode)), _defineProperty(_objectSpread4, OpcodesBCH2023.OP_INPUTSEQUENCENUMBER, conditionallyEvaluate(opInputSequenceNumber)), _defineProperty(_objectSpread4, OpcodesBCH2023.OP_OUTPUTVALUE, conditionallyEvaluate(opOutputValue)), _defineProperty(_objectSpread4, OpcodesBCH2023.OP_OUTPUTBYTECODE, conditionallyEvaluate(opOutputBytecode)), _defineProperty(_objectSpread4, OpcodesBCH2023.OP_UTXOTOKENCATEGORY, conditionallyEvaluate(opUtxoTokenCategory)), _defineProperty(_objectSpread4, OpcodesBCH2023.OP_UTXOTOKENCOMMITMENT, conditionallyEvaluate(opUtxoTokenCommitment)), _defineProperty(_objectSpread4, OpcodesBCH2023.OP_UTXOTOKENAMOUNT, conditionallyEvaluate(opUtxoTokenAmount)), _defineProperty(_objectSpread4, OpcodesBCH2023.OP_OUTPUTTOKENCATEGORY, conditionallyEvaluate(opOutputTokenCategory)), _defineProperty(_objectSpread4, OpcodesBCH2023.OP_OUTPUTTOKENCOMMITMENT, conditionallyEvaluate(opOutputTokenCommitment)), _defineProperty(_objectSpread4, OpcodesBCH2023.OP_OUTPUTTOKENAMOUNT, conditionallyEvaluate(opOutputTokenAmount)), _objectSpread4)))),
    success: function success(state) {
      if (state.error !== undefined) {
        return state.error;
      }
      if (state.controlStack.length !== 0) {
        return AuthenticationErrorCommon.nonEmptyControlStack;
      }
      if (state.stack.length !== 1) {
        return AuthenticationErrorCommon.requiresCleanStack;
      }
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      if (!stackItemIsTruthy(state.stack[0])) {
        return AuthenticationErrorCommon.unsuccessfulEvaluation;
      }
      return true;
    },
    undefined: undefinedOperation,
    // eslint-disable-next-line complexity
    verify: function verify(_ref4, evaluate, stateSuccess) {
      var sourceOutputs = _ref4.sourceOutputs,
        transaction = _ref4.transaction;
      if (transaction.inputs.length === 0) {
        return 'Transactions must have at least one input.';
      }
      if (transaction.outputs.length === 0) {
        return 'Transactions must have at least one output.';
      }
      if (transaction.inputs.length !== sourceOutputs.length) {
        return 'Unable to verify transaction: a single spent output must be provided for each transaction input.';
      }
      var transactionSize = encodeTransactionBCH(transaction).length;
      if (transactionSize < ConsensusBCH2023.minimumTransactionSize) {
        return "Invalid transaction size: the transaction is ".concat(transactionSize, " bytes, but transactions must be no smaller than ").concat(ConsensusBCH2023.minimumTransactionSize, " bytes to prevent an exploit of the transaction Merkle tree design.");
      }
      if (transactionSize > ConsensusBCH2023.maximumTransactionSize) {
        return "Transaction exceeds maximum size: the transaction is ".concat(transactionSize, " bytes, but the maximum transaction size is ").concat(ConsensusBCH2023.maximumTransactionSize, " bytes.");
      }
      var inputValue = sourceOutputs.reduce(function (sum, utxo) {
        return sum + utxo.valueSatoshis;
      }, 0n);
      var outputValue = transaction.outputs.reduce(function (sum, output) {
        return sum + output.valueSatoshis;
      }, 0n);
      if (outputValue > inputValue) {
        return "Unable to verify transaction: the sum of transaction outputs exceeds the sum of transaction inputs. Input value: ".concat(inputValue, ", output value: ").concat(outputValue);
      }
      var outpointList = transaction.inputs.map(function (input) {
        return "outpointTransactionHash: ".concat(binToHex(input.outpointTransactionHash), ", outpointIndex: ").concat(input.outpointIndex);
      });
      var firstDuplicate = outpointList.find(function (outpoint, index) {
        return outpointList.lastIndexOf(outpoint) !== index;
      });
      /**
       * This check isn't strictly necessary to perform in the VM (assuming the
       * provider of `sourceOutputs` is checking for double spends), but it's
       * included here for debugging purposes.
       */
      if (firstDuplicate !== undefined) {
        return "Unable to verify transaction: the transaction attempts to spend the same outpoint in multiple inputs. ".concat(firstDuplicate);
      }
      if (standard) {
        if (transaction.version < 1 || transaction.version > ConsensusBCH2023.maximumStandardVersion) {
          return "Standard transactions must have a version no less than 1 and no greater than ".concat(ConsensusBCH2023.maximumStandardVersion, ".");
        }
        if (transactionSize > ConsensusBCH2023.maximumStandardTransactionSize) {
          return "Transaction exceeds maximum standard size: this transaction is ".concat(transactionSize, " bytes, but the maximum standard transaction size is ").concat(ConsensusBCH2023.maximumStandardTransactionSize, " bytes.");
        }
        // eslint-disable-next-line functional/no-loop-statement
        var _iterator = _createForOfIteratorHelper(sourceOutputs.entries()),
          _step;
        try {
          for (_iterator.s(); !(_step = _iterator.n()).done;) {
            var _step$value = _slicedToArray(_step.value, 2),
              index = _step$value[0],
              output = _step$value[1];
            if (!isStandardOutputBytecode2023(output.lockingBytecode)) {
              return "Standard transactions may only spend standard output types, but source output ".concat(index, " is non-standard.");
            }
          }
          // eslint-disable-next-line functional/no-let
        } catch (err) {
          _iterator.e(err);
        } finally {
          _iterator.f();
        }
        var totalArbitraryDataBytes = 0;
        // eslint-disable-next-line functional/no-loop-statement
        var _iterator2 = _createForOfIteratorHelper(transaction.outputs.entries()),
          _step2;
        try {
          for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
            var _step2$value = _slicedToArray(_step2.value, 2),
              _index = _step2$value[0],
              _output = _step2$value[1];
            if (!isStandardOutputBytecode2023(_output.lockingBytecode)) {
              return "Standard transactions may only create standard output types, but transaction output ".concat(_index, " is non-standard.");
            }
            // eslint-disable-next-line functional/no-conditional-statement
            if (isArbitraryDataOutput(_output.lockingBytecode)) {
              // eslint-disable-next-line functional/no-expression-statement
              totalArbitraryDataBytes += _output.lockingBytecode.length + 1;
            }
            if (isDustOutput(_output)) {
              return "Standard transactions may not have dust outputs, but transaction output ".concat(_index, " is a dust output. Output ").concat(_index, " must have a value of at least ").concat(getDustThreshold(_output), " satoshis. Current value: ").concat(_output.valueSatoshis);
            }
          }
        } catch (err) {
          _iterator2.e(err);
        } finally {
          _iterator2.f();
        }
        if (totalArbitraryDataBytes > ConsensusBCH2023.maximumDataCarrierBytes) {
          return "Standard transactions may carry no more than ".concat(ConsensusBCH2023.maximumDataCarrierBytes, " bytes in arbitrary data outputs; this transaction includes ").concat(totalArbitraryDataBytes, " bytes of arbitrary data.");
        }
        // eslint-disable-next-line functional/no-loop-statement
        var _iterator3 = _createForOfIteratorHelper(transaction.inputs.entries()),
          _step3;
        try {
          for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
            var _step3$value = _slicedToArray(_step3.value, 2),
              _index2 = _step3$value[0],
              input = _step3$value[1];
            if (input.unlockingBytecode.length > ConsensusBCH2023.maximumStandardUnlockingBytecodeLength) {
              return "Input index ".concat(_index2, " is non-standard: the unlocking bytecode (").concat(input.unlockingBytecode.length, " bytes) exceeds the maximum standard unlocking bytecode length (").concat(ConsensusBCH2023.maximumStandardUnlockingBytecodeLength, " bytes).");
            }
            if (!isPushOnly(input.unlockingBytecode)) {
              return "Input index ".concat(_index2, " is non-standard: unlocking bytecode may contain only push operations.");
            }
          }
        } catch (err) {
          _iterator3.e(err);
        } finally {
          _iterator3.f();
        }
      }
      var tokenValidationResult = verifyTransactionTokens(transaction, sourceOutputs);
      if (tokenValidationResult !== true) {
        return tokenValidationResult;
      }
      // eslint-disable-next-line functional/no-loop-statement
      var _iterator4 = _createForOfIteratorHelper(transaction.inputs.keys()),
        _step4;
      try {
        for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {
          var _index3 = _step4.value;
          var state = evaluate({
            inputIndex: _index3,
            sourceOutputs: sourceOutputs,
            transaction: transaction
          });
          var result = stateSuccess(state);
          if (typeof result === 'string') {
            return "Error in evaluating input index ".concat(_index3, ": ").concat(result);
          }
        }
      } catch (err) {
        _iterator4.e(err);
      } finally {
        _iterator4.f();
      }
      return true;
    }
  };
};
var createInstructionSetBCH = createInstructionSetBCH2023;

/**
 * Create an {@link AuthenticationVirtualMachine} to evaluate authentication
 * programs constructed from operations in the `instructionSet`.
 * @param instructionSet - an {@link InstructionSet}
 */
var createAuthenticationVirtualMachine = function createAuthenticationVirtualMachine(instructionSet) {
  var _instructionSet$every;
  var availableOpcodes = 256;
  var operators = range(availableOpcodes).map(function (codepoint) {
    return instructionSet.operations[codepoint] === undefined ? instructionSet.undefined : instructionSet.operations[codepoint];
  });
  // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
  var getCodepoint = function getCodepoint(state) {
    return state.instructions[state.ip];
  };
  var after = function after(state) {
    // eslint-disable-next-line functional/no-expression-statement, functional/immutable-data
    state.ip += 1;
    return state;
  };
  var getOperation = function getOperation(state) {
    return (
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      operators[getCodepoint(state).opcode]
    );
  };
  var noOp = function noOp(state) {
    return state;
  };
  var stateEvery = (_instructionSet$every = instructionSet.every) !== null && _instructionSet$every !== void 0 ? _instructionSet$every : noOp;
  var stateStepMutate = function stateStepMutate(state) {
    var operator = getOperation(state);
    return after(stateEvery(operator(state)));
  };
  var stateContinue = instructionSet.continue;
  /**
   * When we get real tail call optimization, this can be replaced
   * with recursion.
   */
  var untilComplete = function untilComplete(state, stepFunction) {
    // eslint-disable-next-line functional/no-loop-statement
    while (stateContinue(state)) {
      // eslint-disable-next-line functional/no-expression-statement, no-param-reassign
      state = stepFunction(state);
    }
    return state;
  };
  var stateClone = instructionSet.clone;
  var success = instructionSet.success;
  var stateEvaluate = function stateEvaluate(state) {
    return untilComplete(stateClone(state), stateStepMutate);
  };
  var stateDebugStep = function stateDebugStep(state) {
    var operator = getOperation(state);
    return after(stateEvery(operator(stateClone(state))));
  };
  var stateDebug = function stateDebug(state) {
    var trace = [];
    // eslint-disable-next-line functional/no-expression-statement, functional/immutable-data
    trace.push(state);
    // eslint-disable-next-line functional/no-expression-statement
    untilComplete(state, function (currentState) {
      var nextState = stateDebugStep(currentState);
      // eslint-disable-next-line functional/no-expression-statement, functional/immutable-data
      trace.push(nextState);
      return nextState;
    });
    return trace;
  };
  var stateStep = function stateStep(state) {
    return stateStepMutate(stateClone(state));
  };
  var evaluate = function evaluate(program) {
    return instructionSet.evaluate(program, stateEvaluate);
  };
  var debug = function debug(program) {
    var results = [];
    var proxyDebug = function proxyDebug(state) {
      var _debugResult;
      var debugResult = stateDebug(state);
      // eslint-disable-next-line functional/no-expression-statement, functional/immutable-data
      results.push.apply(results, _toConsumableArray(debugResult));
      return (_debugResult = debugResult[debugResult.length - 1]) !== null && _debugResult !== void 0 ? _debugResult : state;
    };
    var finalResult = instructionSet.evaluate(program, proxyDebug);
    return [].concat(results, [finalResult]);
  };
  var verify = function verify(resolvedTransaction) {
    return instructionSet.verify(resolvedTransaction, evaluate, success);
  };
  return {
    debug: debug,
    evaluate: evaluate,
    stateClone: stateClone,
    stateContinue: stateContinue,
    stateDebug: stateDebug,
    stateEvaluate: stateEvaluate,
    stateStep: stateStep,
    stateStepMutate: stateStepMutate,
    stateSuccess: success,
    verify: verify
  };
};

/**
 * Initialize a virtual machine using the `BCH_2023_05` instruction set.
 *
 * @param standard - If `true`, the additional `isStandard` validations will be
 * enabled. Transactions that fail these rules are often called "non-standard"
 * and can technically be included by miners in valid blocks, but most network
 * nodes will refuse to relay them. (Default: `true`)
 */
var createVirtualMachineBCH2023 = function createVirtualMachineBCH2023() {
  var standard = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
  return createAuthenticationVirtualMachine(createInstructionSetBCH2023(standard));
};
var createVirtualMachineBCH = createVirtualMachineBCH2023;

/**
 * create an instance of the BCH 2022 virtual machine instruction set.
 *
 * @param standard - If `true`, the additional `isStandard` validations will be
 * enabled. Transactions that fail these rules are often called "non-standard"
 * and can technically be included by miners in valid blocks, but most network
 * nodes will refuse to relay them. (Default: `true`)
 */
var createInstructionSetBCH2022 = function createInstructionSetBCH2022() {
  var _objectSpread2$1, _objectSpread3, _ref2, _ref3, _objectSpread4;
  var standard = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
  var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {
      ripemd160: ripemd160$1,
      secp256k1: secp256k1,
      sha1: sha1$1,
      sha256: sha256$1
    },
    ripemd160 = _ref.ripemd160,
    secp256k1$1 = _ref.secp256k1,
    sha1 = _ref.sha1,
    sha256 = _ref.sha256;
  var conditionallyPush = pushOperation();
  return {
    clone: cloneAuthenticationProgramStateBCH,
    continue: function _continue(state) {
      return state.error === undefined && state.ip < state.instructions.length;
    },
    // eslint-disable-next-line complexity
    evaluate: function evaluate(program, stateEvaluate) {
      var _p2shStack$pop;
      var unlockingBytecode =
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      program.transaction.inputs[program.inputIndex].unlockingBytecode;
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      var lockingBytecode = program.sourceOutputs[program.inputIndex].lockingBytecode;
      var unlockingInstructions = decodeAuthenticationInstructions(unlockingBytecode);
      var lockingInstructions = decodeAuthenticationInstructions(lockingBytecode);
      var initialState = createAuthenticationProgramStateCommon({
        instructions: unlockingInstructions,
        program: program,
        stack: []
      });
      if (unlockingBytecode.length > ConsensusBCH.maximumBytecodeLength) {
        return applyError(initialState, "The provided unlocking bytecode (".concat(unlockingBytecode.length, " bytes) exceeds the maximum bytecode length (").concat(ConsensusBCH.maximumBytecodeLength, " bytes)."));
      }
      if (authenticationInstructionsAreMalformed(unlockingInstructions)) {
        return applyError(initialState, AuthenticationErrorCommon.malformedUnlockingBytecode);
      }
      if (!isPushOnly(unlockingBytecode)) {
        return applyError(initialState, AuthenticationErrorCommon.requiresPushOnly);
      }
      if (lockingBytecode.length > ConsensusBCH.maximumBytecodeLength) {
        return applyError(initialState, AuthenticationErrorCommon.exceededMaximumBytecodeLengthLocking);
      }
      if (authenticationInstructionsAreMalformed(lockingInstructions)) {
        return applyError(initialState, AuthenticationErrorCommon.malformedLockingBytecode);
      }
      var unlockingResult = stateEvaluate(initialState);
      if (unlockingResult.error !== undefined) {
        return unlockingResult;
      }
      if (unlockingResult.controlStack.length !== 0) {
        return applyError(initialState, AuthenticationErrorCommon.nonEmptyControlStack);
      }
      var lockingResult = stateEvaluate(createAuthenticationProgramStateCommon({
        instructions: lockingInstructions,
        program: program,
        stack: unlockingResult.stack
      }));
      if (!isPayToScriptHash20(lockingBytecode)) {
        return lockingResult;
      }
      var p2shStack = cloneStack(unlockingResult.stack);
      // eslint-disable-next-line functional/immutable-data
      var p2shScript = (_p2shStack$pop = p2shStack.pop()) !== null && _p2shStack$pop !== void 0 ? _p2shStack$pop : Uint8Array.of();
      if (p2shStack.length === 0 && isWitnessProgram(p2shScript)) {
        return lockingResult;
      }
      var p2shInstructions = decodeAuthenticationInstructions(p2shScript);
      return authenticationInstructionsAreMalformed(p2shInstructions) ? _objectSpread2(_objectSpread2({}, lockingResult), {}, {
        error: AuthenticationErrorCommon.malformedP2shBytecode
      }) : stateEvaluate(createAuthenticationProgramStateCommon({
        instructions: p2shInstructions,
        program: program,
        stack: p2shStack
      }));
    },
    every: function every(state) {
      return (
        // TODO: implement sigchecks https://gitlab.com/bitcoin-cash-node/bchn-sw/bitcoincash-upgrade-specifications/-/blob/master/spec/2020-05-15-sigchecks.md
        state.stack.length + state.alternateStack.length > ConsensusBCH.maximumStackDepth ? applyError(state, AuthenticationErrorCommon.exceededMaximumStackDepth) : state.operationCount > ConsensusBCH.maximumOperationCount ? applyError(state, AuthenticationErrorCommon.exceededMaximumOperationCount) : state
      );
    },
    operations: _objectSpread2((_objectSpread2$1 = {}, _defineProperty(_objectSpread2$1, OpcodesBCH.OP_0, conditionallyPush), _defineProperty(_objectSpread2$1, OpcodesBCH.OP_PUSHBYTES_1, conditionallyPush), _defineProperty(_objectSpread2$1, OpcodesBCH.OP_PUSHBYTES_2, conditionallyPush), _defineProperty(_objectSpread2$1, OpcodesBCH.OP_PUSHBYTES_3, conditionallyPush), _defineProperty(_objectSpread2$1, OpcodesBCH.OP_PUSHBYTES_4, conditionallyPush), _defineProperty(_objectSpread2$1, OpcodesBCH.OP_PUSHBYTES_5, conditionallyPush), _defineProperty(_objectSpread2$1, OpcodesBCH.OP_PUSHBYTES_6, conditionallyPush), _defineProperty(_objectSpread2$1, OpcodesBCH.OP_PUSHBYTES_7, conditionallyPush), _defineProperty(_objectSpread2$1, OpcodesBCH.OP_PUSHBYTES_8, conditionallyPush), _defineProperty(_objectSpread2$1, OpcodesBCH.OP_PUSHBYTES_9, conditionallyPush), _defineProperty(_objectSpread2$1, OpcodesBCH.OP_PUSHBYTES_10, conditionallyPush), _defineProperty(_objectSpread2$1, OpcodesBCH.OP_PUSHBYTES_11, conditionallyPush), _defineProperty(_objectSpread2$1, OpcodesBCH.OP_PUSHBYTES_12, conditionallyPush), _defineProperty(_objectSpread2$1, OpcodesBCH.OP_PUSHBYTES_13, conditionallyPush), _defineProperty(_objectSpread2$1, OpcodesBCH.OP_PUSHBYTES_14, conditionallyPush), _defineProperty(_objectSpread2$1, OpcodesBCH.OP_PUSHBYTES_15, conditionallyPush), _defineProperty(_objectSpread2$1, OpcodesBCH.OP_PUSHBYTES_16, conditionallyPush), _defineProperty(_objectSpread2$1, OpcodesBCH.OP_PUSHBYTES_17, conditionallyPush), _defineProperty(_objectSpread2$1, OpcodesBCH.OP_PUSHBYTES_18, conditionallyPush), _defineProperty(_objectSpread2$1, OpcodesBCH.OP_PUSHBYTES_19, conditionallyPush), _defineProperty(_objectSpread2$1, OpcodesBCH.OP_PUSHBYTES_20, conditionallyPush), _defineProperty(_objectSpread2$1, OpcodesBCH.OP_PUSHBYTES_21, conditionallyPush), _defineProperty(_objectSpread2$1, OpcodesBCH.OP_PUSHBYTES_22, conditionallyPush), _defineProperty(_objectSpread2$1, OpcodesBCH.OP_PUSHBYTES_23, conditionallyPush), _defineProperty(_objectSpread2$1, OpcodesBCH.OP_PUSHBYTES_24, conditionallyPush), _defineProperty(_objectSpread2$1, OpcodesBCH.OP_PUSHBYTES_25, conditionallyPush), _defineProperty(_objectSpread2$1, OpcodesBCH.OP_PUSHBYTES_26, conditionallyPush), _defineProperty(_objectSpread2$1, OpcodesBCH.OP_PUSHBYTES_27, conditionallyPush), _defineProperty(_objectSpread2$1, OpcodesBCH.OP_PUSHBYTES_28, conditionallyPush), _defineProperty(_objectSpread2$1, OpcodesBCH.OP_PUSHBYTES_29, conditionallyPush), _defineProperty(_objectSpread2$1, OpcodesBCH.OP_PUSHBYTES_30, conditionallyPush), _defineProperty(_objectSpread2$1, OpcodesBCH.OP_PUSHBYTES_31, conditionallyPush), _defineProperty(_objectSpread2$1, OpcodesBCH.OP_PUSHBYTES_32, conditionallyPush), _defineProperty(_objectSpread2$1, OpcodesBCH.OP_PUSHBYTES_33, conditionallyPush), _defineProperty(_objectSpread2$1, OpcodesBCH.OP_PUSHBYTES_34, conditionallyPush), _defineProperty(_objectSpread2$1, OpcodesBCH.OP_PUSHBYTES_35, conditionallyPush), _defineProperty(_objectSpread2$1, OpcodesBCH.OP_PUSHBYTES_36, conditionallyPush), _defineProperty(_objectSpread2$1, OpcodesBCH.OP_PUSHBYTES_37, conditionallyPush), _defineProperty(_objectSpread2$1, OpcodesBCH.OP_PUSHBYTES_38, conditionallyPush), _defineProperty(_objectSpread2$1, OpcodesBCH.OP_PUSHBYTES_39, conditionallyPush), _defineProperty(_objectSpread2$1, OpcodesBCH.OP_PUSHBYTES_40, conditionallyPush), _defineProperty(_objectSpread2$1, OpcodesBCH.OP_PUSHBYTES_41, conditionallyPush), _defineProperty(_objectSpread2$1, OpcodesBCH.OP_PUSHBYTES_42, conditionallyPush), _defineProperty(_objectSpread2$1, OpcodesBCH.OP_PUSHBYTES_43, conditionallyPush), _defineProperty(_objectSpread2$1, OpcodesBCH.OP_PUSHBYTES_44, conditionallyPush), _defineProperty(_objectSpread2$1, OpcodesBCH.OP_PUSHBYTES_45, conditionallyPush), _defineProperty(_objectSpread2$1, OpcodesBCH.OP_PUSHBYTES_46, conditionallyPush), _defineProperty(_objectSpread2$1, OpcodesBCH.OP_PUSHBYTES_47, conditionallyPush), _defineProperty(_objectSpread2$1, OpcodesBCH.OP_PUSHBYTES_48, conditionallyPush), _defineProperty(_objectSpread2$1, OpcodesBCH.OP_PUSHBYTES_49, conditionallyPush), _defineProperty(_objectSpread2$1, OpcodesBCH.OP_PUSHBYTES_50, conditionallyPush), _defineProperty(_objectSpread2$1, OpcodesBCH.OP_PUSHBYTES_51, conditionallyPush), _defineProperty(_objectSpread2$1, OpcodesBCH.OP_PUSHBYTES_52, conditionallyPush), _defineProperty(_objectSpread2$1, OpcodesBCH.OP_PUSHBYTES_53, conditionallyPush), _defineProperty(_objectSpread2$1, OpcodesBCH.OP_PUSHBYTES_54, conditionallyPush), _defineProperty(_objectSpread2$1, OpcodesBCH.OP_PUSHBYTES_55, conditionallyPush), _defineProperty(_objectSpread2$1, OpcodesBCH.OP_PUSHBYTES_56, conditionallyPush), _defineProperty(_objectSpread2$1, OpcodesBCH.OP_PUSHBYTES_57, conditionallyPush), _defineProperty(_objectSpread2$1, OpcodesBCH.OP_PUSHBYTES_58, conditionallyPush), _defineProperty(_objectSpread2$1, OpcodesBCH.OP_PUSHBYTES_59, conditionallyPush), _defineProperty(_objectSpread2$1, OpcodesBCH.OP_PUSHBYTES_60, conditionallyPush), _defineProperty(_objectSpread2$1, OpcodesBCH.OP_PUSHBYTES_61, conditionallyPush), _defineProperty(_objectSpread2$1, OpcodesBCH.OP_PUSHBYTES_62, conditionallyPush), _defineProperty(_objectSpread2$1, OpcodesBCH.OP_PUSHBYTES_63, conditionallyPush), _defineProperty(_objectSpread2$1, OpcodesBCH.OP_PUSHBYTES_64, conditionallyPush), _defineProperty(_objectSpread2$1, OpcodesBCH.OP_PUSHBYTES_65, conditionallyPush), _defineProperty(_objectSpread2$1, OpcodesBCH.OP_PUSHBYTES_66, conditionallyPush), _defineProperty(_objectSpread2$1, OpcodesBCH.OP_PUSHBYTES_67, conditionallyPush), _defineProperty(_objectSpread2$1, OpcodesBCH.OP_PUSHBYTES_68, conditionallyPush), _defineProperty(_objectSpread2$1, OpcodesBCH.OP_PUSHBYTES_69, conditionallyPush), _defineProperty(_objectSpread2$1, OpcodesBCH.OP_PUSHBYTES_70, conditionallyPush), _defineProperty(_objectSpread2$1, OpcodesBCH.OP_PUSHBYTES_71, conditionallyPush), _defineProperty(_objectSpread2$1, OpcodesBCH.OP_PUSHBYTES_72, conditionallyPush), _defineProperty(_objectSpread2$1, OpcodesBCH.OP_PUSHBYTES_73, conditionallyPush), _defineProperty(_objectSpread2$1, OpcodesBCH.OP_PUSHBYTES_74, conditionallyPush), _defineProperty(_objectSpread2$1, OpcodesBCH.OP_PUSHBYTES_75, conditionallyPush), _defineProperty(_objectSpread2$1, OpcodesBCH.OP_PUSHDATA_1, conditionallyPush), _defineProperty(_objectSpread2$1, OpcodesBCH.OP_PUSHDATA_2, conditionallyPush), _defineProperty(_objectSpread2$1, OpcodesBCH.OP_PUSHDATA_4, conditionallyPush), _defineProperty(_objectSpread2$1, OpcodesBCH.OP_1NEGATE, conditionallyEvaluate(pushNumberOperation(-1))), _defineProperty(_objectSpread2$1, OpcodesBCH.OP_RESERVED, conditionallyEvaluate(reservedOperation)), _defineProperty(_objectSpread2$1, OpcodesBCH.OP_1, conditionallyEvaluate(pushNumberOperation(1))), _defineProperty(_objectSpread2$1, OpcodesBCH.OP_2, conditionallyEvaluate(pushNumberOperation(2))), _defineProperty(_objectSpread2$1, OpcodesBCH.OP_3, conditionallyEvaluate(pushNumberOperation(3))), _defineProperty(_objectSpread2$1, OpcodesBCH.OP_4, conditionallyEvaluate(pushNumberOperation(4))), _defineProperty(_objectSpread2$1, OpcodesBCH.OP_5, conditionallyEvaluate(pushNumberOperation(5))), _defineProperty(_objectSpread2$1, OpcodesBCH.OP_6, conditionallyEvaluate(pushNumberOperation(6))), _defineProperty(_objectSpread2$1, OpcodesBCH.OP_7, conditionallyEvaluate(pushNumberOperation(7))), _defineProperty(_objectSpread2$1, OpcodesBCH.OP_8, conditionallyEvaluate(pushNumberOperation(8))), _defineProperty(_objectSpread2$1, OpcodesBCH.OP_9, conditionallyEvaluate(pushNumberOperation(9))), _defineProperty(_objectSpread2$1, OpcodesBCH.OP_10, conditionallyEvaluate(pushNumberOperation(10))), _defineProperty(_objectSpread2$1, OpcodesBCH.OP_11, conditionallyEvaluate(pushNumberOperation(11))), _defineProperty(_objectSpread2$1, OpcodesBCH.OP_12, conditionallyEvaluate(pushNumberOperation(12))), _defineProperty(_objectSpread2$1, OpcodesBCH.OP_13, conditionallyEvaluate(pushNumberOperation(13))), _defineProperty(_objectSpread2$1, OpcodesBCH.OP_14, conditionallyEvaluate(pushNumberOperation(14))), _defineProperty(_objectSpread2$1, OpcodesBCH.OP_15, conditionallyEvaluate(pushNumberOperation(15))), _defineProperty(_objectSpread2$1, OpcodesBCH.OP_16, conditionallyEvaluate(pushNumberOperation(16))), _objectSpread2$1), mapOverOperations([incrementOperationCount], _objectSpread2(_objectSpread2((_objectSpread3 = {}, _defineProperty(_objectSpread3, OpcodesBCH.OP_NOP, conditionallyEvaluate(opNop)), _defineProperty(_objectSpread3, OpcodesBCH.OP_VER, conditionallyEvaluate(reservedOperation)), _defineProperty(_objectSpread3, OpcodesBCH.OP_IF, opIf), _defineProperty(_objectSpread3, OpcodesBCH.OP_NOTIF, opNotIf), _defineProperty(_objectSpread3, OpcodesBCH.OP_VERIF, reservedOperation), _defineProperty(_objectSpread3, OpcodesBCH.OP_VERNOTIF, reservedOperation), _defineProperty(_objectSpread3, OpcodesBCH.OP_ELSE, opElse), _defineProperty(_objectSpread3, OpcodesBCH.OP_ENDIF, opEndIf), _defineProperty(_objectSpread3, OpcodesBCH.OP_VERIFY, conditionallyEvaluate(opVerify)), _defineProperty(_objectSpread3, OpcodesBCH.OP_RETURN, conditionallyEvaluate(opReturn)), _defineProperty(_objectSpread3, OpcodesBCH.OP_TOALTSTACK, conditionallyEvaluate(opToAltStack)), _defineProperty(_objectSpread3, OpcodesBCH.OP_FROMALTSTACK, conditionallyEvaluate(opFromAltStack)), _defineProperty(_objectSpread3, OpcodesBCH.OP_2DROP, conditionallyEvaluate(op2Drop)), _defineProperty(_objectSpread3, OpcodesBCH.OP_2DUP, conditionallyEvaluate(op2Dup)), _defineProperty(_objectSpread3, OpcodesBCH.OP_3DUP, conditionallyEvaluate(op3Dup)), _defineProperty(_objectSpread3, OpcodesBCH.OP_2OVER, conditionallyEvaluate(op2Over)), _defineProperty(_objectSpread3, OpcodesBCH.OP_2ROT, conditionallyEvaluate(op2Rot)), _defineProperty(_objectSpread3, OpcodesBCH.OP_2SWAP, conditionallyEvaluate(op2Swap)), _defineProperty(_objectSpread3, OpcodesBCH.OP_IFDUP, conditionallyEvaluate(opIfDup)), _defineProperty(_objectSpread3, OpcodesBCH.OP_DEPTH, conditionallyEvaluate(opDepth)), _defineProperty(_objectSpread3, OpcodesBCH.OP_DROP, conditionallyEvaluate(opDrop)), _defineProperty(_objectSpread3, OpcodesBCH.OP_DUP, conditionallyEvaluate(opDup)), _defineProperty(_objectSpread3, OpcodesBCH.OP_NIP, conditionallyEvaluate(opNip)), _defineProperty(_objectSpread3, OpcodesBCH.OP_OVER, conditionallyEvaluate(opOver)), _defineProperty(_objectSpread3, OpcodesBCH.OP_PICK, conditionallyEvaluate(opPick)), _defineProperty(_objectSpread3, OpcodesBCH.OP_ROLL, conditionallyEvaluate(opRoll)), _defineProperty(_objectSpread3, OpcodesBCH.OP_ROT, conditionallyEvaluate(opRot)), _defineProperty(_objectSpread3, OpcodesBCH.OP_SWAP, conditionallyEvaluate(opSwap)), _defineProperty(_objectSpread3, OpcodesBCH.OP_TUCK, conditionallyEvaluate(opTuck)), _defineProperty(_objectSpread3, OpcodesBCH.OP_CAT, conditionallyEvaluate(opCat)), _defineProperty(_objectSpread3, OpcodesBCH.OP_SPLIT, conditionallyEvaluate(opSplit)), _defineProperty(_objectSpread3, OpcodesBCH.OP_NUM2BIN, conditionallyEvaluate(opNum2Bin)), _defineProperty(_objectSpread3, OpcodesBCH.OP_BIN2NUM, conditionallyEvaluate(opBin2Num)), _defineProperty(_objectSpread3, OpcodesBCH.OP_SIZE, conditionallyEvaluate(opSize)), _defineProperty(_objectSpread3, OpcodesBCH.OP_INVERT, disabledOperation), _defineProperty(_objectSpread3, OpcodesBCH.OP_AND, conditionallyEvaluate(opAnd)), _defineProperty(_objectSpread3, OpcodesBCH.OP_OR, conditionallyEvaluate(opOr)), _defineProperty(_objectSpread3, OpcodesBCH.OP_XOR, conditionallyEvaluate(opXor)), _defineProperty(_objectSpread3, OpcodesBCH.OP_EQUAL, conditionallyEvaluate(opEqual)), _defineProperty(_objectSpread3, OpcodesBCH.OP_EQUALVERIFY, conditionallyEvaluate(opEqualVerify)), _defineProperty(_objectSpread3, OpcodesBCH.OP_RESERVED1, conditionallyEvaluate(reservedOperation)), _defineProperty(_objectSpread3, OpcodesBCH.OP_RESERVED2, conditionallyEvaluate(reservedOperation)), _defineProperty(_objectSpread3, OpcodesBCH.OP_1ADD, conditionallyEvaluate(op1Add)), _defineProperty(_objectSpread3, OpcodesBCH.OP_1SUB, conditionallyEvaluate(op1Sub)), _defineProperty(_objectSpread3, OpcodesBCH.OP_2MUL, disabledOperation), _defineProperty(_objectSpread3, OpcodesBCH.OP_2DIV, disabledOperation), _defineProperty(_objectSpread3, OpcodesBCH.OP_NEGATE, conditionallyEvaluate(opNegate)), _defineProperty(_objectSpread3, OpcodesBCH.OP_ABS, conditionallyEvaluate(opAbs)), _defineProperty(_objectSpread3, OpcodesBCH.OP_NOT, conditionallyEvaluate(opNot)), _defineProperty(_objectSpread3, OpcodesBCH.OP_0NOTEQUAL, conditionallyEvaluate(op0NotEqual)), _defineProperty(_objectSpread3, OpcodesBCH.OP_ADD, conditionallyEvaluate(opAdd)), _defineProperty(_objectSpread3, OpcodesBCH.OP_SUB, conditionallyEvaluate(opSub)), _defineProperty(_objectSpread3, OpcodesBCH.OP_MUL, conditionallyEvaluate(opMul)), _defineProperty(_objectSpread3, OpcodesBCH.OP_DIV, conditionallyEvaluate(opDiv)), _defineProperty(_objectSpread3, OpcodesBCH.OP_MOD, conditionallyEvaluate(opMod)), _defineProperty(_objectSpread3, OpcodesBCH.OP_LSHIFT, disabledOperation), _defineProperty(_objectSpread3, OpcodesBCH.OP_RSHIFT, disabledOperation), _defineProperty(_objectSpread3, OpcodesBCH.OP_BOOLAND, conditionallyEvaluate(opBoolAnd)), _defineProperty(_objectSpread3, OpcodesBCH.OP_BOOLOR, conditionallyEvaluate(opBoolOr)), _defineProperty(_objectSpread3, OpcodesBCH.OP_NUMEQUAL, conditionallyEvaluate(opNumEqual)), _defineProperty(_objectSpread3, OpcodesBCH.OP_NUMEQUALVERIFY, conditionallyEvaluate(opNumEqualVerify)), _defineProperty(_objectSpread3, OpcodesBCH.OP_NUMNOTEQUAL, conditionallyEvaluate(opNumNotEqual)), _defineProperty(_objectSpread3, OpcodesBCH.OP_LESSTHAN, conditionallyEvaluate(opLessThan)), _defineProperty(_objectSpread3, OpcodesBCH.OP_GREATERTHAN, conditionallyEvaluate(opGreaterThan)), _defineProperty(_objectSpread3, OpcodesBCH.OP_LESSTHANOREQUAL, conditionallyEvaluate(opLessThanOrEqual)), _defineProperty(_objectSpread3, OpcodesBCH.OP_GREATERTHANOREQUAL, conditionallyEvaluate(opGreaterThanOrEqual)), _defineProperty(_objectSpread3, OpcodesBCH.OP_MIN, conditionallyEvaluate(opMin)), _defineProperty(_objectSpread3, OpcodesBCH.OP_MAX, conditionallyEvaluate(opMax)), _defineProperty(_objectSpread3, OpcodesBCH.OP_WITHIN, conditionallyEvaluate(opWithin)), _defineProperty(_objectSpread3, OpcodesBCH.OP_RIPEMD160, conditionallyEvaluate(opRipemd160({
      ripemd160: ripemd160
    }))), _defineProperty(_objectSpread3, OpcodesBCH.OP_SHA1, conditionallyEvaluate(opSha1({
      sha1: sha1
    }))), _defineProperty(_objectSpread3, OpcodesBCH.OP_SHA256, conditionallyEvaluate(opSha256({
      sha256: sha256
    }))), _defineProperty(_objectSpread3, OpcodesBCH.OP_HASH160, conditionallyEvaluate(opHash160({
      ripemd160: ripemd160,
      sha256: sha256
    }))), _defineProperty(_objectSpread3, OpcodesBCH.OP_HASH256, conditionallyEvaluate(opHash256({
      sha256: sha256
    }))), _defineProperty(_objectSpread3, OpcodesBCH.OP_CODESEPARATOR, conditionallyEvaluate(opCodeSeparator)), _defineProperty(_objectSpread3, OpcodesBCH.OP_CHECKSIG, conditionallyEvaluate(opCheckSig({
      secp256k1: secp256k1$1,
      sha256: sha256
    }))), _defineProperty(_objectSpread3, OpcodesBCH.OP_CHECKSIGVERIFY, conditionallyEvaluate(opCheckSigVerify({
      secp256k1: secp256k1$1,
      sha256: sha256
    }))), _defineProperty(_objectSpread3, OpcodesBCH.OP_CHECKMULTISIG, conditionallyEvaluate(opCheckMultiSig({
      secp256k1: secp256k1$1,
      sha256: sha256
    }))), _defineProperty(_objectSpread3, OpcodesBCH.OP_CHECKMULTISIGVERIFY, conditionallyEvaluate(opCheckMultiSigVerify({
      secp256k1: secp256k1$1,
      sha256: sha256
    }))), _objectSpread3), standard ? (_ref2 = {}, _defineProperty(_ref2, OpcodesBCH.OP_NOP1, conditionallyEvaluate(opNopDisallowed)), _defineProperty(_ref2, OpcodesBCH.OP_CHECKLOCKTIMEVERIFY, conditionallyEvaluate(opCheckLockTimeVerify)), _defineProperty(_ref2, OpcodesBCH.OP_CHECKSEQUENCEVERIFY, conditionallyEvaluate(opCheckSequenceVerify)), _defineProperty(_ref2, OpcodesBCH.OP_NOP4, conditionallyEvaluate(opNopDisallowed)), _defineProperty(_ref2, OpcodesBCH.OP_NOP5, conditionallyEvaluate(opNopDisallowed)), _defineProperty(_ref2, OpcodesBCH.OP_NOP6, conditionallyEvaluate(opNopDisallowed)), _defineProperty(_ref2, OpcodesBCH.OP_NOP7, conditionallyEvaluate(opNopDisallowed)), _defineProperty(_ref2, OpcodesBCH.OP_NOP8, conditionallyEvaluate(opNopDisallowed)), _defineProperty(_ref2, OpcodesBCH.OP_NOP9, conditionallyEvaluate(opNopDisallowed)), _defineProperty(_ref2, OpcodesBCH.OP_NOP10, conditionallyEvaluate(opNopDisallowed)), _ref2) : (_ref3 = {}, _defineProperty(_ref3, OpcodesBCH.OP_NOP1, conditionallyEvaluate(opNop)), _defineProperty(_ref3, OpcodesBCH.OP_CHECKLOCKTIMEVERIFY, conditionallyEvaluate(opCheckLockTimeVerify)), _defineProperty(_ref3, OpcodesBCH.OP_CHECKSEQUENCEVERIFY, conditionallyEvaluate(opCheckSequenceVerify)), _defineProperty(_ref3, OpcodesBCH.OP_NOP4, conditionallyEvaluate(opNop)), _defineProperty(_ref3, OpcodesBCH.OP_NOP5, conditionallyEvaluate(opNop)), _defineProperty(_ref3, OpcodesBCH.OP_NOP6, conditionallyEvaluate(opNop)), _defineProperty(_ref3, OpcodesBCH.OP_NOP7, conditionallyEvaluate(opNop)), _defineProperty(_ref3, OpcodesBCH.OP_NOP8, conditionallyEvaluate(opNop)), _defineProperty(_ref3, OpcodesBCH.OP_NOP9, conditionallyEvaluate(opNop)), _defineProperty(_ref3, OpcodesBCH.OP_NOP10, conditionallyEvaluate(opNop)), _ref3)), {}, (_objectSpread4 = {}, _defineProperty(_objectSpread4, OpcodesBCH.OP_CHECKDATASIG, conditionallyEvaluate(opCheckDataSig({
      secp256k1: secp256k1$1,
      sha256: sha256
    }))), _defineProperty(_objectSpread4, OpcodesBCH.OP_CHECKDATASIGVERIFY, conditionallyEvaluate(opCheckDataSigVerify({
      secp256k1: secp256k1$1,
      sha256: sha256
    }))), _defineProperty(_objectSpread4, OpcodesBCH.OP_REVERSEBYTES, conditionallyEvaluate(opReverseBytes)), _defineProperty(_objectSpread4, OpcodesBCH.OP_INPUTINDEX, conditionallyEvaluate(opInputIndex)), _defineProperty(_objectSpread4, OpcodesBCH.OP_ACTIVEBYTECODE, conditionallyEvaluate(opActiveBytecode)), _defineProperty(_objectSpread4, OpcodesBCH.OP_TXVERSION, conditionallyEvaluate(opTxVersion)), _defineProperty(_objectSpread4, OpcodesBCH.OP_TXINPUTCOUNT, conditionallyEvaluate(opTxInputCount)), _defineProperty(_objectSpread4, OpcodesBCH.OP_TXOUTPUTCOUNT, conditionallyEvaluate(opTxOutputCount)), _defineProperty(_objectSpread4, OpcodesBCH.OP_TXLOCKTIME, conditionallyEvaluate(opTxLocktime)), _defineProperty(_objectSpread4, OpcodesBCH.OP_UTXOVALUE, conditionallyEvaluate(opUtxoValue)), _defineProperty(_objectSpread4, OpcodesBCH.OP_UTXOBYTECODE, conditionallyEvaluate(opUtxoBytecode)), _defineProperty(_objectSpread4, OpcodesBCH.OP_OUTPOINTTXHASH, conditionallyEvaluate(opOutpointTxHash)), _defineProperty(_objectSpread4, OpcodesBCH.OP_OUTPOINTINDEX, conditionallyEvaluate(opOutpointIndex)), _defineProperty(_objectSpread4, OpcodesBCH.OP_INPUTBYTECODE, conditionallyEvaluate(opInputBytecode)), _defineProperty(_objectSpread4, OpcodesBCH.OP_INPUTSEQUENCENUMBER, conditionallyEvaluate(opInputSequenceNumber)), _defineProperty(_objectSpread4, OpcodesBCH.OP_OUTPUTVALUE, conditionallyEvaluate(opOutputValue)), _defineProperty(_objectSpread4, OpcodesBCH.OP_OUTPUTBYTECODE, conditionallyEvaluate(opOutputBytecode)), _objectSpread4)))),
    success: function success(state) {
      if (state.error !== undefined) {
        return state.error;
      }
      if (state.controlStack.length !== 0) {
        return AuthenticationErrorCommon.nonEmptyControlStack;
      }
      if (state.stack.length !== 1) {
        return AuthenticationErrorCommon.requiresCleanStack;
      }
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      if (!stackItemIsTruthy(state.stack[0])) {
        return AuthenticationErrorCommon.unsuccessfulEvaluation;
      }
      return true;
    },
    undefined: undefinedOperation,
    // eslint-disable-next-line complexity
    verify: function verify(_ref4, evaluate, stateSuccess) {
      var sourceOutputs = _ref4.sourceOutputs,
        transaction = _ref4.transaction;
      if (transaction.inputs.length === 0) {
        return 'Transactions must have at least one input.';
      }
      if (transaction.outputs.length === 0) {
        return 'Transactions must have at least one output.';
      }
      if (transaction.inputs.length !== sourceOutputs.length) {
        return 'Unable to verify transaction: a single spent output must be provided for each transaction input.';
      }
      var transactionSize = encodeTransactionBCH(transaction).length;
      if (transactionSize < ConsensusBCH.minimumTransactionSize) {
        return "Transaction does not meet minimum size: the transaction is ".concat(transactionSize, " bytes, but the minimum transaction size is ").concat(ConsensusBCH.minimumTransactionSize, " bytes.");
      }
      if (transactionSize > ConsensusBCH.maximumTransactionSize) {
        return "Transaction exceeds maximum size: the transaction is ".concat(transactionSize, " bytes, but the maximum transaction size is ").concat(ConsensusBCH.maximumTransactionSize, " bytes.");
      }
      if (standard) {
        if (transaction.version < 1 || transaction.version > ConsensusBCH.maximumStandardVersion) {
          return "Standard transactions must have a version no less than 1 and no greater than ".concat(ConsensusBCH.maximumStandardVersion, ".");
        }
        if (transactionSize > ConsensusBCH.maximumStandardTransactionSize) {
          return "Transaction exceeds maximum standard size: this transaction is ".concat(transactionSize, " bytes, but the maximum standard transaction size is ").concat(ConsensusBCH.maximumStandardTransactionSize, " bytes.");
        }
        // eslint-disable-next-line functional/no-loop-statement
        var _iterator = _createForOfIteratorHelper(sourceOutputs.entries()),
          _step;
        try {
          for (_iterator.s(); !(_step = _iterator.n()).done;) {
            var _step$value = _slicedToArray(_step.value, 2),
              index = _step$value[0],
              output = _step$value[1];
            if (!isStandardOutputBytecode(output.lockingBytecode)) {
              return "Standard transactions may only spend standard output types, but source output ".concat(index, " is non-standard.");
            }
          }
          // eslint-disable-next-line functional/no-let
        } catch (err) {
          _iterator.e(err);
        } finally {
          _iterator.f();
        }
        var totalArbitraryDataBytes = 0;
        // eslint-disable-next-line functional/no-loop-statement
        var _iterator2 = _createForOfIteratorHelper(transaction.outputs.entries()),
          _step2;
        try {
          for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
            var _step2$value = _slicedToArray(_step2.value, 2),
              _index = _step2$value[0],
              _output = _step2$value[1];
            if (!isStandardOutputBytecode(_output.lockingBytecode)) {
              return "Standard transactions may only create standard output types, but transaction output ".concat(_index, " is non-standard.");
            }
            // eslint-disable-next-line functional/no-conditional-statement
            if (isArbitraryDataOutput(_output.lockingBytecode)) {
              // eslint-disable-next-line functional/no-expression-statement
              totalArbitraryDataBytes += _output.lockingBytecode.length + 1;
            }
            /*
             * TODO: disallow dust outputs
             * if(IsDustOutput(output)) {
             *   return ``;
             * }
             */
          }
        } catch (err) {
          _iterator2.e(err);
        } finally {
          _iterator2.f();
        }
        if (totalArbitraryDataBytes > ConsensusBCH.maximumDataCarrierBytes) {
          return "Standard transactions may carry no more than ".concat(ConsensusBCH.maximumDataCarrierBytes, " bytes in arbitrary data outputs; this transaction includes ").concat(totalArbitraryDataBytes, " bytes of arbitrary data.");
        }
        // eslint-disable-next-line functional/no-loop-statement
        var _iterator3 = _createForOfIteratorHelper(transaction.inputs.entries()),
          _step3;
        try {
          for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
            var _step3$value = _slicedToArray(_step3.value, 2),
              _index2 = _step3$value[0],
              input = _step3$value[1];
            if (input.unlockingBytecode.length > ConsensusBCH.maximumStandardUnlockingBytecodeLength) {
              return "Input index ".concat(_index2, " is non-standard: the unlocking bytecode (").concat(input.unlockingBytecode.length, " bytes) exceeds the maximum standard unlocking bytecode length (").concat(ConsensusBCH.maximumStandardUnlockingBytecodeLength, " bytes).");
            }
            if (!isPushOnly(input.unlockingBytecode)) {
              return "Input index ".concat(_index2, " is non-standard: unlocking bytecode may contain only push operations.");
            }
          }
        } catch (err) {
          _iterator3.e(err);
        } finally {
          _iterator3.f();
        }
      }
      // eslint-disable-next-line functional/no-loop-statement
      var _iterator4 = _createForOfIteratorHelper(transaction.inputs.keys()),
        _step4;
      try {
        for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {
          var _index3 = _step4.value;
          var state = evaluate({
            inputIndex: _index3,
            sourceOutputs: sourceOutputs,
            transaction: transaction
          });
          var result = stateSuccess(state);
          if (typeof result === 'string') {
            return "Error in evaluating input index ".concat(_index3, ": ").concat(result);
          }
        }
      } catch (err) {
        _iterator4.e(err);
      } finally {
        _iterator4.f();
      }
      return true;
    }
  };
};

/**
 * The `BCH_2022_05` instruction set.
 */
var OpcodesBCH2022;
(function (OpcodesBCH2022) {
  /**
   * A.K.A. `OP_FALSE` or `OP_PUSHBYTES_0`
   */
  OpcodesBCH2022[OpcodesBCH2022["OP_0"] = 0] = "OP_0";
  OpcodesBCH2022[OpcodesBCH2022["OP_PUSHBYTES_1"] = 1] = "OP_PUSHBYTES_1";
  OpcodesBCH2022[OpcodesBCH2022["OP_PUSHBYTES_2"] = 2] = "OP_PUSHBYTES_2";
  OpcodesBCH2022[OpcodesBCH2022["OP_PUSHBYTES_3"] = 3] = "OP_PUSHBYTES_3";
  OpcodesBCH2022[OpcodesBCH2022["OP_PUSHBYTES_4"] = 4] = "OP_PUSHBYTES_4";
  OpcodesBCH2022[OpcodesBCH2022["OP_PUSHBYTES_5"] = 5] = "OP_PUSHBYTES_5";
  OpcodesBCH2022[OpcodesBCH2022["OP_PUSHBYTES_6"] = 6] = "OP_PUSHBYTES_6";
  OpcodesBCH2022[OpcodesBCH2022["OP_PUSHBYTES_7"] = 7] = "OP_PUSHBYTES_7";
  OpcodesBCH2022[OpcodesBCH2022["OP_PUSHBYTES_8"] = 8] = "OP_PUSHBYTES_8";
  OpcodesBCH2022[OpcodesBCH2022["OP_PUSHBYTES_9"] = 9] = "OP_PUSHBYTES_9";
  OpcodesBCH2022[OpcodesBCH2022["OP_PUSHBYTES_10"] = 10] = "OP_PUSHBYTES_10";
  OpcodesBCH2022[OpcodesBCH2022["OP_PUSHBYTES_11"] = 11] = "OP_PUSHBYTES_11";
  OpcodesBCH2022[OpcodesBCH2022["OP_PUSHBYTES_12"] = 12] = "OP_PUSHBYTES_12";
  OpcodesBCH2022[OpcodesBCH2022["OP_PUSHBYTES_13"] = 13] = "OP_PUSHBYTES_13";
  OpcodesBCH2022[OpcodesBCH2022["OP_PUSHBYTES_14"] = 14] = "OP_PUSHBYTES_14";
  OpcodesBCH2022[OpcodesBCH2022["OP_PUSHBYTES_15"] = 15] = "OP_PUSHBYTES_15";
  OpcodesBCH2022[OpcodesBCH2022["OP_PUSHBYTES_16"] = 16] = "OP_PUSHBYTES_16";
  OpcodesBCH2022[OpcodesBCH2022["OP_PUSHBYTES_17"] = 17] = "OP_PUSHBYTES_17";
  OpcodesBCH2022[OpcodesBCH2022["OP_PUSHBYTES_18"] = 18] = "OP_PUSHBYTES_18";
  OpcodesBCH2022[OpcodesBCH2022["OP_PUSHBYTES_19"] = 19] = "OP_PUSHBYTES_19";
  OpcodesBCH2022[OpcodesBCH2022["OP_PUSHBYTES_20"] = 20] = "OP_PUSHBYTES_20";
  OpcodesBCH2022[OpcodesBCH2022["OP_PUSHBYTES_21"] = 21] = "OP_PUSHBYTES_21";
  OpcodesBCH2022[OpcodesBCH2022["OP_PUSHBYTES_22"] = 22] = "OP_PUSHBYTES_22";
  OpcodesBCH2022[OpcodesBCH2022["OP_PUSHBYTES_23"] = 23] = "OP_PUSHBYTES_23";
  OpcodesBCH2022[OpcodesBCH2022["OP_PUSHBYTES_24"] = 24] = "OP_PUSHBYTES_24";
  OpcodesBCH2022[OpcodesBCH2022["OP_PUSHBYTES_25"] = 25] = "OP_PUSHBYTES_25";
  OpcodesBCH2022[OpcodesBCH2022["OP_PUSHBYTES_26"] = 26] = "OP_PUSHBYTES_26";
  OpcodesBCH2022[OpcodesBCH2022["OP_PUSHBYTES_27"] = 27] = "OP_PUSHBYTES_27";
  OpcodesBCH2022[OpcodesBCH2022["OP_PUSHBYTES_28"] = 28] = "OP_PUSHBYTES_28";
  OpcodesBCH2022[OpcodesBCH2022["OP_PUSHBYTES_29"] = 29] = "OP_PUSHBYTES_29";
  OpcodesBCH2022[OpcodesBCH2022["OP_PUSHBYTES_30"] = 30] = "OP_PUSHBYTES_30";
  OpcodesBCH2022[OpcodesBCH2022["OP_PUSHBYTES_31"] = 31] = "OP_PUSHBYTES_31";
  OpcodesBCH2022[OpcodesBCH2022["OP_PUSHBYTES_32"] = 32] = "OP_PUSHBYTES_32";
  OpcodesBCH2022[OpcodesBCH2022["OP_PUSHBYTES_33"] = 33] = "OP_PUSHBYTES_33";
  OpcodesBCH2022[OpcodesBCH2022["OP_PUSHBYTES_34"] = 34] = "OP_PUSHBYTES_34";
  OpcodesBCH2022[OpcodesBCH2022["OP_PUSHBYTES_35"] = 35] = "OP_PUSHBYTES_35";
  OpcodesBCH2022[OpcodesBCH2022["OP_PUSHBYTES_36"] = 36] = "OP_PUSHBYTES_36";
  OpcodesBCH2022[OpcodesBCH2022["OP_PUSHBYTES_37"] = 37] = "OP_PUSHBYTES_37";
  OpcodesBCH2022[OpcodesBCH2022["OP_PUSHBYTES_38"] = 38] = "OP_PUSHBYTES_38";
  OpcodesBCH2022[OpcodesBCH2022["OP_PUSHBYTES_39"] = 39] = "OP_PUSHBYTES_39";
  OpcodesBCH2022[OpcodesBCH2022["OP_PUSHBYTES_40"] = 40] = "OP_PUSHBYTES_40";
  OpcodesBCH2022[OpcodesBCH2022["OP_PUSHBYTES_41"] = 41] = "OP_PUSHBYTES_41";
  OpcodesBCH2022[OpcodesBCH2022["OP_PUSHBYTES_42"] = 42] = "OP_PUSHBYTES_42";
  OpcodesBCH2022[OpcodesBCH2022["OP_PUSHBYTES_43"] = 43] = "OP_PUSHBYTES_43";
  OpcodesBCH2022[OpcodesBCH2022["OP_PUSHBYTES_44"] = 44] = "OP_PUSHBYTES_44";
  OpcodesBCH2022[OpcodesBCH2022["OP_PUSHBYTES_45"] = 45] = "OP_PUSHBYTES_45";
  OpcodesBCH2022[OpcodesBCH2022["OP_PUSHBYTES_46"] = 46] = "OP_PUSHBYTES_46";
  OpcodesBCH2022[OpcodesBCH2022["OP_PUSHBYTES_47"] = 47] = "OP_PUSHBYTES_47";
  OpcodesBCH2022[OpcodesBCH2022["OP_PUSHBYTES_48"] = 48] = "OP_PUSHBYTES_48";
  OpcodesBCH2022[OpcodesBCH2022["OP_PUSHBYTES_49"] = 49] = "OP_PUSHBYTES_49";
  OpcodesBCH2022[OpcodesBCH2022["OP_PUSHBYTES_50"] = 50] = "OP_PUSHBYTES_50";
  OpcodesBCH2022[OpcodesBCH2022["OP_PUSHBYTES_51"] = 51] = "OP_PUSHBYTES_51";
  OpcodesBCH2022[OpcodesBCH2022["OP_PUSHBYTES_52"] = 52] = "OP_PUSHBYTES_52";
  OpcodesBCH2022[OpcodesBCH2022["OP_PUSHBYTES_53"] = 53] = "OP_PUSHBYTES_53";
  OpcodesBCH2022[OpcodesBCH2022["OP_PUSHBYTES_54"] = 54] = "OP_PUSHBYTES_54";
  OpcodesBCH2022[OpcodesBCH2022["OP_PUSHBYTES_55"] = 55] = "OP_PUSHBYTES_55";
  OpcodesBCH2022[OpcodesBCH2022["OP_PUSHBYTES_56"] = 56] = "OP_PUSHBYTES_56";
  OpcodesBCH2022[OpcodesBCH2022["OP_PUSHBYTES_57"] = 57] = "OP_PUSHBYTES_57";
  OpcodesBCH2022[OpcodesBCH2022["OP_PUSHBYTES_58"] = 58] = "OP_PUSHBYTES_58";
  OpcodesBCH2022[OpcodesBCH2022["OP_PUSHBYTES_59"] = 59] = "OP_PUSHBYTES_59";
  OpcodesBCH2022[OpcodesBCH2022["OP_PUSHBYTES_60"] = 60] = "OP_PUSHBYTES_60";
  OpcodesBCH2022[OpcodesBCH2022["OP_PUSHBYTES_61"] = 61] = "OP_PUSHBYTES_61";
  OpcodesBCH2022[OpcodesBCH2022["OP_PUSHBYTES_62"] = 62] = "OP_PUSHBYTES_62";
  OpcodesBCH2022[OpcodesBCH2022["OP_PUSHBYTES_63"] = 63] = "OP_PUSHBYTES_63";
  OpcodesBCH2022[OpcodesBCH2022["OP_PUSHBYTES_64"] = 64] = "OP_PUSHBYTES_64";
  OpcodesBCH2022[OpcodesBCH2022["OP_PUSHBYTES_65"] = 65] = "OP_PUSHBYTES_65";
  OpcodesBCH2022[OpcodesBCH2022["OP_PUSHBYTES_66"] = 66] = "OP_PUSHBYTES_66";
  OpcodesBCH2022[OpcodesBCH2022["OP_PUSHBYTES_67"] = 67] = "OP_PUSHBYTES_67";
  OpcodesBCH2022[OpcodesBCH2022["OP_PUSHBYTES_68"] = 68] = "OP_PUSHBYTES_68";
  OpcodesBCH2022[OpcodesBCH2022["OP_PUSHBYTES_69"] = 69] = "OP_PUSHBYTES_69";
  OpcodesBCH2022[OpcodesBCH2022["OP_PUSHBYTES_70"] = 70] = "OP_PUSHBYTES_70";
  OpcodesBCH2022[OpcodesBCH2022["OP_PUSHBYTES_71"] = 71] = "OP_PUSHBYTES_71";
  OpcodesBCH2022[OpcodesBCH2022["OP_PUSHBYTES_72"] = 72] = "OP_PUSHBYTES_72";
  OpcodesBCH2022[OpcodesBCH2022["OP_PUSHBYTES_73"] = 73] = "OP_PUSHBYTES_73";
  OpcodesBCH2022[OpcodesBCH2022["OP_PUSHBYTES_74"] = 74] = "OP_PUSHBYTES_74";
  OpcodesBCH2022[OpcodesBCH2022["OP_PUSHBYTES_75"] = 75] = "OP_PUSHBYTES_75";
  OpcodesBCH2022[OpcodesBCH2022["OP_PUSHDATA_1"] = 76] = "OP_PUSHDATA_1";
  OpcodesBCH2022[OpcodesBCH2022["OP_PUSHDATA_2"] = 77] = "OP_PUSHDATA_2";
  OpcodesBCH2022[OpcodesBCH2022["OP_PUSHDATA_4"] = 78] = "OP_PUSHDATA_4";
  OpcodesBCH2022[OpcodesBCH2022["OP_1NEGATE"] = 79] = "OP_1NEGATE";
  OpcodesBCH2022[OpcodesBCH2022["OP_RESERVED"] = 80] = "OP_RESERVED";
  /**
   * A.K.A. `OP_TRUE`
   */
  OpcodesBCH2022[OpcodesBCH2022["OP_1"] = 81] = "OP_1";
  OpcodesBCH2022[OpcodesBCH2022["OP_2"] = 82] = "OP_2";
  OpcodesBCH2022[OpcodesBCH2022["OP_3"] = 83] = "OP_3";
  OpcodesBCH2022[OpcodesBCH2022["OP_4"] = 84] = "OP_4";
  OpcodesBCH2022[OpcodesBCH2022["OP_5"] = 85] = "OP_5";
  OpcodesBCH2022[OpcodesBCH2022["OP_6"] = 86] = "OP_6";
  OpcodesBCH2022[OpcodesBCH2022["OP_7"] = 87] = "OP_7";
  OpcodesBCH2022[OpcodesBCH2022["OP_8"] = 88] = "OP_8";
  OpcodesBCH2022[OpcodesBCH2022["OP_9"] = 89] = "OP_9";
  OpcodesBCH2022[OpcodesBCH2022["OP_10"] = 90] = "OP_10";
  OpcodesBCH2022[OpcodesBCH2022["OP_11"] = 91] = "OP_11";
  OpcodesBCH2022[OpcodesBCH2022["OP_12"] = 92] = "OP_12";
  OpcodesBCH2022[OpcodesBCH2022["OP_13"] = 93] = "OP_13";
  OpcodesBCH2022[OpcodesBCH2022["OP_14"] = 94] = "OP_14";
  OpcodesBCH2022[OpcodesBCH2022["OP_15"] = 95] = "OP_15";
  OpcodesBCH2022[OpcodesBCH2022["OP_16"] = 96] = "OP_16";
  OpcodesBCH2022[OpcodesBCH2022["OP_NOP"] = 97] = "OP_NOP";
  OpcodesBCH2022[OpcodesBCH2022["OP_VER"] = 98] = "OP_VER";
  OpcodesBCH2022[OpcodesBCH2022["OP_IF"] = 99] = "OP_IF";
  OpcodesBCH2022[OpcodesBCH2022["OP_NOTIF"] = 100] = "OP_NOTIF";
  OpcodesBCH2022[OpcodesBCH2022["OP_VERIF"] = 101] = "OP_VERIF";
  OpcodesBCH2022[OpcodesBCH2022["OP_VERNOTIF"] = 102] = "OP_VERNOTIF";
  OpcodesBCH2022[OpcodesBCH2022["OP_ELSE"] = 103] = "OP_ELSE";
  OpcodesBCH2022[OpcodesBCH2022["OP_ENDIF"] = 104] = "OP_ENDIF";
  OpcodesBCH2022[OpcodesBCH2022["OP_VERIFY"] = 105] = "OP_VERIFY";
  OpcodesBCH2022[OpcodesBCH2022["OP_RETURN"] = 106] = "OP_RETURN";
  OpcodesBCH2022[OpcodesBCH2022["OP_TOALTSTACK"] = 107] = "OP_TOALTSTACK";
  OpcodesBCH2022[OpcodesBCH2022["OP_FROMALTSTACK"] = 108] = "OP_FROMALTSTACK";
  OpcodesBCH2022[OpcodesBCH2022["OP_2DROP"] = 109] = "OP_2DROP";
  OpcodesBCH2022[OpcodesBCH2022["OP_2DUP"] = 110] = "OP_2DUP";
  OpcodesBCH2022[OpcodesBCH2022["OP_3DUP"] = 111] = "OP_3DUP";
  OpcodesBCH2022[OpcodesBCH2022["OP_2OVER"] = 112] = "OP_2OVER";
  OpcodesBCH2022[OpcodesBCH2022["OP_2ROT"] = 113] = "OP_2ROT";
  OpcodesBCH2022[OpcodesBCH2022["OP_2SWAP"] = 114] = "OP_2SWAP";
  OpcodesBCH2022[OpcodesBCH2022["OP_IFDUP"] = 115] = "OP_IFDUP";
  OpcodesBCH2022[OpcodesBCH2022["OP_DEPTH"] = 116] = "OP_DEPTH";
  OpcodesBCH2022[OpcodesBCH2022["OP_DROP"] = 117] = "OP_DROP";
  OpcodesBCH2022[OpcodesBCH2022["OP_DUP"] = 118] = "OP_DUP";
  OpcodesBCH2022[OpcodesBCH2022["OP_NIP"] = 119] = "OP_NIP";
  OpcodesBCH2022[OpcodesBCH2022["OP_OVER"] = 120] = "OP_OVER";
  OpcodesBCH2022[OpcodesBCH2022["OP_PICK"] = 121] = "OP_PICK";
  OpcodesBCH2022[OpcodesBCH2022["OP_ROLL"] = 122] = "OP_ROLL";
  OpcodesBCH2022[OpcodesBCH2022["OP_ROT"] = 123] = "OP_ROT";
  OpcodesBCH2022[OpcodesBCH2022["OP_SWAP"] = 124] = "OP_SWAP";
  OpcodesBCH2022[OpcodesBCH2022["OP_TUCK"] = 125] = "OP_TUCK";
  OpcodesBCH2022[OpcodesBCH2022["OP_CAT"] = 126] = "OP_CAT";
  OpcodesBCH2022[OpcodesBCH2022["OP_SPLIT"] = 127] = "OP_SPLIT";
  OpcodesBCH2022[OpcodesBCH2022["OP_NUM2BIN"] = 128] = "OP_NUM2BIN";
  OpcodesBCH2022[OpcodesBCH2022["OP_BIN2NUM"] = 129] = "OP_BIN2NUM";
  OpcodesBCH2022[OpcodesBCH2022["OP_SIZE"] = 130] = "OP_SIZE";
  OpcodesBCH2022[OpcodesBCH2022["OP_INVERT"] = 131] = "OP_INVERT";
  OpcodesBCH2022[OpcodesBCH2022["OP_AND"] = 132] = "OP_AND";
  OpcodesBCH2022[OpcodesBCH2022["OP_OR"] = 133] = "OP_OR";
  OpcodesBCH2022[OpcodesBCH2022["OP_XOR"] = 134] = "OP_XOR";
  OpcodesBCH2022[OpcodesBCH2022["OP_EQUAL"] = 135] = "OP_EQUAL";
  OpcodesBCH2022[OpcodesBCH2022["OP_EQUALVERIFY"] = 136] = "OP_EQUALVERIFY";
  OpcodesBCH2022[OpcodesBCH2022["OP_RESERVED1"] = 137] = "OP_RESERVED1";
  OpcodesBCH2022[OpcodesBCH2022["OP_RESERVED2"] = 138] = "OP_RESERVED2";
  OpcodesBCH2022[OpcodesBCH2022["OP_1ADD"] = 139] = "OP_1ADD";
  OpcodesBCH2022[OpcodesBCH2022["OP_1SUB"] = 140] = "OP_1SUB";
  OpcodesBCH2022[OpcodesBCH2022["OP_2MUL"] = 141] = "OP_2MUL";
  OpcodesBCH2022[OpcodesBCH2022["OP_2DIV"] = 142] = "OP_2DIV";
  OpcodesBCH2022[OpcodesBCH2022["OP_NEGATE"] = 143] = "OP_NEGATE";
  OpcodesBCH2022[OpcodesBCH2022["OP_ABS"] = 144] = "OP_ABS";
  OpcodesBCH2022[OpcodesBCH2022["OP_NOT"] = 145] = "OP_NOT";
  OpcodesBCH2022[OpcodesBCH2022["OP_0NOTEQUAL"] = 146] = "OP_0NOTEQUAL";
  OpcodesBCH2022[OpcodesBCH2022["OP_ADD"] = 147] = "OP_ADD";
  OpcodesBCH2022[OpcodesBCH2022["OP_SUB"] = 148] = "OP_SUB";
  OpcodesBCH2022[OpcodesBCH2022["OP_MUL"] = 149] = "OP_MUL";
  OpcodesBCH2022[OpcodesBCH2022["OP_DIV"] = 150] = "OP_DIV";
  OpcodesBCH2022[OpcodesBCH2022["OP_MOD"] = 151] = "OP_MOD";
  OpcodesBCH2022[OpcodesBCH2022["OP_LSHIFT"] = 152] = "OP_LSHIFT";
  OpcodesBCH2022[OpcodesBCH2022["OP_RSHIFT"] = 153] = "OP_RSHIFT";
  OpcodesBCH2022[OpcodesBCH2022["OP_BOOLAND"] = 154] = "OP_BOOLAND";
  OpcodesBCH2022[OpcodesBCH2022["OP_BOOLOR"] = 155] = "OP_BOOLOR";
  OpcodesBCH2022[OpcodesBCH2022["OP_NUMEQUAL"] = 156] = "OP_NUMEQUAL";
  OpcodesBCH2022[OpcodesBCH2022["OP_NUMEQUALVERIFY"] = 157] = "OP_NUMEQUALVERIFY";
  OpcodesBCH2022[OpcodesBCH2022["OP_NUMNOTEQUAL"] = 158] = "OP_NUMNOTEQUAL";
  OpcodesBCH2022[OpcodesBCH2022["OP_LESSTHAN"] = 159] = "OP_LESSTHAN";
  OpcodesBCH2022[OpcodesBCH2022["OP_GREATERTHAN"] = 160] = "OP_GREATERTHAN";
  OpcodesBCH2022[OpcodesBCH2022["OP_LESSTHANOREQUAL"] = 161] = "OP_LESSTHANOREQUAL";
  OpcodesBCH2022[OpcodesBCH2022["OP_GREATERTHANOREQUAL"] = 162] = "OP_GREATERTHANOREQUAL";
  OpcodesBCH2022[OpcodesBCH2022["OP_MIN"] = 163] = "OP_MIN";
  OpcodesBCH2022[OpcodesBCH2022["OP_MAX"] = 164] = "OP_MAX";
  OpcodesBCH2022[OpcodesBCH2022["OP_WITHIN"] = 165] = "OP_WITHIN";
  OpcodesBCH2022[OpcodesBCH2022["OP_RIPEMD160"] = 166] = "OP_RIPEMD160";
  OpcodesBCH2022[OpcodesBCH2022["OP_SHA1"] = 167] = "OP_SHA1";
  OpcodesBCH2022[OpcodesBCH2022["OP_SHA256"] = 168] = "OP_SHA256";
  OpcodesBCH2022[OpcodesBCH2022["OP_HASH160"] = 169] = "OP_HASH160";
  OpcodesBCH2022[OpcodesBCH2022["OP_HASH256"] = 170] = "OP_HASH256";
  OpcodesBCH2022[OpcodesBCH2022["OP_CODESEPARATOR"] = 171] = "OP_CODESEPARATOR";
  OpcodesBCH2022[OpcodesBCH2022["OP_CHECKSIG"] = 172] = "OP_CHECKSIG";
  OpcodesBCH2022[OpcodesBCH2022["OP_CHECKSIGVERIFY"] = 173] = "OP_CHECKSIGVERIFY";
  OpcodesBCH2022[OpcodesBCH2022["OP_CHECKMULTISIG"] = 174] = "OP_CHECKMULTISIG";
  OpcodesBCH2022[OpcodesBCH2022["OP_CHECKMULTISIGVERIFY"] = 175] = "OP_CHECKMULTISIGVERIFY";
  OpcodesBCH2022[OpcodesBCH2022["OP_NOP1"] = 176] = "OP_NOP1";
  OpcodesBCH2022[OpcodesBCH2022["OP_CHECKLOCKTIMEVERIFY"] = 177] = "OP_CHECKLOCKTIMEVERIFY";
  OpcodesBCH2022[OpcodesBCH2022["OP_CHECKSEQUENCEVERIFY"] = 178] = "OP_CHECKSEQUENCEVERIFY";
  OpcodesBCH2022[OpcodesBCH2022["OP_NOP4"] = 179] = "OP_NOP4";
  OpcodesBCH2022[OpcodesBCH2022["OP_NOP5"] = 180] = "OP_NOP5";
  OpcodesBCH2022[OpcodesBCH2022["OP_NOP6"] = 181] = "OP_NOP6";
  OpcodesBCH2022[OpcodesBCH2022["OP_NOP7"] = 182] = "OP_NOP7";
  OpcodesBCH2022[OpcodesBCH2022["OP_NOP8"] = 183] = "OP_NOP8";
  OpcodesBCH2022[OpcodesBCH2022["OP_NOP9"] = 184] = "OP_NOP9";
  OpcodesBCH2022[OpcodesBCH2022["OP_NOP10"] = 185] = "OP_NOP10";
  OpcodesBCH2022[OpcodesBCH2022["OP_CHECKDATASIG"] = 186] = "OP_CHECKDATASIG";
  OpcodesBCH2022[OpcodesBCH2022["OP_CHECKDATASIGVERIFY"] = 187] = "OP_CHECKDATASIGVERIFY";
  OpcodesBCH2022[OpcodesBCH2022["OP_REVERSEBYTES"] = 188] = "OP_REVERSEBYTES";
  /**
   * First codepoint left undefined before nullary introspection operations.
   */
  OpcodesBCH2022[OpcodesBCH2022["OP_UNKNOWN189"] = 189] = "OP_UNKNOWN189";
  OpcodesBCH2022[OpcodesBCH2022["OP_UNKNOWN190"] = 190] = "OP_UNKNOWN190";
  /**
   * Last codepoint left undefined before nullary introspection operations.
   */
  OpcodesBCH2022[OpcodesBCH2022["OP_UNKNOWN191"] = 191] = "OP_UNKNOWN191";
  OpcodesBCH2022[OpcodesBCH2022["OP_INPUTINDEX"] = 192] = "OP_INPUTINDEX";
  OpcodesBCH2022[OpcodesBCH2022["OP_ACTIVEBYTECODE"] = 193] = "OP_ACTIVEBYTECODE";
  OpcodesBCH2022[OpcodesBCH2022["OP_TXVERSION"] = 194] = "OP_TXVERSION";
  OpcodesBCH2022[OpcodesBCH2022["OP_TXINPUTCOUNT"] = 195] = "OP_TXINPUTCOUNT";
  OpcodesBCH2022[OpcodesBCH2022["OP_TXOUTPUTCOUNT"] = 196] = "OP_TXOUTPUTCOUNT";
  OpcodesBCH2022[OpcodesBCH2022["OP_TXLOCKTIME"] = 197] = "OP_TXLOCKTIME";
  OpcodesBCH2022[OpcodesBCH2022["OP_UTXOVALUE"] = 198] = "OP_UTXOVALUE";
  OpcodesBCH2022[OpcodesBCH2022["OP_UTXOBYTECODE"] = 199] = "OP_UTXOBYTECODE";
  OpcodesBCH2022[OpcodesBCH2022["OP_OUTPOINTTXHASH"] = 200] = "OP_OUTPOINTTXHASH";
  OpcodesBCH2022[OpcodesBCH2022["OP_OUTPOINTINDEX"] = 201] = "OP_OUTPOINTINDEX";
  OpcodesBCH2022[OpcodesBCH2022["OP_INPUTBYTECODE"] = 202] = "OP_INPUTBYTECODE";
  OpcodesBCH2022[OpcodesBCH2022["OP_INPUTSEQUENCENUMBER"] = 203] = "OP_INPUTSEQUENCENUMBER";
  OpcodesBCH2022[OpcodesBCH2022["OP_OUTPUTVALUE"] = 204] = "OP_OUTPUTVALUE";
  OpcodesBCH2022[OpcodesBCH2022["OP_OUTPUTBYTECODE"] = 205] = "OP_OUTPUTBYTECODE";
  /**
   * Reserved for unary introspection operations.
   */
  OpcodesBCH2022[OpcodesBCH2022["OP_RESERVED3"] = 206] = "OP_RESERVED3";
  /**
   * Reserved for unary introspection operations.
   */
  OpcodesBCH2022[OpcodesBCH2022["OP_RESERVED4"] = 207] = "OP_RESERVED4";
  OpcodesBCH2022[OpcodesBCH2022["OP_UNKNOWN208"] = 208] = "OP_UNKNOWN208";
  OpcodesBCH2022[OpcodesBCH2022["OP_UNKNOWN209"] = 209] = "OP_UNKNOWN209";
  OpcodesBCH2022[OpcodesBCH2022["OP_UNKNOWN210"] = 210] = "OP_UNKNOWN210";
  OpcodesBCH2022[OpcodesBCH2022["OP_UNKNOWN211"] = 211] = "OP_UNKNOWN211";
  OpcodesBCH2022[OpcodesBCH2022["OP_UNKNOWN212"] = 212] = "OP_UNKNOWN212";
  OpcodesBCH2022[OpcodesBCH2022["OP_UNKNOWN213"] = 213] = "OP_UNKNOWN213";
  OpcodesBCH2022[OpcodesBCH2022["OP_UNKNOWN214"] = 214] = "OP_UNKNOWN214";
  OpcodesBCH2022[OpcodesBCH2022["OP_UNKNOWN215"] = 215] = "OP_UNKNOWN215";
  OpcodesBCH2022[OpcodesBCH2022["OP_UNKNOWN216"] = 216] = "OP_UNKNOWN216";
  OpcodesBCH2022[OpcodesBCH2022["OP_UNKNOWN217"] = 217] = "OP_UNKNOWN217";
  OpcodesBCH2022[OpcodesBCH2022["OP_UNKNOWN218"] = 218] = "OP_UNKNOWN218";
  OpcodesBCH2022[OpcodesBCH2022["OP_UNKNOWN219"] = 219] = "OP_UNKNOWN219";
  OpcodesBCH2022[OpcodesBCH2022["OP_UNKNOWN220"] = 220] = "OP_UNKNOWN220";
  OpcodesBCH2022[OpcodesBCH2022["OP_UNKNOWN221"] = 221] = "OP_UNKNOWN221";
  OpcodesBCH2022[OpcodesBCH2022["OP_UNKNOWN222"] = 222] = "OP_UNKNOWN222";
  OpcodesBCH2022[OpcodesBCH2022["OP_UNKNOWN223"] = 223] = "OP_UNKNOWN223";
  OpcodesBCH2022[OpcodesBCH2022["OP_UNKNOWN224"] = 224] = "OP_UNKNOWN224";
  OpcodesBCH2022[OpcodesBCH2022["OP_UNKNOWN225"] = 225] = "OP_UNKNOWN225";
  OpcodesBCH2022[OpcodesBCH2022["OP_UNKNOWN226"] = 226] = "OP_UNKNOWN226";
  OpcodesBCH2022[OpcodesBCH2022["OP_UNKNOWN227"] = 227] = "OP_UNKNOWN227";
  OpcodesBCH2022[OpcodesBCH2022["OP_UNKNOWN228"] = 228] = "OP_UNKNOWN228";
  OpcodesBCH2022[OpcodesBCH2022["OP_UNKNOWN229"] = 229] = "OP_UNKNOWN229";
  OpcodesBCH2022[OpcodesBCH2022["OP_UNKNOWN230"] = 230] = "OP_UNKNOWN230";
  OpcodesBCH2022[OpcodesBCH2022["OP_UNKNOWN231"] = 231] = "OP_UNKNOWN231";
  OpcodesBCH2022[OpcodesBCH2022["OP_UNKNOWN232"] = 232] = "OP_UNKNOWN232";
  OpcodesBCH2022[OpcodesBCH2022["OP_UNKNOWN233"] = 233] = "OP_UNKNOWN233";
  OpcodesBCH2022[OpcodesBCH2022["OP_UNKNOWN234"] = 234] = "OP_UNKNOWN234";
  OpcodesBCH2022[OpcodesBCH2022["OP_UNKNOWN235"] = 235] = "OP_UNKNOWN235";
  OpcodesBCH2022[OpcodesBCH2022["OP_UNKNOWN236"] = 236] = "OP_UNKNOWN236";
  OpcodesBCH2022[OpcodesBCH2022["OP_UNKNOWN237"] = 237] = "OP_UNKNOWN237";
  OpcodesBCH2022[OpcodesBCH2022["OP_UNKNOWN238"] = 238] = "OP_UNKNOWN238";
  OpcodesBCH2022[OpcodesBCH2022["OP_UNKNOWN239"] = 239] = "OP_UNKNOWN239";
  /**
   * A.K.A. `OP_PREFIX_BEGIN`
   */
  OpcodesBCH2022[OpcodesBCH2022["OP_UNKNOWN240"] = 240] = "OP_UNKNOWN240";
  OpcodesBCH2022[OpcodesBCH2022["OP_UNKNOWN241"] = 241] = "OP_UNKNOWN241";
  OpcodesBCH2022[OpcodesBCH2022["OP_UNKNOWN242"] = 242] = "OP_UNKNOWN242";
  OpcodesBCH2022[OpcodesBCH2022["OP_UNKNOWN243"] = 243] = "OP_UNKNOWN243";
  OpcodesBCH2022[OpcodesBCH2022["OP_UNKNOWN244"] = 244] = "OP_UNKNOWN244";
  OpcodesBCH2022[OpcodesBCH2022["OP_UNKNOWN245"] = 245] = "OP_UNKNOWN245";
  OpcodesBCH2022[OpcodesBCH2022["OP_UNKNOWN246"] = 246] = "OP_UNKNOWN246";
  /**
   * A.K.A. `OP_PREFIX_END`
   */
  OpcodesBCH2022[OpcodesBCH2022["OP_UNKNOWN247"] = 247] = "OP_UNKNOWN247";
  OpcodesBCH2022[OpcodesBCH2022["OP_UNKNOWN248"] = 248] = "OP_UNKNOWN248";
  OpcodesBCH2022[OpcodesBCH2022["OP_UNKNOWN249"] = 249] = "OP_UNKNOWN249";
  OpcodesBCH2022[OpcodesBCH2022["OP_UNKNOWN250"] = 250] = "OP_UNKNOWN250";
  OpcodesBCH2022[OpcodesBCH2022["OP_UNKNOWN251"] = 251] = "OP_UNKNOWN251";
  OpcodesBCH2022[OpcodesBCH2022["OP_UNKNOWN252"] = 252] = "OP_UNKNOWN252";
  OpcodesBCH2022[OpcodesBCH2022["OP_UNKNOWN253"] = 253] = "OP_UNKNOWN253";
  OpcodesBCH2022[OpcodesBCH2022["OP_UNKNOWN254"] = 254] = "OP_UNKNOWN254";
  OpcodesBCH2022[OpcodesBCH2022["OP_UNKNOWN255"] = 255] = "OP_UNKNOWN255";
})(OpcodesBCH2022 || (OpcodesBCH2022 = {}));

var ConsensusXEC;
(function (ConsensusXEC) {
  /**
   * A.K.A. `MAX_SCRIPT_ELEMENT_SIZE`
   */
  ConsensusXEC[ConsensusXEC["maximumStackItemLength"] = 520] = "maximumStackItemLength";
  ConsensusXEC[ConsensusXEC["maximumVmNumberLength"] = 4] = "maximumVmNumberLength";
  /**
   * A.K.A. `MAX_OPS_PER_SCRIPT`
   */
  ConsensusXEC[ConsensusXEC["maximumOperationCount"] = 201] = "maximumOperationCount";
  /**
   * A.K.A. `MAX_SCRIPT_SIZE`
   */
  ConsensusXEC[ConsensusXEC["maximumBytecodeLength"] = 10000] = "maximumBytecodeLength";
  /**
   * A.K.A. `MAX_STACK_SIZE`
   */
  ConsensusXEC[ConsensusXEC["maximumStackDepth"] = 1000] = "maximumStackDepth";
  ConsensusXEC[ConsensusXEC["schnorrSignatureLength"] = 64] = "schnorrSignatureLength";
})(ConsensusXEC || (ConsensusXEC = {}));

var maximumVmNumberByteLength = ConsensusXEC.maximumVmNumberLength;
var opPick4Byte = function opPick4Byte(state) {
  return useOneVmNumber(state, function (nextState, depth) {
    var item = nextState.stack[nextState.stack.length - 1 - Number(depth)];
    if (item === undefined) {
      return applyError(state, AuthenticationErrorCommon.invalidStackIndex);
    }
    return pushToStack(nextState, item.slice());
  });
};
var opRoll4Byte = function opRoll4Byte(state) {
  return useOneVmNumber(state, function (nextState, depth) {
    var index = nextState.stack.length - 1 - Number(depth);
    if (index < 0 || index > nextState.stack.length - 1) {
      return applyError(state, AuthenticationErrorCommon.invalidStackIndex);
    }
    // eslint-disable-next-line functional/immutable-data, @typescript-eslint/no-non-null-assertion
    return pushToStack(nextState, nextState.stack.splice(index, 1)[0]);
  });
};
var opSplit4Byte = function opSplit4Byte(state) {
  return useOneVmNumber(state, function (nextState, value) {
    var index = Number(value);
    return useOneStackItem(nextState, function (finalState, _ref) {
      var _ref2 = _slicedToArray(_ref, 1),
        item = _ref2[0];
      return index < 0 || index > item.length ? applyError(finalState, AuthenticationErrorCommon.invalidSplitIndex) : pushToStack(finalState, item.slice(0, index), item.slice(index));
    });
  }, {
    maximumVmNumberByteLength: maximumVmNumberByteLength
  });
};
var opNum2Bin4Byte = function opNum2Bin4Byte(state) {
  return useOneVmNumber(state, function (nextState, value) {
    var targetLength = Number(value);
    return targetLength > ConsensusXEC.maximumStackItemLength ? applyError(nextState, AuthenticationErrorCommon.exceededMaximumStackItemLength) : useOneVmNumber(nextState, function (finalState, _ref3) {
      var _ref4 = _slicedToArray(_ref3, 1),
        target = _ref4[0];
      var minimallyEncoded = bigIntToVmNumber(target);
      return minimallyEncoded.length > targetLength ? applyError(finalState, AuthenticationErrorCommon.insufficientLength) : minimallyEncoded.length === targetLength ? pushToStack(finalState, minimallyEncoded) : pushToStack(finalState, padMinimallyEncodedVmNumber(minimallyEncoded, targetLength));
    }, {
      maximumVmNumberByteLength: ConsensusXEC.maximumStackItemLength,
      requireMinimalEncoding: false
    });
  });
};
var opBin2Num4Byte = function opBin2Num4Byte(state) {
  return useOneVmNumber(state, function (nextState, _ref5) {
    var _ref6 = _slicedToArray(_ref5, 1),
      target = _ref6[0];
    var minimallyEncoded = bigIntToVmNumber(target);
    return minimallyEncoded.length > ConsensusXEC.maximumVmNumberLength ? applyError(nextState, AuthenticationErrorCommon.exceededMaximumVmNumberLength) : pushToStack(nextState, minimallyEncoded);
  }, {
    maximumVmNumberByteLength: ConsensusXEC.maximumStackItemLength,
    requireMinimalEncoding: false
  });
};
var op1Add4Byte = function op1Add4Byte(state) {
  return useOneVmNumber(state, function (nextState, _ref7) {
    var _ref8 = _slicedToArray(_ref7, 1),
      value = _ref8[0];
    return pushToStack(nextState, bigIntToVmNumber(value + 1n));
  }, {
    maximumVmNumberByteLength: maximumVmNumberByteLength
  });
};
var op1Sub4Byte = function op1Sub4Byte(state) {
  return useOneVmNumber(state, function (nextState, _ref9) {
    var _ref10 = _slicedToArray(_ref9, 1),
      value = _ref10[0];
    return pushToStack(nextState, bigIntToVmNumber(value - 1n));
  }, {
    maximumVmNumberByteLength: maximumVmNumberByteLength
  });
};
var opNegate4Byte = function opNegate4Byte(state) {
  return useOneVmNumber(state, function (nextState, _ref11) {
    var _ref12 = _slicedToArray(_ref11, 1),
      value = _ref12[0];
    return pushToStack(nextState, bigIntToVmNumber(-value));
  }, {
    maximumVmNumberByteLength: maximumVmNumberByteLength
  });
};
var opAbs4Byte = function opAbs4Byte(state) {
  return useOneVmNumber(state, function (nextState, _ref13) {
    var _ref14 = _slicedToArray(_ref13, 1),
      value = _ref14[0];
    return pushToStack(nextState, bigIntToVmNumber(value < 0 ? -value : value));
  }, {
    maximumVmNumberByteLength: maximumVmNumberByteLength
  });
};
var opNot4Byte = function opNot4Byte(state) {
  return useOneVmNumber(state, function (nextState, _ref15) {
    var _ref16 = _slicedToArray(_ref15, 1),
      value = _ref16[0];
    return pushToStack(nextState, value === 0n ? bigIntToVmNumber(1n) : bigIntToVmNumber(0n));
  }, {
    maximumVmNumberByteLength: maximumVmNumberByteLength
  });
};
var op0NotEqual4Byte = function op0NotEqual4Byte(state) {
  return useOneVmNumber(state, function (nextState, _ref17) {
    var _ref18 = _slicedToArray(_ref17, 1),
      value = _ref18[0];
    return pushToStack(nextState, value === 0n ? bigIntToVmNumber(0n) : bigIntToVmNumber(1n));
  }, {
    maximumVmNumberByteLength: maximumVmNumberByteLength
  });
};
var opAdd4Byte = function opAdd4Byte(state) {
  return useTwoVmNumbers(state, function (nextState, _ref19) {
    var _ref20 = _slicedToArray(_ref19, 2),
      firstValue = _ref20[0],
      secondValue = _ref20[1];
    return pushToStack(nextState, bigIntToVmNumber(firstValue + secondValue));
  }, {
    maximumVmNumberByteLength: maximumVmNumberByteLength
  });
};
var opSub4Byte = function opSub4Byte(state) {
  return useTwoVmNumbers(state, function (nextState, _ref21) {
    var _ref22 = _slicedToArray(_ref21, 2),
      firstValue = _ref22[0],
      secondValue = _ref22[1];
    return pushToStack(nextState, bigIntToVmNumber(firstValue - secondValue));
  }, {
    maximumVmNumberByteLength: maximumVmNumberByteLength
  });
};
var opDiv4Byte = function opDiv4Byte(state) {
  return useTwoVmNumbers(state, function (nextState, _ref23) {
    var _ref24 = _slicedToArray(_ref23, 2),
      a = _ref24[0],
      b = _ref24[1];
    return b === 0n ? applyError(nextState, AuthenticationErrorCommon.divisionByZero) : pushToStack(nextState, bigIntToVmNumber(a / b));
  }, {
    maximumVmNumberByteLength: maximumVmNumberByteLength
  });
};
var opMod4Byte = function opMod4Byte(state) {
  return useTwoVmNumbers(state, function (nextState, _ref25) {
    var _ref26 = _slicedToArray(_ref25, 2),
      a = _ref26[0],
      b = _ref26[1];
    return b === 0n ? applyError(nextState, AuthenticationErrorCommon.divisionByZero) : pushToStack(nextState, bigIntToVmNumber(a % b));
  }, {
    maximumVmNumberByteLength: maximumVmNumberByteLength
  });
};
var opBoolAnd4Byte = function opBoolAnd4Byte(state) {
  return useTwoVmNumbers(state, function (nextState, _ref27) {
    var _ref28 = _slicedToArray(_ref27, 2),
      firstValue = _ref28[0],
      secondValue = _ref28[1];
    return pushToStack(nextState, booleanToVmNumber(firstValue !== 0n && secondValue !== 0n));
  }, {
    maximumVmNumberByteLength: maximumVmNumberByteLength
  });
};
var opBoolOr4Byte = function opBoolOr4Byte(state) {
  return useTwoVmNumbers(state, function (nextState, _ref29) {
    var _ref30 = _slicedToArray(_ref29, 2),
      firstValue = _ref30[0],
      secondValue = _ref30[1];
    return pushToStack(nextState, booleanToVmNumber(firstValue !== 0n || secondValue !== 0n));
  }, {
    maximumVmNumberByteLength: maximumVmNumberByteLength
  });
};
var opNumEqual4Byte = function opNumEqual4Byte(state) {
  return useTwoVmNumbers(state, function (nextState, _ref31) {
    var _ref32 = _slicedToArray(_ref31, 2),
      firstValue = _ref32[0],
      secondValue = _ref32[1];
    return pushToStack(nextState, booleanToVmNumber(firstValue === secondValue));
  }, {
    maximumVmNumberByteLength: maximumVmNumberByteLength
  });
};
var opNumEqualVerify4Byte = combineOperations(opNumEqual4Byte, opVerify);
var opNumNotEqual4Byte = function opNumNotEqual4Byte(state) {
  return useTwoVmNumbers(state, function (nextState, _ref33) {
    var _ref34 = _slicedToArray(_ref33, 2),
      firstValue = _ref34[0],
      secondValue = _ref34[1];
    return pushToStack(nextState, booleanToVmNumber(firstValue !== secondValue));
  }, {
    maximumVmNumberByteLength: maximumVmNumberByteLength
  });
};
var opLessThan4Byte = function opLessThan4Byte(state) {
  return useTwoVmNumbers(state, function (nextState, _ref35) {
    var _ref36 = _slicedToArray(_ref35, 2),
      firstValue = _ref36[0],
      secondValue = _ref36[1];
    return pushToStack(nextState, booleanToVmNumber(firstValue < secondValue));
  }, {
    maximumVmNumberByteLength: maximumVmNumberByteLength
  });
};
var opLessThanOrEqual4Byte = function opLessThanOrEqual4Byte(state) {
  return useTwoVmNumbers(state, function (nextState, _ref37) {
    var _ref38 = _slicedToArray(_ref37, 2),
      firstValue = _ref38[0],
      secondValue = _ref38[1];
    return pushToStack(nextState, booleanToVmNumber(firstValue <= secondValue));
  }, {
    maximumVmNumberByteLength: maximumVmNumberByteLength
  });
};
var opGreaterThan4Byte = function opGreaterThan4Byte(state) {
  return useTwoVmNumbers(state, function (nextState, _ref39) {
    var _ref40 = _slicedToArray(_ref39, 2),
      firstValue = _ref40[0],
      secondValue = _ref40[1];
    return pushToStack(nextState, booleanToVmNumber(firstValue > secondValue));
  }, {
    maximumVmNumberByteLength: maximumVmNumberByteLength
  });
};
var opGreaterThanOrEqual4Byte = function opGreaterThanOrEqual4Byte(state) {
  return useTwoVmNumbers(state, function (nextState, _ref41) {
    var _ref42 = _slicedToArray(_ref41, 2),
      firstValue = _ref42[0],
      secondValue = _ref42[1];
    return pushToStack(nextState, booleanToVmNumber(firstValue >= secondValue));
  }, {
    maximumVmNumberByteLength: maximumVmNumberByteLength
  });
};
var opMin4Byte = function opMin4Byte(state) {
  return useTwoVmNumbers(state, function (nextState, _ref43) {
    var _ref44 = _slicedToArray(_ref43, 2),
      firstValue = _ref44[0],
      secondValue = _ref44[1];
    return pushToStack(nextState, bigIntToVmNumber(firstValue < secondValue ? firstValue : secondValue));
  }, {
    maximumVmNumberByteLength: maximumVmNumberByteLength
  });
};
var opMax4Byte = function opMax4Byte(state) {
  return useTwoVmNumbers(state, function (nextState, _ref45) {
    var _ref46 = _slicedToArray(_ref45, 2),
      firstValue = _ref46[0],
      secondValue = _ref46[1];
    return pushToStack(nextState, bigIntToVmNumber(firstValue > secondValue ? firstValue : secondValue));
  }, {
    maximumVmNumberByteLength: maximumVmNumberByteLength
  });
};
var opWithin4Byte = function opWithin4Byte(state) {
  return useThreeVmNumbers(state, function (nextState, _ref47) {
    var _ref48 = _slicedToArray(_ref47, 3),
      firstValue = _ref48[0],
      secondValue = _ref48[1],
      thirdValue = _ref48[2];
    return pushToStack(nextState, booleanToVmNumber(secondValue <= firstValue && firstValue < thirdValue));
  }, {
    maximumVmNumberByteLength: maximumVmNumberByteLength
  });
};

/**
 * create an instance of the XEC virtual machine instruction set.
 *
 * @param standard - If `true`, the additional `isStandard` validations will be
 * enabled. Transactions that fail these rules are often called "non-standard"
 * and can technically be included by miners in valid blocks, but most network
 * nodes will refuse to relay them. (Default: `true`)
 */
var createInstructionSetXEC = function createInstructionSetXEC() {
  var _mapOverOperations, _objectSpread2$1;
  var standard = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
  var instructionSet = createInstructionSetBCH2022(standard);
  return _objectSpread2(_objectSpread2({}, instructionSet), {}, {
    operations: _objectSpread2(_objectSpread2(_objectSpread2({}, instructionSet.operations), mapOverOperations([conditionallyEvaluate, incrementOperationCount], (_mapOverOperations = {}, _defineProperty(_mapOverOperations, OpcodesBCH2022.OP_PICK, opPick4Byte), _defineProperty(_mapOverOperations, OpcodesBCH2022.OP_ROLL, opRoll4Byte), _defineProperty(_mapOverOperations, OpcodesBCH2022.OP_SPLIT, opSplit4Byte), _defineProperty(_mapOverOperations, OpcodesBCH2022.OP_NUM2BIN, opNum2Bin4Byte), _defineProperty(_mapOverOperations, OpcodesBCH2022.OP_BIN2NUM, opBin2Num4Byte), _defineProperty(_mapOverOperations, OpcodesBCH2022.OP_1ADD, op1Add4Byte), _defineProperty(_mapOverOperations, OpcodesBCH2022.OP_1SUB, op1Sub4Byte), _defineProperty(_mapOverOperations, OpcodesBCH2022.OP_NEGATE, opNegate4Byte), _defineProperty(_mapOverOperations, OpcodesBCH2022.OP_ABS, opAbs4Byte), _defineProperty(_mapOverOperations, OpcodesBCH2022.OP_NOT, opNot4Byte), _defineProperty(_mapOverOperations, OpcodesBCH2022.OP_0NOTEQUAL, op0NotEqual4Byte), _defineProperty(_mapOverOperations, OpcodesBCH2022.OP_ADD, opAdd4Byte), _defineProperty(_mapOverOperations, OpcodesBCH2022.OP_SUB, opSub4Byte), _defineProperty(_mapOverOperations, OpcodesBCH2022.OP_MUL, disabledOperation), _defineProperty(_mapOverOperations, OpcodesBCH2022.OP_DIV, opDiv4Byte), _defineProperty(_mapOverOperations, OpcodesBCH2022.OP_MOD, opMod4Byte), _defineProperty(_mapOverOperations, OpcodesBCH2022.OP_BOOLAND, opBoolAnd4Byte), _defineProperty(_mapOverOperations, OpcodesBCH2022.OP_BOOLOR, opBoolOr4Byte), _defineProperty(_mapOverOperations, OpcodesBCH2022.OP_NUMEQUAL, opNumEqual4Byte), _defineProperty(_mapOverOperations, OpcodesBCH2022.OP_NUMEQUALVERIFY, opNumEqualVerify4Byte), _defineProperty(_mapOverOperations, OpcodesBCH2022.OP_NUMNOTEQUAL, opNumNotEqual4Byte), _defineProperty(_mapOverOperations, OpcodesBCH2022.OP_LESSTHAN, opLessThan4Byte), _defineProperty(_mapOverOperations, OpcodesBCH2022.OP_GREATERTHAN, opGreaterThan4Byte), _defineProperty(_mapOverOperations, OpcodesBCH2022.OP_LESSTHANOREQUAL, opLessThanOrEqual4Byte), _defineProperty(_mapOverOperations, OpcodesBCH2022.OP_GREATERTHANOREQUAL, opGreaterThanOrEqual4Byte), _defineProperty(_mapOverOperations, OpcodesBCH2022.OP_MIN, opMin4Byte), _defineProperty(_mapOverOperations, OpcodesBCH2022.OP_MAX, opMax4Byte), _defineProperty(_mapOverOperations, OpcodesBCH2022.OP_WITHIN, opWithin4Byte), _mapOverOperations))), {}, (_objectSpread2$1 = {}, _defineProperty(_objectSpread2$1, OpcodesBCH2022.OP_INPUTINDEX, undefinedOperation), _defineProperty(_objectSpread2$1, OpcodesBCH2022.OP_ACTIVEBYTECODE, undefinedOperation), _defineProperty(_objectSpread2$1, OpcodesBCH2022.OP_TXVERSION, undefinedOperation), _defineProperty(_objectSpread2$1, OpcodesBCH2022.OP_TXINPUTCOUNT, undefinedOperation), _defineProperty(_objectSpread2$1, OpcodesBCH2022.OP_TXOUTPUTCOUNT, undefinedOperation), _defineProperty(_objectSpread2$1, OpcodesBCH2022.OP_TXLOCKTIME, undefinedOperation), _defineProperty(_objectSpread2$1, OpcodesBCH2022.OP_UTXOVALUE, undefinedOperation), _defineProperty(_objectSpread2$1, OpcodesBCH2022.OP_UTXOBYTECODE, undefinedOperation), _defineProperty(_objectSpread2$1, OpcodesBCH2022.OP_OUTPOINTTXHASH, undefinedOperation), _defineProperty(_objectSpread2$1, OpcodesBCH2022.OP_OUTPOINTINDEX, undefinedOperation), _defineProperty(_objectSpread2$1, OpcodesBCH2022.OP_INPUTBYTECODE, undefinedOperation), _defineProperty(_objectSpread2$1, OpcodesBCH2022.OP_INPUTSEQUENCENUMBER, undefinedOperation), _defineProperty(_objectSpread2$1, OpcodesBCH2022.OP_OUTPUTVALUE, undefinedOperation), _defineProperty(_objectSpread2$1, OpcodesBCH2022.OP_OUTPUTBYTECODE, undefinedOperation), _objectSpread2$1))
  });
};

var OpcodesXEC;
(function (OpcodesXEC) {
  /**
   * A.K.A. `OP_FALSE` or `OP_PUSHBYTES_0`
   */
  OpcodesXEC[OpcodesXEC["OP_0"] = 0] = "OP_0";
  OpcodesXEC[OpcodesXEC["OP_PUSHBYTES_1"] = 1] = "OP_PUSHBYTES_1";
  OpcodesXEC[OpcodesXEC["OP_PUSHBYTES_2"] = 2] = "OP_PUSHBYTES_2";
  OpcodesXEC[OpcodesXEC["OP_PUSHBYTES_3"] = 3] = "OP_PUSHBYTES_3";
  OpcodesXEC[OpcodesXEC["OP_PUSHBYTES_4"] = 4] = "OP_PUSHBYTES_4";
  OpcodesXEC[OpcodesXEC["OP_PUSHBYTES_5"] = 5] = "OP_PUSHBYTES_5";
  OpcodesXEC[OpcodesXEC["OP_PUSHBYTES_6"] = 6] = "OP_PUSHBYTES_6";
  OpcodesXEC[OpcodesXEC["OP_PUSHBYTES_7"] = 7] = "OP_PUSHBYTES_7";
  OpcodesXEC[OpcodesXEC["OP_PUSHBYTES_8"] = 8] = "OP_PUSHBYTES_8";
  OpcodesXEC[OpcodesXEC["OP_PUSHBYTES_9"] = 9] = "OP_PUSHBYTES_9";
  OpcodesXEC[OpcodesXEC["OP_PUSHBYTES_10"] = 10] = "OP_PUSHBYTES_10";
  OpcodesXEC[OpcodesXEC["OP_PUSHBYTES_11"] = 11] = "OP_PUSHBYTES_11";
  OpcodesXEC[OpcodesXEC["OP_PUSHBYTES_12"] = 12] = "OP_PUSHBYTES_12";
  OpcodesXEC[OpcodesXEC["OP_PUSHBYTES_13"] = 13] = "OP_PUSHBYTES_13";
  OpcodesXEC[OpcodesXEC["OP_PUSHBYTES_14"] = 14] = "OP_PUSHBYTES_14";
  OpcodesXEC[OpcodesXEC["OP_PUSHBYTES_15"] = 15] = "OP_PUSHBYTES_15";
  OpcodesXEC[OpcodesXEC["OP_PUSHBYTES_16"] = 16] = "OP_PUSHBYTES_16";
  OpcodesXEC[OpcodesXEC["OP_PUSHBYTES_17"] = 17] = "OP_PUSHBYTES_17";
  OpcodesXEC[OpcodesXEC["OP_PUSHBYTES_18"] = 18] = "OP_PUSHBYTES_18";
  OpcodesXEC[OpcodesXEC["OP_PUSHBYTES_19"] = 19] = "OP_PUSHBYTES_19";
  OpcodesXEC[OpcodesXEC["OP_PUSHBYTES_20"] = 20] = "OP_PUSHBYTES_20";
  OpcodesXEC[OpcodesXEC["OP_PUSHBYTES_21"] = 21] = "OP_PUSHBYTES_21";
  OpcodesXEC[OpcodesXEC["OP_PUSHBYTES_22"] = 22] = "OP_PUSHBYTES_22";
  OpcodesXEC[OpcodesXEC["OP_PUSHBYTES_23"] = 23] = "OP_PUSHBYTES_23";
  OpcodesXEC[OpcodesXEC["OP_PUSHBYTES_24"] = 24] = "OP_PUSHBYTES_24";
  OpcodesXEC[OpcodesXEC["OP_PUSHBYTES_25"] = 25] = "OP_PUSHBYTES_25";
  OpcodesXEC[OpcodesXEC["OP_PUSHBYTES_26"] = 26] = "OP_PUSHBYTES_26";
  OpcodesXEC[OpcodesXEC["OP_PUSHBYTES_27"] = 27] = "OP_PUSHBYTES_27";
  OpcodesXEC[OpcodesXEC["OP_PUSHBYTES_28"] = 28] = "OP_PUSHBYTES_28";
  OpcodesXEC[OpcodesXEC["OP_PUSHBYTES_29"] = 29] = "OP_PUSHBYTES_29";
  OpcodesXEC[OpcodesXEC["OP_PUSHBYTES_30"] = 30] = "OP_PUSHBYTES_30";
  OpcodesXEC[OpcodesXEC["OP_PUSHBYTES_31"] = 31] = "OP_PUSHBYTES_31";
  OpcodesXEC[OpcodesXEC["OP_PUSHBYTES_32"] = 32] = "OP_PUSHBYTES_32";
  OpcodesXEC[OpcodesXEC["OP_PUSHBYTES_33"] = 33] = "OP_PUSHBYTES_33";
  OpcodesXEC[OpcodesXEC["OP_PUSHBYTES_34"] = 34] = "OP_PUSHBYTES_34";
  OpcodesXEC[OpcodesXEC["OP_PUSHBYTES_35"] = 35] = "OP_PUSHBYTES_35";
  OpcodesXEC[OpcodesXEC["OP_PUSHBYTES_36"] = 36] = "OP_PUSHBYTES_36";
  OpcodesXEC[OpcodesXEC["OP_PUSHBYTES_37"] = 37] = "OP_PUSHBYTES_37";
  OpcodesXEC[OpcodesXEC["OP_PUSHBYTES_38"] = 38] = "OP_PUSHBYTES_38";
  OpcodesXEC[OpcodesXEC["OP_PUSHBYTES_39"] = 39] = "OP_PUSHBYTES_39";
  OpcodesXEC[OpcodesXEC["OP_PUSHBYTES_40"] = 40] = "OP_PUSHBYTES_40";
  OpcodesXEC[OpcodesXEC["OP_PUSHBYTES_41"] = 41] = "OP_PUSHBYTES_41";
  OpcodesXEC[OpcodesXEC["OP_PUSHBYTES_42"] = 42] = "OP_PUSHBYTES_42";
  OpcodesXEC[OpcodesXEC["OP_PUSHBYTES_43"] = 43] = "OP_PUSHBYTES_43";
  OpcodesXEC[OpcodesXEC["OP_PUSHBYTES_44"] = 44] = "OP_PUSHBYTES_44";
  OpcodesXEC[OpcodesXEC["OP_PUSHBYTES_45"] = 45] = "OP_PUSHBYTES_45";
  OpcodesXEC[OpcodesXEC["OP_PUSHBYTES_46"] = 46] = "OP_PUSHBYTES_46";
  OpcodesXEC[OpcodesXEC["OP_PUSHBYTES_47"] = 47] = "OP_PUSHBYTES_47";
  OpcodesXEC[OpcodesXEC["OP_PUSHBYTES_48"] = 48] = "OP_PUSHBYTES_48";
  OpcodesXEC[OpcodesXEC["OP_PUSHBYTES_49"] = 49] = "OP_PUSHBYTES_49";
  OpcodesXEC[OpcodesXEC["OP_PUSHBYTES_50"] = 50] = "OP_PUSHBYTES_50";
  OpcodesXEC[OpcodesXEC["OP_PUSHBYTES_51"] = 51] = "OP_PUSHBYTES_51";
  OpcodesXEC[OpcodesXEC["OP_PUSHBYTES_52"] = 52] = "OP_PUSHBYTES_52";
  OpcodesXEC[OpcodesXEC["OP_PUSHBYTES_53"] = 53] = "OP_PUSHBYTES_53";
  OpcodesXEC[OpcodesXEC["OP_PUSHBYTES_54"] = 54] = "OP_PUSHBYTES_54";
  OpcodesXEC[OpcodesXEC["OP_PUSHBYTES_55"] = 55] = "OP_PUSHBYTES_55";
  OpcodesXEC[OpcodesXEC["OP_PUSHBYTES_56"] = 56] = "OP_PUSHBYTES_56";
  OpcodesXEC[OpcodesXEC["OP_PUSHBYTES_57"] = 57] = "OP_PUSHBYTES_57";
  OpcodesXEC[OpcodesXEC["OP_PUSHBYTES_58"] = 58] = "OP_PUSHBYTES_58";
  OpcodesXEC[OpcodesXEC["OP_PUSHBYTES_59"] = 59] = "OP_PUSHBYTES_59";
  OpcodesXEC[OpcodesXEC["OP_PUSHBYTES_60"] = 60] = "OP_PUSHBYTES_60";
  OpcodesXEC[OpcodesXEC["OP_PUSHBYTES_61"] = 61] = "OP_PUSHBYTES_61";
  OpcodesXEC[OpcodesXEC["OP_PUSHBYTES_62"] = 62] = "OP_PUSHBYTES_62";
  OpcodesXEC[OpcodesXEC["OP_PUSHBYTES_63"] = 63] = "OP_PUSHBYTES_63";
  OpcodesXEC[OpcodesXEC["OP_PUSHBYTES_64"] = 64] = "OP_PUSHBYTES_64";
  OpcodesXEC[OpcodesXEC["OP_PUSHBYTES_65"] = 65] = "OP_PUSHBYTES_65";
  OpcodesXEC[OpcodesXEC["OP_PUSHBYTES_66"] = 66] = "OP_PUSHBYTES_66";
  OpcodesXEC[OpcodesXEC["OP_PUSHBYTES_67"] = 67] = "OP_PUSHBYTES_67";
  OpcodesXEC[OpcodesXEC["OP_PUSHBYTES_68"] = 68] = "OP_PUSHBYTES_68";
  OpcodesXEC[OpcodesXEC["OP_PUSHBYTES_69"] = 69] = "OP_PUSHBYTES_69";
  OpcodesXEC[OpcodesXEC["OP_PUSHBYTES_70"] = 70] = "OP_PUSHBYTES_70";
  OpcodesXEC[OpcodesXEC["OP_PUSHBYTES_71"] = 71] = "OP_PUSHBYTES_71";
  OpcodesXEC[OpcodesXEC["OP_PUSHBYTES_72"] = 72] = "OP_PUSHBYTES_72";
  OpcodesXEC[OpcodesXEC["OP_PUSHBYTES_73"] = 73] = "OP_PUSHBYTES_73";
  OpcodesXEC[OpcodesXEC["OP_PUSHBYTES_74"] = 74] = "OP_PUSHBYTES_74";
  OpcodesXEC[OpcodesXEC["OP_PUSHBYTES_75"] = 75] = "OP_PUSHBYTES_75";
  OpcodesXEC[OpcodesXEC["OP_PUSHDATA_1"] = 76] = "OP_PUSHDATA_1";
  OpcodesXEC[OpcodesXEC["OP_PUSHDATA_2"] = 77] = "OP_PUSHDATA_2";
  OpcodesXEC[OpcodesXEC["OP_PUSHDATA_4"] = 78] = "OP_PUSHDATA_4";
  OpcodesXEC[OpcodesXEC["OP_1NEGATE"] = 79] = "OP_1NEGATE";
  OpcodesXEC[OpcodesXEC["OP_RESERVED"] = 80] = "OP_RESERVED";
  /**
   * A.K.A. `OP_TRUE`
   */
  OpcodesXEC[OpcodesXEC["OP_1"] = 81] = "OP_1";
  OpcodesXEC[OpcodesXEC["OP_2"] = 82] = "OP_2";
  OpcodesXEC[OpcodesXEC["OP_3"] = 83] = "OP_3";
  OpcodesXEC[OpcodesXEC["OP_4"] = 84] = "OP_4";
  OpcodesXEC[OpcodesXEC["OP_5"] = 85] = "OP_5";
  OpcodesXEC[OpcodesXEC["OP_6"] = 86] = "OP_6";
  OpcodesXEC[OpcodesXEC["OP_7"] = 87] = "OP_7";
  OpcodesXEC[OpcodesXEC["OP_8"] = 88] = "OP_8";
  OpcodesXEC[OpcodesXEC["OP_9"] = 89] = "OP_9";
  OpcodesXEC[OpcodesXEC["OP_10"] = 90] = "OP_10";
  OpcodesXEC[OpcodesXEC["OP_11"] = 91] = "OP_11";
  OpcodesXEC[OpcodesXEC["OP_12"] = 92] = "OP_12";
  OpcodesXEC[OpcodesXEC["OP_13"] = 93] = "OP_13";
  OpcodesXEC[OpcodesXEC["OP_14"] = 94] = "OP_14";
  OpcodesXEC[OpcodesXEC["OP_15"] = 95] = "OP_15";
  OpcodesXEC[OpcodesXEC["OP_16"] = 96] = "OP_16";
  OpcodesXEC[OpcodesXEC["OP_NOP"] = 97] = "OP_NOP";
  OpcodesXEC[OpcodesXEC["OP_VER"] = 98] = "OP_VER";
  OpcodesXEC[OpcodesXEC["OP_IF"] = 99] = "OP_IF";
  OpcodesXEC[OpcodesXEC["OP_NOTIF"] = 100] = "OP_NOTIF";
  OpcodesXEC[OpcodesXEC["OP_VERIF"] = 101] = "OP_VERIF";
  OpcodesXEC[OpcodesXEC["OP_VERNOTIF"] = 102] = "OP_VERNOTIF";
  OpcodesXEC[OpcodesXEC["OP_ELSE"] = 103] = "OP_ELSE";
  OpcodesXEC[OpcodesXEC["OP_ENDIF"] = 104] = "OP_ENDIF";
  OpcodesXEC[OpcodesXEC["OP_VERIFY"] = 105] = "OP_VERIFY";
  OpcodesXEC[OpcodesXEC["OP_RETURN"] = 106] = "OP_RETURN";
  OpcodesXEC[OpcodesXEC["OP_TOALTSTACK"] = 107] = "OP_TOALTSTACK";
  OpcodesXEC[OpcodesXEC["OP_FROMALTSTACK"] = 108] = "OP_FROMALTSTACK";
  OpcodesXEC[OpcodesXEC["OP_2DROP"] = 109] = "OP_2DROP";
  OpcodesXEC[OpcodesXEC["OP_2DUP"] = 110] = "OP_2DUP";
  OpcodesXEC[OpcodesXEC["OP_3DUP"] = 111] = "OP_3DUP";
  OpcodesXEC[OpcodesXEC["OP_2OVER"] = 112] = "OP_2OVER";
  OpcodesXEC[OpcodesXEC["OP_2ROT"] = 113] = "OP_2ROT";
  OpcodesXEC[OpcodesXEC["OP_2SWAP"] = 114] = "OP_2SWAP";
  OpcodesXEC[OpcodesXEC["OP_IFDUP"] = 115] = "OP_IFDUP";
  OpcodesXEC[OpcodesXEC["OP_DEPTH"] = 116] = "OP_DEPTH";
  OpcodesXEC[OpcodesXEC["OP_DROP"] = 117] = "OP_DROP";
  OpcodesXEC[OpcodesXEC["OP_DUP"] = 118] = "OP_DUP";
  OpcodesXEC[OpcodesXEC["OP_NIP"] = 119] = "OP_NIP";
  OpcodesXEC[OpcodesXEC["OP_OVER"] = 120] = "OP_OVER";
  OpcodesXEC[OpcodesXEC["OP_PICK"] = 121] = "OP_PICK";
  OpcodesXEC[OpcodesXEC["OP_ROLL"] = 122] = "OP_ROLL";
  OpcodesXEC[OpcodesXEC["OP_ROT"] = 123] = "OP_ROT";
  OpcodesXEC[OpcodesXEC["OP_SWAP"] = 124] = "OP_SWAP";
  OpcodesXEC[OpcodesXEC["OP_TUCK"] = 125] = "OP_TUCK";
  OpcodesXEC[OpcodesXEC["OP_CAT"] = 126] = "OP_CAT";
  OpcodesXEC[OpcodesXEC["OP_SPLIT"] = 127] = "OP_SPLIT";
  OpcodesXEC[OpcodesXEC["OP_NUM2BIN"] = 128] = "OP_NUM2BIN";
  OpcodesXEC[OpcodesXEC["OP_BIN2NUM"] = 129] = "OP_BIN2NUM";
  OpcodesXEC[OpcodesXEC["OP_SIZE"] = 130] = "OP_SIZE";
  OpcodesXEC[OpcodesXEC["OP_INVERT"] = 131] = "OP_INVERT";
  OpcodesXEC[OpcodesXEC["OP_AND"] = 132] = "OP_AND";
  OpcodesXEC[OpcodesXEC["OP_OR"] = 133] = "OP_OR";
  OpcodesXEC[OpcodesXEC["OP_XOR"] = 134] = "OP_XOR";
  OpcodesXEC[OpcodesXEC["OP_EQUAL"] = 135] = "OP_EQUAL";
  OpcodesXEC[OpcodesXEC["OP_EQUALVERIFY"] = 136] = "OP_EQUALVERIFY";
  OpcodesXEC[OpcodesXEC["OP_RESERVED1"] = 137] = "OP_RESERVED1";
  OpcodesXEC[OpcodesXEC["OP_RESERVED2"] = 138] = "OP_RESERVED2";
  OpcodesXEC[OpcodesXEC["OP_1ADD"] = 139] = "OP_1ADD";
  OpcodesXEC[OpcodesXEC["OP_1SUB"] = 140] = "OP_1SUB";
  OpcodesXEC[OpcodesXEC["OP_2MUL"] = 141] = "OP_2MUL";
  OpcodesXEC[OpcodesXEC["OP_2DIV"] = 142] = "OP_2DIV";
  OpcodesXEC[OpcodesXEC["OP_NEGATE"] = 143] = "OP_NEGATE";
  OpcodesXEC[OpcodesXEC["OP_ABS"] = 144] = "OP_ABS";
  OpcodesXEC[OpcodesXEC["OP_NOT"] = 145] = "OP_NOT";
  OpcodesXEC[OpcodesXEC["OP_0NOTEQUAL"] = 146] = "OP_0NOTEQUAL";
  OpcodesXEC[OpcodesXEC["OP_ADD"] = 147] = "OP_ADD";
  OpcodesXEC[OpcodesXEC["OP_SUB"] = 148] = "OP_SUB";
  OpcodesXEC[OpcodesXEC["OP_MUL"] = 149] = "OP_MUL";
  OpcodesXEC[OpcodesXEC["OP_DIV"] = 150] = "OP_DIV";
  OpcodesXEC[OpcodesXEC["OP_MOD"] = 151] = "OP_MOD";
  OpcodesXEC[OpcodesXEC["OP_LSHIFT"] = 152] = "OP_LSHIFT";
  OpcodesXEC[OpcodesXEC["OP_RSHIFT"] = 153] = "OP_RSHIFT";
  OpcodesXEC[OpcodesXEC["OP_BOOLAND"] = 154] = "OP_BOOLAND";
  OpcodesXEC[OpcodesXEC["OP_BOOLOR"] = 155] = "OP_BOOLOR";
  OpcodesXEC[OpcodesXEC["OP_NUMEQUAL"] = 156] = "OP_NUMEQUAL";
  OpcodesXEC[OpcodesXEC["OP_NUMEQUALVERIFY"] = 157] = "OP_NUMEQUALVERIFY";
  OpcodesXEC[OpcodesXEC["OP_NUMNOTEQUAL"] = 158] = "OP_NUMNOTEQUAL";
  OpcodesXEC[OpcodesXEC["OP_LESSTHAN"] = 159] = "OP_LESSTHAN";
  OpcodesXEC[OpcodesXEC["OP_GREATERTHAN"] = 160] = "OP_GREATERTHAN";
  OpcodesXEC[OpcodesXEC["OP_LESSTHANOREQUAL"] = 161] = "OP_LESSTHANOREQUAL";
  OpcodesXEC[OpcodesXEC["OP_GREATERTHANOREQUAL"] = 162] = "OP_GREATERTHANOREQUAL";
  OpcodesXEC[OpcodesXEC["OP_MIN"] = 163] = "OP_MIN";
  OpcodesXEC[OpcodesXEC["OP_MAX"] = 164] = "OP_MAX";
  OpcodesXEC[OpcodesXEC["OP_WITHIN"] = 165] = "OP_WITHIN";
  OpcodesXEC[OpcodesXEC["OP_RIPEMD160"] = 166] = "OP_RIPEMD160";
  OpcodesXEC[OpcodesXEC["OP_SHA1"] = 167] = "OP_SHA1";
  OpcodesXEC[OpcodesXEC["OP_SHA256"] = 168] = "OP_SHA256";
  OpcodesXEC[OpcodesXEC["OP_HASH160"] = 169] = "OP_HASH160";
  OpcodesXEC[OpcodesXEC["OP_HASH256"] = 170] = "OP_HASH256";
  OpcodesXEC[OpcodesXEC["OP_CODESEPARATOR"] = 171] = "OP_CODESEPARATOR";
  OpcodesXEC[OpcodesXEC["OP_CHECKSIG"] = 172] = "OP_CHECKSIG";
  OpcodesXEC[OpcodesXEC["OP_CHECKSIGVERIFY"] = 173] = "OP_CHECKSIGVERIFY";
  OpcodesXEC[OpcodesXEC["OP_CHECKMULTISIG"] = 174] = "OP_CHECKMULTISIG";
  OpcodesXEC[OpcodesXEC["OP_CHECKMULTISIGVERIFY"] = 175] = "OP_CHECKMULTISIGVERIFY";
  OpcodesXEC[OpcodesXEC["OP_NOP1"] = 176] = "OP_NOP1";
  OpcodesXEC[OpcodesXEC["OP_CHECKLOCKTIMEVERIFY"] = 177] = "OP_CHECKLOCKTIMEVERIFY";
  OpcodesXEC[OpcodesXEC["OP_CHECKSEQUENCEVERIFY"] = 178] = "OP_CHECKSEQUENCEVERIFY";
  OpcodesXEC[OpcodesXEC["OP_NOP4"] = 179] = "OP_NOP4";
  OpcodesXEC[OpcodesXEC["OP_NOP5"] = 180] = "OP_NOP5";
  OpcodesXEC[OpcodesXEC["OP_NOP6"] = 181] = "OP_NOP6";
  OpcodesXEC[OpcodesXEC["OP_NOP7"] = 182] = "OP_NOP7";
  OpcodesXEC[OpcodesXEC["OP_NOP8"] = 183] = "OP_NOP8";
  OpcodesXEC[OpcodesXEC["OP_NOP9"] = 184] = "OP_NOP9";
  OpcodesXEC[OpcodesXEC["OP_NOP10"] = 185] = "OP_NOP10";
  OpcodesXEC[OpcodesXEC["OP_CHECKDATASIG"] = 186] = "OP_CHECKDATASIG";
  OpcodesXEC[OpcodesXEC["OP_CHECKDATASIGVERIFY"] = 187] = "OP_CHECKDATASIGVERIFY";
  OpcodesXEC[OpcodesXEC["OP_REVERSEBYTES"] = 188] = "OP_REVERSEBYTES";
  OpcodesXEC[OpcodesXEC["OP_UNKNOWN189"] = 189] = "OP_UNKNOWN189";
  OpcodesXEC[OpcodesXEC["OP_UNKNOWN190"] = 190] = "OP_UNKNOWN190";
  OpcodesXEC[OpcodesXEC["OP_UNKNOWN191"] = 191] = "OP_UNKNOWN191";
  OpcodesXEC[OpcodesXEC["OP_UNKNOWN192"] = 192] = "OP_UNKNOWN192";
  OpcodesXEC[OpcodesXEC["OP_UNKNOWN193"] = 193] = "OP_UNKNOWN193";
  OpcodesXEC[OpcodesXEC["OP_UNKNOWN194"] = 194] = "OP_UNKNOWN194";
  OpcodesXEC[OpcodesXEC["OP_UNKNOWN195"] = 195] = "OP_UNKNOWN195";
  OpcodesXEC[OpcodesXEC["OP_UNKNOWN196"] = 196] = "OP_UNKNOWN196";
  OpcodesXEC[OpcodesXEC["OP_UNKNOWN197"] = 197] = "OP_UNKNOWN197";
  OpcodesXEC[OpcodesXEC["OP_UNKNOWN198"] = 198] = "OP_UNKNOWN198";
  OpcodesXEC[OpcodesXEC["OP_UNKNOWN199"] = 199] = "OP_UNKNOWN199";
  OpcodesXEC[OpcodesXEC["OP_UNKNOWN200"] = 200] = "OP_UNKNOWN200";
  OpcodesXEC[OpcodesXEC["OP_UNKNOWN201"] = 201] = "OP_UNKNOWN201";
  OpcodesXEC[OpcodesXEC["OP_UNKNOWN202"] = 202] = "OP_UNKNOWN202";
  OpcodesXEC[OpcodesXEC["OP_UNKNOWN203"] = 203] = "OP_UNKNOWN203";
  OpcodesXEC[OpcodesXEC["OP_UNKNOWN204"] = 204] = "OP_UNKNOWN204";
  OpcodesXEC[OpcodesXEC["OP_UNKNOWN205"] = 205] = "OP_UNKNOWN205";
  OpcodesXEC[OpcodesXEC["OP_UNKNOWN206"] = 206] = "OP_UNKNOWN206";
  OpcodesXEC[OpcodesXEC["OP_UNKNOWN207"] = 207] = "OP_UNKNOWN207";
  OpcodesXEC[OpcodesXEC["OP_UNKNOWN208"] = 208] = "OP_UNKNOWN208";
  OpcodesXEC[OpcodesXEC["OP_UNKNOWN209"] = 209] = "OP_UNKNOWN209";
  OpcodesXEC[OpcodesXEC["OP_UNKNOWN210"] = 210] = "OP_UNKNOWN210";
  OpcodesXEC[OpcodesXEC["OP_UNKNOWN211"] = 211] = "OP_UNKNOWN211";
  OpcodesXEC[OpcodesXEC["OP_UNKNOWN212"] = 212] = "OP_UNKNOWN212";
  OpcodesXEC[OpcodesXEC["OP_UNKNOWN213"] = 213] = "OP_UNKNOWN213";
  OpcodesXEC[OpcodesXEC["OP_UNKNOWN214"] = 214] = "OP_UNKNOWN214";
  OpcodesXEC[OpcodesXEC["OP_UNKNOWN215"] = 215] = "OP_UNKNOWN215";
  OpcodesXEC[OpcodesXEC["OP_UNKNOWN216"] = 216] = "OP_UNKNOWN216";
  OpcodesXEC[OpcodesXEC["OP_UNKNOWN217"] = 217] = "OP_UNKNOWN217";
  OpcodesXEC[OpcodesXEC["OP_UNKNOWN218"] = 218] = "OP_UNKNOWN218";
  OpcodesXEC[OpcodesXEC["OP_UNKNOWN219"] = 219] = "OP_UNKNOWN219";
  OpcodesXEC[OpcodesXEC["OP_UNKNOWN220"] = 220] = "OP_UNKNOWN220";
  OpcodesXEC[OpcodesXEC["OP_UNKNOWN221"] = 221] = "OP_UNKNOWN221";
  OpcodesXEC[OpcodesXEC["OP_UNKNOWN222"] = 222] = "OP_UNKNOWN222";
  OpcodesXEC[OpcodesXEC["OP_UNKNOWN223"] = 223] = "OP_UNKNOWN223";
  OpcodesXEC[OpcodesXEC["OP_UNKNOWN224"] = 224] = "OP_UNKNOWN224";
  OpcodesXEC[OpcodesXEC["OP_UNKNOWN225"] = 225] = "OP_UNKNOWN225";
  OpcodesXEC[OpcodesXEC["OP_UNKNOWN226"] = 226] = "OP_UNKNOWN226";
  OpcodesXEC[OpcodesXEC["OP_UNKNOWN227"] = 227] = "OP_UNKNOWN227";
  OpcodesXEC[OpcodesXEC["OP_UNKNOWN228"] = 228] = "OP_UNKNOWN228";
  OpcodesXEC[OpcodesXEC["OP_UNKNOWN229"] = 229] = "OP_UNKNOWN229";
  OpcodesXEC[OpcodesXEC["OP_UNKNOWN230"] = 230] = "OP_UNKNOWN230";
  OpcodesXEC[OpcodesXEC["OP_UNKNOWN231"] = 231] = "OP_UNKNOWN231";
  OpcodesXEC[OpcodesXEC["OP_UNKNOWN232"] = 232] = "OP_UNKNOWN232";
  OpcodesXEC[OpcodesXEC["OP_UNKNOWN233"] = 233] = "OP_UNKNOWN233";
  OpcodesXEC[OpcodesXEC["OP_UNKNOWN234"] = 234] = "OP_UNKNOWN234";
  OpcodesXEC[OpcodesXEC["OP_UNKNOWN235"] = 235] = "OP_UNKNOWN235";
  OpcodesXEC[OpcodesXEC["OP_UNKNOWN236"] = 236] = "OP_UNKNOWN236";
  OpcodesXEC[OpcodesXEC["OP_UNKNOWN237"] = 237] = "OP_UNKNOWN237";
  OpcodesXEC[OpcodesXEC["OP_UNKNOWN238"] = 238] = "OP_UNKNOWN238";
  OpcodesXEC[OpcodesXEC["OP_UNKNOWN239"] = 239] = "OP_UNKNOWN239";
  OpcodesXEC[OpcodesXEC["OP_UNKNOWN240"] = 240] = "OP_UNKNOWN240";
  OpcodesXEC[OpcodesXEC["OP_UNKNOWN241"] = 241] = "OP_UNKNOWN241";
  OpcodesXEC[OpcodesXEC["OP_UNKNOWN242"] = 242] = "OP_UNKNOWN242";
  OpcodesXEC[OpcodesXEC["OP_UNKNOWN243"] = 243] = "OP_UNKNOWN243";
  OpcodesXEC[OpcodesXEC["OP_UNKNOWN244"] = 244] = "OP_UNKNOWN244";
  OpcodesXEC[OpcodesXEC["OP_UNKNOWN245"] = 245] = "OP_UNKNOWN245";
  OpcodesXEC[OpcodesXEC["OP_UNKNOWN246"] = 246] = "OP_UNKNOWN246";
  OpcodesXEC[OpcodesXEC["OP_UNKNOWN247"] = 247] = "OP_UNKNOWN247";
  OpcodesXEC[OpcodesXEC["OP_UNKNOWN248"] = 248] = "OP_UNKNOWN248";
  OpcodesXEC[OpcodesXEC["OP_UNKNOWN249"] = 249] = "OP_UNKNOWN249";
  OpcodesXEC[OpcodesXEC["OP_UNKNOWN250"] = 250] = "OP_UNKNOWN250";
  OpcodesXEC[OpcodesXEC["OP_UNKNOWN251"] = 251] = "OP_UNKNOWN251";
  OpcodesXEC[OpcodesXEC["OP_UNKNOWN252"] = 252] = "OP_UNKNOWN252";
  OpcodesXEC[OpcodesXEC["OP_UNKNOWN253"] = 253] = "OP_UNKNOWN253";
  OpcodesXEC[OpcodesXEC["OP_UNKNOWN254"] = 254] = "OP_UNKNOWN254";
  OpcodesXEC[OpcodesXEC["OP_UNKNOWN255"] = 255] = "OP_UNKNOWN255";
})(OpcodesXEC || (OpcodesXEC = {}));

/**
 * Initialize a virtual machine using the XEC instruction set.
 *
 * @param standard - If `true`, the additional `isStandard` validations will be
 * enabled. Transactions that fail these rules are often called "non-standard"
 * and can technically be included by miners in valid blocks, but most network
 * nodes will refuse to relay them. (Default: `true`)
 */
var createVirtualMachineXEC = function createVirtualMachineXEC() {
  var standard = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
  return createAuthenticationVirtualMachine(createInstructionSetXEC(standard));
};

var bitcoinSatoshiOpcodes = Object.entries(generateBytecodeMap(OpcodesXEC)).reduce(function (acc, cur) {
  return _objectSpread2(_objectSpread2({}, acc), {}, _defineProperty({}, cur[0].slice('OP_'.length), cur[1]));
}, {
  PUSHDATA1: Uint8Array.of(OpcodesXEC.OP_PUSHDATA_1),
  PUSHDATA2: Uint8Array.of(OpcodesXEC.OP_PUSHDATA_2),
  PUSHDATA4: Uint8Array.of(OpcodesXEC.OP_PUSHDATA_4) // eslint-disable-line @typescript-eslint/naming-convention
});
/**
 * Convert a string from the Satoshi implementation's `script_tests.json`
 * text-format to bytecode. The string must be valid – this method attempts to
 * convert all unmatched tokens to `BigInt`s.
 *
 * @privateRemarks
 * This method doesn't use {@link compileScript} because of a slight
 * incompatibility in the languages. In CashAssembly, BigIntLiterals are a
 * primitive type, and must be surrounded by a push statement (e.g. `<100>`) to
 * push a number to the stack. In the `script_tests.json` text-format, numbers
 * are assumed to be pushed. We could implement a transformation after the
 * compiler's parse step, but because this format doesn't require any other
 * features of the compiler, we opt to implement this as a simple method.
 * @param satoshiScript - the script in the Satoshi implementation's
 * `script_tests.json` text format
 */
var assembleBitcoinSatoshiScript = function assembleBitcoinSatoshiScript(satoshiScript) {
  return flattenBinArray(satoshiScript.split(' ').filter(function (token) {
    return token !== '';
  }).map(function (token) {
    return token.startsWith('0x') ? hexToBin(token.slice('0x'.length)) : token.startsWith("'") ? encodeDataPush(utf8ToBin(token.slice(1, token.length - 1))) : bitcoinSatoshiOpcodes[token] === undefined ? encodeDataPush(bigIntToVmNumber(BigInt(token))) : bitcoinSatoshiOpcodes[token];
  }));
};

var OpcodeDescriptionsBCH2022;
(function (OpcodeDescriptionsBCH2022) {
  OpcodeDescriptionsBCH2022["OP_0"] = "Push the VM Number 0 onto the stack.";
  OpcodeDescriptionsBCH2022["OP_PUSHBYTES_1"] = "Push the next byte onto the stack.";
  OpcodeDescriptionsBCH2022["OP_PUSHBYTES_2"] = "Push the next 2 bytes onto the stack.";
  OpcodeDescriptionsBCH2022["OP_PUSHBYTES_3"] = "Push the next 3 bytes onto the stack.";
  OpcodeDescriptionsBCH2022["OP_PUSHBYTES_4"] = "Push the next 4 bytes onto the stack.";
  OpcodeDescriptionsBCH2022["OP_PUSHBYTES_5"] = "Push the next 5 bytes onto the stack.";
  OpcodeDescriptionsBCH2022["OP_PUSHBYTES_6"] = "Push the next 6 bytes onto the stack.";
  OpcodeDescriptionsBCH2022["OP_PUSHBYTES_7"] = "Push the next 7 bytes onto the stack.";
  OpcodeDescriptionsBCH2022["OP_PUSHBYTES_8"] = "Push the next 8 bytes onto the stack.";
  OpcodeDescriptionsBCH2022["OP_PUSHBYTES_9"] = "Push the next 9 bytes onto the stack.";
  OpcodeDescriptionsBCH2022["OP_PUSHBYTES_10"] = "Push the next 10 bytes onto the stack.";
  OpcodeDescriptionsBCH2022["OP_PUSHBYTES_11"] = "Push the next 11 bytes onto the stack.";
  OpcodeDescriptionsBCH2022["OP_PUSHBYTES_12"] = "Push the next 12 bytes onto the stack.";
  OpcodeDescriptionsBCH2022["OP_PUSHBYTES_13"] = "Push the next 13 bytes onto the stack.";
  OpcodeDescriptionsBCH2022["OP_PUSHBYTES_14"] = "Push the next 14 bytes onto the stack.";
  OpcodeDescriptionsBCH2022["OP_PUSHBYTES_15"] = "Push the next 15 bytes onto the stack.";
  OpcodeDescriptionsBCH2022["OP_PUSHBYTES_16"] = "Push the next 16 bytes onto the stack.";
  OpcodeDescriptionsBCH2022["OP_PUSHBYTES_17"] = "Push the next 17 bytes onto the stack.";
  OpcodeDescriptionsBCH2022["OP_PUSHBYTES_18"] = "Push the next 18 bytes onto the stack.";
  OpcodeDescriptionsBCH2022["OP_PUSHBYTES_19"] = "Push the next 19 bytes onto the stack.";
  OpcodeDescriptionsBCH2022["OP_PUSHBYTES_20"] = "Push the next 20 bytes onto the stack.";
  OpcodeDescriptionsBCH2022["OP_PUSHBYTES_21"] = "Push the next 21 bytes onto the stack.";
  OpcodeDescriptionsBCH2022["OP_PUSHBYTES_22"] = "Push the next 22 bytes onto the stack.";
  OpcodeDescriptionsBCH2022["OP_PUSHBYTES_23"] = "Push the next 23 bytes onto the stack.";
  OpcodeDescriptionsBCH2022["OP_PUSHBYTES_24"] = "Push the next 24 bytes onto the stack.";
  OpcodeDescriptionsBCH2022["OP_PUSHBYTES_25"] = "Push the next 25 bytes onto the stack.";
  OpcodeDescriptionsBCH2022["OP_PUSHBYTES_26"] = "Push the next 26 bytes onto the stack.";
  OpcodeDescriptionsBCH2022["OP_PUSHBYTES_27"] = "Push the next 27 bytes onto the stack.";
  OpcodeDescriptionsBCH2022["OP_PUSHBYTES_28"] = "Push the next 28 bytes onto the stack.";
  OpcodeDescriptionsBCH2022["OP_PUSHBYTES_29"] = "Push the next 29 bytes onto the stack.";
  OpcodeDescriptionsBCH2022["OP_PUSHBYTES_30"] = "Push the next 30 bytes onto the stack.";
  OpcodeDescriptionsBCH2022["OP_PUSHBYTES_31"] = "Push the next 31 bytes onto the stack.";
  OpcodeDescriptionsBCH2022["OP_PUSHBYTES_32"] = "Push the next 32 bytes onto the stack.";
  OpcodeDescriptionsBCH2022["OP_PUSHBYTES_33"] = "Push the next 33 bytes onto the stack.";
  OpcodeDescriptionsBCH2022["OP_PUSHBYTES_34"] = "Push the next 34 bytes onto the stack.";
  OpcodeDescriptionsBCH2022["OP_PUSHBYTES_35"] = "Push the next 35 bytes onto the stack.";
  OpcodeDescriptionsBCH2022["OP_PUSHBYTES_36"] = "Push the next 36 bytes onto the stack.";
  OpcodeDescriptionsBCH2022["OP_PUSHBYTES_37"] = "Push the next 37 bytes onto the stack.";
  OpcodeDescriptionsBCH2022["OP_PUSHBYTES_38"] = "Push the next 38 bytes onto the stack.";
  OpcodeDescriptionsBCH2022["OP_PUSHBYTES_39"] = "Push the next 39 bytes onto the stack.";
  OpcodeDescriptionsBCH2022["OP_PUSHBYTES_40"] = "Push the next 40 bytes onto the stack.";
  OpcodeDescriptionsBCH2022["OP_PUSHBYTES_41"] = "Push the next 41 bytes onto the stack.";
  OpcodeDescriptionsBCH2022["OP_PUSHBYTES_42"] = "Push the next 42 bytes onto the stack.";
  OpcodeDescriptionsBCH2022["OP_PUSHBYTES_43"] = "Push the next 43 bytes onto the stack.";
  OpcodeDescriptionsBCH2022["OP_PUSHBYTES_44"] = "Push the next 44 bytes onto the stack.";
  OpcodeDescriptionsBCH2022["OP_PUSHBYTES_45"] = "Push the next 45 bytes onto the stack.";
  OpcodeDescriptionsBCH2022["OP_PUSHBYTES_46"] = "Push the next 46 bytes onto the stack.";
  OpcodeDescriptionsBCH2022["OP_PUSHBYTES_47"] = "Push the next 47 bytes onto the stack.";
  OpcodeDescriptionsBCH2022["OP_PUSHBYTES_48"] = "Push the next 48 bytes onto the stack.";
  OpcodeDescriptionsBCH2022["OP_PUSHBYTES_49"] = "Push the next 49 bytes onto the stack.";
  OpcodeDescriptionsBCH2022["OP_PUSHBYTES_50"] = "Push the next 50 bytes onto the stack.";
  OpcodeDescriptionsBCH2022["OP_PUSHBYTES_51"] = "Push the next 51 bytes onto the stack.";
  OpcodeDescriptionsBCH2022["OP_PUSHBYTES_52"] = "Push the next 52 bytes onto the stack.";
  OpcodeDescriptionsBCH2022["OP_PUSHBYTES_53"] = "Push the next 53 bytes onto the stack.";
  OpcodeDescriptionsBCH2022["OP_PUSHBYTES_54"] = "Push the next 54 bytes onto the stack.";
  OpcodeDescriptionsBCH2022["OP_PUSHBYTES_55"] = "Push the next 55 bytes onto the stack.";
  OpcodeDescriptionsBCH2022["OP_PUSHBYTES_56"] = "Push the next 56 bytes onto the stack.";
  OpcodeDescriptionsBCH2022["OP_PUSHBYTES_57"] = "Push the next 57 bytes onto the stack.";
  OpcodeDescriptionsBCH2022["OP_PUSHBYTES_58"] = "Push the next 58 bytes onto the stack.";
  OpcodeDescriptionsBCH2022["OP_PUSHBYTES_59"] = "Push the next 59 bytes onto the stack.";
  OpcodeDescriptionsBCH2022["OP_PUSHBYTES_60"] = "Push the next 60 bytes onto the stack.";
  OpcodeDescriptionsBCH2022["OP_PUSHBYTES_61"] = "Push the next 61 bytes onto the stack.";
  OpcodeDescriptionsBCH2022["OP_PUSHBYTES_62"] = "Push the next 62 bytes onto the stack.";
  OpcodeDescriptionsBCH2022["OP_PUSHBYTES_63"] = "Push the next 63 bytes onto the stack.";
  OpcodeDescriptionsBCH2022["OP_PUSHBYTES_64"] = "Push the next 64 bytes onto the stack.";
  OpcodeDescriptionsBCH2022["OP_PUSHBYTES_65"] = "Push the next 65 bytes onto the stack.";
  OpcodeDescriptionsBCH2022["OP_PUSHBYTES_66"] = "Push the next 66 bytes onto the stack.";
  OpcodeDescriptionsBCH2022["OP_PUSHBYTES_67"] = "Push the next 67 bytes onto the stack.";
  OpcodeDescriptionsBCH2022["OP_PUSHBYTES_68"] = "Push the next 68 bytes onto the stack.";
  OpcodeDescriptionsBCH2022["OP_PUSHBYTES_69"] = "Push the next 69 bytes onto the stack.";
  OpcodeDescriptionsBCH2022["OP_PUSHBYTES_70"] = "Push the next 70 bytes onto the stack.";
  OpcodeDescriptionsBCH2022["OP_PUSHBYTES_71"] = "Push the next 71 bytes onto the stack.";
  OpcodeDescriptionsBCH2022["OP_PUSHBYTES_72"] = "Push the next 72 bytes onto the stack.";
  OpcodeDescriptionsBCH2022["OP_PUSHBYTES_73"] = "Push the next 73 bytes onto the stack.";
  OpcodeDescriptionsBCH2022["OP_PUSHBYTES_74"] = "Push the next 74 bytes onto the stack.";
  OpcodeDescriptionsBCH2022["OP_PUSHBYTES_75"] = "Push the next 75 bytes onto the stack.";
  OpcodeDescriptionsBCH2022["OP_PUSHDATA_1"] = "Read the next Uint8 and push that number of bytes onto the stack.";
  OpcodeDescriptionsBCH2022["OP_PUSHDATA_2"] = "Read the next little-endian Uint16 and push that number of bytes onto the stack.";
  OpcodeDescriptionsBCH2022["OP_PUSHDATA_4"] = "Read the next little-endian Uint32 and push that number of bytes onto the stack.";
  OpcodeDescriptionsBCH2022["OP_1NEGATE"] = "Push the VM Number -1 onto the stack.";
  OpcodeDescriptionsBCH2022["OP_RESERVED"] = "Error unless found in an unexecuted conditional branch. Note: OP_RESERVED does not count toward the opcode limit.";
  OpcodeDescriptionsBCH2022["OP_1"] = "Push a 1 (VM Number) onto the stack.";
  OpcodeDescriptionsBCH2022["OP_2"] = "Push a 2 (VM Number) onto the stack.";
  OpcodeDescriptionsBCH2022["OP_3"] = "Push a 3 (VM Number) onto the stack.";
  OpcodeDescriptionsBCH2022["OP_4"] = "Push a 4 (VM Number) onto the stack.";
  OpcodeDescriptionsBCH2022["OP_5"] = "Push a 5 (VM Number) onto the stack.";
  OpcodeDescriptionsBCH2022["OP_6"] = "Push a 6 (VM Number) onto the stack.";
  OpcodeDescriptionsBCH2022["OP_7"] = "Push a 7 (VM Number) onto the stack.";
  OpcodeDescriptionsBCH2022["OP_8"] = "Push a 8 (VM Number) onto the stack.";
  OpcodeDescriptionsBCH2022["OP_9"] = "Push a 9 (VM Number) onto the stack.";
  OpcodeDescriptionsBCH2022["OP_10"] = "Push a 10 (VM Number) onto the stack.";
  OpcodeDescriptionsBCH2022["OP_11"] = "Push a 11 (VM Number) onto the stack.";
  OpcodeDescriptionsBCH2022["OP_12"] = "Push a 12 (VM Number) onto the stack.";
  OpcodeDescriptionsBCH2022["OP_13"] = "Push a 13 (VM Number) onto the stack.";
  OpcodeDescriptionsBCH2022["OP_14"] = "Push a 14 (VM Number) onto the stack.";
  OpcodeDescriptionsBCH2022["OP_15"] = "Push a 15 (VM Number) onto the stack.";
  OpcodeDescriptionsBCH2022["OP_16"] = "Push a 16 (VM Number) onto the stack.";
  OpcodeDescriptionsBCH2022["OP_NOP"] = "No operation. Note: OP_NOP counts toward the opcode limit.";
  OpcodeDescriptionsBCH2022["OP_VER"] = "Error unless found in an unexecuted conditional branch. Note: OP_VER counts toward the opcode limit. (Historically, this pushed a protocol version number to the stack.)";
  OpcodeDescriptionsBCH2022["OP_IF"] = "Pop the top item from the stack. If it is not \"truthy\", skip evaluation until a matching OP_ELSE or OP_ENDIF.";
  OpcodeDescriptionsBCH2022["OP_NOTIF"] = "Pop the top item from the stack. If it is \"truthy\", skip evaluation until a matching OP_ELSE or OP_ENDIF.";
  OpcodeDescriptionsBCH2022["OP_VERIF"] = "Error, even when found in an unexecuted conditional branch. (Historically, this was a combination of OP_VER and OP_IF.)";
  OpcodeDescriptionsBCH2022["OP_VERNOTIF"] = "Error, even when found in an unexecuted conditional branch. (Historically, this was a combination of OP_VER and OP_NOTIF.)";
  OpcodeDescriptionsBCH2022["OP_ELSE"] = "Invert conditional evaluation within the current OP_IF ... OP_ENDIF block. (If evaluation is enabled, disable it, if it is disabled, enable it.)";
  OpcodeDescriptionsBCH2022["OP_ENDIF"] = "End the current OP_IF/OP_NOTIF ... OP_ENDIF block.";
  OpcodeDescriptionsBCH2022["OP_VERIFY"] = "Pop the top item from the stack and error if it isn't \"truthy\".";
  OpcodeDescriptionsBCH2022["OP_RETURN"] = "Error when executed.";
  OpcodeDescriptionsBCH2022["OP_TOALTSTACK"] = "Pop the top item from the stack and push it onto the alternate stack.";
  OpcodeDescriptionsBCH2022["OP_FROMALTSTACK"] = "Pop the top item from the alternate stack and push it onto the stack.";
  OpcodeDescriptionsBCH2022["OP_2DROP"] = "Pop the top 2 items from the stack and discard them.";
  OpcodeDescriptionsBCH2022["OP_2DUP"] = "Duplicate the top 2 items on the stack. (E.g. [a, b] -> [a, b, a, b])";
  OpcodeDescriptionsBCH2022["OP_3DUP"] = "Duplicate the top 3 items on the stack. (E.g. [a, b, c] -> [a, b, c, a, b, c])";
  OpcodeDescriptionsBCH2022["OP_2OVER"] = "Duplicate the 2 items beginning at a depth of 2 on the stack. (E.g. [a, b, c, d] -> [a, b, c, d, a, b])";
  OpcodeDescriptionsBCH2022["OP_2ROT"] = "Rotate the top 6 items on the stack, bringing the fifth and sixth items to the top. (E.g. [a, b, c, d, e, f] -> [c, d, e, f, a, b])";
  OpcodeDescriptionsBCH2022["OP_2SWAP"] = "Swap the positions of the top two pairs of items on the stack. (E.g. [a, b, c, d] -> [c, d, a, b])";
  OpcodeDescriptionsBCH2022["OP_IFDUP"] = "If the top item on the stack is \"truthy\", duplicate it.";
  OpcodeDescriptionsBCH2022["OP_DEPTH"] = "Push the current number of stack items as a VM Number.";
  OpcodeDescriptionsBCH2022["OP_DROP"] = "Pop the top item from the stack and discard it. (E.g. [a] -> [])";
  OpcodeDescriptionsBCH2022["OP_DUP"] = "Duplicate the top item on the stack. (E.g. [a] -> [a, a])";
  OpcodeDescriptionsBCH2022["OP_NIP"] = "Remove the second-to-top item from the stack. (E.g. [a, b] -> [b])";
  OpcodeDescriptionsBCH2022["OP_OVER"] = "Duplicate the second-to-top item on the stack. (E.g. [a, b] -> [a, b, a])";
  OpcodeDescriptionsBCH2022["OP_PICK"] = "Pop the top item from the stack as a VM Number. Duplicate the item at that depth (zero-indexed), placing it on top of the stack. (E.g. [a, b, c, 2] -> [a, b, c, a])";
  OpcodeDescriptionsBCH2022["OP_ROLL"] = "Pop the top item from the stack as a VM Number. Move the item at that depth (zero-indexed) to the top of the stack. (E.g. [a, b, c, 2] -> [b, c, a])";
  OpcodeDescriptionsBCH2022["OP_ROT"] = "Rotate the top 3 items on the stack, bringing the third item to the top. (E.g. [a, b, c] -> [b, c, a])";
  OpcodeDescriptionsBCH2022["OP_SWAP"] = "Swap the top two items on the stack. (E.g. [a, b] -> [b, a])";
  OpcodeDescriptionsBCH2022["OP_TUCK"] = "Duplicate the item at the top of the stack, inserting it below the second-to-top item. (E.g. [a, b] -> [b, a, b])";
  OpcodeDescriptionsBCH2022["OP_CAT"] = "Pop the top 2 items from the stack and concatenate them, pushing the result.";
  OpcodeDescriptionsBCH2022["OP_SPLIT"] = "Pop the top item from the stack as an index (VM Number) and the next item as a byte array. Split the byte array into two stack items at the index (zero-based), pushing the results.";
  OpcodeDescriptionsBCH2022["OP_NUM2BIN"] = "Pop the top item from the stack as an item length (VM Number) and the next item as a VM Number (without encoding restrictions). Re-encode the number using a byte array of the provided length, filling any unused bytes with zeros, then push the result. (If the requested length is too short to encode the number, error.)";
  OpcodeDescriptionsBCH2022["OP_BIN2NUM"] = "Pop the top item from the stack as a VM Number without encoding restrictions. Minimally-encode the number and push the result. (If the number can't be encoded in 4 bytes or less, error.)";
  OpcodeDescriptionsBCH2022["OP_SIZE"] = "Push the byte-length of the top stack item as a VM Number.";
  OpcodeDescriptionsBCH2022["OP_INVERT"] = "Error, even when found in an unexecuted conditional branch. (Historically, this flipped all the bits in a stack item.)";
  OpcodeDescriptionsBCH2022["OP_AND"] = "Pop the top 2 items from the stack and perform a bitwise AND on each byte, pushing the result. If the length of the items are not equal, error.";
  OpcodeDescriptionsBCH2022["OP_OR"] = "Pop the top 2 items from the stack and perform a bitwise OR on each byte, pushing the result. If the length of the items are not equal, error.";
  OpcodeDescriptionsBCH2022["OP_XOR"] = "Pop the top 2 items from the stack and perform a bitwise XOR on each byte, pushing the result. If the length of the items are not equal, error.";
  OpcodeDescriptionsBCH2022["OP_EQUAL"] = "Pop the top two items from the stack and compare them byte-by-byte. If they are the same, push a 1 (VM Number), otherwise push a 0 (VM Number).";
  OpcodeDescriptionsBCH2022["OP_EQUALVERIFY"] = "Pop the top two items from the stack and compare them byte-by-byte. If the values are different, error. (This operation is a combination of OP_EQUAL followed by OP_VERIFY.)";
  OpcodeDescriptionsBCH2022["OP_RESERVED1"] = "Error unless found in an unexecuted conditional branch. Note: OP_RESERVED1 counts toward the opcode limit.";
  OpcodeDescriptionsBCH2022["OP_RESERVED2"] = "Error unless found in an unexecuted conditional branch. Note: OP_RESERVED2 counts toward the opcode limit.";
  OpcodeDescriptionsBCH2022["OP_1ADD"] = "Pop the top item from the stack as a VM Number, add 1, then push the result.";
  OpcodeDescriptionsBCH2022["OP_1SUB"] = "Pop the top item from the stack as a VM Number, subtract 1, then push the result.";
  OpcodeDescriptionsBCH2022["OP_2MUL"] = "Error, even when found in an unexecuted conditional branch. (Historically, this multiplied a VM Number by 2.)";
  OpcodeDescriptionsBCH2022["OP_2DIV"] = "Error, even when found in an unexecuted conditional branch. (Historically, this divided a VM Number by 2.)";
  OpcodeDescriptionsBCH2022["OP_NEGATE"] = "Pop the top item from the stack as a VM Number, negate it, then push the result.";
  OpcodeDescriptionsBCH2022["OP_ABS"] = "Pop the top item from the stack as a VM Number, take its absolute value, then push the result.";
  OpcodeDescriptionsBCH2022["OP_NOT"] = "Pop the top item from the stack as a VM Number. If its value is 0, push a 1 (VM Number), otherwise, push a 0 (VM Number).";
  OpcodeDescriptionsBCH2022["OP_0NOTEQUAL"] = "Pop the top item from the stack as a VM Number. If its value is not 0, push a 1 (VM Number), otherwise, push a 0 (VM Number).";
  OpcodeDescriptionsBCH2022["OP_ADD"] = "Pop the top two items from the stack as VM Numbers. Add them, then push the result.";
  OpcodeDescriptionsBCH2022["OP_SUB"] = "Pop the top two items from the stack as VM Numbers. Subtract the top item from the second item, then push the result.";
  OpcodeDescriptionsBCH2022["OP_MUL"] = "Pop the top two items from the stack as VM Numbers. Multiply them, then push the result.";
  OpcodeDescriptionsBCH2022["OP_DIV"] = "Pop the top item from the stack as a denominator (VM Number) and the next as a numerator (VM Number). Divide and push the result to the stack.";
  OpcodeDescriptionsBCH2022["OP_MOD"] = "Pop the top item from the stack as a denominator (VM Number) and the next as a numerator (VM Number). Divide and push the remainder to the stack.";
  OpcodeDescriptionsBCH2022["OP_LSHIFT"] = "Error, even when found in an unexecuted conditional branch. (Historically, this performed a sign-preserving, left bit shift.)";
  OpcodeDescriptionsBCH2022["OP_RSHIFT"] = "Error, even when found in an unexecuted conditional branch. (Historically, this performed a sign-preserving, right bit shift.)";
  OpcodeDescriptionsBCH2022["OP_BOOLAND"] = "Pop the top two items from the stack as VM Numbers. If neither value is a 0 (VM Number), push a 1 (VM Number). Otherwise, push a 0 (VM Number).";
  OpcodeDescriptionsBCH2022["OP_BOOLOR"] = "Pop the top two items from the stack as VM Numbers. If either value is a 1 (VM Number), push a 1 (VM Number). Otherwise, push a 0 (VM Number).";
  OpcodeDescriptionsBCH2022["OP_NUMEQUAL"] = "Pop the top two items from the stack as VM Numbers. If the values are equal, push a 1 (VM Number). Otherwise, push a 0 (VM Number).";
  OpcodeDescriptionsBCH2022["OP_NUMEQUALVERIFY"] = "Pop the top two items from the stack as VM Numbers. If the values are different, error. (This operation is a combination of OP_NUMEQUAL followed by OP_VERIFY.)";
  OpcodeDescriptionsBCH2022["OP_NUMNOTEQUAL"] = "Pop the top two items from the stack as VM Numbers. If the values are not equal, push a 1 (VM Number). Otherwise, push a 0 (VM Number).";
  OpcodeDescriptionsBCH2022["OP_LESSTHAN"] = "Pop the top two items from the stack as VM Numbers. If the second item is less than top item, push a 1 (VM Number). Otherwise, push a 0 (VM Number).";
  OpcodeDescriptionsBCH2022["OP_GREATERTHAN"] = "Pop the top two items from the stack as VM Numbers. If the second item is greater than top item, push a 1 (VM Number). Otherwise, push a 0 (VM Number).";
  OpcodeDescriptionsBCH2022["OP_LESSTHANOREQUAL"] = "Pop the top two items from the stack as VM Numbers. If the second item is less than or equal to the top item, push a 1 (VM Number). Otherwise, push a 0 (VM Number).";
  OpcodeDescriptionsBCH2022["OP_GREATERTHANOREQUAL"] = "Pop the top two items from the stack as VM Numbers. If the second item is greater than or equal to the top item, push a 1 (VM Number). Otherwise, push a 0 (VM Number).";
  OpcodeDescriptionsBCH2022["OP_MIN"] = "Pop the top two items from the stack as VM Numbers. Push the smaller of the two numbers.";
  OpcodeDescriptionsBCH2022["OP_MAX"] = "Pop the top two items from the stack as VM Numbers. Push the larger of the two numbers.";
  OpcodeDescriptionsBCH2022["OP_WITHIN"] = "Pop the top three items from the stack as VM Numbers. If the top number is within the range defined by the following two numbers (left-inclusive), push a 1 (VM Number). Otherwise, push a 0 (VM Number). (E.g. for [a, b, c]: if (b <= a), and (a < c), [1]. Else [0].)";
  OpcodeDescriptionsBCH2022["OP_RIPEMD160"] = "Pop the top item from the stack and pass it through ripemd160, pushing the result onto the stack.";
  OpcodeDescriptionsBCH2022["OP_SHA1"] = "Pop the top item from the stack and pass it through sha1, pushing the result onto the stack.";
  OpcodeDescriptionsBCH2022["OP_SHA256"] = "Pop the top item from the stack and pass it through sha256, pushing the result onto the stack.";
  OpcodeDescriptionsBCH2022["OP_HASH160"] = "Pop the top item from the stack and pass it through sha256, then ripemd160, pushing the result onto the stack.";
  OpcodeDescriptionsBCH2022["OP_HASH256"] = "Pop the top item from the stack and pass it through sha256 twice, pushing the result onto the stack.";
  OpcodeDescriptionsBCH2022["OP_CODESEPARATOR"] = "Update the value of lastCodeSeparator to the instruction pointer's current value. (This reduces the coverage of signing serializations used in signature verification operations.)";
  OpcodeDescriptionsBCH2022["OP_CHECKSIG"] = "Pop the top two items from the stack. Treat the top as a signature and the second as a public key. If the signature is valid, push a 1 (VM Number), otherwise push a 0 (VM Number).";
  OpcodeDescriptionsBCH2022["OP_CHECKSIGVERIFY"] = "Pop the top two items from the stack. Treat the top as a signature and the second as a public key. If the signature is not valid, error. (This operation is a combination of OP_CHECKSIG followed by OP_VERIFY.)";
  OpcodeDescriptionsBCH2022["OP_CHECKMULTISIG"] = "Pop items from the stack: first pop the VM Number of public keys, then pop each of those public keys. Next, pop the VM Number of required signatures, then pop each of those signatures. Finally, pop a final VM Number that must be 0 due to a protocol bug. Checking each signature against each public key in order, if all signatures are valid \u2013 and the required number of signatures have been provided \u2013 push a 1 (VM Number), otherwise push a 0 (VM Number).";
  OpcodeDescriptionsBCH2022["OP_CHECKMULTISIGVERIFY"] = "Pop items from the stack: first pop the VM Number of public keys, then pop each of those public keys. Next, pop the VM Number of required signatures, then pop each of those signatures. Finally, (due to a protocol bug) pop an unused final VM Number that must be 0. Checking each signature against each public key in order, if any signatures are invalid \u2013 or the required number of signatures have not been provided \u2013 error. (This operation is a combination of OP_CHECKMULTISIG followed by OP_VERIFY.)";
  OpcodeDescriptionsBCH2022["OP_NOP1"] = "No operation (reserved for future expansion). Note: OP_NOP1 counts toward the opcode limit.";
  OpcodeDescriptionsBCH2022["OP_CHECKLOCKTIMEVERIFY"] = "Verify the transaction occurs after an absolute block time or height: read the top item on the stack as a VM Number (without removing it), and compare it to the transaction's locktime. If the required locktime has not passed, or if locktime has been disabled for this input by a maximized sequence number, error.";
  OpcodeDescriptionsBCH2022["OP_CHECKSEQUENCEVERIFY"] = "Verify the transaction occurs after the output being spent has \"aged\" by a relative block time or block height since it was created: read the top item on the stack as a VM Number (without removing it), and compare it to the age encoded in the input's sequence number. If the required relative locktime has not passed, or if relative locktime has been disabled by the sequence number or the transaction version, error.";
  OpcodeDescriptionsBCH2022["OP_NOP4"] = "No operation (reserved for future expansion). Note: OP_NOP4 counts toward the opcode limit.";
  OpcodeDescriptionsBCH2022["OP_NOP6"] = "No operation (reserved for future expansion). Note: OP_NOP6 counts toward the opcode limit.";
  OpcodeDescriptionsBCH2022["OP_NOP5"] = "No operation (reserved for future expansion). Note: OP_NOP5 counts toward the opcode limit.";
  OpcodeDescriptionsBCH2022["OP_NOP7"] = "No operation (reserved for future expansion). Note: OP_NOP7 counts toward the opcode limit.";
  OpcodeDescriptionsBCH2022["OP_NOP8"] = "No operation (reserved for future expansion). Note: OP_NOP8 counts toward the opcode limit.";
  OpcodeDescriptionsBCH2022["OP_NOP9"] = "No operation (reserved for future expansion). Note: OP_NOP9 counts toward the opcode limit.";
  OpcodeDescriptionsBCH2022["OP_NOP10"] = "No operation (reserved for future expansion). Note: OP_NOP10 counts toward the opcode limit.";
  OpcodeDescriptionsBCH2022["OP_CHECKDATASIG"] = "Pop the top 3 items from the stack. Treat the top as a public key, the second as a message, and the third as a signature. If the signature is valid, push a 1 (VM Number), otherwise push a 0 (VM Number).";
  OpcodeDescriptionsBCH2022["OP_CHECKDATASIGVERIFY"] = "Pop the top 3 items from the stack. Treat the top as a public key, the second as a message, and the third as a signature. If the signature is not valid, error. (This operation is a combination of OP_CHECKDATASIG followed by OP_VERIFY.)";
  OpcodeDescriptionsBCH2022["OP_REVERSEBYTES"] = "Pop the top item from the stack and reverse it, pushing the result.";
  OpcodeDescriptionsBCH2022["OP_INPUTINDEX"] = "Push the index of the input being evaluated to the stack as a VM Number.";
  OpcodeDescriptionsBCH2022["OP_ACTIVEBYTECODE"] = "Push the bytecode currently being evaluated, beginning after the last executed OP_CODESEPARATOR, to the stack. For Pay-to-Script-Hash (P2SH) evaluations, this is the redeem bytecode of the Unspent Transaction Output (UTXO) being spent; for all other evaluations, this is the locking bytecode of the UTXO being spent.";
  OpcodeDescriptionsBCH2022["OP_TXVERSION"] = "Push the version of the current transaction to the stack as a VM Number.";
  OpcodeDescriptionsBCH2022["OP_TXINPUTCOUNT"] = "Push the count of inputs in the current transaction to the stack as a VM Number.";
  OpcodeDescriptionsBCH2022["OP_TXOUTPUTCOUNT"] = "Push the count of outputs in the current transaction to the stack as a VM Number.";
  OpcodeDescriptionsBCH2022["OP_TXLOCKTIME"] = "Push the locktime of the current transaction to the stack as a VM Number.";
  OpcodeDescriptionsBCH2022["OP_UTXOVALUE"] = "Pop the top item from the stack as an input index (VM Number). Push the value (in satoshis) of the Unspent Transaction Output (UTXO) spent by that input to the stack as a VM Number.";
  OpcodeDescriptionsBCH2022["OP_UTXOBYTECODE"] = "Pop the top item from the stack as an input index (VM Number). Push the full locking bytecode of the Unspent Transaction Output (UTXO) spent by that input to the stack.";
  OpcodeDescriptionsBCH2022["OP_OUTPOINTTXHASH"] = "Pop the top item from the stack as an input index (VM Number). From that input, push the outpoint transaction hash \u2013 the hash of the transaction that created the Unspent Transaction Output (UTXO) that is being spent \u2013 to the stack in OP_HASH256 byte order.";
  OpcodeDescriptionsBCH2022["OP_OUTPOINTINDEX"] = "Pop the top item from the stack as an input index (VM Number). From that input, push the outpoint index \u2013 the index of the output in the transaction that created the Unspent Transaction Output (UTXO) that is being spent \u2013 to the stack as a VM Number.";
  OpcodeDescriptionsBCH2022["OP_INPUTBYTECODE"] = "Pop the top item from the stack as an input index (VM Number). Push the unlocking bytecode of the input at that index to the stack.";
  OpcodeDescriptionsBCH2022["OP_INPUTSEQUENCENUMBER"] = "Pop the top item from the stack as an input index (VM Number). Push the sequence number of the input at that index to the stack as a VM Number.";
  OpcodeDescriptionsBCH2022["OP_OUTPUTVALUE"] = "Pop the top item from the stack as an output index (VM Number). Push the value (in satoshis) of the output at that index to the stack as a VM Number.";
  OpcodeDescriptionsBCH2022["OP_OUTPUTBYTECODE"] = "Pop the top item from the stack as an output index (VM Number). Push the locking bytecode of the output at that index to the stack.";
})(OpcodeDescriptionsBCH2022 || (OpcodeDescriptionsBCH2022 = {}));

var AuthenticationErrorBCH2022;
(function (AuthenticationErrorBCH2022) {
  AuthenticationErrorBCH2022["exceededMaximumVmNumberLength"] = "Program attempted an OP_BIN2NUM operation on a byte sequence that cannot be encoded within the maximum VM Number length (8 bytes).";
})(AuthenticationErrorBCH2022 || (AuthenticationErrorBCH2022 = {}));

// TODO: replace with scenarios
var createTestAuthenticationProgramBCH = function createTestAuthenticationProgramBCH(_ref) {
  var lockingBytecode = _ref.lockingBytecode,
    valueSatoshis = _ref.valueSatoshis,
    unlockingBytecode = _ref.unlockingBytecode;
  var testFundingTransaction = {
    inputs: [{
      outpointIndex: 0xffffffff,
      outpointTransactionHash: hexToBin('0000000000000000000000000000000000000000000000000000000000000000'),
      sequenceNumber: 0xffffffff,
      unlockingBytecode: Uint8Array.of(0, 0)
    }],
    locktime: 0,
    outputs: [{
      lockingBytecode: lockingBytecode,
      valueSatoshis: valueSatoshis
    }],
    version: 1
  };
  var testSpendingTransaction = {
    inputs: [{
      outpointIndex: 0,
      outpointTransactionHash: hashTransactionP2pOrder(encodeTransactionCommon(testFundingTransaction)),
      sequenceNumber: 0xffffffff,
      unlockingBytecode: unlockingBytecode
    }],
    locktime: 0,
    outputs: [{
      lockingBytecode: Uint8Array.of(),
      valueSatoshis: valueSatoshis
    }],
    version: 1
  };
  return {
    inputIndex: 0,
    sourceOutputs: testFundingTransaction.outputs,
    transaction: testSpendingTransaction
  };
};

/**
 * Initialize a virtual machine using the BCH instruction set.
 *
 * @param standard - If `true`, the additional `isStandard` validations will be
 * enabled. Transactions that fail these rules are often called "non-standard"
 * and can technically be included by miners in valid blocks, but most network
 * nodes will refuse to relay them. (Default: `true`)
 */
var createVirtualMachineBCH2022 = function createVirtualMachineBCH2022() {
  var standard = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
  return createAuthenticationVirtualMachine(createInstructionSetBCH2022(standard));
};

var AuthenticationErrorBCHCHIPs;
(function (AuthenticationErrorBCHCHIPs) {
  AuthenticationErrorBCHCHIPs["invalidBoolean"] = "Invalid input: this operation requires a valid boolean (VM Number 0 or VM Number 1).";
  AuthenticationErrorBCHCHIPs["unexpectedUntil"] = "Encountered an OP_UNTIL that is not following a matching OP_BEGIN.";
  AuthenticationErrorBCHCHIPs["excessiveHashing"] = "Program attempted a hashing operation that would exceed the hashing limit (660 hash digest iterations).";
  AuthenticationErrorBCHCHIPs["excessiveLooping"] = "Program attempted an OP_UNTIL operation that would exceed the limit of repeated bytes (10,000 bytes minus active bytecode length).";
})(AuthenticationErrorBCHCHIPs || (AuthenticationErrorBCHCHIPs = {}));

/**
 * Consensus settings for the `BCH_CHIPs` instruction set.
 */
var ConsensusBCHCHIPs;
(function (ConsensusBCHCHIPs) {
  ConsensusBCHCHIPs[ConsensusBCHCHIPs["maximumTransactionVersion"] = 2] = "maximumTransactionVersion";
  ConsensusBCHCHIPs[ConsensusBCHCHIPs["bannedTransactionSize"] = 64] = "bannedTransactionSize";
  ConsensusBCHCHIPs[ConsensusBCHCHIPs["maximumHashDigestIterations"] = 660] = "maximumHashDigestIterations";
})(ConsensusBCHCHIPs || (ConsensusBCHCHIPs = {}));
var cloneAuthenticationProgramStateBCHCHIPs = function cloneAuthenticationProgramStateBCHCHIPs(state) {
  return _objectSpread2(_objectSpread2({}, state.error === undefined ? {} : {
    error: state.error
  }), {}, {
    alternateStack: cloneStack(state.alternateStack),
    controlStack: state.controlStack.slice(),
    hashDigestIterations: state.hashDigestIterations,
    instructions: state.instructions.map(cloneAuthenticationInstruction),
    ip: state.ip,
    lastCodeSeparator: state.lastCodeSeparator,
    program: cloneAuthenticationProgramCommon(state.program),
    repeatedBytes: state.repeatedBytes,
    signedMessages: state.signedMessages.map(function (item) {
      return _objectSpread2({
        digest: item.digest.slice()
      }, 'serialization' in item ? {
        serialization: item.serialization.slice()
      } : {
        message: item.message.slice()
      });
    }),
    stack: cloneStack(state.stack)
  });
};
var createAuthenticationProgramStateBCHCHIPs = function createAuthenticationProgramStateBCHCHIPs(_ref) {
  var program = _ref.program,
    instructions = _ref.instructions,
    stack = _ref.stack;
  return {
    alternateStack: [],
    controlStack: [],
    hashDigestIterations: 0,
    instructions: instructions,
    ip: 0,
    lastCodeSeparator: -1,
    program: program,
    repeatedBytes: 0,
    signedMessages: [],
    stack: stack
  };
};

/**
 * Given a message length, compute and return the number of hash digest
 * iterations required. (See `CHIP-2021-05-vm-limits`)
 */
var hashDigestIterations = function hashDigestIterations(messageLength) {
  return (
    // eslint-disable-next-line no-bitwise, @typescript-eslint/no-magic-numbers
    1 + ((messageLength + 8) / 64 | 0)
  );
};
/**
 * Given a program state, increment the hash digest iteration count for a
 * message of the provided length. If the total would exceed the maximum, append
 * an error.
 *
 * @param state - the program state
 * @param messageLength - the message length
 * @param operation - the operation to execute if no error occurred
 */
var incrementHashDigestIterations = function incrementHashDigestIterations(state, messageLength, operation) {
  var requiredTotalIterations = state.hashDigestIterations + hashDigestIterations(messageLength);
  if (requiredTotalIterations > ConsensusBCHCHIPs.maximumHashDigestIterations) {
    return applyError(state, AuthenticationErrorBCHCHIPs.excessiveHashing, "Required cumulative iterations: ".concat(requiredTotalIterations));
  }
  return operation(state);
};
var opRipemd160ChipLimits = function opRipemd160ChipLimits() {
  var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {
      ripemd160: ripemd160$1
    },
    ripemd160 = _ref.ripemd160;
  return function (state) {
    return useOneStackItem(state, function (nextState, _ref2) {
      var _ref3 = _slicedToArray(_ref2, 1),
        value = _ref3[0];
      return incrementHashDigestIterations(nextState, value.length, function (finalState) {
        return pushToStack(finalState, ripemd160.hash(value));
      });
    });
  };
};
var opSha1ChipLimits = function opSha1ChipLimits() {
  var _ref4 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {
      sha1: sha1$1
    },
    sha1 = _ref4.sha1;
  return function (state) {
    return useOneStackItem(state, function (nextState, _ref5) {
      var _ref6 = _slicedToArray(_ref5, 1),
        value = _ref6[0];
      return incrementHashDigestIterations(nextState, value.length, function (finalState) {
        return pushToStack(finalState, sha1.hash(value));
      });
    });
  };
};
var opSha256ChipLimits = function opSha256ChipLimits() {
  var _ref7 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {
      sha256: sha256$1
    },
    sha256 = _ref7.sha256;
  return function (state) {
    return useOneStackItem(state, function (nextState, _ref8) {
      var _ref9 = _slicedToArray(_ref8, 1),
        value = _ref9[0];
      return incrementHashDigestIterations(nextState, value.length, function (finalState) {
        return pushToStack(finalState, sha256.hash(value));
      });
    });
  };
};
var opHash160ChipLimits = function opHash160ChipLimits() {
  var _ref10 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {
      ripemd160: ripemd160$1,
      sha256: sha256$1
    },
    ripemd160 = _ref10.ripemd160,
    sha256 = _ref10.sha256;
  return function (state) {
    return useOneStackItem(state, function (nextState, _ref11) {
      var _ref12 = _slicedToArray(_ref11, 1),
        value = _ref12[0];
      return incrementHashDigestIterations(nextState, value.length, function (finalState) {
        return pushToStack(finalState, ripemd160.hash(sha256.hash(value)));
      });
    });
  };
};
var opHash256ChipLimits = function opHash256ChipLimits() {
  var _ref13 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {
      sha256: sha256$1
    },
    sha256 = _ref13.sha256;
  return function (state) {
    return useOneStackItem(state, function (nextState, _ref14) {
      var _ref15 = _slicedToArray(_ref14, 1),
        value = _ref15[0];
      return incrementHashDigestIterations(nextState, value.length, function (finalState) {
        return pushToStack(finalState, hash256(value, sha256));
      });
    });
  };
};
var opCheckSigChipLimits = function opCheckSigChipLimits() {
  var _ref16 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {
      secp256k1: secp256k1,
      sha256: sha256$1
    },
    secp256k1$1 = _ref16.secp256k1,
    sha256 = _ref16.sha256;
  return function (s) {
    return (
      // eslint-disable-next-line complexity
      useTwoStackItems(s, function (state, _ref17) {
        var _ref18 = _slicedToArray(_ref17, 2),
          bitcoinEncodedSignature = _ref18[0],
          publicKey = _ref18[1];
        if (!isValidPublicKeyEncoding(publicKey)) {
          return applyError(state, AuthenticationErrorCommon.invalidPublicKeyEncoding);
        }
        if (!isValidSignatureEncodingBCHTransaction(bitcoinEncodedSignature, SigningSerializationTypesBCH2023)) {
          return applyError(state, AuthenticationErrorCommon.invalidSignatureEncoding, "Transaction signature (including signing serialization type): ".concat(binToHex(bitcoinEncodedSignature)));
        }
        var coveredBytecode = encodeAuthenticationInstructions(state.instructions).subarray(state.lastCodeSeparator + 1);
        var _decodeBitcoinSignatu = decodeBitcoinSignature(bitcoinEncodedSignature),
          signingSerializationType = _decodeBitcoinSignatu.signingSerializationType,
          signature = _decodeBitcoinSignatu.signature;
        var serialization = generateSigningSerializationBCH(state.program, {
          coveredBytecode: coveredBytecode,
          signingSerializationType: signingSerializationType
        }, sha256);
        var requiredTotalIterations = state.hashDigestIterations + hashDigestIterations(serialization.length);
        if (requiredTotalIterations > ConsensusBCHCHIPs.maximumHashDigestIterations) {
          return applyError(state, AuthenticationErrorBCHCHIPs.excessiveHashing, "Required cumulative iterations: ".concat(requiredTotalIterations));
        }
        var digest = hash256(serialization, sha256);
        // eslint-disable-next-line functional/no-expression-statement, functional/immutable-data
        state.signedMessages.push({
          digest: digest,
          serialization: serialization
        });
        var useSchnorr = signature.length === ConsensusCommon.schnorrSignatureLength;
        var success = useSchnorr ? secp256k1$1.verifySignatureSchnorr(signature, publicKey, digest) : secp256k1$1.verifySignatureDERLowS(signature, publicKey, digest);
        return !success && signature.length !== 0 ? applyError(state, AuthenticationErrorCommon.nonNullSignatureFailure) : pushToStack(state, booleanToVmNumber(success));
      })
    );
  };
};
// TODO: implement schnorr multisig https://gitlab.com/bitcoin-cash-node/bchn-sw/bitcoincash-upgrade-specifications/-/blob/master/spec/2019-11-15-schnorrmultisig.md
var opCheckMultiSigChipLimits = function opCheckMultiSigChipLimits() {
  var _ref19 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {
      secp256k1: secp256k1,
      sha256: sha256$1
    },
    secp256k1$1 = _ref19.secp256k1,
    sha256 = _ref19.sha256;
  return function (s) {
    return useOneVmNumber(s, function (state, publicKeysValue) {
      var potentialPublicKeys = Number(publicKeysValue);
      if (potentialPublicKeys < 0) {
        return applyError(state, AuthenticationErrorCommon.invalidNaturalNumber);
      }
      if (potentialPublicKeys > 20 /* Multisig.maximumPublicKeys */) {
        return applyError(state, AuthenticationErrorCommon.exceedsMaximumMultisigPublicKeyCount);
      }
      var publicKeys =
      // eslint-disable-next-line functional/immutable-data
      potentialPublicKeys > 0 ? state.stack.splice(-potentialPublicKeys) : [];
      return useOneVmNumber(state, function (nextState, approvingKeys) {
        var requiredApprovingPublicKeys = Number(approvingKeys);
        if (requiredApprovingPublicKeys < 0) {
          return applyError(nextState, AuthenticationErrorCommon.invalidNaturalNumber);
        }
        if (requiredApprovingPublicKeys > potentialPublicKeys) {
          return applyError(nextState, AuthenticationErrorCommon.insufficientPublicKeys);
        }
        var signatures = requiredApprovingPublicKeys > 0 ?
        // eslint-disable-next-line functional/immutable-data
        nextState.stack.splice(-requiredApprovingPublicKeys) : [];
        return useOneStackItem(nextState,
        // eslint-disable-next-line complexity
        function (finalState, _ref20) {
          var _ref21 = _slicedToArray(_ref20, 1),
            protocolBugValue = _ref21[0];
          if (protocolBugValue.length !== 0) {
            return applyError(finalState, AuthenticationErrorCommon.invalidProtocolBugValue);
          }
          var coveredBytecode = encodeAuthenticationInstructions(finalState.instructions).subarray(finalState.lastCodeSeparator + 1);
          var approvingPublicKeys = 0; // eslint-disable-line functional/no-let
          var remainingSignatures = signatures.length; // eslint-disable-line functional/no-let
          var remainingPublicKeys = publicKeys.length; // eslint-disable-line functional/no-let
          // eslint-disable-next-line functional/no-loop-statement
          while (remainingSignatures > 0 && remainingPublicKeys > 0 && approvingPublicKeys + remainingPublicKeys >= remainingSignatures && approvingPublicKeys !== requiredApprovingPublicKeys) {
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            var publicKey = publicKeys[remainingPublicKeys - 1];
            var bitcoinEncodedSignature =
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            signatures[remainingSignatures - 1];
            if (!isValidPublicKeyEncoding(publicKey)) {
              return applyError(finalState, AuthenticationErrorCommon.invalidPublicKeyEncoding);
            }
            if (!isValidSignatureEncodingBCHTransaction(bitcoinEncodedSignature, SigningSerializationTypesBCH2023)) {
              return applyError(finalState, AuthenticationErrorCommon.invalidSignatureEncoding, "Transaction signature (including signing serialization type): ".concat(binToHex(bitcoinEncodedSignature)));
            }
            var _decodeBitcoinSignatu2 = decodeBitcoinSignature(bitcoinEncodedSignature),
              signingSerializationType = _decodeBitcoinSignatu2.signingSerializationType,
              signature = _decodeBitcoinSignatu2.signature;
            var serialization = generateSigningSerializationBCH(state.program, {
              coveredBytecode: coveredBytecode,
              signingSerializationType: signingSerializationType
            }, sha256);
            var requiredTotalIterations = state.hashDigestIterations + hashDigestIterations(serialization.length);
            if (requiredTotalIterations > ConsensusBCHCHIPs.maximumHashDigestIterations) {
              return applyError(state, AuthenticationErrorBCHCHIPs.excessiveHashing, "Required cumulative iterations: ".concat(requiredTotalIterations));
            }
            var digest = hash256(serialization, sha256);
            // eslint-disable-next-line functional/no-expression-statement, functional/immutable-data
            finalState.signedMessages.push({
              digest: digest,
              serialization: serialization
            });
            if (signature.length === ConsensusCommon.schnorrSignatureLength) {
              return applyError(finalState, AuthenticationErrorCommon.schnorrSizedSignatureInCheckMultiSig);
            }
            var signed = secp256k1$1.verifySignatureDERLowS(signature, publicKey, digest);
            // eslint-disable-next-line functional/no-conditional-statement
            if (signed) {
              approvingPublicKeys += 1; // eslint-disable-line functional/no-expression-statement
              remainingSignatures -= 1; // eslint-disable-line functional/no-expression-statement
            }

            remainingPublicKeys -= 1; // eslint-disable-line functional/no-expression-statement
          }

          var success = approvingPublicKeys === requiredApprovingPublicKeys;
          if (!success && !signatures.every(function (signature) {
            return signature.length === 0;
          })) {
            return applyError(finalState, AuthenticationErrorCommon.nonNullSignatureFailure);
          }
          return pushToStack(finalState, booleanToVmNumber(success));
        });
      });
    });
  };
};
var opCheckSigVerifyChipLimits = function opCheckSigVerifyChipLimits() {
  var _ref22 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {
      secp256k1: secp256k1,
      sha256: sha256$1
    },
    secp256k1$1 = _ref22.secp256k1,
    sha256 = _ref22.sha256;
  return combineOperations(opCheckSigChipLimits({
    secp256k1: secp256k1$1,
    sha256: sha256
  }), opVerify);
};
var opCheckMultiSigVerifyChipLimits = function opCheckMultiSigVerifyChipLimits(_ref23) {
  var secp256k1 = _ref23.secp256k1,
    sha256 = _ref23.sha256;
  return combineOperations(opCheckMultiSigChipLimits({
    secp256k1: secp256k1,
    sha256: sha256
  }), opVerify);
};
var opCheckDataSigChipLimits = function opCheckDataSigChipLimits(_ref24) {
  var secp256k1 = _ref24.secp256k1,
    sha256 = _ref24.sha256;
  return function (state) {
    return (
      // eslint-disable-next-line complexity
      useThreeStackItems(state, function (nextState, _ref25) {
        var _ref26 = _slicedToArray(_ref25, 3),
          signature = _ref26[0],
          message = _ref26[1],
          publicKey = _ref26[2];
        if (!isValidSignatureEncodingBCHRaw(signature)) {
          return applyError(nextState, AuthenticationErrorCommon.invalidSignatureEncoding, "Data signature: ".concat(binToHex(signature)));
        }
        if (!isValidPublicKeyEncoding(publicKey)) {
          return applyError(nextState, AuthenticationErrorCommon.invalidPublicKeyEncoding);
        }
        var requiredTotalIterations = state.hashDigestIterations + hashDigestIterations(message.length);
        if (requiredTotalIterations > ConsensusBCHCHIPs.maximumHashDigestIterations) {
          return applyError(state, AuthenticationErrorBCHCHIPs.excessiveHashing, "Required cumulative iterations: ".concat(requiredTotalIterations));
        }
        var digest = sha256.hash(message);
        // eslint-disable-next-line functional/no-expression-statement, functional/immutable-data
        nextState.signedMessages.push({
          digest: digest,
          message: message
        });
        var useSchnorr = signature.length === ConsensusCommon.schnorrSignatureLength;
        var success = useSchnorr ? secp256k1.verifySignatureSchnorr(signature, publicKey, digest) : secp256k1.verifySignatureDERLowS(signature, publicKey, digest);
        return !success && signature.length !== 0 ? applyError(nextState, AuthenticationErrorCommon.nonNullSignatureFailure) : pushToStack(nextState, booleanToVmNumber(success));
      })
    );
  };
};
var opCheckDataSigVerifyChipLimits = function opCheckDataSigVerifyChipLimits() {
  var _ref27 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {
      secp256k1: secp256k1,
      sha256: sha256$1
    },
    secp256k1$1 = _ref27.secp256k1,
    sha256 = _ref27.sha256;
  return combineOperations(opCheckDataSigChipLimits({
    secp256k1: secp256k1$1,
    sha256: sha256
  }), opVerify);
};

var OpcodeDescriptionsBCHCHIPs;
(function (OpcodeDescriptionsBCHCHIPs) {
  OpcodeDescriptionsBCHCHIPs["OP_0"] = "Push the VM Number 0 onto the stack.";
  OpcodeDescriptionsBCHCHIPs["OP_PUSHBYTES_1"] = "Push the next byte onto the stack.";
  OpcodeDescriptionsBCHCHIPs["OP_PUSHBYTES_2"] = "Push the next 2 bytes onto the stack.";
  OpcodeDescriptionsBCHCHIPs["OP_PUSHBYTES_3"] = "Push the next 3 bytes onto the stack.";
  OpcodeDescriptionsBCHCHIPs["OP_PUSHBYTES_4"] = "Push the next 4 bytes onto the stack.";
  OpcodeDescriptionsBCHCHIPs["OP_PUSHBYTES_5"] = "Push the next 5 bytes onto the stack.";
  OpcodeDescriptionsBCHCHIPs["OP_PUSHBYTES_6"] = "Push the next 6 bytes onto the stack.";
  OpcodeDescriptionsBCHCHIPs["OP_PUSHBYTES_7"] = "Push the next 7 bytes onto the stack.";
  OpcodeDescriptionsBCHCHIPs["OP_PUSHBYTES_8"] = "Push the next 8 bytes onto the stack.";
  OpcodeDescriptionsBCHCHIPs["OP_PUSHBYTES_9"] = "Push the next 9 bytes onto the stack.";
  OpcodeDescriptionsBCHCHIPs["OP_PUSHBYTES_10"] = "Push the next 10 bytes onto the stack.";
  OpcodeDescriptionsBCHCHIPs["OP_PUSHBYTES_11"] = "Push the next 11 bytes onto the stack.";
  OpcodeDescriptionsBCHCHIPs["OP_PUSHBYTES_12"] = "Push the next 12 bytes onto the stack.";
  OpcodeDescriptionsBCHCHIPs["OP_PUSHBYTES_13"] = "Push the next 13 bytes onto the stack.";
  OpcodeDescriptionsBCHCHIPs["OP_PUSHBYTES_14"] = "Push the next 14 bytes onto the stack.";
  OpcodeDescriptionsBCHCHIPs["OP_PUSHBYTES_15"] = "Push the next 15 bytes onto the stack.";
  OpcodeDescriptionsBCHCHIPs["OP_PUSHBYTES_16"] = "Push the next 16 bytes onto the stack.";
  OpcodeDescriptionsBCHCHIPs["OP_PUSHBYTES_17"] = "Push the next 17 bytes onto the stack.";
  OpcodeDescriptionsBCHCHIPs["OP_PUSHBYTES_18"] = "Push the next 18 bytes onto the stack.";
  OpcodeDescriptionsBCHCHIPs["OP_PUSHBYTES_19"] = "Push the next 19 bytes onto the stack.";
  OpcodeDescriptionsBCHCHIPs["OP_PUSHBYTES_20"] = "Push the next 20 bytes onto the stack.";
  OpcodeDescriptionsBCHCHIPs["OP_PUSHBYTES_21"] = "Push the next 21 bytes onto the stack.";
  OpcodeDescriptionsBCHCHIPs["OP_PUSHBYTES_22"] = "Push the next 22 bytes onto the stack.";
  OpcodeDescriptionsBCHCHIPs["OP_PUSHBYTES_23"] = "Push the next 23 bytes onto the stack.";
  OpcodeDescriptionsBCHCHIPs["OP_PUSHBYTES_24"] = "Push the next 24 bytes onto the stack.";
  OpcodeDescriptionsBCHCHIPs["OP_PUSHBYTES_25"] = "Push the next 25 bytes onto the stack.";
  OpcodeDescriptionsBCHCHIPs["OP_PUSHBYTES_26"] = "Push the next 26 bytes onto the stack.";
  OpcodeDescriptionsBCHCHIPs["OP_PUSHBYTES_27"] = "Push the next 27 bytes onto the stack.";
  OpcodeDescriptionsBCHCHIPs["OP_PUSHBYTES_28"] = "Push the next 28 bytes onto the stack.";
  OpcodeDescriptionsBCHCHIPs["OP_PUSHBYTES_29"] = "Push the next 29 bytes onto the stack.";
  OpcodeDescriptionsBCHCHIPs["OP_PUSHBYTES_30"] = "Push the next 30 bytes onto the stack.";
  OpcodeDescriptionsBCHCHIPs["OP_PUSHBYTES_31"] = "Push the next 31 bytes onto the stack.";
  OpcodeDescriptionsBCHCHIPs["OP_PUSHBYTES_32"] = "Push the next 32 bytes onto the stack.";
  OpcodeDescriptionsBCHCHIPs["OP_PUSHBYTES_33"] = "Push the next 33 bytes onto the stack.";
  OpcodeDescriptionsBCHCHIPs["OP_PUSHBYTES_34"] = "Push the next 34 bytes onto the stack.";
  OpcodeDescriptionsBCHCHIPs["OP_PUSHBYTES_35"] = "Push the next 35 bytes onto the stack.";
  OpcodeDescriptionsBCHCHIPs["OP_PUSHBYTES_36"] = "Push the next 36 bytes onto the stack.";
  OpcodeDescriptionsBCHCHIPs["OP_PUSHBYTES_37"] = "Push the next 37 bytes onto the stack.";
  OpcodeDescriptionsBCHCHIPs["OP_PUSHBYTES_38"] = "Push the next 38 bytes onto the stack.";
  OpcodeDescriptionsBCHCHIPs["OP_PUSHBYTES_39"] = "Push the next 39 bytes onto the stack.";
  OpcodeDescriptionsBCHCHIPs["OP_PUSHBYTES_40"] = "Push the next 40 bytes onto the stack.";
  OpcodeDescriptionsBCHCHIPs["OP_PUSHBYTES_41"] = "Push the next 41 bytes onto the stack.";
  OpcodeDescriptionsBCHCHIPs["OP_PUSHBYTES_42"] = "Push the next 42 bytes onto the stack.";
  OpcodeDescriptionsBCHCHIPs["OP_PUSHBYTES_43"] = "Push the next 43 bytes onto the stack.";
  OpcodeDescriptionsBCHCHIPs["OP_PUSHBYTES_44"] = "Push the next 44 bytes onto the stack.";
  OpcodeDescriptionsBCHCHIPs["OP_PUSHBYTES_45"] = "Push the next 45 bytes onto the stack.";
  OpcodeDescriptionsBCHCHIPs["OP_PUSHBYTES_46"] = "Push the next 46 bytes onto the stack.";
  OpcodeDescriptionsBCHCHIPs["OP_PUSHBYTES_47"] = "Push the next 47 bytes onto the stack.";
  OpcodeDescriptionsBCHCHIPs["OP_PUSHBYTES_48"] = "Push the next 48 bytes onto the stack.";
  OpcodeDescriptionsBCHCHIPs["OP_PUSHBYTES_49"] = "Push the next 49 bytes onto the stack.";
  OpcodeDescriptionsBCHCHIPs["OP_PUSHBYTES_50"] = "Push the next 50 bytes onto the stack.";
  OpcodeDescriptionsBCHCHIPs["OP_PUSHBYTES_51"] = "Push the next 51 bytes onto the stack.";
  OpcodeDescriptionsBCHCHIPs["OP_PUSHBYTES_52"] = "Push the next 52 bytes onto the stack.";
  OpcodeDescriptionsBCHCHIPs["OP_PUSHBYTES_53"] = "Push the next 53 bytes onto the stack.";
  OpcodeDescriptionsBCHCHIPs["OP_PUSHBYTES_54"] = "Push the next 54 bytes onto the stack.";
  OpcodeDescriptionsBCHCHIPs["OP_PUSHBYTES_55"] = "Push the next 55 bytes onto the stack.";
  OpcodeDescriptionsBCHCHIPs["OP_PUSHBYTES_56"] = "Push the next 56 bytes onto the stack.";
  OpcodeDescriptionsBCHCHIPs["OP_PUSHBYTES_57"] = "Push the next 57 bytes onto the stack.";
  OpcodeDescriptionsBCHCHIPs["OP_PUSHBYTES_58"] = "Push the next 58 bytes onto the stack.";
  OpcodeDescriptionsBCHCHIPs["OP_PUSHBYTES_59"] = "Push the next 59 bytes onto the stack.";
  OpcodeDescriptionsBCHCHIPs["OP_PUSHBYTES_60"] = "Push the next 60 bytes onto the stack.";
  OpcodeDescriptionsBCHCHIPs["OP_PUSHBYTES_61"] = "Push the next 61 bytes onto the stack.";
  OpcodeDescriptionsBCHCHIPs["OP_PUSHBYTES_62"] = "Push the next 62 bytes onto the stack.";
  OpcodeDescriptionsBCHCHIPs["OP_PUSHBYTES_63"] = "Push the next 63 bytes onto the stack.";
  OpcodeDescriptionsBCHCHIPs["OP_PUSHBYTES_64"] = "Push the next 64 bytes onto the stack.";
  OpcodeDescriptionsBCHCHIPs["OP_PUSHBYTES_65"] = "Push the next 65 bytes onto the stack.";
  OpcodeDescriptionsBCHCHIPs["OP_PUSHBYTES_66"] = "Push the next 66 bytes onto the stack.";
  OpcodeDescriptionsBCHCHIPs["OP_PUSHBYTES_67"] = "Push the next 67 bytes onto the stack.";
  OpcodeDescriptionsBCHCHIPs["OP_PUSHBYTES_68"] = "Push the next 68 bytes onto the stack.";
  OpcodeDescriptionsBCHCHIPs["OP_PUSHBYTES_69"] = "Push the next 69 bytes onto the stack.";
  OpcodeDescriptionsBCHCHIPs["OP_PUSHBYTES_70"] = "Push the next 70 bytes onto the stack.";
  OpcodeDescriptionsBCHCHIPs["OP_PUSHBYTES_71"] = "Push the next 71 bytes onto the stack.";
  OpcodeDescriptionsBCHCHIPs["OP_PUSHBYTES_72"] = "Push the next 72 bytes onto the stack.";
  OpcodeDescriptionsBCHCHIPs["OP_PUSHBYTES_73"] = "Push the next 73 bytes onto the stack.";
  OpcodeDescriptionsBCHCHIPs["OP_PUSHBYTES_74"] = "Push the next 74 bytes onto the stack.";
  OpcodeDescriptionsBCHCHIPs["OP_PUSHBYTES_75"] = "Push the next 75 bytes onto the stack.";
  OpcodeDescriptionsBCHCHIPs["OP_PUSHDATA_1"] = "Read the next Uint8 and push that number of bytes onto the stack.";
  OpcodeDescriptionsBCHCHIPs["OP_PUSHDATA_2"] = "Read the next little-endian Uint16 and push that number of bytes onto the stack.";
  OpcodeDescriptionsBCHCHIPs["OP_PUSHDATA_4"] = "Read the next little-endian Uint32 and push that number of bytes onto the stack.";
  OpcodeDescriptionsBCHCHIPs["OP_1NEGATE"] = "Push the VM Number -1 onto the stack.";
  OpcodeDescriptionsBCHCHIPs["OP_RESERVED"] = "Error unless found in an unexecuted conditional branch. Note: OP_RESERVED does not count toward the opcode limit.";
  OpcodeDescriptionsBCHCHIPs["OP_1"] = "Push a 1 (VM Number) onto the stack.";
  OpcodeDescriptionsBCHCHIPs["OP_2"] = "Push a 2 (VM Number) onto the stack.";
  OpcodeDescriptionsBCHCHIPs["OP_3"] = "Push a 3 (VM Number) onto the stack.";
  OpcodeDescriptionsBCHCHIPs["OP_4"] = "Push a 4 (VM Number) onto the stack.";
  OpcodeDescriptionsBCHCHIPs["OP_5"] = "Push a 5 (VM Number) onto the stack.";
  OpcodeDescriptionsBCHCHIPs["OP_6"] = "Push a 6 (VM Number) onto the stack.";
  OpcodeDescriptionsBCHCHIPs["OP_7"] = "Push a 7 (VM Number) onto the stack.";
  OpcodeDescriptionsBCHCHIPs["OP_8"] = "Push a 8 (VM Number) onto the stack.";
  OpcodeDescriptionsBCHCHIPs["OP_9"] = "Push a 9 (VM Number) onto the stack.";
  OpcodeDescriptionsBCHCHIPs["OP_10"] = "Push a 10 (VM Number) onto the stack.";
  OpcodeDescriptionsBCHCHIPs["OP_11"] = "Push a 11 (VM Number) onto the stack.";
  OpcodeDescriptionsBCHCHIPs["OP_12"] = "Push a 12 (VM Number) onto the stack.";
  OpcodeDescriptionsBCHCHIPs["OP_13"] = "Push a 13 (VM Number) onto the stack.";
  OpcodeDescriptionsBCHCHIPs["OP_14"] = "Push a 14 (VM Number) onto the stack.";
  OpcodeDescriptionsBCHCHIPs["OP_15"] = "Push a 15 (VM Number) onto the stack.";
  OpcodeDescriptionsBCHCHIPs["OP_16"] = "Push a 16 (VM Number) onto the stack.";
  OpcodeDescriptionsBCHCHIPs["OP_NOP"] = "No operation. Note: OP_NOP counts toward the opcode limit.";
  OpcodeDescriptionsBCHCHIPs["OP_VER"] = "Error unless found in an unexecuted conditional branch. Note: OP_VER counts toward the opcode limit. (Historically, this pushed a protocol version number to the stack.)";
  OpcodeDescriptionsBCHCHIPs["OP_IF"] = "Pop the top item from the stack. If it is not \"truthy\", skip evaluation until a matching OP_ELSE or OP_ENDIF.";
  OpcodeDescriptionsBCHCHIPs["OP_NOTIF"] = "Pop the top item from the stack. If it is \"truthy\", skip evaluation until a matching OP_ELSE or OP_ENDIF.";
  OpcodeDescriptionsBCHCHIPs["OP_BEGIN"] = "Push the current instruction pointer index to the control stack as an integer (to be read by OP_UNTIL).";
  OpcodeDescriptionsBCHCHIPs["OP_UNTIL"] = "Pop the top item from the control stack (if the control value is not an integer, error). Add the difference between the control value and the current instruction pointer index to the repeated bytes counter, if the sum of the repeated bytes counter and the active bytecode length is greater than the maximum bytecode length, error. Pop the top item from the stack, if the value is a 0 (VM Number), move the instruction pointer to the control value (and re-evaluate the OP_BEGIN).";
  OpcodeDescriptionsBCHCHIPs["OP_ELSE"] = "Invert conditional evaluation within the current OP_IF ... OP_ENDIF block. (If evaluation is enabled, disable it, if it is disabled, enable it.)";
  OpcodeDescriptionsBCHCHIPs["OP_ENDIF"] = "End the current OP_IF/OP_NOTIF ... OP_ENDIF block.";
  OpcodeDescriptionsBCHCHIPs["OP_VERIFY"] = "Pop the top item from the stack and error if it isn't \"truthy\".";
  OpcodeDescriptionsBCHCHIPs["OP_RETURN"] = "Error when executed.";
  OpcodeDescriptionsBCHCHIPs["OP_TOALTSTACK"] = "Pop the top item from the stack and push it onto the alternate stack.";
  OpcodeDescriptionsBCHCHIPs["OP_FROMALTSTACK"] = "Pop the top item from the alternate stack and push it onto the stack.";
  OpcodeDescriptionsBCHCHIPs["OP_2DROP"] = "Pop the top 2 items from the stack and discard them.";
  OpcodeDescriptionsBCHCHIPs["OP_2DUP"] = "Duplicate the top 2 items on the stack. (E.g. [a, b] -> [a, b, a, b])";
  OpcodeDescriptionsBCHCHIPs["OP_3DUP"] = "Duplicate the top 3 items on the stack. (E.g. [a, b, c] -> [a, b, c, a, b, c])";
  OpcodeDescriptionsBCHCHIPs["OP_2OVER"] = "Duplicate the 2 items beginning at a depth of 2 on the stack. (E.g. [a, b, c, d] -> [a, b, c, d, a, b])";
  OpcodeDescriptionsBCHCHIPs["OP_2ROT"] = "Rotate the top 6 items on the stack, bringing the fifth and sixth items to the top. (E.g. [a, b, c, d, e, f] -> [c, d, e, f, a, b])";
  OpcodeDescriptionsBCHCHIPs["OP_2SWAP"] = "Swap the positions of the top two pairs of items on the stack. (E.g. [a, b, c, d] -> [c, d, a, b])";
  OpcodeDescriptionsBCHCHIPs["OP_IFDUP"] = "If the top item on the stack is \"truthy\", duplicate it.";
  OpcodeDescriptionsBCHCHIPs["OP_DEPTH"] = "Push the current number of stack items as a VM Number.";
  OpcodeDescriptionsBCHCHIPs["OP_DROP"] = "Pop the top item from the stack and discard it. (E.g. [a] -> [])";
  OpcodeDescriptionsBCHCHIPs["OP_DUP"] = "Duplicate the top item on the stack. (E.g. [a] -> [a, a])";
  OpcodeDescriptionsBCHCHIPs["OP_NIP"] = "Remove the second-to-top item from the stack. (E.g. [a, b] -> [b])";
  OpcodeDescriptionsBCHCHIPs["OP_OVER"] = "Duplicate the second-to-top item on the stack. (E.g. [a, b] -> [a, b, a])";
  OpcodeDescriptionsBCHCHIPs["OP_PICK"] = "Pop the top item from the stack as a VM Number. Duplicate the item at that depth (zero-indexed), placing it on top of the stack. (E.g. [a, b, c, 2] -> [a, b, c, a])";
  OpcodeDescriptionsBCHCHIPs["OP_ROLL"] = "Pop the top item from the stack as a VM Number. Move the item at that depth (zero-indexed) to the top of the stack. (E.g. [a, b, c, 2] -> [b, c, a])";
  OpcodeDescriptionsBCHCHIPs["OP_ROT"] = "Rotate the top 3 items on the stack, bringing the third item to the top. (E.g. [a, b, c] -> [b, c, a])";
  OpcodeDescriptionsBCHCHIPs["OP_SWAP"] = "Swap the top two items on the stack. (E.g. [a, b] -> [b, a])";
  OpcodeDescriptionsBCHCHIPs["OP_TUCK"] = "Duplicate the item at the top of the stack, inserting it below the second-to-top item. (E.g. [a, b] -> [b, a, b])";
  OpcodeDescriptionsBCHCHIPs["OP_CAT"] = "Pop the top 2 items from the stack and concatenate them, pushing the result.";
  OpcodeDescriptionsBCHCHIPs["OP_SPLIT"] = "Pop the top item from the stack as an index (VM Number) and the next item as a byte array. Split the byte array into two stack items at the index (zero-based), pushing the results.";
  OpcodeDescriptionsBCHCHIPs["OP_NUM2BIN"] = "Pop the top item from the stack as an item length (VM Number) and the next item as a VM Number (without encoding restrictions). Re-encode the number using a byte array of the provided length, filling any unused bytes with zeros, then push the result. (If the requested length is too short to encode the number, error.)";
  OpcodeDescriptionsBCHCHIPs["OP_BIN2NUM"] = "Pop the top item from the stack as a VM Number without encoding restrictions. Minimally-encode the number and push the result. (If the number can't be encoded in 4 bytes or less, error.)";
  OpcodeDescriptionsBCHCHIPs["OP_SIZE"] = "Push the byte-length of the top stack item as a VM Number.";
  OpcodeDescriptionsBCHCHIPs["OP_INVERT"] = "Error, even when found in an unexecuted conditional branch. (Historically, this flipped all the bits in a stack item.)";
  OpcodeDescriptionsBCHCHIPs["OP_AND"] = "Pop the top 2 items from the stack and perform a bitwise AND on each byte, pushing the result. If the length of the items are not equal, error.";
  OpcodeDescriptionsBCHCHIPs["OP_OR"] = "Pop the top 2 items from the stack and perform a bitwise OR on each byte, pushing the result. If the length of the items are not equal, error.";
  OpcodeDescriptionsBCHCHIPs["OP_XOR"] = "Pop the top 2 items from the stack and perform a bitwise XOR on each byte, pushing the result. If the length of the items are not equal, error.";
  OpcodeDescriptionsBCHCHIPs["OP_EQUAL"] = "Pop the top two items from the stack and compare them byte-by-byte. If they are the same, push a 1 (VM Number), otherwise push a 0 (VM Number).";
  OpcodeDescriptionsBCHCHIPs["OP_EQUALVERIFY"] = "Pop the top two items from the stack and compare them byte-by-byte. If the values are different, error. (This operation is a combination of OP_EQUAL followed by OP_VERIFY.)";
  OpcodeDescriptionsBCHCHIPs["OP_RESERVED1"] = "Error unless found in an unexecuted conditional branch. Note: OP_RESERVED1 counts toward the opcode limit.";
  OpcodeDescriptionsBCHCHIPs["OP_RESERVED2"] = "Error unless found in an unexecuted conditional branch. Note: OP_RESERVED2 counts toward the opcode limit.";
  OpcodeDescriptionsBCHCHIPs["OP_1ADD"] = "Pop the top item from the stack as a VM Number, add 1, then push the result.";
  OpcodeDescriptionsBCHCHIPs["OP_1SUB"] = "Pop the top item from the stack as a VM Number, subtract 1, then push the result.";
  OpcodeDescriptionsBCHCHIPs["OP_2MUL"] = "Error, even when found in an unexecuted conditional branch. (Historically, this multiplied a VM Number by 2.)";
  OpcodeDescriptionsBCHCHIPs["OP_2DIV"] = "Error, even when found in an unexecuted conditional branch. (Historically, this divided a VM Number by 2.)";
  OpcodeDescriptionsBCHCHIPs["OP_NEGATE"] = "Pop the top item from the stack as a VM Number, negate it, then push the result.";
  OpcodeDescriptionsBCHCHIPs["OP_ABS"] = "Pop the top item from the stack as a VM Number, take its absolute value, then push the result.";
  OpcodeDescriptionsBCHCHIPs["OP_NOT"] = "Pop the top item from the stack as a VM Number. If its value is 0, push a 1 (VM Number), otherwise, push a 0 (VM Number).";
  OpcodeDescriptionsBCHCHIPs["OP_0NOTEQUAL"] = "Pop the top item from the stack as a VM Number. If its value is not 0, push a 1 (VM Number), otherwise, push a 0 (VM Number).";
  OpcodeDescriptionsBCHCHIPs["OP_ADD"] = "Pop the top two items from the stack as VM Numbers. Add them, then push the result.";
  OpcodeDescriptionsBCHCHIPs["OP_SUB"] = "Pop the top two items from the stack as VM Numbers. Subtract the top item from the second item, then push the result.";
  OpcodeDescriptionsBCHCHIPs["OP_MUL"] = "Pop the top two items from the stack as VM Numbers. Multiply them, then push the result.";
  OpcodeDescriptionsBCHCHIPs["OP_DIV"] = "Pop the top item from the stack as a denominator (VM Number) and the next as a numerator (VM Number). Divide and push the result to the stack.";
  OpcodeDescriptionsBCHCHIPs["OP_MOD"] = "Pop the top item from the stack as a denominator (VM Number) and the next as a numerator (VM Number). Divide and push the remainder to the stack.";
  OpcodeDescriptionsBCHCHIPs["OP_LSHIFT"] = "Error, even when found in an unexecuted conditional branch. (Historically, this performed a sign-preserving, left bit shift.)";
  OpcodeDescriptionsBCHCHIPs["OP_RSHIFT"] = "Error, even when found in an unexecuted conditional branch. (Historically, this performed a sign-preserving, right bit shift.)";
  OpcodeDescriptionsBCHCHIPs["OP_BOOLAND"] = "Pop the top two items from the stack as VM Numbers. If neither value is a 0 (VM Number), push a 1 (VM Number). Otherwise, push a 0 (VM Number).";
  OpcodeDescriptionsBCHCHIPs["OP_BOOLOR"] = "Pop the top two items from the stack as VM Numbers. If either value is a 1 (VM Number), push a 1 (VM Number). Otherwise, push a 0 (VM Number).";
  OpcodeDescriptionsBCHCHIPs["OP_NUMEQUAL"] = "Pop the top two items from the stack as VM Numbers. If the values are equal, push a 1 (VM Number). Otherwise, push a 0 (VM Number).";
  OpcodeDescriptionsBCHCHIPs["OP_NUMEQUALVERIFY"] = "Pop the top two items from the stack as VM Numbers. If the values are different, error. (This operation is a combination of OP_NUMEQUAL followed by OP_VERIFY.)";
  OpcodeDescriptionsBCHCHIPs["OP_NUMNOTEQUAL"] = "Pop the top two items from the stack as VM Numbers. If the values are not equal, push a 1 (VM Number). Otherwise, push a 0 (VM Number).";
  OpcodeDescriptionsBCHCHIPs["OP_LESSTHAN"] = "Pop the top two items from the stack as VM Numbers. If the second item is less than top item, push a 1 (VM Number). Otherwise, push a 0 (VM Number).";
  OpcodeDescriptionsBCHCHIPs["OP_GREATERTHAN"] = "Pop the top two items from the stack as VM Numbers. If the second item is greater than top item, push a 1 (VM Number). Otherwise, push a 0 (VM Number).";
  OpcodeDescriptionsBCHCHIPs["OP_LESSTHANOREQUAL"] = "Pop the top two items from the stack as VM Numbers. If the second item is less than or equal to the top item, push a 1 (VM Number). Otherwise, push a 0 (VM Number).";
  OpcodeDescriptionsBCHCHIPs["OP_GREATERTHANOREQUAL"] = "Pop the top two items from the stack as VM Numbers. If the second item is greater than or equal to the top item, push a 1 (VM Number). Otherwise, push a 0 (VM Number).";
  OpcodeDescriptionsBCHCHIPs["OP_MIN"] = "Pop the top two items from the stack as VM Numbers. Push the smaller of the two numbers.";
  OpcodeDescriptionsBCHCHIPs["OP_MAX"] = "Pop the top two items from the stack as VM Numbers. Push the larger of the two numbers.";
  OpcodeDescriptionsBCHCHIPs["OP_WITHIN"] = "Pop the top three items from the stack as VM Numbers. If the top number is within the range defined by the following two numbers (left-inclusive), push a 1 (VM Number). Otherwise, push a 0 (VM Number). (E.g. for [a, b, c]: if (b <= a), and (a < c), [1]. Else [0].)";
  OpcodeDescriptionsBCHCHIPs["OP_RIPEMD160"] = "Pop the top item from the stack and pass it through ripemd160, pushing the result onto the stack.";
  OpcodeDescriptionsBCHCHIPs["OP_SHA1"] = "Pop the top item from the stack and pass it through sha1, pushing the result onto the stack.";
  OpcodeDescriptionsBCHCHIPs["OP_SHA256"] = "Pop the top item from the stack and pass it through sha256, pushing the result onto the stack.";
  OpcodeDescriptionsBCHCHIPs["OP_HASH160"] = "Pop the top item from the stack and pass it through sha256, then ripemd160, pushing the result onto the stack.";
  OpcodeDescriptionsBCHCHIPs["OP_HASH256"] = "Pop the top item from the stack and pass it through sha256 twice, pushing the result onto the stack.";
  OpcodeDescriptionsBCHCHIPs["OP_CODESEPARATOR"] = "Update the value of lastCodeSeparator to the instruction pointer's current value. (This reduces the coverage of signing serializations used in signature verification operations.)";
  OpcodeDescriptionsBCHCHIPs["OP_CHECKSIG"] = "Pop the top two items from the stack. Treat the top as a signature and the second as a public key. If the signature is valid, push a 1 (VM Number), otherwise push a 0 (VM Number).";
  OpcodeDescriptionsBCHCHIPs["OP_CHECKSIGVERIFY"] = "Pop the top two items from the stack. Treat the top as a signature and the second as a public key. If the signature is not valid, error. (This operation is a combination of OP_CHECKSIG followed by OP_VERIFY.)";
  OpcodeDescriptionsBCHCHIPs["OP_CHECKMULTISIG"] = "Pop items from the stack: first pop the VM Number of public keys, then pop each of those public keys. Next, pop the VM Number of required signatures, then pop each of those signatures. Finally, pop a final VM Number that must be 0 due to a protocol bug. Checking each signature against each public key in order, if all signatures are valid \u2013 and the required number of signatures have been provided \u2013 push a 1 (VM Number), otherwise push a 0 (VM Number).";
  OpcodeDescriptionsBCHCHIPs["OP_CHECKMULTISIGVERIFY"] = "Pop items from the stack: first pop the VM Number of public keys, then pop each of those public keys. Next, pop the VM Number of required signatures, then pop each of those signatures. Finally, (due to a protocol bug) pop an unused final VM Number that must be 0. Checking each signature against each public key in order, if any signatures are invalid \u2013 or the required number of signatures have not been provided \u2013 error. (This operation is a combination of OP_CHECKMULTISIG followed by OP_VERIFY.)";
  OpcodeDescriptionsBCHCHIPs["OP_NOP1"] = "No operation (reserved for future expansion). Note: OP_NOP1 counts toward the opcode limit.";
  OpcodeDescriptionsBCHCHIPs["OP_CHECKLOCKTIMEVERIFY"] = "Verify the transaction occurs after an absolute block time or height: read the top item on the stack as a VM Number (without removing it), and compare it to the transaction's locktime. If the required locktime has not passed, or if locktime has been disabled for this input by a maximized sequence number, error.";
  OpcodeDescriptionsBCHCHIPs["OP_CHECKSEQUENCEVERIFY"] = "Verify the transaction occurs after the output being spent has \"aged\" by a relative block time or block height since it was created: read the top item on the stack as a VM Number (without removing it), and compare it to the age encoded in the input's sequence number. If the required relative locktime has not passed, or if relative locktime has been disabled by the sequence number or the transaction version, error.";
  OpcodeDescriptionsBCHCHIPs["OP_NOP4"] = "No operation (reserved for future expansion). Note: OP_NOP4 counts toward the opcode limit.";
  OpcodeDescriptionsBCHCHIPs["OP_NOP6"] = "No operation (reserved for future expansion). Note: OP_NOP6 counts toward the opcode limit.";
  OpcodeDescriptionsBCHCHIPs["OP_NOP5"] = "No operation (reserved for future expansion). Note: OP_NOP5 counts toward the opcode limit.";
  OpcodeDescriptionsBCHCHIPs["OP_NOP7"] = "No operation (reserved for future expansion). Note: OP_NOP7 counts toward the opcode limit.";
  OpcodeDescriptionsBCHCHIPs["OP_NOP8"] = "No operation (reserved for future expansion). Note: OP_NOP8 counts toward the opcode limit.";
  OpcodeDescriptionsBCHCHIPs["OP_NOP9"] = "No operation (reserved for future expansion). Note: OP_NOP9 counts toward the opcode limit.";
  OpcodeDescriptionsBCHCHIPs["OP_NOP10"] = "No operation (reserved for future expansion). Note: OP_NOP10 counts toward the opcode limit.";
  OpcodeDescriptionsBCHCHIPs["OP_CHECKDATASIG"] = "Pop the top 3 items from the stack. Treat the top as a public key, the second as a message, and the third as a signature. If the signature is valid, push a 1 (VM Number), otherwise push a 0 (VM Number).";
  OpcodeDescriptionsBCHCHIPs["OP_CHECKDATASIGVERIFY"] = "Pop the top 3 items from the stack. Treat the top as a public key, the second as a message, and the third as a signature. If the signature is not valid, error. (This operation is a combination of OP_CHECKDATASIG followed by OP_VERIFY.)";
  OpcodeDescriptionsBCHCHIPs["OP_REVERSEBYTES"] = "Pop the top item from the stack and reverse it, pushing the result.";
  OpcodeDescriptionsBCHCHIPs["OP_INPUTINDEX"] = "Push the index of the input being evaluated to the stack as a VM Number.";
  OpcodeDescriptionsBCHCHIPs["OP_ACTIVEBYTECODE"] = "Push the bytecode currently being evaluated, beginning after the last executed OP_CODESEPARATOR, to the stack. For Pay-to-Script-Hash (P2SH) evaluations, this is the redeem bytecode of the Unspent Transaction Output (UTXO) being spent; for all other evaluations, this is the locking bytecode of the UTXO being spent.";
  OpcodeDescriptionsBCHCHIPs["OP_TXVERSION"] = "Push the version of the current transaction to the stack as a VM Number.";
  OpcodeDescriptionsBCHCHIPs["OP_TXINPUTCOUNT"] = "Push the count of inputs in the current transaction to the stack as a VM Number.";
  OpcodeDescriptionsBCHCHIPs["OP_TXOUTPUTCOUNT"] = "Push the count of outputs in the current transaction to the stack as a VM Number.";
  OpcodeDescriptionsBCHCHIPs["OP_TXLOCKTIME"] = "Push the locktime of the current transaction to the stack as a VM Number.";
  OpcodeDescriptionsBCHCHIPs["OP_UTXOVALUE"] = "Pop the top item from the stack as an input index (VM Number). Push the value (in satoshis) of the Unspent Transaction Output (UTXO) spent by that input to the stack as a VM Number.";
  OpcodeDescriptionsBCHCHIPs["OP_UTXOBYTECODE"] = "Pop the top item from the stack as an input index (VM Number). Push the full locking bytecode of the Unspent Transaction Output (UTXO) spent by that input to the stack.";
  OpcodeDescriptionsBCHCHIPs["OP_OUTPOINTTXHASH"] = "Pop the top item from the stack as an input index (VM Number). From that input, push the outpoint transaction hash \u2013 the hash of the transaction that created the Unspent Transaction Output (UTXO) that is being spent \u2013 to the stack in OP_HASH256 byte order.";
  OpcodeDescriptionsBCHCHIPs["OP_OUTPOINTINDEX"] = "Pop the top item from the stack as an input index (VM Number). From that input, push the outpoint index \u2013 the index of the output in the transaction that created the Unspent Transaction Output (UTXO) that is being spent \u2013 to the stack as a VM Number.";
  OpcodeDescriptionsBCHCHIPs["OP_INPUTBYTECODE"] = "Pop the top item from the stack as an input index (VM Number). Push the unlocking bytecode of the input at that index to the stack.";
  OpcodeDescriptionsBCHCHIPs["OP_INPUTSEQUENCENUMBER"] = "Pop the top item from the stack as an input index (VM Number). Push the sequence number of the input at that index to the stack as a VM Number.";
  OpcodeDescriptionsBCHCHIPs["OP_OUTPUTVALUE"] = "Pop the top item from the stack as an output index (VM Number). Push the value (in satoshis) of the output at that index to the stack as a VM Number.";
  OpcodeDescriptionsBCHCHIPs["OP_OUTPUTBYTECODE"] = "Pop the top item from the stack as an output index (VM Number). Push the locking bytecode of the output at that index to the stack.";
  OpcodeDescriptionsBCHCHIPs["OP_UTXOTOKENCATEGORY"] = "Pop the top item from the stack as an input index (VM Number). If the Unspent Transaction Output (UTXO) spent by that input includes no tokens, push a 0 (VM Number) to the stack. If the UTXO does not include a non-fungible token with a capability, push the UTXO's token category, otherwise, push the concatenation of the token category and capability, where the mutable capability is represented by 1 (VM Number) and the minting capability is represented by 2 (VM Number).";
  OpcodeDescriptionsBCHCHIPs["OP_UTXOTOKENCOMMITMENT"] = "Pop the top item from the stack as an input index (VM Number). Push the token commitment of the Unspent Transaction Output (UTXO) spent by that input to the stack. If the UTXO does not include a non-fungible token, or if it includes a non-fungible token with a zero-length commitment, push a 0 (VM Number).";
  OpcodeDescriptionsBCHCHIPs["OP_UTXOTOKENAMOUNT"] = "Pop the top item from the stack as an input index (VM Number). Push the fungible token amount of the Unspent Transaction Output (UTXO) spent by that input to the stack as a VM Number. If the UTXO includes no fungible tokens, push a 0 (VM Number).";
  OpcodeDescriptionsBCHCHIPs["OP_OUTPUTTOKENCATEGORY"] = "Pop the top item from the stack as an output index (VM Number). If the output spent by that input includes no tokens, push a 0 (VM Number) to the stack. If the output does not include a non-fungible token with a capability, push the output's token category, otherwise, push the concatenation of the token category and capability, where the mutable capability is represented by 1 (VM Number) and the minting capability is represented by 2 (VM Number).";
  OpcodeDescriptionsBCHCHIPs["OP_OUTPUTTOKENCOMMITMENT"] = "Pop the top item from the stack as an output index (VM Number). Push the token commitment of the output at that index to the stack. If the output does not include a non-fungible token, or if it includes a non-fungible token with a zero-length commitment, push a 0 (VM Number).";
  OpcodeDescriptionsBCHCHIPs["OP_OUTPUTTOKENAMOUNT"] = "Pop the top item from the stack as an output index (VM Number). Push the fungible token amount of the output at that index to the stack as a VM Number. If the output includes no fungible tokens, push a 0 (VM Number).";
})(OpcodeDescriptionsBCHCHIPs || (OpcodeDescriptionsBCHCHIPs = {}));

var executionIsActive = function executionIsActive(state) {
  return state.controlStack.every(function (item) {
    return item !== false;
  });
};
/**
 * An implementation of {@link conditionallyEvaluate} that supports
 * `CHIP-2021-05-loops`.
 */
var conditionallyEvaluateChipLoops = function conditionallyEvaluateChipLoops(operation) {
  return function (state) {
    return executionIsActive(state) ? operation(state) : state;
  };
};
var undefinedOperationChipLoops = conditionallyEvaluateChipLoops(function (state) {
  return applyError(state, AuthenticationErrorCommon.unknownOpcode);
});
var pushOperationChipLoops = function pushOperationChipLoops() {
  var maximumPushSize = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : ConsensusCommon.maximumStackItemLength;
  return function (state) {
    var instruction = state.instructions[state.ip];
    return instruction.data.length > maximumPushSize ? applyError(state, "".concat(AuthenticationErrorCommon.exceededMaximumStackItemLength, " Item length: ").concat(instruction.data.length, " bytes.")) : executionIsActive(state) ? isMinimalDataPush(instruction.opcode, instruction.data) ? pushToStack(state, instruction.data) : applyError(state, AuthenticationErrorCommon.nonMinimalPush) : state;
  };
};
/**
 * Return the provided state with the provided value pushed to its control stack.
 * @param state - the state to update and return
 * @param data - the value to push to the stack
 */
var pushToControlStackChipLoops = function pushToControlStackChipLoops(state, value) {
  // eslint-disable-next-line functional/no-expression-statement, functional/immutable-data
  state.controlStack.push(value);
  return state;
};
var opIfChipLoops = function opIfChipLoops(state) {
  if (executionIsActive(state)) {
    return useOneStackItem(state, function (nextState, _ref) {
      var _ref2 = _slicedToArray(_ref, 1),
        item = _ref2[0];
      return pushToControlStackChipLoops(nextState, stackItemIsTruthy(item));
    });
  }
  return pushToControlStackChipLoops(state, false);
};
var opNotIfChipLoops = function opNotIfChipLoops(state) {
  if (executionIsActive(state)) {
    return useOneStackItem(state, function (nextState, _ref3) {
      var _ref4 = _slicedToArray(_ref3, 1),
        item = _ref4[0];
      return pushToControlStackChipLoops(nextState, !stackItemIsTruthy(item));
    });
  }
  return pushToControlStackChipLoops(state, false);
};
var opEndIfChipLoops = function opEndIfChipLoops(state) {
  // eslint-disable-next-line functional/immutable-data
  var element = state.controlStack.pop();
  if (typeof element !== 'boolean') {
    return applyError(state, AuthenticationErrorCommon.unexpectedEndIf);
  }
  return state;
};
var opElseChipLoops = function opElseChipLoops(state) {
  var top = state.controlStack[state.controlStack.length - 1];
  if (typeof top !== 'boolean') {
    return applyError(state, AuthenticationErrorCommon.unexpectedElse);
  }
  // eslint-disable-next-line functional/no-expression-statement, functional/immutable-data
  state.controlStack[state.controlStack.length - 1] = !top;
  return state;
};
var opBegin = function opBegin(state) {
  return pushToControlStackChipLoops(state, state.ip);
};
var opUntil = function opUntil(state) {
  // eslint-disable-next-line functional/immutable-data
  var controlValue = state.controlStack.pop();
  if (typeof controlValue !== 'number') {
    return applyError(state, AuthenticationErrorBCHCHIPs.unexpectedUntil);
  }
  // eslint-disable-next-line functional/no-expression-statement, functional/immutable-data
  state.repeatedBytes += encodeAuthenticationInstructions(state.instructions.slice(controlValue, state.ip)).length;
  var activeBytecodeLength = encodeAuthenticationInstructions(state.instructions).length;
  if (state.repeatedBytes + activeBytecodeLength > ConsensusCommon.maximumBytecodeLength) {
    return applyError(state, AuthenticationErrorBCHCHIPs.excessiveLooping, "Repeated bytes: ".concat(state.repeatedBytes, "; active bytecode length: ").concat(activeBytecodeLength));
  }
  return useOneStackItem(state, function (nextState, _ref5) {
    var _ref6 = _slicedToArray(_ref5, 1),
      item = _ref6[0];
    if (item.length === 1 && item[0] === 1) {
      return nextState;
    }
    // eslint-disable-next-line functional/no-expression-statement, functional/immutable-data
    nextState.ip = controlValue - 1;
    return nextState;
  });
};

/**
 * The `BCH_CHIPs` instruction set.
 *
 * Note: to maximize script compilation compatibility, this instruction set also
 * includes the previous names for new opcodes (e.g. `OP_VERIF` for `OP_BEGIN`).
 */
var OpcodesBCHCHIPs;
(function (OpcodesBCHCHIPs) {
  /**
   * A.K.A. `OP_FALSE` or `OP_PUSHBYTES_0`
   */
  OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_0"] = 0] = "OP_0";
  OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_PUSHBYTES_1"] = 1] = "OP_PUSHBYTES_1";
  OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_PUSHBYTES_2"] = 2] = "OP_PUSHBYTES_2";
  OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_PUSHBYTES_3"] = 3] = "OP_PUSHBYTES_3";
  OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_PUSHBYTES_4"] = 4] = "OP_PUSHBYTES_4";
  OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_PUSHBYTES_5"] = 5] = "OP_PUSHBYTES_5";
  OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_PUSHBYTES_6"] = 6] = "OP_PUSHBYTES_6";
  OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_PUSHBYTES_7"] = 7] = "OP_PUSHBYTES_7";
  OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_PUSHBYTES_8"] = 8] = "OP_PUSHBYTES_8";
  OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_PUSHBYTES_9"] = 9] = "OP_PUSHBYTES_9";
  OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_PUSHBYTES_10"] = 10] = "OP_PUSHBYTES_10";
  OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_PUSHBYTES_11"] = 11] = "OP_PUSHBYTES_11";
  OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_PUSHBYTES_12"] = 12] = "OP_PUSHBYTES_12";
  OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_PUSHBYTES_13"] = 13] = "OP_PUSHBYTES_13";
  OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_PUSHBYTES_14"] = 14] = "OP_PUSHBYTES_14";
  OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_PUSHBYTES_15"] = 15] = "OP_PUSHBYTES_15";
  OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_PUSHBYTES_16"] = 16] = "OP_PUSHBYTES_16";
  OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_PUSHBYTES_17"] = 17] = "OP_PUSHBYTES_17";
  OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_PUSHBYTES_18"] = 18] = "OP_PUSHBYTES_18";
  OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_PUSHBYTES_19"] = 19] = "OP_PUSHBYTES_19";
  OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_PUSHBYTES_20"] = 20] = "OP_PUSHBYTES_20";
  OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_PUSHBYTES_21"] = 21] = "OP_PUSHBYTES_21";
  OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_PUSHBYTES_22"] = 22] = "OP_PUSHBYTES_22";
  OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_PUSHBYTES_23"] = 23] = "OP_PUSHBYTES_23";
  OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_PUSHBYTES_24"] = 24] = "OP_PUSHBYTES_24";
  OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_PUSHBYTES_25"] = 25] = "OP_PUSHBYTES_25";
  OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_PUSHBYTES_26"] = 26] = "OP_PUSHBYTES_26";
  OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_PUSHBYTES_27"] = 27] = "OP_PUSHBYTES_27";
  OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_PUSHBYTES_28"] = 28] = "OP_PUSHBYTES_28";
  OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_PUSHBYTES_29"] = 29] = "OP_PUSHBYTES_29";
  OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_PUSHBYTES_30"] = 30] = "OP_PUSHBYTES_30";
  OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_PUSHBYTES_31"] = 31] = "OP_PUSHBYTES_31";
  OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_PUSHBYTES_32"] = 32] = "OP_PUSHBYTES_32";
  OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_PUSHBYTES_33"] = 33] = "OP_PUSHBYTES_33";
  OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_PUSHBYTES_34"] = 34] = "OP_PUSHBYTES_34";
  OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_PUSHBYTES_35"] = 35] = "OP_PUSHBYTES_35";
  OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_PUSHBYTES_36"] = 36] = "OP_PUSHBYTES_36";
  OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_PUSHBYTES_37"] = 37] = "OP_PUSHBYTES_37";
  OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_PUSHBYTES_38"] = 38] = "OP_PUSHBYTES_38";
  OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_PUSHBYTES_39"] = 39] = "OP_PUSHBYTES_39";
  OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_PUSHBYTES_40"] = 40] = "OP_PUSHBYTES_40";
  OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_PUSHBYTES_41"] = 41] = "OP_PUSHBYTES_41";
  OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_PUSHBYTES_42"] = 42] = "OP_PUSHBYTES_42";
  OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_PUSHBYTES_43"] = 43] = "OP_PUSHBYTES_43";
  OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_PUSHBYTES_44"] = 44] = "OP_PUSHBYTES_44";
  OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_PUSHBYTES_45"] = 45] = "OP_PUSHBYTES_45";
  OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_PUSHBYTES_46"] = 46] = "OP_PUSHBYTES_46";
  OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_PUSHBYTES_47"] = 47] = "OP_PUSHBYTES_47";
  OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_PUSHBYTES_48"] = 48] = "OP_PUSHBYTES_48";
  OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_PUSHBYTES_49"] = 49] = "OP_PUSHBYTES_49";
  OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_PUSHBYTES_50"] = 50] = "OP_PUSHBYTES_50";
  OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_PUSHBYTES_51"] = 51] = "OP_PUSHBYTES_51";
  OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_PUSHBYTES_52"] = 52] = "OP_PUSHBYTES_52";
  OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_PUSHBYTES_53"] = 53] = "OP_PUSHBYTES_53";
  OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_PUSHBYTES_54"] = 54] = "OP_PUSHBYTES_54";
  OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_PUSHBYTES_55"] = 55] = "OP_PUSHBYTES_55";
  OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_PUSHBYTES_56"] = 56] = "OP_PUSHBYTES_56";
  OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_PUSHBYTES_57"] = 57] = "OP_PUSHBYTES_57";
  OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_PUSHBYTES_58"] = 58] = "OP_PUSHBYTES_58";
  OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_PUSHBYTES_59"] = 59] = "OP_PUSHBYTES_59";
  OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_PUSHBYTES_60"] = 60] = "OP_PUSHBYTES_60";
  OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_PUSHBYTES_61"] = 61] = "OP_PUSHBYTES_61";
  OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_PUSHBYTES_62"] = 62] = "OP_PUSHBYTES_62";
  OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_PUSHBYTES_63"] = 63] = "OP_PUSHBYTES_63";
  OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_PUSHBYTES_64"] = 64] = "OP_PUSHBYTES_64";
  OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_PUSHBYTES_65"] = 65] = "OP_PUSHBYTES_65";
  OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_PUSHBYTES_66"] = 66] = "OP_PUSHBYTES_66";
  OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_PUSHBYTES_67"] = 67] = "OP_PUSHBYTES_67";
  OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_PUSHBYTES_68"] = 68] = "OP_PUSHBYTES_68";
  OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_PUSHBYTES_69"] = 69] = "OP_PUSHBYTES_69";
  OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_PUSHBYTES_70"] = 70] = "OP_PUSHBYTES_70";
  OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_PUSHBYTES_71"] = 71] = "OP_PUSHBYTES_71";
  OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_PUSHBYTES_72"] = 72] = "OP_PUSHBYTES_72";
  OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_PUSHBYTES_73"] = 73] = "OP_PUSHBYTES_73";
  OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_PUSHBYTES_74"] = 74] = "OP_PUSHBYTES_74";
  OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_PUSHBYTES_75"] = 75] = "OP_PUSHBYTES_75";
  OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_PUSHDATA_1"] = 76] = "OP_PUSHDATA_1";
  OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_PUSHDATA_2"] = 77] = "OP_PUSHDATA_2";
  OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_PUSHDATA_4"] = 78] = "OP_PUSHDATA_4";
  OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_1NEGATE"] = 79] = "OP_1NEGATE";
  OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_RESERVED"] = 80] = "OP_RESERVED";
  /**
   * A.K.A. `OP_TRUE`
   */
  OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_1"] = 81] = "OP_1";
  OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_2"] = 82] = "OP_2";
  OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_3"] = 83] = "OP_3";
  OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_4"] = 84] = "OP_4";
  OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_5"] = 85] = "OP_5";
  OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_6"] = 86] = "OP_6";
  OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_7"] = 87] = "OP_7";
  OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_8"] = 88] = "OP_8";
  OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_9"] = 89] = "OP_9";
  OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_10"] = 90] = "OP_10";
  OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_11"] = 91] = "OP_11";
  OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_12"] = 92] = "OP_12";
  OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_13"] = 93] = "OP_13";
  OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_14"] = 94] = "OP_14";
  OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_15"] = 95] = "OP_15";
  OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_16"] = 96] = "OP_16";
  OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_NOP"] = 97] = "OP_NOP";
  OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_VER"] = 98] = "OP_VER";
  OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_IF"] = 99] = "OP_IF";
  OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_NOTIF"] = 100] = "OP_NOTIF";
  OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_VERIF"] = 101] = "OP_VERIF";
  // eslint-disable-next-line @typescript-eslint/no-duplicate-enum-values
  OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_BEGIN"] = 101] = "OP_BEGIN";
  OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_VERNOTIF"] = 102] = "OP_VERNOTIF";
  // eslint-disable-next-line @typescript-eslint/no-duplicate-enum-values
  OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_UNTIL"] = 102] = "OP_UNTIL";
  OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_ELSE"] = 103] = "OP_ELSE";
  OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_ENDIF"] = 104] = "OP_ENDIF";
  OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_VERIFY"] = 105] = "OP_VERIFY";
  OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_RETURN"] = 106] = "OP_RETURN";
  OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_TOALTSTACK"] = 107] = "OP_TOALTSTACK";
  OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_FROMALTSTACK"] = 108] = "OP_FROMALTSTACK";
  OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_2DROP"] = 109] = "OP_2DROP";
  OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_2DUP"] = 110] = "OP_2DUP";
  OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_3DUP"] = 111] = "OP_3DUP";
  OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_2OVER"] = 112] = "OP_2OVER";
  OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_2ROT"] = 113] = "OP_2ROT";
  OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_2SWAP"] = 114] = "OP_2SWAP";
  OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_IFDUP"] = 115] = "OP_IFDUP";
  OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_DEPTH"] = 116] = "OP_DEPTH";
  OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_DROP"] = 117] = "OP_DROP";
  OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_DUP"] = 118] = "OP_DUP";
  OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_NIP"] = 119] = "OP_NIP";
  OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_OVER"] = 120] = "OP_OVER";
  OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_PICK"] = 121] = "OP_PICK";
  OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_ROLL"] = 122] = "OP_ROLL";
  OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_ROT"] = 123] = "OP_ROT";
  OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_SWAP"] = 124] = "OP_SWAP";
  OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_TUCK"] = 125] = "OP_TUCK";
  OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_CAT"] = 126] = "OP_CAT";
  OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_SPLIT"] = 127] = "OP_SPLIT";
  OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_NUM2BIN"] = 128] = "OP_NUM2BIN";
  OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_BIN2NUM"] = 129] = "OP_BIN2NUM";
  OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_SIZE"] = 130] = "OP_SIZE";
  OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_INVERT"] = 131] = "OP_INVERT";
  OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_AND"] = 132] = "OP_AND";
  OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_OR"] = 133] = "OP_OR";
  OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_XOR"] = 134] = "OP_XOR";
  OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_EQUAL"] = 135] = "OP_EQUAL";
  OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_EQUALVERIFY"] = 136] = "OP_EQUALVERIFY";
  OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_RESERVED1"] = 137] = "OP_RESERVED1";
  OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_RESERVED2"] = 138] = "OP_RESERVED2";
  OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_1ADD"] = 139] = "OP_1ADD";
  OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_1SUB"] = 140] = "OP_1SUB";
  OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_2MUL"] = 141] = "OP_2MUL";
  OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_2DIV"] = 142] = "OP_2DIV";
  OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_NEGATE"] = 143] = "OP_NEGATE";
  OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_ABS"] = 144] = "OP_ABS";
  OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_NOT"] = 145] = "OP_NOT";
  // eslint-disable-next-line @typescript-eslint/no-duplicate-enum-values
  OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_0EQUAL"] = 145] = "OP_0EQUAL";
  OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_0NOTEQUAL"] = 146] = "OP_0NOTEQUAL";
  OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_ADD"] = 147] = "OP_ADD";
  OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_SUB"] = 148] = "OP_SUB";
  OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_MUL"] = 149] = "OP_MUL";
  OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_DIV"] = 150] = "OP_DIV";
  OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_MOD"] = 151] = "OP_MOD";
  OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_LSHIFT"] = 152] = "OP_LSHIFT";
  OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_RSHIFT"] = 153] = "OP_RSHIFT";
  OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_BOOLAND"] = 154] = "OP_BOOLAND";
  OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_BOOLOR"] = 155] = "OP_BOOLOR";
  OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_NUMEQUAL"] = 156] = "OP_NUMEQUAL";
  OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_NUMEQUALVERIFY"] = 157] = "OP_NUMEQUALVERIFY";
  OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_NUMNOTEQUAL"] = 158] = "OP_NUMNOTEQUAL";
  OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_LESSTHAN"] = 159] = "OP_LESSTHAN";
  OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_GREATERTHAN"] = 160] = "OP_GREATERTHAN";
  OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_LESSTHANOREQUAL"] = 161] = "OP_LESSTHANOREQUAL";
  OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_GREATERTHANOREQUAL"] = 162] = "OP_GREATERTHANOREQUAL";
  OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_MIN"] = 163] = "OP_MIN";
  OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_MAX"] = 164] = "OP_MAX";
  OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_WITHIN"] = 165] = "OP_WITHIN";
  OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_RIPEMD160"] = 166] = "OP_RIPEMD160";
  OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_SHA1"] = 167] = "OP_SHA1";
  OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_SHA256"] = 168] = "OP_SHA256";
  OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_HASH160"] = 169] = "OP_HASH160";
  OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_HASH256"] = 170] = "OP_HASH256";
  OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_CODESEPARATOR"] = 171] = "OP_CODESEPARATOR";
  OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_CHECKSIG"] = 172] = "OP_CHECKSIG";
  OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_CHECKSIGVERIFY"] = 173] = "OP_CHECKSIGVERIFY";
  OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_CHECKMULTISIG"] = 174] = "OP_CHECKMULTISIG";
  OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_CHECKMULTISIGVERIFY"] = 175] = "OP_CHECKMULTISIGVERIFY";
  OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_NOP1"] = 176] = "OP_NOP1";
  OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_CHECKLOCKTIMEVERIFY"] = 177] = "OP_CHECKLOCKTIMEVERIFY";
  OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_CHECKSEQUENCEVERIFY"] = 178] = "OP_CHECKSEQUENCEVERIFY";
  OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_NOP4"] = 179] = "OP_NOP4";
  OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_NOP5"] = 180] = "OP_NOP5";
  OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_NOP6"] = 181] = "OP_NOP6";
  OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_NOP7"] = 182] = "OP_NOP7";
  OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_NOP8"] = 183] = "OP_NOP8";
  OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_NOP9"] = 184] = "OP_NOP9";
  OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_NOP10"] = 185] = "OP_NOP10";
  OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_CHECKDATASIG"] = 186] = "OP_CHECKDATASIG";
  OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_CHECKDATASIGVERIFY"] = 187] = "OP_CHECKDATASIGVERIFY";
  OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_REVERSEBYTES"] = 188] = "OP_REVERSEBYTES";
  /**
   * First codepoint left undefined before nullary introspection operations.
   */
  OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_UNKNOWN189"] = 189] = "OP_UNKNOWN189";
  OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_UNKNOWN190"] = 190] = "OP_UNKNOWN190";
  /**
   * Last codepoint left undefined before nullary introspection operations.
   */
  OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_UNKNOWN191"] = 191] = "OP_UNKNOWN191";
  OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_INPUTINDEX"] = 192] = "OP_INPUTINDEX";
  OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_ACTIVEBYTECODE"] = 193] = "OP_ACTIVEBYTECODE";
  OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_TXVERSION"] = 194] = "OP_TXVERSION";
  OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_TXINPUTCOUNT"] = 195] = "OP_TXINPUTCOUNT";
  OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_TXOUTPUTCOUNT"] = 196] = "OP_TXOUTPUTCOUNT";
  OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_TXLOCKTIME"] = 197] = "OP_TXLOCKTIME";
  OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_UTXOVALUE"] = 198] = "OP_UTXOVALUE";
  OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_UTXOBYTECODE"] = 199] = "OP_UTXOBYTECODE";
  OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_OUTPOINTTXHASH"] = 200] = "OP_OUTPOINTTXHASH";
  OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_OUTPOINTINDEX"] = 201] = "OP_OUTPOINTINDEX";
  OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_INPUTBYTECODE"] = 202] = "OP_INPUTBYTECODE";
  OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_INPUTSEQUENCENUMBER"] = 203] = "OP_INPUTSEQUENCENUMBER";
  OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_OUTPUTVALUE"] = 204] = "OP_OUTPUTVALUE";
  OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_OUTPUTBYTECODE"] = 205] = "OP_OUTPUTBYTECODE";
  OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_UTXOTOKENCATEGORY"] = 206] = "OP_UTXOTOKENCATEGORY";
  OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_UTXOTOKENCOMMITMENT"] = 207] = "OP_UTXOTOKENCOMMITMENT";
  OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_UTXOTOKENAMOUNT"] = 208] = "OP_UTXOTOKENAMOUNT";
  OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_OUTPUTTOKENCATEGORY"] = 209] = "OP_OUTPUTTOKENCATEGORY";
  OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_OUTPUTTOKENCOMMITMENT"] = 210] = "OP_OUTPUTTOKENCOMMITMENT";
  OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_OUTPUTTOKENAMOUNT"] = 211] = "OP_OUTPUTTOKENAMOUNT";
  OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_UNKNOWN212"] = 212] = "OP_UNKNOWN212";
  OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_UNKNOWN213"] = 213] = "OP_UNKNOWN213";
  OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_UNKNOWN214"] = 214] = "OP_UNKNOWN214";
  OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_UNKNOWN215"] = 215] = "OP_UNKNOWN215";
  OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_UNKNOWN216"] = 216] = "OP_UNKNOWN216";
  OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_UNKNOWN217"] = 217] = "OP_UNKNOWN217";
  OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_UNKNOWN218"] = 218] = "OP_UNKNOWN218";
  OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_UNKNOWN219"] = 219] = "OP_UNKNOWN219";
  OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_UNKNOWN220"] = 220] = "OP_UNKNOWN220";
  OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_UNKNOWN221"] = 221] = "OP_UNKNOWN221";
  OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_UNKNOWN222"] = 222] = "OP_UNKNOWN222";
  OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_UNKNOWN223"] = 223] = "OP_UNKNOWN223";
  OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_UNKNOWN224"] = 224] = "OP_UNKNOWN224";
  OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_UNKNOWN225"] = 225] = "OP_UNKNOWN225";
  OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_UNKNOWN226"] = 226] = "OP_UNKNOWN226";
  OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_UNKNOWN227"] = 227] = "OP_UNKNOWN227";
  OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_UNKNOWN228"] = 228] = "OP_UNKNOWN228";
  OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_UNKNOWN229"] = 229] = "OP_UNKNOWN229";
  OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_UNKNOWN230"] = 230] = "OP_UNKNOWN230";
  OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_UNKNOWN231"] = 231] = "OP_UNKNOWN231";
  OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_UNKNOWN232"] = 232] = "OP_UNKNOWN232";
  OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_UNKNOWN233"] = 233] = "OP_UNKNOWN233";
  OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_UNKNOWN234"] = 234] = "OP_UNKNOWN234";
  OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_UNKNOWN235"] = 235] = "OP_UNKNOWN235";
  OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_UNKNOWN236"] = 236] = "OP_UNKNOWN236";
  OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_UNKNOWN237"] = 237] = "OP_UNKNOWN237";
  OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_UNKNOWN238"] = 238] = "OP_UNKNOWN238";
  OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_UNKNOWN239"] = 239] = "OP_UNKNOWN239";
  OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_UNKNOWN240"] = 240] = "OP_UNKNOWN240";
  OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_UNKNOWN241"] = 241] = "OP_UNKNOWN241";
  OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_UNKNOWN242"] = 242] = "OP_UNKNOWN242";
  OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_UNKNOWN243"] = 243] = "OP_UNKNOWN243";
  OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_UNKNOWN244"] = 244] = "OP_UNKNOWN244";
  OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_UNKNOWN245"] = 245] = "OP_UNKNOWN245";
  OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_UNKNOWN246"] = 246] = "OP_UNKNOWN246";
  OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_UNKNOWN247"] = 247] = "OP_UNKNOWN247";
  OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_UNKNOWN248"] = 248] = "OP_UNKNOWN248";
  OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_UNKNOWN249"] = 249] = "OP_UNKNOWN249";
  OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_UNKNOWN250"] = 250] = "OP_UNKNOWN250";
  OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_UNKNOWN251"] = 251] = "OP_UNKNOWN251";
  OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_UNKNOWN252"] = 252] = "OP_UNKNOWN252";
  OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_UNKNOWN253"] = 253] = "OP_UNKNOWN253";
  OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_UNKNOWN254"] = 254] = "OP_UNKNOWN254";
  OpcodesBCHCHIPs[OpcodesBCHCHIPs["OP_UNKNOWN255"] = 255] = "OP_UNKNOWN255";
})(OpcodesBCHCHIPs || (OpcodesBCHCHIPs = {}));

/**
 * create an instance of the BCH CHIPs virtual machine instruction set, an
 * informal, speculative instruction set that implements a variety of future
 * Bitcoin Cash Improvement Proposals (CHIPs).
 *
 * @param standard - If `true`, the additional `isStandard` validations will be
 * enabled. Transactions that fail these rules are often called "non-standard"
 * and can technically be included by miners in valid blocks, but most network
 * nodes will refuse to relay them. (Default: `true`)
 */
var createInstructionSetBCHCHIPs = function createInstructionSetBCHCHIPs() {
  var _objectSpread2$1, _ref2, _ref3, _objectSpread3;
  var standard = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
  var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {
      ripemd160: ripemd160$1,
      secp256k1: secp256k1,
      sha1: sha1$1,
      sha256: sha256$1
    },
    ripemd160 = _ref.ripemd160,
    secp256k1$1 = _ref.secp256k1,
    sha1 = _ref.sha1,
    sha256 = _ref.sha256;
  var conditionallyPush = pushOperationChipLoops();
  return {
    clone: cloneAuthenticationProgramStateBCHCHIPs,
    continue: function _continue(state) {
      return state.error === undefined && state.ip < state.instructions.length;
    },
    // eslint-disable-next-line complexity
    evaluate: function evaluate(program, stateEvaluate) {
      var _p2shStack$pop;
      var unlockingBytecode =
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      program.transaction.inputs[program.inputIndex].unlockingBytecode;
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      var lockingBytecode = program.sourceOutputs[program.inputIndex].lockingBytecode;
      var unlockingInstructions = decodeAuthenticationInstructions(unlockingBytecode);
      var lockingInstructions = decodeAuthenticationInstructions(lockingBytecode);
      var initialState = createAuthenticationProgramStateBCHCHIPs({
        instructions: unlockingInstructions,
        program: program,
        stack: []
      });
      if (unlockingBytecode.length > ConsensusBCH.maximumBytecodeLength) {
        return applyError(initialState, "The provided unlocking bytecode (".concat(unlockingBytecode.length, " bytes) exceeds the maximum bytecode length (").concat(ConsensusBCH.maximumBytecodeLength, " bytes)."));
      }
      if (authenticationInstructionsAreMalformed(unlockingInstructions)) {
        return applyError(initialState, AuthenticationErrorCommon.malformedUnlockingBytecode);
      }
      if (!isPushOnly(unlockingBytecode)) {
        return applyError(initialState, AuthenticationErrorCommon.requiresPushOnly);
      }
      if (lockingBytecode.length > ConsensusBCH.maximumBytecodeLength) {
        return applyError(initialState, AuthenticationErrorCommon.exceededMaximumBytecodeLengthLocking);
      }
      if (authenticationInstructionsAreMalformed(lockingInstructions)) {
        return applyError(initialState, AuthenticationErrorCommon.malformedLockingBytecode);
      }
      var unlockingResult = stateEvaluate(initialState);
      if (unlockingResult.error !== undefined) {
        return unlockingResult;
      }
      if (unlockingResult.controlStack.length !== 0) {
        return applyError(initialState, AuthenticationErrorCommon.nonEmptyControlStack);
      }
      var lockingResult = stateEvaluate(createAuthenticationProgramStateBCHCHIPs({
        instructions: lockingInstructions,
        program: program,
        stack: unlockingResult.stack
      }));
      if (!isPayToScriptHash20(lockingBytecode)) {
        return lockingResult;
      }
      var p2shStack = cloneStack(unlockingResult.stack);
      // eslint-disable-next-line functional/immutable-data
      var p2shScript = (_p2shStack$pop = p2shStack.pop()) !== null && _p2shStack$pop !== void 0 ? _p2shStack$pop : Uint8Array.of();
      if (p2shStack.length === 0 && isWitnessProgram(p2shScript)) {
        return lockingResult;
      }
      var p2shInstructions = decodeAuthenticationInstructions(p2shScript);
      return authenticationInstructionsAreMalformed(p2shInstructions) ? _objectSpread2(_objectSpread2({}, lockingResult), {}, {
        error: AuthenticationErrorCommon.malformedP2shBytecode
      }) : stateEvaluate(createAuthenticationProgramStateBCHCHIPs({
        instructions: p2shInstructions,
        program: program,
        stack: p2shStack
      }));
    },
    every: function every(state) {
      if (state.stack.length + state.alternateStack.length > ConsensusBCH.maximumStackDepth) {
        return applyError(state, AuthenticationErrorCommon.exceededMaximumStackDepth);
      }
      return state;
    },
    operations: _objectSpread2(_objectSpread2((_objectSpread2$1 = {}, _defineProperty(_objectSpread2$1, OpcodesBCHCHIPs.OP_0, conditionallyPush), _defineProperty(_objectSpread2$1, OpcodesBCHCHIPs.OP_PUSHBYTES_1, conditionallyPush), _defineProperty(_objectSpread2$1, OpcodesBCHCHIPs.OP_PUSHBYTES_2, conditionallyPush), _defineProperty(_objectSpread2$1, OpcodesBCHCHIPs.OP_PUSHBYTES_3, conditionallyPush), _defineProperty(_objectSpread2$1, OpcodesBCHCHIPs.OP_PUSHBYTES_4, conditionallyPush), _defineProperty(_objectSpread2$1, OpcodesBCHCHIPs.OP_PUSHBYTES_5, conditionallyPush), _defineProperty(_objectSpread2$1, OpcodesBCHCHIPs.OP_PUSHBYTES_6, conditionallyPush), _defineProperty(_objectSpread2$1, OpcodesBCHCHIPs.OP_PUSHBYTES_7, conditionallyPush), _defineProperty(_objectSpread2$1, OpcodesBCHCHIPs.OP_PUSHBYTES_8, conditionallyPush), _defineProperty(_objectSpread2$1, OpcodesBCHCHIPs.OP_PUSHBYTES_9, conditionallyPush), _defineProperty(_objectSpread2$1, OpcodesBCHCHIPs.OP_PUSHBYTES_10, conditionallyPush), _defineProperty(_objectSpread2$1, OpcodesBCHCHIPs.OP_PUSHBYTES_11, conditionallyPush), _defineProperty(_objectSpread2$1, OpcodesBCHCHIPs.OP_PUSHBYTES_12, conditionallyPush), _defineProperty(_objectSpread2$1, OpcodesBCHCHIPs.OP_PUSHBYTES_13, conditionallyPush), _defineProperty(_objectSpread2$1, OpcodesBCHCHIPs.OP_PUSHBYTES_14, conditionallyPush), _defineProperty(_objectSpread2$1, OpcodesBCHCHIPs.OP_PUSHBYTES_15, conditionallyPush), _defineProperty(_objectSpread2$1, OpcodesBCHCHIPs.OP_PUSHBYTES_16, conditionallyPush), _defineProperty(_objectSpread2$1, OpcodesBCHCHIPs.OP_PUSHBYTES_17, conditionallyPush), _defineProperty(_objectSpread2$1, OpcodesBCHCHIPs.OP_PUSHBYTES_18, conditionallyPush), _defineProperty(_objectSpread2$1, OpcodesBCHCHIPs.OP_PUSHBYTES_19, conditionallyPush), _defineProperty(_objectSpread2$1, OpcodesBCHCHIPs.OP_PUSHBYTES_20, conditionallyPush), _defineProperty(_objectSpread2$1, OpcodesBCHCHIPs.OP_PUSHBYTES_21, conditionallyPush), _defineProperty(_objectSpread2$1, OpcodesBCHCHIPs.OP_PUSHBYTES_22, conditionallyPush), _defineProperty(_objectSpread2$1, OpcodesBCHCHIPs.OP_PUSHBYTES_23, conditionallyPush), _defineProperty(_objectSpread2$1, OpcodesBCHCHIPs.OP_PUSHBYTES_24, conditionallyPush), _defineProperty(_objectSpread2$1, OpcodesBCHCHIPs.OP_PUSHBYTES_25, conditionallyPush), _defineProperty(_objectSpread2$1, OpcodesBCHCHIPs.OP_PUSHBYTES_26, conditionallyPush), _defineProperty(_objectSpread2$1, OpcodesBCHCHIPs.OP_PUSHBYTES_27, conditionallyPush), _defineProperty(_objectSpread2$1, OpcodesBCHCHIPs.OP_PUSHBYTES_28, conditionallyPush), _defineProperty(_objectSpread2$1, OpcodesBCHCHIPs.OP_PUSHBYTES_29, conditionallyPush), _defineProperty(_objectSpread2$1, OpcodesBCHCHIPs.OP_PUSHBYTES_30, conditionallyPush), _defineProperty(_objectSpread2$1, OpcodesBCHCHIPs.OP_PUSHBYTES_31, conditionallyPush), _defineProperty(_objectSpread2$1, OpcodesBCHCHIPs.OP_PUSHBYTES_32, conditionallyPush), _defineProperty(_objectSpread2$1, OpcodesBCHCHIPs.OP_PUSHBYTES_33, conditionallyPush), _defineProperty(_objectSpread2$1, OpcodesBCHCHIPs.OP_PUSHBYTES_34, conditionallyPush), _defineProperty(_objectSpread2$1, OpcodesBCHCHIPs.OP_PUSHBYTES_35, conditionallyPush), _defineProperty(_objectSpread2$1, OpcodesBCHCHIPs.OP_PUSHBYTES_36, conditionallyPush), _defineProperty(_objectSpread2$1, OpcodesBCHCHIPs.OP_PUSHBYTES_37, conditionallyPush), _defineProperty(_objectSpread2$1, OpcodesBCHCHIPs.OP_PUSHBYTES_38, conditionallyPush), _defineProperty(_objectSpread2$1, OpcodesBCHCHIPs.OP_PUSHBYTES_39, conditionallyPush), _defineProperty(_objectSpread2$1, OpcodesBCHCHIPs.OP_PUSHBYTES_40, conditionallyPush), _defineProperty(_objectSpread2$1, OpcodesBCHCHIPs.OP_PUSHBYTES_41, conditionallyPush), _defineProperty(_objectSpread2$1, OpcodesBCHCHIPs.OP_PUSHBYTES_42, conditionallyPush), _defineProperty(_objectSpread2$1, OpcodesBCHCHIPs.OP_PUSHBYTES_43, conditionallyPush), _defineProperty(_objectSpread2$1, OpcodesBCHCHIPs.OP_PUSHBYTES_44, conditionallyPush), _defineProperty(_objectSpread2$1, OpcodesBCHCHIPs.OP_PUSHBYTES_45, conditionallyPush), _defineProperty(_objectSpread2$1, OpcodesBCHCHIPs.OP_PUSHBYTES_46, conditionallyPush), _defineProperty(_objectSpread2$1, OpcodesBCHCHIPs.OP_PUSHBYTES_47, conditionallyPush), _defineProperty(_objectSpread2$1, OpcodesBCHCHIPs.OP_PUSHBYTES_48, conditionallyPush), _defineProperty(_objectSpread2$1, OpcodesBCHCHIPs.OP_PUSHBYTES_49, conditionallyPush), _defineProperty(_objectSpread2$1, OpcodesBCHCHIPs.OP_PUSHBYTES_50, conditionallyPush), _defineProperty(_objectSpread2$1, OpcodesBCHCHIPs.OP_PUSHBYTES_51, conditionallyPush), _defineProperty(_objectSpread2$1, OpcodesBCHCHIPs.OP_PUSHBYTES_52, conditionallyPush), _defineProperty(_objectSpread2$1, OpcodesBCHCHIPs.OP_PUSHBYTES_53, conditionallyPush), _defineProperty(_objectSpread2$1, OpcodesBCHCHIPs.OP_PUSHBYTES_54, conditionallyPush), _defineProperty(_objectSpread2$1, OpcodesBCHCHIPs.OP_PUSHBYTES_55, conditionallyPush), _defineProperty(_objectSpread2$1, OpcodesBCHCHIPs.OP_PUSHBYTES_56, conditionallyPush), _defineProperty(_objectSpread2$1, OpcodesBCHCHIPs.OP_PUSHBYTES_57, conditionallyPush), _defineProperty(_objectSpread2$1, OpcodesBCHCHIPs.OP_PUSHBYTES_58, conditionallyPush), _defineProperty(_objectSpread2$1, OpcodesBCHCHIPs.OP_PUSHBYTES_59, conditionallyPush), _defineProperty(_objectSpread2$1, OpcodesBCHCHIPs.OP_PUSHBYTES_60, conditionallyPush), _defineProperty(_objectSpread2$1, OpcodesBCHCHIPs.OP_PUSHBYTES_61, conditionallyPush), _defineProperty(_objectSpread2$1, OpcodesBCHCHIPs.OP_PUSHBYTES_62, conditionallyPush), _defineProperty(_objectSpread2$1, OpcodesBCHCHIPs.OP_PUSHBYTES_63, conditionallyPush), _defineProperty(_objectSpread2$1, OpcodesBCHCHIPs.OP_PUSHBYTES_64, conditionallyPush), _defineProperty(_objectSpread2$1, OpcodesBCHCHIPs.OP_PUSHBYTES_65, conditionallyPush), _defineProperty(_objectSpread2$1, OpcodesBCHCHIPs.OP_PUSHBYTES_66, conditionallyPush), _defineProperty(_objectSpread2$1, OpcodesBCHCHIPs.OP_PUSHBYTES_67, conditionallyPush), _defineProperty(_objectSpread2$1, OpcodesBCHCHIPs.OP_PUSHBYTES_68, conditionallyPush), _defineProperty(_objectSpread2$1, OpcodesBCHCHIPs.OP_PUSHBYTES_69, conditionallyPush), _defineProperty(_objectSpread2$1, OpcodesBCHCHIPs.OP_PUSHBYTES_70, conditionallyPush), _defineProperty(_objectSpread2$1, OpcodesBCHCHIPs.OP_PUSHBYTES_71, conditionallyPush), _defineProperty(_objectSpread2$1, OpcodesBCHCHIPs.OP_PUSHBYTES_72, conditionallyPush), _defineProperty(_objectSpread2$1, OpcodesBCHCHIPs.OP_PUSHBYTES_73, conditionallyPush), _defineProperty(_objectSpread2$1, OpcodesBCHCHIPs.OP_PUSHBYTES_74, conditionallyPush), _defineProperty(_objectSpread2$1, OpcodesBCHCHIPs.OP_PUSHBYTES_75, conditionallyPush), _defineProperty(_objectSpread2$1, OpcodesBCHCHIPs.OP_PUSHDATA_1, conditionallyPush), _defineProperty(_objectSpread2$1, OpcodesBCHCHIPs.OP_PUSHDATA_2, conditionallyPush), _defineProperty(_objectSpread2$1, OpcodesBCHCHIPs.OP_PUSHDATA_4, conditionallyPush), _defineProperty(_objectSpread2$1, OpcodesBCHCHIPs.OP_1NEGATE, conditionallyEvaluateChipLoops(pushNumberOperation(-1))), _defineProperty(_objectSpread2$1, OpcodesBCHCHIPs.OP_RESERVED, conditionallyEvaluateChipLoops(reservedOperation)), _defineProperty(_objectSpread2$1, OpcodesBCHCHIPs.OP_1, conditionallyEvaluateChipLoops(pushNumberOperation(1))), _defineProperty(_objectSpread2$1, OpcodesBCHCHIPs.OP_2, conditionallyEvaluateChipLoops(pushNumberOperation(2))), _defineProperty(_objectSpread2$1, OpcodesBCHCHIPs.OP_3, conditionallyEvaluateChipLoops(pushNumberOperation(3))), _defineProperty(_objectSpread2$1, OpcodesBCHCHIPs.OP_4, conditionallyEvaluateChipLoops(pushNumberOperation(4))), _defineProperty(_objectSpread2$1, OpcodesBCHCHIPs.OP_5, conditionallyEvaluateChipLoops(pushNumberOperation(5))), _defineProperty(_objectSpread2$1, OpcodesBCHCHIPs.OP_6, conditionallyEvaluateChipLoops(pushNumberOperation(6))), _defineProperty(_objectSpread2$1, OpcodesBCHCHIPs.OP_7, conditionallyEvaluateChipLoops(pushNumberOperation(7))), _defineProperty(_objectSpread2$1, OpcodesBCHCHIPs.OP_8, conditionallyEvaluateChipLoops(pushNumberOperation(8))), _defineProperty(_objectSpread2$1, OpcodesBCHCHIPs.OP_9, conditionallyEvaluateChipLoops(pushNumberOperation(9))), _defineProperty(_objectSpread2$1, OpcodesBCHCHIPs.OP_10, conditionallyEvaluateChipLoops(pushNumberOperation(10))), _defineProperty(_objectSpread2$1, OpcodesBCHCHIPs.OP_11, conditionallyEvaluateChipLoops(pushNumberOperation(11))), _defineProperty(_objectSpread2$1, OpcodesBCHCHIPs.OP_12, conditionallyEvaluateChipLoops(pushNumberOperation(12))), _defineProperty(_objectSpread2$1, OpcodesBCHCHIPs.OP_13, conditionallyEvaluateChipLoops(pushNumberOperation(13))), _defineProperty(_objectSpread2$1, OpcodesBCHCHIPs.OP_14, conditionallyEvaluateChipLoops(pushNumberOperation(14))), _defineProperty(_objectSpread2$1, OpcodesBCHCHIPs.OP_15, conditionallyEvaluateChipLoops(pushNumberOperation(15))), _defineProperty(_objectSpread2$1, OpcodesBCHCHIPs.OP_16, conditionallyEvaluateChipLoops(pushNumberOperation(16))), _defineProperty(_objectSpread2$1, OpcodesBCHCHIPs.OP_NOP, conditionallyEvaluateChipLoops(opNop)), _defineProperty(_objectSpread2$1, OpcodesBCHCHIPs.OP_VER, conditionallyEvaluateChipLoops(reservedOperation)), _defineProperty(_objectSpread2$1, OpcodesBCHCHIPs.OP_IF, opIfChipLoops), _defineProperty(_objectSpread2$1, OpcodesBCHCHIPs.OP_NOTIF, opNotIfChipLoops), _defineProperty(_objectSpread2$1, OpcodesBCHCHIPs.OP_BEGIN, conditionallyEvaluateChipLoops(opBegin)), _defineProperty(_objectSpread2$1, OpcodesBCHCHIPs.OP_UNTIL, conditionallyEvaluateChipLoops(opUntil)), _defineProperty(_objectSpread2$1, OpcodesBCHCHIPs.OP_ELSE, opElseChipLoops), _defineProperty(_objectSpread2$1, OpcodesBCHCHIPs.OP_ENDIF, opEndIfChipLoops), _defineProperty(_objectSpread2$1, OpcodesBCHCHIPs.OP_VERIFY, conditionallyEvaluateChipLoops(opVerify)), _defineProperty(_objectSpread2$1, OpcodesBCHCHIPs.OP_RETURN, conditionallyEvaluateChipLoops(opReturn)), _defineProperty(_objectSpread2$1, OpcodesBCHCHIPs.OP_TOALTSTACK, conditionallyEvaluateChipLoops(opToAltStack)), _defineProperty(_objectSpread2$1, OpcodesBCHCHIPs.OP_FROMALTSTACK, conditionallyEvaluateChipLoops(opFromAltStack)), _defineProperty(_objectSpread2$1, OpcodesBCHCHIPs.OP_2DROP, conditionallyEvaluateChipLoops(op2Drop)), _defineProperty(_objectSpread2$1, OpcodesBCHCHIPs.OP_2DUP, conditionallyEvaluateChipLoops(op2Dup)), _defineProperty(_objectSpread2$1, OpcodesBCHCHIPs.OP_3DUP, conditionallyEvaluateChipLoops(op3Dup)), _defineProperty(_objectSpread2$1, OpcodesBCHCHIPs.OP_2OVER, conditionallyEvaluateChipLoops(op2Over)), _defineProperty(_objectSpread2$1, OpcodesBCHCHIPs.OP_2ROT, conditionallyEvaluateChipLoops(op2Rot)), _defineProperty(_objectSpread2$1, OpcodesBCHCHIPs.OP_2SWAP, conditionallyEvaluateChipLoops(op2Swap)), _defineProperty(_objectSpread2$1, OpcodesBCHCHIPs.OP_IFDUP, conditionallyEvaluateChipLoops(opIfDup)), _defineProperty(_objectSpread2$1, OpcodesBCHCHIPs.OP_DEPTH, conditionallyEvaluateChipLoops(opDepth)), _defineProperty(_objectSpread2$1, OpcodesBCHCHIPs.OP_DROP, conditionallyEvaluateChipLoops(opDrop)), _defineProperty(_objectSpread2$1, OpcodesBCHCHIPs.OP_DUP, conditionallyEvaluateChipLoops(opDup)), _defineProperty(_objectSpread2$1, OpcodesBCHCHIPs.OP_NIP, conditionallyEvaluateChipLoops(opNip)), _defineProperty(_objectSpread2$1, OpcodesBCHCHIPs.OP_OVER, conditionallyEvaluateChipLoops(opOver)), _defineProperty(_objectSpread2$1, OpcodesBCHCHIPs.OP_PICK, conditionallyEvaluateChipLoops(opPick)), _defineProperty(_objectSpread2$1, OpcodesBCHCHIPs.OP_ROLL, conditionallyEvaluateChipLoops(opRoll)), _defineProperty(_objectSpread2$1, OpcodesBCHCHIPs.OP_ROT, conditionallyEvaluateChipLoops(opRot)), _defineProperty(_objectSpread2$1, OpcodesBCHCHIPs.OP_SWAP, conditionallyEvaluateChipLoops(opSwap)), _defineProperty(_objectSpread2$1, OpcodesBCHCHIPs.OP_TUCK, conditionallyEvaluateChipLoops(opTuck)), _defineProperty(_objectSpread2$1, OpcodesBCHCHIPs.OP_CAT, conditionallyEvaluateChipLoops(opCat)), _defineProperty(_objectSpread2$1, OpcodesBCHCHIPs.OP_SPLIT, conditionallyEvaluateChipLoops(opSplit)), _defineProperty(_objectSpread2$1, OpcodesBCHCHIPs.OP_NUM2BIN, conditionallyEvaluateChipLoops(opNum2Bin)), _defineProperty(_objectSpread2$1, OpcodesBCHCHIPs.OP_BIN2NUM, conditionallyEvaluateChipLoops(opBin2Num)), _defineProperty(_objectSpread2$1, OpcodesBCHCHIPs.OP_SIZE, conditionallyEvaluateChipLoops(opSize)), _defineProperty(_objectSpread2$1, OpcodesBCHCHIPs.OP_INVERT, disabledOperation), _defineProperty(_objectSpread2$1, OpcodesBCHCHIPs.OP_AND, conditionallyEvaluateChipLoops(opAnd)), _defineProperty(_objectSpread2$1, OpcodesBCHCHIPs.OP_OR, conditionallyEvaluateChipLoops(opOr)), _defineProperty(_objectSpread2$1, OpcodesBCHCHIPs.OP_XOR, conditionallyEvaluateChipLoops(opXor)), _defineProperty(_objectSpread2$1, OpcodesBCHCHIPs.OP_EQUAL, conditionallyEvaluateChipLoops(opEqual)), _defineProperty(_objectSpread2$1, OpcodesBCHCHIPs.OP_EQUALVERIFY, conditionallyEvaluateChipLoops(opEqualVerify)), _defineProperty(_objectSpread2$1, OpcodesBCHCHIPs.OP_RESERVED1, conditionallyEvaluateChipLoops(reservedOperation)), _defineProperty(_objectSpread2$1, OpcodesBCHCHIPs.OP_RESERVED2, conditionallyEvaluateChipLoops(reservedOperation)), _defineProperty(_objectSpread2$1, OpcodesBCHCHIPs.OP_1ADD, conditionallyEvaluateChipLoops(op1Add)), _defineProperty(_objectSpread2$1, OpcodesBCHCHIPs.OP_1SUB, conditionallyEvaluateChipLoops(op1Sub)), _defineProperty(_objectSpread2$1, OpcodesBCHCHIPs.OP_2MUL, disabledOperation), _defineProperty(_objectSpread2$1, OpcodesBCHCHIPs.OP_2DIV, disabledOperation), _defineProperty(_objectSpread2$1, OpcodesBCHCHIPs.OP_NEGATE, conditionallyEvaluateChipLoops(opNegate)), _defineProperty(_objectSpread2$1, OpcodesBCHCHIPs.OP_ABS, conditionallyEvaluateChipLoops(opAbs)), _defineProperty(_objectSpread2$1, OpcodesBCHCHIPs.OP_NOT, conditionallyEvaluateChipLoops(opNot)), _defineProperty(_objectSpread2$1, OpcodesBCHCHIPs.OP_0NOTEQUAL, conditionallyEvaluateChipLoops(op0NotEqual)), _defineProperty(_objectSpread2$1, OpcodesBCHCHIPs.OP_ADD, conditionallyEvaluateChipLoops(opAdd)), _defineProperty(_objectSpread2$1, OpcodesBCHCHIPs.OP_SUB, conditionallyEvaluateChipLoops(opSub)), _defineProperty(_objectSpread2$1, OpcodesBCHCHIPs.OP_MUL, conditionallyEvaluateChipLoops(opMul)), _defineProperty(_objectSpread2$1, OpcodesBCHCHIPs.OP_DIV, conditionallyEvaluateChipLoops(opDiv)), _defineProperty(_objectSpread2$1, OpcodesBCHCHIPs.OP_MOD, conditionallyEvaluateChipLoops(opMod)), _defineProperty(_objectSpread2$1, OpcodesBCHCHIPs.OP_LSHIFT, disabledOperation), _defineProperty(_objectSpread2$1, OpcodesBCHCHIPs.OP_RSHIFT, disabledOperation), _defineProperty(_objectSpread2$1, OpcodesBCHCHIPs.OP_BOOLAND, conditionallyEvaluateChipLoops(opBoolAnd)), _defineProperty(_objectSpread2$1, OpcodesBCHCHIPs.OP_BOOLOR, conditionallyEvaluateChipLoops(opBoolOr)), _defineProperty(_objectSpread2$1, OpcodesBCHCHIPs.OP_NUMEQUAL, conditionallyEvaluateChipLoops(opNumEqual)), _defineProperty(_objectSpread2$1, OpcodesBCHCHIPs.OP_NUMEQUALVERIFY, conditionallyEvaluateChipLoops(opNumEqualVerify)), _defineProperty(_objectSpread2$1, OpcodesBCHCHIPs.OP_NUMNOTEQUAL, conditionallyEvaluateChipLoops(opNumNotEqual)), _defineProperty(_objectSpread2$1, OpcodesBCHCHIPs.OP_LESSTHAN, conditionallyEvaluateChipLoops(opLessThan)), _defineProperty(_objectSpread2$1, OpcodesBCHCHIPs.OP_GREATERTHAN, conditionallyEvaluateChipLoops(opGreaterThan)), _defineProperty(_objectSpread2$1, OpcodesBCHCHIPs.OP_LESSTHANOREQUAL, conditionallyEvaluateChipLoops(opLessThanOrEqual)), _defineProperty(_objectSpread2$1, OpcodesBCHCHIPs.OP_GREATERTHANOREQUAL, conditionallyEvaluateChipLoops(opGreaterThanOrEqual)), _defineProperty(_objectSpread2$1, OpcodesBCHCHIPs.OP_MIN, conditionallyEvaluateChipLoops(opMin)), _defineProperty(_objectSpread2$1, OpcodesBCHCHIPs.OP_MAX, conditionallyEvaluateChipLoops(opMax)), _defineProperty(_objectSpread2$1, OpcodesBCHCHIPs.OP_WITHIN, conditionallyEvaluateChipLoops(opWithin)), _defineProperty(_objectSpread2$1, OpcodesBCHCHIPs.OP_RIPEMD160, conditionallyEvaluateChipLoops(opRipemd160({
      ripemd160: ripemd160
    }))), _defineProperty(_objectSpread2$1, OpcodesBCHCHIPs.OP_SHA1, conditionallyEvaluateChipLoops(opSha1({
      sha1: sha1
    }))), _defineProperty(_objectSpread2$1, OpcodesBCHCHIPs.OP_SHA256, conditionallyEvaluateChipLoops(opSha256({
      sha256: sha256
    }))), _defineProperty(_objectSpread2$1, OpcodesBCHCHIPs.OP_HASH160, conditionallyEvaluateChipLoops(opHash160({
      ripemd160: ripemd160,
      sha256: sha256
    }))), _defineProperty(_objectSpread2$1, OpcodesBCHCHIPs.OP_HASH256, conditionallyEvaluateChipLoops(opHash256({
      sha256: sha256
    }))), _defineProperty(_objectSpread2$1, OpcodesBCHCHIPs.OP_CODESEPARATOR, conditionallyEvaluateChipLoops(opCodeSeparator)), _defineProperty(_objectSpread2$1, OpcodesBCHCHIPs.OP_CHECKSIG, conditionallyEvaluateChipLoops(opCheckSigChipLimits({
      secp256k1: secp256k1$1,
      sha256: sha256
    }))), _defineProperty(_objectSpread2$1, OpcodesBCHCHIPs.OP_CHECKSIGVERIFY, conditionallyEvaluateChipLoops(opCheckSigVerifyChipLimits({
      secp256k1: secp256k1$1,
      sha256: sha256
    }))), _defineProperty(_objectSpread2$1, OpcodesBCHCHIPs.OP_CHECKMULTISIG, conditionallyEvaluateChipLoops(opCheckMultiSigChipLimits({
      secp256k1: secp256k1$1,
      sha256: sha256
    }))), _defineProperty(_objectSpread2$1, OpcodesBCHCHIPs.OP_CHECKMULTISIGVERIFY, conditionallyEvaluateChipLoops(opCheckMultiSigVerifyChipLimits({
      secp256k1: secp256k1$1,
      sha256: sha256
    }))), _objectSpread2$1), standard ? (_ref2 = {}, _defineProperty(_ref2, OpcodesBCHCHIPs.OP_NOP1, conditionallyEvaluateChipLoops(opNopDisallowed)), _defineProperty(_ref2, OpcodesBCHCHIPs.OP_CHECKLOCKTIMEVERIFY, conditionallyEvaluateChipLoops(opCheckLockTimeVerify)), _defineProperty(_ref2, OpcodesBCHCHIPs.OP_CHECKSEQUENCEVERIFY, conditionallyEvaluateChipLoops(opCheckSequenceVerify)), _defineProperty(_ref2, OpcodesBCHCHIPs.OP_NOP4, conditionallyEvaluateChipLoops(opNopDisallowed)), _defineProperty(_ref2, OpcodesBCHCHIPs.OP_NOP5, conditionallyEvaluateChipLoops(opNopDisallowed)), _defineProperty(_ref2, OpcodesBCHCHIPs.OP_NOP6, conditionallyEvaluateChipLoops(opNopDisallowed)), _defineProperty(_ref2, OpcodesBCHCHIPs.OP_NOP7, conditionallyEvaluateChipLoops(opNopDisallowed)), _defineProperty(_ref2, OpcodesBCHCHIPs.OP_NOP8, conditionallyEvaluateChipLoops(opNopDisallowed)), _defineProperty(_ref2, OpcodesBCHCHIPs.OP_NOP9, conditionallyEvaluateChipLoops(opNopDisallowed)), _defineProperty(_ref2, OpcodesBCHCHIPs.OP_NOP10, conditionallyEvaluateChipLoops(opNopDisallowed)), _ref2) : (_ref3 = {}, _defineProperty(_ref3, OpcodesBCHCHIPs.OP_NOP1, conditionallyEvaluateChipLoops(opNop)), _defineProperty(_ref3, OpcodesBCHCHIPs.OP_CHECKLOCKTIMEVERIFY, conditionallyEvaluateChipLoops(opCheckLockTimeVerify)), _defineProperty(_ref3, OpcodesBCHCHIPs.OP_CHECKSEQUENCEVERIFY, conditionallyEvaluateChipLoops(opCheckSequenceVerify)), _defineProperty(_ref3, OpcodesBCHCHIPs.OP_NOP4, conditionallyEvaluateChipLoops(opNop)), _defineProperty(_ref3, OpcodesBCHCHIPs.OP_NOP5, conditionallyEvaluateChipLoops(opNop)), _defineProperty(_ref3, OpcodesBCHCHIPs.OP_NOP6, conditionallyEvaluateChipLoops(opNop)), _defineProperty(_ref3, OpcodesBCHCHIPs.OP_NOP7, conditionallyEvaluateChipLoops(opNop)), _defineProperty(_ref3, OpcodesBCHCHIPs.OP_NOP8, conditionallyEvaluateChipLoops(opNop)), _defineProperty(_ref3, OpcodesBCHCHIPs.OP_NOP9, conditionallyEvaluateChipLoops(opNop)), _defineProperty(_ref3, OpcodesBCHCHIPs.OP_NOP10, conditionallyEvaluateChipLoops(opNop)), _ref3)), {}, (_objectSpread3 = {}, _defineProperty(_objectSpread3, OpcodesBCHCHIPs.OP_CHECKDATASIG, conditionallyEvaluateChipLoops(opCheckDataSig({
      secp256k1: secp256k1$1,
      sha256: sha256
    }))), _defineProperty(_objectSpread3, OpcodesBCHCHIPs.OP_CHECKDATASIGVERIFY, conditionallyEvaluateChipLoops(opCheckDataSigVerify({
      secp256k1: secp256k1$1,
      sha256: sha256
    }))), _defineProperty(_objectSpread3, OpcodesBCHCHIPs.OP_REVERSEBYTES, conditionallyEvaluateChipLoops(opReverseBytes)), _defineProperty(_objectSpread3, OpcodesBCHCHIPs.OP_INPUTINDEX, conditionallyEvaluateChipLoops(opInputIndex)), _defineProperty(_objectSpread3, OpcodesBCHCHIPs.OP_ACTIVEBYTECODE, conditionallyEvaluateChipLoops(opActiveBytecode)), _defineProperty(_objectSpread3, OpcodesBCHCHIPs.OP_TXVERSION, conditionallyEvaluateChipLoops(opTxVersion)), _defineProperty(_objectSpread3, OpcodesBCHCHIPs.OP_TXINPUTCOUNT, conditionallyEvaluateChipLoops(opTxInputCount)), _defineProperty(_objectSpread3, OpcodesBCHCHIPs.OP_TXOUTPUTCOUNT, conditionallyEvaluateChipLoops(opTxOutputCount)), _defineProperty(_objectSpread3, OpcodesBCHCHIPs.OP_TXLOCKTIME, conditionallyEvaluateChipLoops(opTxLocktime)), _defineProperty(_objectSpread3, OpcodesBCHCHIPs.OP_UTXOVALUE, conditionallyEvaluateChipLoops(opUtxoValue)), _defineProperty(_objectSpread3, OpcodesBCHCHIPs.OP_UTXOBYTECODE, conditionallyEvaluateChipLoops(opUtxoBytecode)), _defineProperty(_objectSpread3, OpcodesBCHCHIPs.OP_OUTPOINTTXHASH, conditionallyEvaluateChipLoops(opOutpointTxHash)), _defineProperty(_objectSpread3, OpcodesBCHCHIPs.OP_OUTPOINTINDEX, conditionallyEvaluateChipLoops(opOutpointIndex)), _defineProperty(_objectSpread3, OpcodesBCHCHIPs.OP_INPUTBYTECODE, conditionallyEvaluateChipLoops(opInputBytecode)), _defineProperty(_objectSpread3, OpcodesBCHCHIPs.OP_INPUTSEQUENCENUMBER, conditionallyEvaluateChipLoops(opInputSequenceNumber)), _defineProperty(_objectSpread3, OpcodesBCHCHIPs.OP_OUTPUTVALUE, conditionallyEvaluateChipLoops(opOutputValue)), _defineProperty(_objectSpread3, OpcodesBCHCHIPs.OP_OUTPUTBYTECODE, conditionallyEvaluateChipLoops(opOutputBytecode)), _defineProperty(_objectSpread3, OpcodesBCHCHIPs.OP_UTXOTOKENCATEGORY, conditionallyEvaluateChipLoops(opUtxoTokenCategory)), _defineProperty(_objectSpread3, OpcodesBCHCHIPs.OP_UTXOTOKENCOMMITMENT, conditionallyEvaluateChipLoops(opUtxoTokenCommitment)), _defineProperty(_objectSpread3, OpcodesBCHCHIPs.OP_UTXOTOKENAMOUNT, conditionallyEvaluateChipLoops(opUtxoTokenAmount)), _defineProperty(_objectSpread3, OpcodesBCHCHIPs.OP_OUTPUTTOKENCATEGORY, conditionallyEvaluateChipLoops(opOutputTokenCategory)), _defineProperty(_objectSpread3, OpcodesBCHCHIPs.OP_OUTPUTTOKENCOMMITMENT, conditionallyEvaluateChipLoops(opOutputTokenCommitment)), _defineProperty(_objectSpread3, OpcodesBCHCHIPs.OP_OUTPUTTOKENAMOUNT, conditionallyEvaluateChipLoops(opOutputTokenAmount)), _objectSpread3)),
    success: function success(state) {
      if (state.error !== undefined) {
        return state.error;
      }
      if (state.controlStack.length !== 0) {
        return AuthenticationErrorCommon.nonEmptyControlStack;
      }
      if (state.stack.length !== 1) {
        return AuthenticationErrorCommon.requiresCleanStack;
      }
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      if (!stackItemIsTruthy(state.stack[0])) {
        return AuthenticationErrorCommon.unsuccessfulEvaluation;
      }
      return true;
    },
    undefined: undefinedOperationChipLoops,
    // eslint-disable-next-line complexity
    verify: function verify(_ref4, evaluate, stateSuccess) {
      var sourceOutputs = _ref4.sourceOutputs,
        transaction = _ref4.transaction;
      if (transaction.inputs.length === 0) {
        return 'Transactions must have at least one input.';
      }
      if (transaction.outputs.length === 0) {
        return 'Transactions must have at least one output.';
      }
      if (transaction.inputs.length !== sourceOutputs.length) {
        return 'Unable to verify transaction: a single spent output must be provided for each transaction input.';
      }
      var transactionSize = encodeTransactionBCH(transaction).length;
      if (transactionSize < ConsensusBCH.minimumTransactionSize) {
        return "Transaction does not meet minimum size: the transaction is ".concat(transactionSize, " bytes, but the minimum transaction size is ").concat(ConsensusBCH.minimumTransactionSize, " bytes.");
      }
      if (transactionSize > ConsensusBCH.maximumTransactionSize) {
        return "Transaction exceeds maximum size: the transaction is ".concat(transactionSize, " bytes, but the maximum transaction size is ").concat(ConsensusBCH.maximumTransactionSize, " bytes.");
      }
      if (standard) {
        if (transaction.version < 1 || transaction.version > ConsensusBCH.maximumStandardVersion) {
          return "Standard transactions must have a version no less than 1 and no greater than ".concat(ConsensusBCH.maximumStandardVersion, ".");
        }
        if (transactionSize > ConsensusBCH.maximumStandardTransactionSize) {
          return "Transaction exceeds maximum standard size: this transaction is ".concat(transactionSize, " bytes, but the maximum standard transaction size is ").concat(ConsensusBCH.maximumStandardTransactionSize, " bytes.");
        }
        // eslint-disable-next-line functional/no-loop-statement
        var _iterator = _createForOfIteratorHelper(sourceOutputs.entries()),
          _step;
        try {
          for (_iterator.s(); !(_step = _iterator.n()).done;) {
            var _step$value = _slicedToArray(_step.value, 2),
              index = _step$value[0],
              output = _step$value[1];
            if (!isStandardOutputBytecode(output.lockingBytecode)) {
              return "Standard transactions may only spend standard output types, but source output ".concat(index, " is non-standard.");
            }
          }
          // eslint-disable-next-line functional/no-let
        } catch (err) {
          _iterator.e(err);
        } finally {
          _iterator.f();
        }
        var totalArbitraryDataBytes = 0;
        // eslint-disable-next-line functional/no-loop-statement
        var _iterator2 = _createForOfIteratorHelper(transaction.outputs.entries()),
          _step2;
        try {
          for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
            var _step2$value = _slicedToArray(_step2.value, 2),
              _index = _step2$value[0],
              _output = _step2$value[1];
            if (!isStandardOutputBytecode(_output.lockingBytecode)) {
              return "Standard transactions may only create standard output types, but transaction output ".concat(_index, " is non-standard.");
            }
            // eslint-disable-next-line functional/no-conditional-statement
            if (isArbitraryDataOutput(_output.lockingBytecode)) {
              // eslint-disable-next-line functional/no-expression-statement
              totalArbitraryDataBytes += _output.lockingBytecode.length + 1;
            }
            /*
             * TODO: disallow dust outputs
             * if(IsDustOutput(output)) {
             *   return ``;
             * }
             */
          }
        } catch (err) {
          _iterator2.e(err);
        } finally {
          _iterator2.f();
        }
        if (totalArbitraryDataBytes > ConsensusBCH.maximumDataCarrierBytes) {
          return "Standard transactions may carry no more than ".concat(ConsensusBCH.maximumDataCarrierBytes, " bytes in arbitrary data outputs; this transaction includes ").concat(totalArbitraryDataBytes, " bytes of arbitrary data.");
        }
        // eslint-disable-next-line functional/no-loop-statement
        var _iterator3 = _createForOfIteratorHelper(transaction.inputs.entries()),
          _step3;
        try {
          for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
            var _step3$value = _slicedToArray(_step3.value, 2),
              _index2 = _step3$value[0],
              input = _step3$value[1];
            if (input.unlockingBytecode.length > ConsensusBCH.maximumStandardUnlockingBytecodeLength) {
              return "Input index ".concat(_index2, " is non-standard: the unlocking bytecode (").concat(input.unlockingBytecode.length, " bytes) exceeds the maximum standard unlocking bytecode length (").concat(ConsensusBCH.maximumStandardUnlockingBytecodeLength, " bytes).");
            }
            if (!isPushOnly(input.unlockingBytecode)) {
              return "Input index ".concat(_index2, " is non-standard: unlocking bytecode may contain only push operations.");
            }
          }
        } catch (err) {
          _iterator3.e(err);
        } finally {
          _iterator3.f();
        }
      }
      // eslint-disable-next-line functional/no-loop-statement
      var _iterator4 = _createForOfIteratorHelper(transaction.inputs.keys()),
        _step4;
      try {
        for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {
          var _index3 = _step4.value;
          var state = evaluate({
            inputIndex: _index3,
            sourceOutputs: sourceOutputs,
            transaction: transaction
          });
          var result = stateSuccess(state);
          if (typeof result === 'string') {
            return "Error in evaluating input index ".concat(_index3, ": ").concat(result);
          }
        }
      } catch (err) {
        _iterator4.e(err);
      } finally {
        _iterator4.f();
      }
      return true;
    }
  };
};

/**
 * Initialize a virtual machine using the BCH CHIPs instruction set, an
 * informal, speculative instruction set that implements a variety of future
 * Bitcoin Cash Improvement Proposals (CHIPs).
 *
 * @param standard - If `true`, the additional `isStandard` validations will be
 * enabled. Transactions that fail these rules are often called "non-standard"
 * and can technically be included by miners in valid blocks, but most network
 * nodes will refuse to relay them. (Default: `true`)
 */
var createVirtualMachineBCHCHIPs = function createVirtualMachineBCHCHIPs() {
  var standard = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
  return createAuthenticationVirtualMachine(createInstructionSetBCHCHIPs(standard));
};

var OpcodeDescriptionsBTC;
(function (OpcodeDescriptionsBTC) {
  OpcodeDescriptionsBTC["OP_0"] = "Push the VM Number 0 onto the stack.";
  OpcodeDescriptionsBTC["OP_PUSHBYTES_1"] = "Push the next byte onto the stack.";
  OpcodeDescriptionsBTC["OP_PUSHBYTES_2"] = "Push the next 2 bytes onto the stack.";
  OpcodeDescriptionsBTC["OP_PUSHBYTES_3"] = "Push the next 3 bytes onto the stack.";
  OpcodeDescriptionsBTC["OP_PUSHBYTES_4"] = "Push the next 4 bytes onto the stack.";
  OpcodeDescriptionsBTC["OP_PUSHBYTES_5"] = "Push the next 5 bytes onto the stack.";
  OpcodeDescriptionsBTC["OP_PUSHBYTES_6"] = "Push the next 6 bytes onto the stack.";
  OpcodeDescriptionsBTC["OP_PUSHBYTES_7"] = "Push the next 7 bytes onto the stack.";
  OpcodeDescriptionsBTC["OP_PUSHBYTES_8"] = "Push the next 8 bytes onto the stack.";
  OpcodeDescriptionsBTC["OP_PUSHBYTES_9"] = "Push the next 9 bytes onto the stack.";
  OpcodeDescriptionsBTC["OP_PUSHBYTES_10"] = "Push the next 10 bytes onto the stack.";
  OpcodeDescriptionsBTC["OP_PUSHBYTES_11"] = "Push the next 11 bytes onto the stack.";
  OpcodeDescriptionsBTC["OP_PUSHBYTES_12"] = "Push the next 12 bytes onto the stack.";
  OpcodeDescriptionsBTC["OP_PUSHBYTES_13"] = "Push the next 13 bytes onto the stack.";
  OpcodeDescriptionsBTC["OP_PUSHBYTES_14"] = "Push the next 14 bytes onto the stack.";
  OpcodeDescriptionsBTC["OP_PUSHBYTES_15"] = "Push the next 15 bytes onto the stack.";
  OpcodeDescriptionsBTC["OP_PUSHBYTES_16"] = "Push the next 16 bytes onto the stack.";
  OpcodeDescriptionsBTC["OP_PUSHBYTES_17"] = "Push the next 17 bytes onto the stack.";
  OpcodeDescriptionsBTC["OP_PUSHBYTES_18"] = "Push the next 18 bytes onto the stack.";
  OpcodeDescriptionsBTC["OP_PUSHBYTES_19"] = "Push the next 19 bytes onto the stack.";
  OpcodeDescriptionsBTC["OP_PUSHBYTES_20"] = "Push the next 20 bytes onto the stack.";
  OpcodeDescriptionsBTC["OP_PUSHBYTES_21"] = "Push the next 21 bytes onto the stack.";
  OpcodeDescriptionsBTC["OP_PUSHBYTES_22"] = "Push the next 22 bytes onto the stack.";
  OpcodeDescriptionsBTC["OP_PUSHBYTES_23"] = "Push the next 23 bytes onto the stack.";
  OpcodeDescriptionsBTC["OP_PUSHBYTES_24"] = "Push the next 24 bytes onto the stack.";
  OpcodeDescriptionsBTC["OP_PUSHBYTES_25"] = "Push the next 25 bytes onto the stack.";
  OpcodeDescriptionsBTC["OP_PUSHBYTES_26"] = "Push the next 26 bytes onto the stack.";
  OpcodeDescriptionsBTC["OP_PUSHBYTES_27"] = "Push the next 27 bytes onto the stack.";
  OpcodeDescriptionsBTC["OP_PUSHBYTES_28"] = "Push the next 28 bytes onto the stack.";
  OpcodeDescriptionsBTC["OP_PUSHBYTES_29"] = "Push the next 29 bytes onto the stack.";
  OpcodeDescriptionsBTC["OP_PUSHBYTES_30"] = "Push the next 30 bytes onto the stack.";
  OpcodeDescriptionsBTC["OP_PUSHBYTES_31"] = "Push the next 31 bytes onto the stack.";
  OpcodeDescriptionsBTC["OP_PUSHBYTES_32"] = "Push the next 32 bytes onto the stack.";
  OpcodeDescriptionsBTC["OP_PUSHBYTES_33"] = "Push the next 33 bytes onto the stack.";
  OpcodeDescriptionsBTC["OP_PUSHBYTES_34"] = "Push the next 34 bytes onto the stack.";
  OpcodeDescriptionsBTC["OP_PUSHBYTES_35"] = "Push the next 35 bytes onto the stack.";
  OpcodeDescriptionsBTC["OP_PUSHBYTES_36"] = "Push the next 36 bytes onto the stack.";
  OpcodeDescriptionsBTC["OP_PUSHBYTES_37"] = "Push the next 37 bytes onto the stack.";
  OpcodeDescriptionsBTC["OP_PUSHBYTES_38"] = "Push the next 38 bytes onto the stack.";
  OpcodeDescriptionsBTC["OP_PUSHBYTES_39"] = "Push the next 39 bytes onto the stack.";
  OpcodeDescriptionsBTC["OP_PUSHBYTES_40"] = "Push the next 40 bytes onto the stack.";
  OpcodeDescriptionsBTC["OP_PUSHBYTES_41"] = "Push the next 41 bytes onto the stack.";
  OpcodeDescriptionsBTC["OP_PUSHBYTES_42"] = "Push the next 42 bytes onto the stack.";
  OpcodeDescriptionsBTC["OP_PUSHBYTES_43"] = "Push the next 43 bytes onto the stack.";
  OpcodeDescriptionsBTC["OP_PUSHBYTES_44"] = "Push the next 44 bytes onto the stack.";
  OpcodeDescriptionsBTC["OP_PUSHBYTES_45"] = "Push the next 45 bytes onto the stack.";
  OpcodeDescriptionsBTC["OP_PUSHBYTES_46"] = "Push the next 46 bytes onto the stack.";
  OpcodeDescriptionsBTC["OP_PUSHBYTES_47"] = "Push the next 47 bytes onto the stack.";
  OpcodeDescriptionsBTC["OP_PUSHBYTES_48"] = "Push the next 48 bytes onto the stack.";
  OpcodeDescriptionsBTC["OP_PUSHBYTES_49"] = "Push the next 49 bytes onto the stack.";
  OpcodeDescriptionsBTC["OP_PUSHBYTES_50"] = "Push the next 50 bytes onto the stack.";
  OpcodeDescriptionsBTC["OP_PUSHBYTES_51"] = "Push the next 51 bytes onto the stack.";
  OpcodeDescriptionsBTC["OP_PUSHBYTES_52"] = "Push the next 52 bytes onto the stack.";
  OpcodeDescriptionsBTC["OP_PUSHBYTES_53"] = "Push the next 53 bytes onto the stack.";
  OpcodeDescriptionsBTC["OP_PUSHBYTES_54"] = "Push the next 54 bytes onto the stack.";
  OpcodeDescriptionsBTC["OP_PUSHBYTES_55"] = "Push the next 55 bytes onto the stack.";
  OpcodeDescriptionsBTC["OP_PUSHBYTES_56"] = "Push the next 56 bytes onto the stack.";
  OpcodeDescriptionsBTC["OP_PUSHBYTES_57"] = "Push the next 57 bytes onto the stack.";
  OpcodeDescriptionsBTC["OP_PUSHBYTES_58"] = "Push the next 58 bytes onto the stack.";
  OpcodeDescriptionsBTC["OP_PUSHBYTES_59"] = "Push the next 59 bytes onto the stack.";
  OpcodeDescriptionsBTC["OP_PUSHBYTES_60"] = "Push the next 60 bytes onto the stack.";
  OpcodeDescriptionsBTC["OP_PUSHBYTES_61"] = "Push the next 61 bytes onto the stack.";
  OpcodeDescriptionsBTC["OP_PUSHBYTES_62"] = "Push the next 62 bytes onto the stack.";
  OpcodeDescriptionsBTC["OP_PUSHBYTES_63"] = "Push the next 63 bytes onto the stack.";
  OpcodeDescriptionsBTC["OP_PUSHBYTES_64"] = "Push the next 64 bytes onto the stack.";
  OpcodeDescriptionsBTC["OP_PUSHBYTES_65"] = "Push the next 65 bytes onto the stack.";
  OpcodeDescriptionsBTC["OP_PUSHBYTES_66"] = "Push the next 66 bytes onto the stack.";
  OpcodeDescriptionsBTC["OP_PUSHBYTES_67"] = "Push the next 67 bytes onto the stack.";
  OpcodeDescriptionsBTC["OP_PUSHBYTES_68"] = "Push the next 68 bytes onto the stack.";
  OpcodeDescriptionsBTC["OP_PUSHBYTES_69"] = "Push the next 69 bytes onto the stack.";
  OpcodeDescriptionsBTC["OP_PUSHBYTES_70"] = "Push the next 70 bytes onto the stack.";
  OpcodeDescriptionsBTC["OP_PUSHBYTES_71"] = "Push the next 71 bytes onto the stack.";
  OpcodeDescriptionsBTC["OP_PUSHBYTES_72"] = "Push the next 72 bytes onto the stack.";
  OpcodeDescriptionsBTC["OP_PUSHBYTES_73"] = "Push the next 73 bytes onto the stack.";
  OpcodeDescriptionsBTC["OP_PUSHBYTES_74"] = "Push the next 74 bytes onto the stack.";
  OpcodeDescriptionsBTC["OP_PUSHBYTES_75"] = "Push the next 75 bytes onto the stack.";
  OpcodeDescriptionsBTC["OP_PUSHDATA_1"] = "Read the next Uint8 and push that number of bytes onto the stack.";
  OpcodeDescriptionsBTC["OP_PUSHDATA_2"] = "Read the next little-endian Uint16 and push that number of bytes onto the stack.";
  OpcodeDescriptionsBTC["OP_PUSHDATA_4"] = "Read the next little-endian Uint32 and push that number of bytes onto the stack.";
  OpcodeDescriptionsBTC["OP_1NEGATE"] = "Push the VM Number -1 onto the stack.";
  OpcodeDescriptionsBTC["OP_RESERVED"] = "Error unless found in an unexecuted conditional branch. Note: OP_RESERVED does not count toward the opcode limit.";
  OpcodeDescriptionsBTC["OP_1"] = "Push a 1 (VM Number) onto the stack.";
  OpcodeDescriptionsBTC["OP_2"] = "Push a 2 (VM Number) onto the stack.";
  OpcodeDescriptionsBTC["OP_3"] = "Push a 3 (VM Number) onto the stack.";
  OpcodeDescriptionsBTC["OP_4"] = "Push a 4 (VM Number) onto the stack.";
  OpcodeDescriptionsBTC["OP_5"] = "Push a 5 (VM Number) onto the stack.";
  OpcodeDescriptionsBTC["OP_6"] = "Push a 6 (VM Number) onto the stack.";
  OpcodeDescriptionsBTC["OP_7"] = "Push a 7 (VM Number) onto the stack.";
  OpcodeDescriptionsBTC["OP_8"] = "Push a 8 (VM Number) onto the stack.";
  OpcodeDescriptionsBTC["OP_9"] = "Push a 9 (VM Number) onto the stack.";
  OpcodeDescriptionsBTC["OP_10"] = "Push a 10 (VM Number) onto the stack.";
  OpcodeDescriptionsBTC["OP_11"] = "Push a 11 (VM Number) onto the stack.";
  OpcodeDescriptionsBTC["OP_12"] = "Push a 12 (VM Number) onto the stack.";
  OpcodeDescriptionsBTC["OP_13"] = "Push a 13 (VM Number) onto the stack.";
  OpcodeDescriptionsBTC["OP_14"] = "Push a 14 (VM Number) onto the stack.";
  OpcodeDescriptionsBTC["OP_15"] = "Push a 15 (VM Number) onto the stack.";
  OpcodeDescriptionsBTC["OP_16"] = "Push a 16 (VM Number) onto the stack.";
  OpcodeDescriptionsBTC["OP_NOP"] = "No operation. Note: OP_NOP counts toward the opcode limit.";
  OpcodeDescriptionsBTC["OP_VER"] = "Error unless found in an unexecuted conditional branch. Note: OP_VER counts toward the opcode limit. (Historically, this pushed a protocol version number to the stack.)";
  OpcodeDescriptionsBTC["OP_IF"] = "Pop the top item from the stack. If it is not \"truthy\", skip evaluation until a matching OP_ELSE or OP_ENDIF.";
  OpcodeDescriptionsBTC["OP_NOTIF"] = "Pop the top item from the stack. If it is \"truthy\", skip evaluation until a matching OP_ELSE or OP_ENDIF.";
  OpcodeDescriptionsBTC["OP_VERIF"] = "Error, even when found in an unexecuted conditional branch. (Historically, this was a combination of OP_VER and OP_IF.)";
  OpcodeDescriptionsBTC["OP_VERNOTIF"] = "Error, even when found in an unexecuted conditional branch. (Historically, this was a combination of OP_VER and OP_NOTIF.)";
  OpcodeDescriptionsBTC["OP_ELSE"] = "Invert conditional evaluation within the current OP_IF ... OP_ENDIF block. (If evaluation is enabled, disable it, if it is disabled, enable it.)";
  OpcodeDescriptionsBTC["OP_ENDIF"] = "End the current OP_IF/OP_NOTIF ... OP_ENDIF block.";
  OpcodeDescriptionsBTC["OP_VERIFY"] = "Pop the top item from the stack and error if it isn't \"truthy\".";
  OpcodeDescriptionsBTC["OP_RETURN"] = "Error when executed.";
  OpcodeDescriptionsBTC["OP_TOALTSTACK"] = "Pop the top item from the stack and push it onto the alternate stack.";
  OpcodeDescriptionsBTC["OP_FROMALTSTACK"] = "Pop the top item from the alternate stack and push it onto the stack.";
  OpcodeDescriptionsBTC["OP_2DROP"] = "Pop the top 2 items from the stack and discard them.";
  OpcodeDescriptionsBTC["OP_2DUP"] = "Duplicate the top 2 items on the stack. (E.g. [a, b] -> [a, b, a, b])";
  OpcodeDescriptionsBTC["OP_3DUP"] = "Duplicate the top 3 items on the stack. (E.g. [a, b, c] -> [a, b, c, a, b, c])";
  OpcodeDescriptionsBTC["OP_2OVER"] = "Duplicate the 2 items beginning at a depth of 2 on the stack. (E.g. [a, b, c, d] -> [a, b, c, d, a, b])";
  OpcodeDescriptionsBTC["OP_2ROT"] = "Rotate the top 6 items on the stack, bringing the fifth and sixth items to the top. (E.g. [a, b, c, d, e, f] -> [c, d, e, f, a, b])";
  OpcodeDescriptionsBTC["OP_2SWAP"] = "Swap the positions of the top two pairs of items on the stack. (E.g. [a, b, c, d] -> [c, d, a, b])";
  OpcodeDescriptionsBTC["OP_IFDUP"] = "If the top item on the stack is \"truthy\", duplicate it.";
  OpcodeDescriptionsBTC["OP_DEPTH"] = "Push the current number of stack items as a VM Number.";
  OpcodeDescriptionsBTC["OP_DROP"] = "Pop the top item from the stack and discard it. (E.g. [a] -> [])";
  OpcodeDescriptionsBTC["OP_DUP"] = "Duplicate the top item on the stack. (E.g. [a] -> [a, a])";
  OpcodeDescriptionsBTC["OP_NIP"] = "Remove the second-to-top item from the stack. (E.g. [a, b] -> [b])";
  OpcodeDescriptionsBTC["OP_OVER"] = "Duplicate the second-to-top item on the stack. (E.g. [a, b] -> [a, b, a])";
  OpcodeDescriptionsBTC["OP_PICK"] = "Pop the top item from the stack as a VM Number. Duplicate the item at that depth (zero-indexed), placing it on top of the stack. (E.g. [a, b, c, 2] -> [a, b, c, a])";
  OpcodeDescriptionsBTC["OP_ROLL"] = "Pop the top item from the stack as a VM Number. Move the item at that depth (zero-indexed) to the top of the stack. (E.g. [a, b, c, 2] -> [b, c, a])";
  OpcodeDescriptionsBTC["OP_ROT"] = "Rotate the top 3 items on the stack, bringing the third item to the top. (E.g. [a, b, c] -> [b, c, a])";
  OpcodeDescriptionsBTC["OP_SWAP"] = "Swap the top two items on the stack. (E.g. [a, b] -> [b, a])";
  OpcodeDescriptionsBTC["OP_TUCK"] = "Duplicate the item at the top of the stack, inserting it below the second-to-top item. (E.g. [a, b] -> [b, a, b])";
  OpcodeDescriptionsBTC["OP_CAT"] = "Error, even when found in an unexecuted conditional branch. (Historically, this concatenated two stack items.)";
  OpcodeDescriptionsBTC["OP_SUBSTR"] = "Error, even when found in an unexecuted conditional branch. (Historically, this returned a section of a stack item.)";
  OpcodeDescriptionsBTC["OP_LEFT"] = "Error, even when found in an unexecuted conditional branch. (Historically, this returned a section to the left of a point in a stack item.)";
  OpcodeDescriptionsBTC["OP_RIGHT"] = "Error, even when found in an unexecuted conditional branch. (Historically, this returned a section to the right of a point in a stack item.)";
  OpcodeDescriptionsBTC["OP_SIZE"] = "Push the byte-length of the top stack item as a VM Number.";
  OpcodeDescriptionsBTC["OP_INVERT"] = "Error, even when found in an unexecuted conditional branch. (Historically, this flipped all the bits in a stack item.)";
  OpcodeDescriptionsBTC["OP_AND"] = "Error, even when found in an unexecuted conditional branch. (Historically, this performed a boolean AND on each bit in two stack items.)";
  OpcodeDescriptionsBTC["OP_OR"] = "Error, even when found in an unexecuted conditional branch. (Historically, this performed a boolean OR on each bit in two stack items.)";
  OpcodeDescriptionsBTC["OP_XOR"] = "Error, even when found in an unexecuted conditional branch. (Historically, this performed a boolean XOR on each bit in two stack items.)";
  OpcodeDescriptionsBTC["OP_EQUAL"] = "Pop the top two items from the stack and compare them byte-by-byte. If they are the same, push a 1 (VM Number), otherwise push a 0 (VM Number).";
  OpcodeDescriptionsBTC["OP_EQUALVERIFY"] = "Pop the top two items from the stack and compare them byte-by-byte. If the values are different, error. (This operation is a combination of OP_EQUAL followed by OP_VERIFY.)";
  OpcodeDescriptionsBTC["OP_RESERVED1"] = "Error unless found in an unexecuted conditional branch. Note: OP_RESERVED1 counts toward the opcode limit.";
  OpcodeDescriptionsBTC["OP_RESERVED2"] = "Error unless found in an unexecuted conditional branch. Note: OP_RESERVED2 counts toward the opcode limit.";
  OpcodeDescriptionsBTC["OP_MUL"] = "Error, even when found in an unexecuted conditional branch. (Historically, this multiplied two VM Numbers.)";
  OpcodeDescriptionsBTC["OP_DIV"] = "Error, even when found in an unexecuted conditional branch. (Historically, this divided a VM Number by another.)";
  OpcodeDescriptionsBTC["OP_MOD"] = "Error, even when found in an unexecuted conditional branch. (Historically, this returned the remainder after dividing one VM Number by another.)";
  OpcodeDescriptionsBTC["OP_1ADD"] = "Pop the top item from the stack as a VM Number, add 1, then push the result.";
  OpcodeDescriptionsBTC["OP_1SUB"] = "Pop the top item from the stack as a VM Number, subtract 1, then push the result.";
  OpcodeDescriptionsBTC["OP_2MUL"] = "Error, even when found in an unexecuted conditional branch. (Historically, this multiplied a VM Number by 2.)";
  OpcodeDescriptionsBTC["OP_2DIV"] = "Error, even when found in an unexecuted conditional branch. (Historically, this divided a VM Number by 2.)";
  OpcodeDescriptionsBTC["OP_NEGATE"] = "Pop the top item from the stack as a VM Number, negate it, then push the result.";
  OpcodeDescriptionsBTC["OP_ABS"] = "Pop the top item from the stack as a VM Number, take its absolute value, then push the result.";
  OpcodeDescriptionsBTC["OP_NOT"] = "Pop the top item from the stack as a VM Number. If its value is 0, push a 1 (VM Number), otherwise, push a 0 (VM Number).";
  OpcodeDescriptionsBTC["OP_0NOTEQUAL"] = "Pop the top item from the stack as a VM Number. If its value is not 0, push a 1 (VM Number), otherwise, push a 0 (VM Number).";
  OpcodeDescriptionsBTC["OP_ADD"] = "Pop the top two items from the stack as VM Numbers. Add them, then push the result.";
  OpcodeDescriptionsBTC["OP_SUB"] = "Pop the top two items from the stack as VM Numbers. Subtract the top item from the second item, then push the result.";
  OpcodeDescriptionsBTC["OP_LSHIFT"] = "Error, even when found in an unexecuted conditional branch. (Historically, this performed a sign-preserving, left bit shift.)";
  OpcodeDescriptionsBTC["OP_RSHIFT"] = "Error, even when found in an unexecuted conditional branch. (Historically, this performed a sign-preserving, right bit shift.)";
  OpcodeDescriptionsBTC["OP_BOOLAND"] = "Pop the top two items from the stack as VM Numbers. If neither value is a 0 (VM Number), push a 1 (VM Number). Otherwise, push a 0 (VM Number).";
  OpcodeDescriptionsBTC["OP_BOOLOR"] = "Pop the top two items from the stack as VM Numbers. If either value is a 1 (VM Number), push a 1 (VM Number). Otherwise, push a 0 (VM Number).";
  OpcodeDescriptionsBTC["OP_NUMEQUAL"] = "Pop the top two items from the stack as VM Numbers. If the values are equal, push a 1 (VM Number). Otherwise, push a 0 (VM Number).";
  OpcodeDescriptionsBTC["OP_NUMEQUALVERIFY"] = "Pop the top two items from the stack as VM Numbers. If the values are different, error. (This operation is a combination of OP_NUMEQUAL followed by OP_VERIFY.)";
  OpcodeDescriptionsBTC["OP_NUMNOTEQUAL"] = "Pop the top two items from the stack as VM Numbers. If the values are not equal, push a 1 (VM Number). Otherwise, push a 0 (VM Number).";
  OpcodeDescriptionsBTC["OP_LESSTHAN"] = "Pop the top two items from the stack as VM Numbers. If the second item is less than top item, push a 1 (VM Number). Otherwise, push a 0 (VM Number).";
  OpcodeDescriptionsBTC["OP_GREATERTHAN"] = "Pop the top two items from the stack as VM Numbers. If the second item is greater than top item, push a 1 (VM Number). Otherwise, push a 0 (VM Number).";
  OpcodeDescriptionsBTC["OP_LESSTHANOREQUAL"] = "Pop the top two items from the stack as VM Numbers. If the second item is less than or equal to the top item, push a 1 (VM Number). Otherwise, push a 0 (VM Number).";
  OpcodeDescriptionsBTC["OP_GREATERTHANOREQUAL"] = "Pop the top two items from the stack as VM Numbers. If the second item is greater than or equal to the top item, push a 1 (VM Number). Otherwise, push a 0 (VM Number).";
  OpcodeDescriptionsBTC["OP_MIN"] = "Pop the top two items from the stack as VM Numbers. Push the smaller of the two numbers.";
  OpcodeDescriptionsBTC["OP_MAX"] = "Pop the top two items from the stack as VM Numbers. Push the larger of the two numbers.";
  OpcodeDescriptionsBTC["OP_WITHIN"] = "Pop the top three items from the stack as VM Numbers. If the top number is within the range defined by the following two numbers (left-inclusive), push a 1 (VM Number). Otherwise, push a 0 (VM Number). (E.g. for [a, b, c]: if (b <= a), and (a < c), [1]. Else [0].)";
  OpcodeDescriptionsBTC["OP_RIPEMD160"] = "Pop the top item from the stack and pass it through ripemd160, pushing the result onto the stack.";
  OpcodeDescriptionsBTC["OP_SHA1"] = "Pop the top item from the stack and pass it through sha1, pushing the result onto the stack.";
  OpcodeDescriptionsBTC["OP_SHA256"] = "Pop the top item from the stack and pass it through sha256, pushing the result onto the stack.";
  OpcodeDescriptionsBTC["OP_HASH160"] = "Pop the top item from the stack and pass it through sha256, then ripemd160, pushing the result onto the stack.";
  OpcodeDescriptionsBTC["OP_HASH256"] = "Pop the top item from the stack and pass it through sha256 twice, pushing the result onto the stack.";
  OpcodeDescriptionsBTC["OP_CODESEPARATOR"] = "Update the value of lastCodeSeparator to the instruction pointer's current value. (This reduces the coverage of signing serializations used in signature verification operations.)";
  OpcodeDescriptionsBTC["OP_CHECKSIG"] = "Pop the top two items from the stack. Treat the top as a signature and the second as a public key. If the signature is valid, push a 1 (VM Number), otherwise push a 0 (VM Number).";
  OpcodeDescriptionsBTC["OP_CHECKSIGVERIFY"] = "Pop the top two items from the stack. Treat the top as a signature and the second as a public key. If the signature is not valid, error. (This operation is a combination of OP_CHECKSIG followed by OP_VERIFY.)";
  OpcodeDescriptionsBTC["OP_CHECKMULTISIG"] = "Pop items from the stack: first pop the VM Number of public keys, then pop each of those public keys. Next, pop the VM Number of required signatures, then pop each of those signatures. Finally, pop a final VM Number that must be 0 due to a protocol bug. Checking each signature against each public key in order, if all signatures are valid \u2013 and the required number of signatures have been provided \u2013 push a 1 (VM Number), otherwise push a 0 (VM Number).";
  OpcodeDescriptionsBTC["OP_CHECKMULTISIGVERIFY"] = "Pop items from the stack: first pop the VM Number of public keys, then pop each of those public keys. Next, pop the VM Number of required signatures, then pop each of those signatures. Finally, (due to a protocol bug) pop an unused final VM Number that must be 0. Checking each signature against each public key in order, if any signatures are invalid \u2013 or the required number of signatures have not been provided \u2013 error. (This operation is a combination of OP_CHECKMULTISIG followed by OP_VERIFY.)";
  OpcodeDescriptionsBTC["OP_NOP1"] = "No operation (reserved for future expansion). Note: OP_NOP1 counts toward the opcode limit.";
  OpcodeDescriptionsBTC["OP_CHECKLOCKTIMEVERIFY"] = "Verify the transaction occurs after an absolute block time or height: read the top item on the stack as a VM Number (without removing it), and compare it to the transaction's locktime. If the required locktime has not passed, or if locktime has been disabled for this input by a maximized sequence number, error.";
  OpcodeDescriptionsBTC["OP_CHECKSEQUENCEVERIFY"] = "Verify the transaction occurs after the output being spent has \"aged\" by a relative block time or block height since it was created: read the top item on the stack as a VM Number (without removing it), and compare it to the age encoded in the input's sequence number. If the required relative locktime has not passed, or if relative locktime has been disabled by the sequence number or the transaction version, error.";
  OpcodeDescriptionsBTC["OP_NOP4"] = "No operation (reserved for future expansion). Note: OP_NOP4 counts toward the opcode limit.";
  OpcodeDescriptionsBTC["OP_NOP6"] = "No operation (reserved for future expansion). Note: OP_NOP6 counts toward the opcode limit.";
  OpcodeDescriptionsBTC["OP_NOP5"] = "No operation (reserved for future expansion). Note: OP_NOP5 counts toward the opcode limit.";
  OpcodeDescriptionsBTC["OP_NOP7"] = "No operation (reserved for future expansion). Note: OP_NOP7 counts toward the opcode limit.";
  OpcodeDescriptionsBTC["OP_NOP8"] = "No operation (reserved for future expansion). Note: OP_NOP8 counts toward the opcode limit.";
  OpcodeDescriptionsBTC["OP_NOP9"] = "No operation (reserved for future expansion). Note: OP_NOP9 counts toward the opcode limit.";
  OpcodeDescriptionsBTC["OP_NOP10"] = "No operation (reserved for future expansion). Note: OP_NOP10 counts toward the opcode limit.";
})(OpcodeDescriptionsBTC || (OpcodeDescriptionsBTC = {}));

var IdentifierResolutionType;
(function (IdentifierResolutionType) {
  IdentifierResolutionType["opcode"] = "opcode";
  IdentifierResolutionType["variable"] = "variable";
  IdentifierResolutionType["script"] = "script";
})(IdentifierResolutionType || (IdentifierResolutionType = {}));
var IdentifierResolutionErrorType;
(function (IdentifierResolutionErrorType) {
  IdentifierResolutionErrorType["unknown"] = "unknown";
  IdentifierResolutionErrorType["variable"] = "variable";
  IdentifierResolutionErrorType["script"] = "script";
})(IdentifierResolutionErrorType || (IdentifierResolutionErrorType = {}));

var pluckStartPosition = function pluckStartPosition(range) {
  return {
    startColumn: range.startColumn,
    startLineNumber: range.startLineNumber
  };
};
var pluckEndPosition = function pluckEndPosition(range) {
  return {
    endColumn: range.endColumn,
    endLineNumber: range.endLineNumber
  };
};
/**
 * Combine an array of `Range`s into a single larger `Range`.
 *
 * @param ranges - an array of `Range`s
 * @param parentRange - the range to assume if `ranges` is an empty array
 */
var mergeRanges = function mergeRanges(ranges) {
  var parentRange = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {
    endColumn: 0,
    endLineNumber: 0,
    startColumn: 0,
    startLineNumber: 0
  };
  var minimumRangesToMerge = 2;
  var unsortedMerged = ranges.length < minimumRangesToMerge ? ranges.length === 1 ?
  // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
  ranges[0] : parentRange : ranges.reduce(
  // eslint-disable-next-line complexity
  function (merged, range) {
    return _objectSpread2(_objectSpread2({}, range.endLineNumber > merged.endLineNumber ? pluckEndPosition(range) : range.endLineNumber === merged.endLineNumber && range.endColumn > merged.endColumn ? pluckEndPosition(range) : pluckEndPosition(merged)), range.startLineNumber < merged.startLineNumber ? pluckStartPosition(range) : range.startLineNumber === merged.startLineNumber && range.startColumn < merged.startColumn ? pluckStartPosition(range) : pluckStartPosition(merged));
  },
  // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
  ranges[0]);
  return _objectSpread2(_objectSpread2({}, pluckEndPosition(unsortedMerged)), pluckStartPosition(unsortedMerged));
};
/**
 * Returns true if the `outerRange` fully contains the `innerRange`, otherwise,
 * `false`.
 *
 * @param outerRange - the bounds of the outer range
 * @param innerRange - the inner range to test
 * @param exclusive - disallow the `innerRange` from overlapping the
 * `outerRange` (such that the outer start and end columns may not be equal) –
 * defaults to `true`
 */
// eslint-disable-next-line complexity
var containsRange = function containsRange(outerRange, innerRange) {
  var exclusive = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;
  var startsAfter = outerRange.startLineNumber < innerRange.startLineNumber ? true : outerRange.startLineNumber === innerRange.startLineNumber ? exclusive ? outerRange.startColumn < innerRange.startColumn : outerRange.startColumn <= innerRange.startColumn : false;
  var endsBefore = outerRange.endLineNumber > innerRange.endLineNumber ? true : outerRange.endLineNumber === innerRange.endLineNumber ? exclusive ? outerRange.endColumn > innerRange.endColumn : outerRange.endColumn >= innerRange.endColumn : false;
  return startsAfter && endsBefore;
};
/**
 * Extract a list of the errors that occurred while resolving a script.
 *
 * @param resolvedScript - the result of {@link resolveScript} from which to
 * extract errors
 */
var getResolutionErrors = function getResolutionErrors(resolvedScript) {
  return resolvedScript.reduce(function (errors, segment) {
    switch (segment.type) {
      case 'error':
        return [].concat(_toConsumableArray(errors), [_objectSpread2(_objectSpread2({
          error: segment.value
        }, segment.missingIdentifier === undefined ? {} : {
          missingIdentifier: segment.missingIdentifier,
          owningEntity: segment.owningEntity
        }), {}, {
          range: segment.range
        })]);
      case 'push':
      case 'evaluation':
        return [].concat(_toConsumableArray(errors), _toConsumableArray(getResolutionErrors(segment.value)));
      default:
        return errors;
    }
  }, []);
};
/**
 * Verify that every error in the provided array can be resolved by providing
 * additional variables in the compilation data (rather than deeper issues, like
 * problems with the authentication template or wallet implementation).
 *
 * Note, errors are only recoverable if the "entity ownership" of each missing
 * identifier is known (specified in `CompilationData`'s `entityOwnership`).
 *
 * @param errors - an array of compilation errors
 */
var allErrorsAreRecoverable = function allErrorsAreRecoverable(errors) {
  return errors.every(function (error) {
    return 'missingIdentifier' in error && 'owningEntity' in error;
  });
};
/**
 * Get an array of all resolutions used in a {@link ResolvedScript}.
 * @param resolvedScript - the resolved script to search
 */
var extractBytecodeResolutions = function extractBytecodeResolutions(resolvedScript) {
  return (
    // eslint-disable-next-line complexity
    resolvedScript.reduce(function (all, segment) {
      switch (segment.type) {
        case 'push':
        case 'evaluation':
          return [].concat(_toConsumableArray(all), _toConsumableArray(extractBytecodeResolutions(segment.value)));
        case 'bytecode':
          if ('variable' in segment) {
            return [].concat(_toConsumableArray(all), [{
              bytecode: segment.value,
              text: segment.variable,
              type: 'variable'
            }]);
          }
          if ('script' in segment) {
            return [].concat(_toConsumableArray(all), _toConsumableArray(extractBytecodeResolutions(segment.source)), [{
              bytecode: segment.value,
              text: segment.script,
              type: 'script'
            }]);
          }
          if ('opcode' in segment) {
            return [].concat(_toConsumableArray(all), [{
              bytecode: segment.value,
              text: segment.opcode,
              type: 'opcode'
            }]);
          }
          return [].concat(_toConsumableArray(all), [{
            bytecode: segment.value,
            text: segment.literal,
            type: segment.literalType
          }]);
        default:
          return all;
      }
    }, [])
  );
};
/**
 * Extract an object mapping the variable identifiers used in a
 * {@link ResolvedScript} to their resolved bytecode.
 *
 * @param resolvedScript - the resolved script to search
 */
var extractResolvedVariableBytecodeMap = function extractResolvedVariableBytecodeMap(resolvedScript) {
  return extractBytecodeResolutions(resolvedScript).reduce(function (all, resolution) {
    return resolution.type === 'variable' ? _objectSpread2(_objectSpread2({}, all), {}, _defineProperty({}, resolution.text, resolution.bytecode)) : all;
  }, {});
};
/**
 * Format a list of {@link CompilationError}s into a single string, with an
 * error start position following each error. E.g. for line 1, column 2:
 * `The error message. [1, 2]`
 *
 * Errors are separated with the `separator`, which defaults to `; `, e.g.:
 * `The first error message. [1, 2]; The second error message. [3, 4]`
 *
 * @param errors - an array of compilation errors
 * @param separator - the characters with which to join the formatted errors.
 */
var stringifyErrors = function stringifyErrors(errors) {
  var separator = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '; ';
  return "".concat(errors.map(function (error) {
    return "[".concat(error.range.startLineNumber, ", ").concat(error.range.startColumn, "] ").concat(error.error);
  }).join(separator));
};
/**
 * Extract a set of "evaluation samples" from the result of a CashAssembly
 * compilation and a matching debug trace (from `vm.debug`), pairing program
 * states with the source ranges that produced them – like a "source map" for
 * complete evaluations. This is useful for omniscient debuggers like
 * Bitauth IDE.
 *
 * Returns an array of samples and an array of unmatched program states
 * remaining if `nodes` doesn't contain enough instructions to consume all
 * program states provided in `trace`. Returned samples are ordered by the
 * ending position (line and column) of their range.
 *
 * If all program states are consumed before the available nodes are exhausted,
 * the remaining nodes are ignored (the produced samples end at the last
 * instruction for which a program state exists). This usually occurs when an
 * error halts evaluation before the end of the script. (Note: if this occurs,
 * the final trace state will not be used, as it is expected to be the
 * duplicated final result produced by `vm.debug`, and should not be matched
 * with the next instruction. The returned `unmatchedStates` will have a length
 * of `0`.)
 *
 * This method allows for samples to be extracted from a single evaluation;
 * most applications should use
 * {@link extractEvaluationSamplesRecursive} instead.
 *
 * @remarks
 * This method incrementally concatenates the reduced bytecode from each node,
 * parsing the result into evaluation samples.
 *
 * Each node can contain only a portion of an instruction (like a long push
 * operation), or it can contain multiple instructions (like a long hex literal
 * representing a string of bytecode or an evaluation that is not wrapped by a
 * push).
 *
 * If a node contains only a portion of an instruction, the bytecode from
 * additional nodes are concatenated (and ranges merged) until an instruction
 * can be created. If any bytecode remains after a sample has been created, the
 * next sample begins in the same range. (For this reason, it's possible that
 * samples overlap.)
 *
 * If a node contains more than one instruction, the intermediate states
 * produced before the final state for that sample are saved to the sample's
 * `intermediateStates` array.
 *
 * If the program states in `trace` are exhausted before the final instruction
 * in a sample (usually caused by an evaluation error), the last instruction
 * with a matching program state is used for the sample (with its program
 * state), and the unmatched instructions are ignored. (This allows the "last
 * known state" to be displayed for the sample that caused evaluation to halt.)
 *
 * ---
 *
 * For example, the following script demonstrates many of these cases:
 *
 * `0x00 0x01 0xab01 0xcd9300 $(OP_3 <0x00> OP_SWAP OP_CAT) 0x010203`
 *
 * Which compiles to `0x0001ab01cd93000003010203`, disassembled:
 *
 * `OP_0 OP_PUSHBYTES_1 0xab OP_PUSHBYTES_1 0xcd OP_ADD OP_0 OP_0 OP_PUSHBYTES_3 0x010203`
 *
 * In the script, there are 6 top-level nodes (identified below within `[]`):
 *
 * `[0x00] [0x01] [0xab01] [0xcd9300] [$(OP_3 <0x00> OP_SWAP OP_CAT)] [0x010203]`
 *
 * These nodes together encode 7 instructions, some within a single node, and
 * some split between several nodes. Below we substitute the evaluation for its
 * result `0x0003` to group instructions by `[]`:
 *
 * `[0x00] [0x01 0xab][01 0xcd][93][00] [0x00][03 0x010203]`
 *
 * The "resolution" of samples is limited to the range of single nodes: nodes
 * cannot always be introspected to determine where contained instructions begin
 * and end. For example, it is ambiguous which portions of the evaluation are
 * responsible for the initial `0x00` and which are responsible for the `0x03`.
 *
 * For this reason, the range of each sample is limited to the range(s) of one
 * or more adjacent nodes. Samples may overlap in the range of a node that is
 * responsible for both ending a previous sample and beginning a new sample.
 * (Though, only 2 samples can overlap. If a node is responsible for more than 2
 * instructions, the second sample includes `internalStates` for instructions
 * that occur before the end of the second sample.)
 *
 * In this case, there are 6 samples identified below within `[]`, where each
 * `[` is closed by the closest following `]` (no nesting):
 *
 * `[0x00] [0x01 [0xab01] [0xcd9300]] [[$(OP_3 <0x00> OP_SWAP OP_CAT)] 0x010203]`
 *
 * The ranges for each sample (in terms of nodes) are as follows:
 * - Sample 1: node 1
 * - Sample 2: node 2 + node 3
 * - Sample 3: node 3 + node 4
 * - Sample 4: node 4
 * - Sample 5: node 5
 * - Sample 6: node 5 + node 6
 *
 * Note that the following samples overlap:
 * - Sample 2 and Sample 3
 * - Sample 3 and Sample 4
 * - Sample 5 and Sample 6
 *
 * Finally, note that Sample 4 will have one internal state produced by the
 * `OP_ADD` instruction. Sample 4 then ends with the `OP_0` (`0x00`) instruction
 * at the end of the `0xcd9300` node.
 *
 * ---
 *
 * Note, this implementation relies on the expectation that `trace` begins with
 * the initial program state, contains a single program state per instruction,
 * and ends with the final program state (as produced by `vm.debug`). It also
 * expects the `bytecode` provided by nodes to be parsable by
 * {@link decodeAuthenticationInstructions}.
 */
// eslint-disable-next-line complexity
var extractEvaluationSamples = function extractEvaluationSamples(_ref) {
  var evaluationRange = _ref.evaluationRange,
    nodes = _ref.nodes,
    trace = _ref.trace;
  var traceWithoutFinalState = trace.length > 1 ? trace.slice(0, -1) : trace.slice();
  if (traceWithoutFinalState.length === 0) {
    return {
      samples: [],
      unmatchedStates: []
    };
  }
  var samples = [{
    evaluationRange: evaluationRange,
    internalStates: [],
    range: {
      endColumn: evaluationRange.startColumn,
      endLineNumber: evaluationRange.startLineNumber,
      startColumn: evaluationRange.startColumn,
      startLineNumber: evaluationRange.startLineNumber
    },
    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
    state: traceWithoutFinalState[0]
  }];
  // eslint-disable-next-line functional/no-let
  var nextState = 1;
  // eslint-disable-next-line functional/no-let
  var nextNode = 0;
  // eslint-disable-next-line functional/no-let, @typescript-eslint/init-declarations
  var incomplete;
  // eslint-disable-next-line functional/no-loop-statement
  var _loop = function _loop() {
    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
    var currentNode = nodes[nextNode];
    var _ref2 = incomplete === undefined ? {
        mergedBytecode: currentNode.bytecode,
        mergedRange: currentNode.range
      } : {
        mergedBytecode: flattenBinArray([incomplete.bytecode, currentNode.bytecode]),
        mergedRange: mergeRanges([incomplete.range, currentNode.range])
      },
      mergedBytecode = _ref2.mergedBytecode,
      mergedRange = _ref2.mergedRange;
    var decoded = decodeAuthenticationInstructions(mergedBytecode);
    var _decoded = _slicedToArray(decoded, 1),
      zeroth = _decoded[0];
    var hasNonMalformedInstructions = zeroth !== undefined && !('malformed' in zeroth);
    if (hasNonMalformedInstructions) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      var lastInstruction = decoded[decoded.length - 1];
      var validInstructions = authenticationInstructionIsMalformed(lastInstruction) ? decoded.slice(0, decoded.length - 1) : decoded;
      var firstUnmatchedStateIndex = nextState + validInstructions.length;
      var matchingStates = traceWithoutFinalState.slice(nextState, firstUnmatchedStateIndex);
      var pairedStates = validInstructions.map(function (instruction, index) {
        return {
          instruction: instruction,
          state: matchingStates[index]
        };
      });
      /**
       * Guaranteed to have a defined `state` (or the loop would have exited).
       */
      var firstPairedState = pairedStates[0];
      var closesCurrentlyOpenSample = incomplete !== undefined;
      // eslint-disable-next-line functional/no-conditional-statement
      if (closesCurrentlyOpenSample) {
        // eslint-disable-next-line functional/no-expression-statement, functional/immutable-data
        samples.push({
          evaluationRange: evaluationRange,
          instruction: firstPairedState.instruction,
          internalStates: [],
          range: mergedRange,
          state: firstPairedState.state
        });
      }
      var firstUndefinedStateIndex = pairedStates.findIndex(function (_ref3) {
        var state = _ref3.state;
        return state === undefined;
      });
      var sampleHasError = firstUndefinedStateIndex !== -1;
      var sampleClosingIndex = sampleHasError ? firstUndefinedStateIndex - 1 : pairedStates.length - 1;
      var closesASecondSample = !closesCurrentlyOpenSample || sampleClosingIndex > 0;
      // eslint-disable-next-line functional/no-conditional-statement
      if (closesASecondSample) {
        var finalState = pairedStates[sampleClosingIndex];
        var secondSamplePairsBegin = closesCurrentlyOpenSample ? 1 : 0;
        var internalStates = pairedStates.slice(secondSamplePairsBegin, sampleClosingIndex);
        // eslint-disable-next-line functional/no-expression-statement, functional/immutable-data
        samples.push({
          evaluationRange: evaluationRange,
          instruction: finalState.instruction,
          internalStates: internalStates,
          range: currentNode.range,
          state: finalState.state
        });
      }
      // eslint-disable-next-line functional/no-expression-statement
      nextState = firstUnmatchedStateIndex;
      // eslint-disable-next-line functional/no-conditional-statement
      if (authenticationInstructionIsMalformed(lastInstruction)) {
        // eslint-disable-next-line functional/no-expression-statement
        incomplete = {
          bytecode: encodeAuthenticationInstructionMalformed(lastInstruction),
          range: currentNode.range
        };
        // eslint-disable-next-line functional/no-conditional-statement
      } else {
        // eslint-disable-next-line functional/no-expression-statement
        incomplete = undefined;
      }
      // eslint-disable-next-line functional/no-conditional-statement
    } else {
      var _lastInstruction = decoded[decoded.length - 1];
      // eslint-disable-next-line functional/no-expression-statement
      incomplete = _lastInstruction === undefined ? undefined : {
        bytecode: encodeAuthenticationInstructionMalformed(_lastInstruction),
        range: mergedRange
      };
    }
    // eslint-disable-next-line functional/no-expression-statement
    nextNode += 1;
  };
  while (nextState < traceWithoutFinalState.length && nextNode < nodes.length) {
    _loop();
  }
  /**
   * Because we ran out of `trace` states before all `nodes` were matched, we
   * know an error occurred which halted evaluation. This error is indicated in
   * the result by returning an empty array of `unmatchedStates`. Successful
   * evaluations will always return at least one unmatched state: the final
   * "evaluation result" state produced by `vm.debug`.
   */
  var errorOccurred = nextNode < nodes.length;
  var unmatchedStates = errorOccurred ? [] : trace.slice(nextState);
  return {
    samples: samples,
    unmatchedStates: unmatchedStates
  };
};
/**
 * Similar to {@link extractEvaluationSamples}, but recursively extracts samples
 * from evaluations within the provided array of nodes.
 *
 * Because CashAssembly evaluations are fully self-contained, there should never
 * be unmatched states from evaluations within a script reduction trace tree.
 * (For this reason, this method does not return the `unmatchedStates` from
 * nested evaluations.)
 *
 * Returned samples are ordered by the ending position (line and column) of
 * their range. Samples from CashAssembly evaluations that occur within an
 * outer evaluation appear before their parent sample (which uses their result).
 */
var extractEvaluationSamplesRecursive = function extractEvaluationSamplesRecursive(_ref4) {
  var evaluationRange = _ref4.evaluationRange,
    nodes = _ref4.nodes,
    trace = _ref4.trace;
  var extractEvaluations = function extractEvaluations(node) {
    if ('push' in node) {
      return node.push.script.reduce(function (all, childNode) {
        return [].concat(_toConsumableArray(all), _toConsumableArray(extractEvaluations(childNode)));
      }, []);
    }
    if ('source' in node) {
      var _childSamples = node.source.script.reduce(function (all, childNode) {
        return [].concat(_toConsumableArray(all), _toConsumableArray(extractEvaluations(childNode)));
      }, []);
      var traceWithoutUnlockingPhase = node.trace.slice(1);
      var evaluationBeginToken = '$(';
      var evaluationEndToken = ')';
      var extracted = extractEvaluationSamples({
        evaluationRange: {
          endColumn: node.range.endColumn - evaluationEndToken.length,
          endLineNumber: node.range.endLineNumber,
          startColumn: node.range.startColumn + evaluationBeginToken.length,
          startLineNumber: node.range.startLineNumber
        },
        nodes: node.source.script,
        trace: traceWithoutUnlockingPhase
      });
      return [].concat(_toConsumableArray(extracted.samples), _toConsumableArray(_childSamples));
    }
    return [];
  };
  var _extractEvaluationSam = extractEvaluationSamples({
      evaluationRange: evaluationRange,
      nodes: nodes,
      trace: trace
    }),
    samples = _extractEvaluationSam.samples,
    unmatchedStates = _extractEvaluationSam.unmatchedStates;
  var childSamples = nodes.reduce(function (all, node) {
    return [].concat(_toConsumableArray(all), _toConsumableArray(extractEvaluations(node)));
  }, []);
  var endingOrderedSamples = [].concat(_toConsumableArray(samples), _toConsumableArray(childSamples)).sort(function (a, b) {
    var linesOrdered = a.range.endLineNumber - b.range.endLineNumber;
    return linesOrdered === 0 ? a.range.endColumn - b.range.endColumn : linesOrdered;
  });
  return {
    samples: endingOrderedSamples,
    unmatchedStates: unmatchedStates
  };
};
var stateIsExecuting = function stateIsExecuting(state) {
  return state.controlStack.every(function (item) {
    return item !== false;
  });
};
/**
 * Extract an array of ranges that were unused by an evaluation. This is useful
 * in development tooling for fading out or hiding code that is unimportant to
 * the current evaluation being tested.
 *
 * @remarks
 * Only ranges that are guaranteed to be unimportant to an evaluation are
 * returned by this method. These ranges are extracted from samples that:
 * - are preceded by a sample that ends with execution disabled (e.g. an
 * unsuccessful `OP_IF`)
 * - end with execution disabled, and
 * - contain no `internalStates` that enable execution.
 *
 * Note, internal states that temporarily re-enable and then disable execution
 * again can still have an effect on the parent evaluation, so this method
 * conservatively excludes such samples. For example, the hex literal
 * `0x675167`, which encodes `OP_ELSE OP_1 OP_ELSE`, could begin and end with
 * states in which execution is disabled, yet a `1` is pushed to the stack
 * during the sample's evaluation. (Samples like this are unusual, and can
 * almost always be reformatted to clearly separate the executed and unexecuted
 * instructions.)
 *
 * @param samples - an array of samples ordered by the ending position (line and
 * column) of their range.
 * @param evaluationBegins - the line and column at which the initial sample's
 * evaluation range begins (where the preceding state is assumed to be
 * executing), defaults to `1,1`
 */
var extractUnexecutedRanges = function extractUnexecutedRanges(samples) {
  var evaluationBegins = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '1,1';
  var reduced = samples.reduce(function (all, sample) {
    var precedingStateSkipsByEvaluation = all.precedingStateSkipsByEvaluation,
      unexecutedRanges = all.unexecutedRanges;
    var currentEvaluationStartLineAndColumn = "".concat(sample.evaluationRange.startLineNumber, ",").concat(sample.evaluationRange.startColumn);
    var precedingStateSkips =
    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
    precedingStateSkipsByEvaluation[currentEvaluationStartLineAndColumn];
    var endsWithSkip = !stateIsExecuting(sample.state);
    var sampleHasNoExecutedInstructions = endsWithSkip && sample.internalStates.every(function (group) {
      return !stateIsExecuting(group.state);
    });
    if (precedingStateSkips && sampleHasNoExecutedInstructions) {
      return {
        precedingStateSkipsByEvaluation: _objectSpread2(_objectSpread2({}, precedingStateSkipsByEvaluation), {}, _defineProperty({}, currentEvaluationStartLineAndColumn, true)),
        unexecutedRanges: [].concat(_toConsumableArray(unexecutedRanges), [sample.range])
      };
    }
    return {
      precedingStateSkipsByEvaluation: _objectSpread2(_objectSpread2({}, precedingStateSkipsByEvaluation), {}, _defineProperty({}, currentEvaluationStartLineAndColumn, endsWithSkip)),
      unexecutedRanges: unexecutedRanges
    };
  }, {
    precedingStateSkipsByEvaluation: _defineProperty({}, evaluationBegins, false),
    unexecutedRanges: []
  });
  var canHaveContainedRanges = 2;
  var containedRangesExcluded = reduced.unexecutedRanges.length < canHaveContainedRanges ? reduced.unexecutedRanges : reduced.unexecutedRanges.slice(0, -1).reduceRight(function (all, range) {
    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
    if (containsRange(all[0], range)) {
      return all;
    }
    return [range].concat(_toConsumableArray(all));
  },
  // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
  [reduced.unexecutedRanges[reduced.unexecutedRanges.length - 1]]);
  return containedRangesExcluded;
};
/**
 * Given a stack, return a summary of the stack's contents, encoding valid VM
 * numbers as numbers, and all other stack items as hex literals.
 *
 * @param stack - a stack of Uint8Array values
 */
var summarizeStack = function summarizeStack(stack) {
  return stack.map(function (item) {
    var asNumber = vmNumberToBigInt(item);
    return "0x".concat(binToHex(item)).concat(typeof asNumber === 'string' ? '' : "(".concat(asNumber.toString(), ")"));
  });
};
/**
 * Given a debug trace (produced by {@link AuthenticationVirtualMachine.debug}),
 * return an array summarizing each step of the trace. Note, debug traces
 * include the full program state at the beginning of each evaluation step; the
 * summary produced by this method instead shows the resulting stacks after each
 * evaluation step.
 */
var summarizeDebugTrace = function summarizeDebugTrace(trace) {
  return trace.reduce(
  // eslint-disable-next-line max-params
  function (steps, state, stateIndex, states) {
    var nextState = states[stateIndex + 1];
    return nextState === undefined ? steps : [].concat(_toConsumableArray(steps), [_objectSpread2(_objectSpread2({
      alternateStack: summarizeStack(nextState.alternateStack)
    }, nextState.error === undefined ? {} : {
      error: nextState.error
    }), {}, {
      execute: state.controlStack[state.controlStack.length - 1] !== false,
      instruction: state.instructions[state.ip],
      ip: state.ip,
      stack: summarizeStack(nextState.stack)
    })]);
  }, []);
};
/**
 * Return a string with the result of {@link summarizeDebugTrace} including one
 * step per line.
 *
 * @param summary - a summary produced by {@link summarizeDebugTrace}
 */
var stringifyDebugTraceSummary = function stringifyDebugTraceSummary(summary) {
  var _ref5 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {
      opcodes: OpcodesBCHCHIPs,
      padInstruction: 23
    },
    opcodes = _ref5.opcodes,
    padInstruction = _ref5.padInstruction;
  return summary.map(
  // eslint-disable-next-line complexity
  function (line) {
    var _opcodes$line$instruc;
    return "".concat((line.instruction === undefined ? '=>' : "".concat(line.ip, ". ").concat(line.execute ? '' : '(skip)').concat((_opcodes$line$instruc = opcodes[line.instruction.opcode]) !== null && _opcodes$line$instruc !== void 0 ? _opcodes$line$instruc : "OP_UNKNOWN".concat(line.instruction.opcode), ":")).padEnd(padInstruction), " ").concat(typeof line.error === 'string' ? line.error : "".concat(line.stack.join(' ')).concat(line.alternateStack.length === 0 ? '' : "| alt: ".concat(line.alternateStack.join(' '))));
  }).join('\n');
};

/**
 * This file is derived from https://github.com/jneen/parsimmon and
 * https://github.com/DefinitelyTyped/DefinitelyTyped.
 */
/* eslint-disable @typescript-eslint/unified-signatures, functional/no-method-signature, functional/no-throw-statement, functional/no-conditional-statement, @typescript-eslint/no-this-alias, consistent-this, @typescript-eslint/ban-ts-comment, prefer-spread, @typescript-eslint/restrict-template-expressions, func-names, @typescript-eslint/init-declarations, new-cap, @typescript-eslint/require-array-sort-compare, guard-for-in, no-plusplus, functional/no-let, functional/no-loop-statement, @typescript-eslint/prefer-for-of, @typescript-eslint/restrict-plus-operands, functional/immutable-data, @typescript-eslint/no-use-before-define, @typescript-eslint/strict-boolean-expressions, no-param-reassign, functional/no-expression-statement, functional/no-this-expression, @typescript-eslint/no-explicit-any, func-style, @typescript-eslint/no-unsafe-member-access, @typescript-eslint/no-unsafe-call, @typescript-eslint/no-unsafe-assignment, @typescript-eslint/no-unsafe-return, @typescript-eslint/naming-convention, @typescript-eslint/method-signature-style, @typescript-eslint/no-confusing-void-expression, prefer-arrow-callback, functional/no-return-void, @typescript-eslint/no-unsafe-argument */
// cspell: ignore accum
function Parsimmon(action) {
  // @ts-expect-error
  if (!(this instanceof Parsimmon)) {
    // @ts-expect-error
    return new Parsimmon(action);
  }
  // @ts-expect-error
  this._ = action;
}
var _ = Parsimmon.prototype;
// -*- Helpers -*-
function makeSuccess(index, value) {
  return {
    expected: [],
    furthest: -1,
    index: index,
    status: true,
    value: value
  };
}
function makeFailure(index, expected) {
  expected = [expected];
  return {
    expected: expected,
    furthest: index,
    index: -1,
    status: false,
    value: null
  };
}
function mergeReplies(result, last) {
  if (!last) {
    return result;
  }
  if (result.furthest > last.furthest) {
    return result;
  }
  var expected = result.furthest === last.furthest ? union(result.expected, last.expected) : last.expected;
  return {
    expected: expected,
    furthest: last.furthest,
    index: result.index,
    status: result.status,
    value: result.value
  };
}
function makeLineColumnIndex(input, i) {
  var lines = input.slice(0, i).split('\n');
  /*
   * Note that unlike the character offset, the line and column offsets are
   * 1-based.
   */
  var lineWeAreUpTo = lines.length;
  var columnWeAreUpTo = lines[lines.length - 1].length + 1;
  return {
    column: columnWeAreUpTo,
    line: lineWeAreUpTo,
    offset: i
  };
}
// Returns the sorted set union of two arrays of strings
function union(xs, ys) {
  var obj = {};
  for (var i = 0; i < xs.length; i++) {
    // @ts-expect-error
    obj[xs[i]] = true;
  }
  for (var j = 0; j < ys.length; j++) {
    // @ts-expect-error
    obj[ys[j]] = true;
  }
  var keys = [];
  for (var k in obj) {
    keys.push(k);
  }
  keys.sort();
  return keys;
}
// -*- Error Formatting -*-
function flags(re) {
  var s = String(re);
  return s.slice(s.lastIndexOf('/') + 1);
}
function anchoredRegexp(re) {
  return RegExp("^(?:".concat(re.source, ")"), flags(re));
}
// -*- Combinators -*-
function seq() {
  for (var _len = arguments.length, params = new Array(_len), _key = 0; _key < _len; _key++) {
    params[_key] = arguments[_key];
  }
  var parsers = [].slice.call(params);
  var numParsers = parsers.length;
  return Parsimmon(function (input, i) {
    var result;
    var accum = new Array(numParsers);
    for (var j = 0; j < numParsers; j += 1) {
      result = mergeReplies(parsers[j]._(input, i), result);
      if (!result.status) {
        return result;
      }
      accum[j] = result.value;
      i = result.index;
    }
    return mergeReplies(makeSuccess(i, accum), result);
  });
}
function seqMap() {
  for (var _len2 = arguments.length, params = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
    params[_key2] = arguments[_key2];
  }
  var args = [].slice.call(params);
  var mapper = args.pop();
  return seq.apply(null, args).map(function (results) {
    // @ts-expect-error
    return mapper.apply(null, results);
  });
}
function createLanguage(parsers) {
  var language = {};
  for (var key in parsers) {
    (function (rule) {
      var func = function func() {
        // @ts-expect-error
        return parsers[rule](language);
      };
      // @ts-expect-error
      language[rule] = lazy(func);
    })(key);
  }
  return language;
}
function alt() {
  for (var _len3 = arguments.length, params = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
    params[_key3] = arguments[_key3];
  }
  var parsers = [].slice.call(params);
  return Parsimmon(function (input, i) {
    var result;
    for (var j = 0; j < parsers.length; j += 1) {
      result = mergeReplies(parsers[j]._(input, i), result);
      if (result.status) {
        return result;
      }
    }
    return result;
  });
}
function sepBy(parser, separator) {
  return sepBy1(parser, separator).or(succeed([]));
}
function sepBy1(parser, separator) {
  var pairs = separator.then(parser).many();
  return seqMap(parser, pairs, function (r, rs) {
    return [r].concat(rs);
  });
}
// -*- Core Parsing Methods -*-
_.parse = function (input) {
  var result = this.skip(eof)._(input, 0);
  if (result.status) {
    return {
      status: true,
      value: result.value
    };
  }
  return {
    expected: result.expected,
    index: makeLineColumnIndex(input, result.furthest),
    status: false
  };
};
// -*- Other Methods -*-
_.or = function (alternative) {
  return alt(this, alternative);
};
_.then = function (next) {
  return seq(this, next).map(function (results) {
    return results[1];
  });
};
_.many = function () {
  var self = this;
  return Parsimmon(function (input, i) {
    var accum = [];
    var result;
    for (;;) {
      result = mergeReplies(self._(input, i), result);
      if (result.status) {
        /* istanbul ignore if */if (i === result.index) {
          throw new Error('infinite loop detected in .many() parser --- calling .many() on ' + 'a parser that can accept zero characters is usually the cause');
        }
        i = result.index;
        accum.push(result.value);
      } else {
        return mergeReplies(makeSuccess(i, accum), result);
      }
    }
  });
};
_.map = function (fn) {
  var self = this;
  return Parsimmon(function (input, i) {
    var result = self._(input, i);
    if (!result.status) {
      return result;
    }
    return mergeReplies(makeSuccess(result.index, fn(result.value)), result);
  });
};
_.skip = function (next) {
  return seq(this, next).map(function (results) {
    return results[0];
  });
};
_.node = function (name) {
  return seqMap(index, this, index, function (start, value, end) {
    return {
      end: end,
      name: name,
      start: start,
      value: value
    };
  });
};
_.sepBy = function (separator) {
  return sepBy(this, separator);
};
_.desc = function (expected) {
  expected = [expected];
  var self = this;
  return Parsimmon(function (input, i) {
    var reply = self._(input, i);
    if (!reply.status) {
      reply.expected = expected;
    }
    return reply;
  });
};
// -*- Constructors -*-
function string(str) {
  var expected = "'".concat(str, "'");
  return Parsimmon(function (input, i) {
    var j = i + str.length;
    var head = input.slice(i, j);
    if (head === str) {
      return makeSuccess(j, head);
    }
    return makeFailure(i, expected);
  });
}
function regexp(re) {
  var group = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
  var anchored = anchoredRegexp(re);
  var expected = String(re);
  return Parsimmon(function (input, i) {
    var match = anchored.exec(input.slice(i));
    if (match) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      var fullMatch = match[0];
      var groupMatch = match[group];
      return makeSuccess(i + fullMatch.length, groupMatch);
    }
    return makeFailure(i, expected);
  });
}
function succeed(value) {
  return Parsimmon(function (__, i) {
    return makeSuccess(i, value);
  });
}
function lazy(f) {
  var parser = Parsimmon(function (input, i) {
    parser._ = f()._;
    return parser._(input, i);
  });
  return parser;
}
// -*- Base Parsers -*-
var index = Parsimmon(function (input, i) {
  return makeSuccess(i, makeLineColumnIndex(input, i));
});
var eof = Parsimmon(function (input, i) {
  if (i < input.length) {
    return makeFailure(i, 'EOF');
  }
  return makeSuccess(i, null);
});
var optWhitespace = regexp(/[\t-\r \xA0\u1680\u2000-\u200A\u2028\u2029\u202F\u205F\u3000\uFEFF]*/).desc('optional whitespace');
var whitespace = regexp(/[\t-\r \xA0\u1680\u2000-\u200A\u2028\u2029\u202F\u205F\u3000\uFEFF]+/).desc('whitespace');
var P = {
  alt: alt,
  createLanguage: createLanguage,
  index: index,
  lazy: lazy,
  makeFailure: makeFailure,
  makeSuccess: makeSuccess,
  of: succeed,
  optWhitespace: optWhitespace,
  regexp: regexp,
  sepBy: sepBy,
  sepBy1: sepBy1,
  seq: seq,
  seqMap: seqMap,
  string: string,
  succeed: succeed,
  whitespace: whitespace
};

/* eslint-disable sort-keys, @typescript-eslint/naming-convention, @typescript-eslint/no-unsafe-return, @typescript-eslint/no-unsafe-call, @typescript-eslint/no-unsafe-member-access */
var cashAssemblyParser = P.createLanguage({
  script: function script(r) {
    return P.seqMap(P.optWhitespace, r.expression.sepBy(P.optWhitespace), P.optWhitespace, function (_, expressions) {
      return expressions;
    }).node('Script');
  },
  expression: function expression(r) {
    return P.alt(r.comment, r.push, r.evaluation, r.utf8, r.binary, r.hex, r.bigint, r.identifier);
  },
  comment: function comment(r) {
    return P.alt(r.singleLineComment, r.multiLineComment).node('Comment');
  },
  singleLineComment: function singleLineComment() {
    return P.seqMap(P.string('//').desc("the start of a single-line comment ('//')"), P.regexp(/(?:[\0-\t\x0B-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])*/), function (__, comment) {
      return comment.trim();
    });
  },
  multiLineComment: function multiLineComment() {
    return P.seqMap(P.string('/*').desc("the start of a multi-line comment ('/*')"), P.regexp(/(?:[\0-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])*?\*\//).desc("the end of this multi-line comment ('*/')"), function (__, comment) {
      return comment.slice(0, -'*/'.length).trim();
    });
  },
  push: function push(r) {
    return P.seqMap(P.string('<').desc("the start of a push statement ('<')"), r.script, P.string('>').desc("the end of this push statement ('>')"), function (_, push) {
      return push;
    }).node('Push');
  },
  evaluation: function evaluation(r) {
    return P.seqMap(P.string('$').desc("the start of an evaluation ('$')"), P.string('(').desc("the opening parenthesis of this evaluation ('(')"), r.script, P.string(')').desc("the closing parenthesis of this evaluation (')')"), function (_, __, evaluation) {
      return evaluation;
    }).node('Evaluation');
  },
  identifier: function identifier() {
    return P.regexp(/[A-Z_a-z][\x2D\.0-9A-Z_a-z]*/).desc('a valid identifier').node('Identifier');
  },
  utf8: function utf8() {
    return P.alt(P.seqMap(P.string('"').desc('a double quote (")'), P.regexp(/(?:[\0-!#-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])*/), P.string('"').desc('a closing double quote (")'), function (__, literal) {
      return literal;
    }), P.seqMap(P.string("'").desc("a single quote (')"), P.regexp(/(?:[\0-&\(-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])*/), P.string("'").desc("a closing single quote (')"), function (__, literal) {
      return literal;
    })).node('UTF8Literal');
  },
  hex: function hex() {
    return P.seqMap(P.string('0x').desc("a hex literal ('0x...')"), P.regexp(/[0-9a-f]_*(?:_*[0-9a-f]_*[0-9a-f]_*)*[0-9a-f]/i).desc('a valid hexadecimal string'), function (__, literal) {
      return literal;
    }).node('HexLiteral');
  },
  binary: function binary() {
    return P.seqMap(P.string('0b').desc("a binary literal ('0b...')"), P.regexp(/[01]+(?:[01_]*[01]+)*/i).desc('a string of binary digits'), function (__, literal) {
      return literal;
    }).node('BinaryLiteral');
  },
  bigint: function bigint() {
    return P.regexp(/\x2D?[0-9]+(?:[0-9_]*[0-9]+)*/).desc('an integer literal').node('BigIntLiteral');
  }
});
/* eslint-enable sort-keys, @typescript-eslint/naming-convention, @typescript-eslint/no-unsafe-return, @typescript-eslint/no-unsafe-call, @typescript-eslint/no-unsafe-member-access */
var parseScript = function parseScript(script) {
  return cashAssemblyParser.script.parse(script);
};

var emptyReductionTraceNode = function emptyReductionTraceNode(range) {
  return {
    bytecode: Uint8Array.of(),
    range: range
  };
};
/**
 * Perform the standard verification of CashAssembly evaluation results. This
 * ensures that evaluations complete as expected: if an error occurs while
 * computing an evaluation, script compilation should fail.
 *
 * Three requirements are enforced:
 * - the evaluation may not produce an `error`
 * - the resulting stack must contain exactly 1 item
 * - the resulting execution stack must be empty (no missing `OP_ENDIF`s)
 *
 * This differs from the virtual machine's built-in `vm.verify` in that it is
 * often more lenient, for example, evaluations can succeed with an non-truthy
 * value on top of the stack.
 *
 * @param state - the final program state to verify
 */
var verifyCashAssemblyEvaluationState = function verifyCashAssemblyEvaluationState(state) {
  if (state.error !== undefined) {
    return state.error;
  }
  if (state.controlStack.length !== 0) {
    return AuthenticationErrorCommon.nonEmptyControlStack;
  }
  if (state.stack.length !== 1) {
    return AuthenticationErrorCommon.requiresCleanStack;
  }
  return true;
};
/**
 * Reduce a resolved script, returning the resulting bytecode and a trace of the
 * reduction process.
 *
 * This method will return an error if provided a {@link resolvedScript} with
 * resolution errors. To check for resolution errors, use
 * {@link getResolutionErrors}.
 *
 * @param resolvedScript - the {@link CompiledScript} to reduce
 * @param vm - the {@link AuthenticationVirtualMachine} to use for evaluations
 * @param createEvaluationProgram - a method which accepts the compiled bytecode
 * of an evaluation and returns the authentication program used to evaluate it
 */
var reduceScript = function reduceScript(resolvedScript, vm, createEvaluationProgram) {
  var script = resolvedScript.map(function (segment) {
    switch (segment.type) {
      case 'bytecode':
        return {
          bytecode: segment.value,
          range: segment.range
        };
      case 'push':
        {
          var push = reduceScript(segment.value, vm, createEvaluationProgram);
          var bytecode = encodeDataPush(push.bytecode);
          return _objectSpread2(_objectSpread2({
            bytecode: bytecode
          }, push.errors === undefined ? undefined : {
            errors: push.errors
          }), {}, {
            push: push,
            range: segment.range
          });
        }
      case 'evaluation':
        {
          if (typeof vm === 'undefined' || typeof createEvaluationProgram === 'undefined') {
            return _objectSpread2({
              errors: [{
                error: 'Both a VM and a createState method are required to reduce evaluations.',
                range: segment.range
              }]
            }, emptyReductionTraceNode(segment.range));
          }
          var reductionTrace = reduceScript(segment.value, vm, createEvaluationProgram);
          if (reductionTrace.errors !== undefined) {
            return _objectSpread2(_objectSpread2({}, emptyReductionTraceNode(segment.range)), {}, {
              errors: reductionTrace.errors,
              source: reductionTrace,
              trace: []
            });
          }
          var trace = vm.debug(createEvaluationProgram(reductionTrace.bytecode));
          /**
           * `vm.debug` should always return at least one state.
           */
          // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
          var lastState = trace[trace.length - 1];
          var result = verifyCashAssemblyEvaluationState(lastState);
          // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
          var _bytecode = lastState.stack[lastState.stack.length - 1];
          return _objectSpread2(_objectSpread2({}, typeof result === 'string' ? {
            bytecode: Uint8Array.of(),
            errors: [{
              error: "Failed to reduce evaluation: ".concat(result),
              range: segment.range
            }]
          } : {
            bytecode: _bytecode
          }), {}, {
            range: segment.range,
            source: reductionTrace,
            trace: trace
          });
        }
      case 'comment':
        return emptyReductionTraceNode(segment.range);
      case 'error':
        return _objectSpread2({
          errors: [{
            error: "Tried to reduce a CashAssembly script with resolution errors: ".concat(segment.value),
            range: segment.range
          }]
        }, emptyReductionTraceNode(segment.range));
      default:
        // eslint-disable-next-line functional/no-throw-statement, @typescript-eslint/no-throw-literal
        throw new Error("\"".concat(segment.type, "\" is not a known segment type."));
    }
  });
  var reduction = script.reduce(function (all, segment) {
    return _objectSpread2({
      bytecode: [].concat(_toConsumableArray(all.bytecode), [segment.bytecode]),
      ranges: [].concat(_toConsumableArray(all.ranges), [segment.range])
    }, all.errors !== undefined || segment.errors !== undefined ? {
      errors: [].concat(_toConsumableArray(all.errors === undefined ? [] : all.errors), _toConsumableArray(segment.errors === undefined ? [] : segment.errors))
    } : undefined);
  }, {
    bytecode: [],
    ranges: []
  });
  return _objectSpread2(_objectSpread2({}, reduction.errors === undefined ? undefined : {
    errors: reduction.errors
  }), {}, {
    bytecode: flattenBinArray(reduction.bytecode),
    range: mergeRanges(reduction.ranges,
    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
    resolvedScript.length === 0 ? undefined : resolvedScript[0].range),
    script: script
  });
};

var pluckRange = function pluckRange(node) {
  return {
    endColumn: node.end.column,
    endLineNumber: node.end.line,
    startColumn: node.start.column,
    startLineNumber: node.start.line
  };
};
var removeNumericSeparators = function removeNumericSeparators(numericLiteral) {
  return numericLiteral.replace(/_/g, '');
};
var resolveScriptSegment = function resolveScriptSegment(segment, resolveIdentifiers) {
  // eslint-disable-next-line complexity
  var resolved = segment.value.map(function (child) {
    var range = pluckRange(child);
    switch (child.name) {
      case 'Identifier':
        {
          var identifier = child.value;
          var result = resolveIdentifiers(identifier);
          var ret = result.status ? _objectSpread2({
            range: range,
            type: 'bytecode',
            value: result.bytecode
          }, result.type === IdentifierResolutionType.opcode ? {
            opcode: identifier
          } : result.type === IdentifierResolutionType.variable ? _objectSpread2(_objectSpread2(_objectSpread2({}, 'debug' in result ? {
            debug: result.debug
          } : {}), 'signature' in result ? {
            signature: result.signature
          } : {}), {}, {
            variable: identifier
          }) :
          // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
          result.type === IdentifierResolutionType.script ? {
            script: identifier,
            source: result.source
          } : {
            unknown: identifier
          }) : _objectSpread2(_objectSpread2(_objectSpread2({}, 'debug' in result ? {
            debug: result.debug
          } : {}), 'recoverable' in result && result.recoverable ? {
            missingIdentifier: identifier,
            owningEntity: result.entityOwnership
          } : {}), {}, {
            range: range,
            type: 'error',
            value: result.error
          });
          return ret;
        }
      case 'Push':
        return {
          range: range,
          type: 'push',
          value: resolveScriptSegment(child.value, resolveIdentifiers)
        };
      case 'Evaluation':
        return {
          range: range,
          type: 'evaluation',
          value: resolveScriptSegment(child.value, resolveIdentifiers)
        };
      case 'BigIntLiteral':
        return {
          literal: child.value,
          literalType: 'BigIntLiteral',
          range: range,
          type: 'bytecode',
          value: bigIntToVmNumber(BigInt(removeNumericSeparators(child.value)))
        };
      case 'BinaryLiteral':
        return {
          literal: child.value,
          literalType: 'BinaryLiteral',
          range: range,
          type: 'bytecode',
          value: binStringToBin(removeNumericSeparators(child.value))
        };
      case 'HexLiteral':
        return {
          literal: child.value,
          literalType: 'HexLiteral',
          range: range,
          type: 'bytecode',
          value: hexToBin(removeNumericSeparators(child.value))
        };
      case 'UTF8Literal':
        return {
          literal: child.value,
          literalType: 'UTF8Literal',
          range: range,
          type: 'bytecode',
          value: utf8ToBin(child.value)
        };
      case 'Comment':
        return {
          range: range,
          type: 'comment',
          value: child.value
        };
      default:
        return {
          range: range,
          type: 'error',
          value: "Unrecognized segment: ".concat(child.name)
        };
    }
  });
  return resolved.length === 0 ? [{
    range: pluckRange(segment),
    type: 'comment',
    value: ''
  }] : resolved;
};
var BuiltInVariables;
(function (BuiltInVariables) {
  BuiltInVariables["currentBlockTime"] = "current_block_time";
  BuiltInVariables["currentBlockHeight"] = "current_block_height";
  BuiltInVariables["signingSerialization"] = "signing_serialization";
})(BuiltInVariables || (BuiltInVariables = {}));
var attemptCompilerOperation = function attemptCompilerOperation(_ref) {
  var data = _ref.data,
    configuration = _ref.configuration,
    identifier = _ref.identifier,
    matchingOperations = _ref.matchingOperations,
    _ref$operationExample = _ref.operationExample,
    operationExample = _ref$operationExample === void 0 ? 'operation_identifier' : _ref$operationExample,
    operationId = _ref.operationId,
    variableId = _ref.variableId,
    variableType = _ref.variableType;
  if (matchingOperations === undefined) {
    return {
      error: "The \"".concat(variableId, "\" variable type can not be resolved because the \"").concat(variableType, "\" operation has not been included in this compiler's CompilationEnvironment."),
      status: 'error'
    };
  }
  if (typeof matchingOperations === 'function') {
    var _operation = matchingOperations;
    return _operation(identifier, data, configuration);
  }
  if (operationId === undefined) {
    return {
      error: "This \"".concat(variableId, "\" variable could not be resolved because this compiler's \"").concat(variableType, "\" operations require an operation identifier, e.g. '").concat(variableId, ".").concat(operationExample, "'."),
      status: 'error'
    };
  }
  var operation = matchingOperations[operationId];
  if (operation === undefined) {
    return {
      error: "The identifier \"".concat(identifier, "\" could not be resolved because the \"").concat(variableId, ".").concat(operationId, "\" operation is not available to this compiler."),
      status: 'error'
    };
  }
  return operation(identifier, data, configuration);
};
/**
 * If the identifier can be successfully resolved as a variable, the result is
 * returned as a Uint8Array. If the identifier references a known variable, but
 * an error occurs in resolving it, the error is returned as a string.
 * Otherwise, the identifier is not recognized as a variable, and this method
 * simply returns `false`.
 *
 * @param identifier - The full identifier used to describe this operation, e.g.
 * `owner.signature.all_outputs`.
 * @param data - The {@link CompilationData} provided to the compiler
 * @param configuration - The {@link CompilerConfiguration} provided to
 * the compiler
 */
var resolveVariableIdentifier = function resolveVariableIdentifier(_ref2) {
  var _configuration$operat, _configuration$operat2, _configuration$operat3;
  var data = _ref2.data,
    configuration = _ref2.configuration,
    identifier = _ref2.identifier;
  var _identifier$split = identifier.split('.'),
    _identifier$split2 = _slicedToArray(_identifier$split, 2),
    variableId = _identifier$split2[0],
    operationId = _identifier$split2[1];
  switch (variableId) {
    case BuiltInVariables.currentBlockHeight:
      return attemptCompilerOperation({
        configuration: configuration,
        data: data,
        identifier: identifier,
        matchingOperations: (_configuration$operat = configuration.operations) === null || _configuration$operat === void 0 ? void 0 : _configuration$operat.currentBlockHeight,
        operationId: operationId,
        variableId: variableId,
        variableType: 'currentBlockHeight'
      });
    case BuiltInVariables.currentBlockTime:
      return attemptCompilerOperation({
        configuration: configuration,
        data: data,
        identifier: identifier,
        matchingOperations: (_configuration$operat2 = configuration.operations) === null || _configuration$operat2 === void 0 ? void 0 : _configuration$operat2.currentBlockTime,
        operationId: operationId,
        variableId: variableId,
        variableType: 'currentBlockTime'
      });
    case BuiltInVariables.signingSerialization:
      return attemptCompilerOperation({
        configuration: configuration,
        data: data,
        identifier: identifier,
        matchingOperations: (_configuration$operat3 = configuration.operations) === null || _configuration$operat3 === void 0 ? void 0 : _configuration$operat3.signingSerialization,
        operationExample: 'version',
        operationId: operationId,
        variableId: variableId,
        variableType: 'signingSerialization'
      });
    default:
      {
        var _configuration$variab, _configuration$operat4, _configuration$operat5, _configuration$operat6, _configuration$operat7;
        var expectedVariable = (_configuration$variab = configuration.variables) === null || _configuration$variab === void 0 ? void 0 : _configuration$variab[variableId];
        if (expectedVariable === undefined) {
          return {
            status: 'skip'
          };
        }
        return attemptCompilerOperation(_objectSpread2({
          configuration: configuration,
          data: data,
          identifier: identifier,
          operationId: operationId,
          variableId: variableId
        }, {
          // eslint-disable-next-line @typescript-eslint/naming-convention
          AddressData: {
            matchingOperations: (_configuration$operat4 = configuration.operations) === null || _configuration$operat4 === void 0 ? void 0 : _configuration$operat4.addressData,
            variableType: 'addressData'
          },
          // eslint-disable-next-line @typescript-eslint/naming-convention
          HdKey: {
            matchingOperations: (_configuration$operat5 = configuration.operations) === null || _configuration$operat5 === void 0 ? void 0 : _configuration$operat5.hdKey,
            operationExample: 'public_key',
            variableType: 'hdKey'
          },
          // eslint-disable-next-line @typescript-eslint/naming-convention
          Key: {
            matchingOperations: (_configuration$operat6 = configuration.operations) === null || _configuration$operat6 === void 0 ? void 0 : _configuration$operat6.key,
            operationExample: 'public_key',
            variableType: 'key'
          },
          // eslint-disable-next-line @typescript-eslint/naming-convention
          WalletData: {
            matchingOperations: (_configuration$operat7 = configuration.operations) === null || _configuration$operat7 === void 0 ? void 0 : _configuration$operat7.walletData,
            variableType: 'walletData'
          }
        }[expectedVariable.type]));
      }
  }
};
/**
 * A text-formatting method to pretty-print the list of expected inputs
 * (`Encountered unexpected input while parsing script. Expected ...`). If
 * present, the `EOF` expectation is always moved to the end of the list.
 * @param expectedArray - the alphabetized list of expected inputs produced by
 * `parseScript`
 */
var describeExpectedInput = function describeExpectedInput(expectedArray) {
  /**
   * The constant used by the parser to denote the end of the input
   */
  var EOF = 'EOF';
  var newArray = expectedArray.filter(function (value) {
    return value !== EOF;
  });
  // eslint-disable-next-line functional/no-conditional-statement
  if (newArray.length !== expectedArray.length) {
    // eslint-disable-next-line functional/no-expression-statement, functional/immutable-data
    newArray.push('the end of the script');
  }
  var withoutLastElement = newArray.slice(0, newArray.length - 1);
  // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
  var lastElement = newArray[newArray.length - 1];
  var arrayRequiresCommas = 3;
  var arrayRequiresOr = 2;
  return "Encountered unexpected input while parsing script. Expected ".concat(newArray.length >= arrayRequiresCommas ? withoutLastElement.join(', ').concat(", or ".concat(lastElement)) : newArray.length === arrayRequiresOr ? newArray.join(' or ') : lastElement, ".");
};
var createEmptyRange = function createEmptyRange() {
  return {
    endColumn: 0,
    endLineNumber: 0,
    startColumn: 0,
    startLineNumber: 0
  };
};
/**
 * This method is generally for internal use. The {@link compileScript} method
 * is the recommended API for direct compilation.
 */
var compileScriptRaw = function compileScriptRaw(_ref3) {
  var _configuration$source;
  var data = _ref3.data,
    configuration = _ref3.configuration,
    scriptId = _ref3.scriptId;
  var script = configuration.scripts[scriptId];
  if (script === undefined) {
    return {
      errorType: 'parse',
      errors: [{
        error: "No script with an ID of \"".concat(scriptId, "\" was provided in the compiler configuration."),
        range: createEmptyRange()
      }],
      success: false
    };
  }
  if (((_configuration$source = configuration.sourceScriptIds) === null || _configuration$source === void 0 ? void 0 : _configuration$source.includes(scriptId)) === true) {
    return {
      errorType: 'parse',
      errors: [{
        error: "A circular dependency was encountered: script \"".concat(scriptId, "\" relies on itself to be generated. (Source scripts: ").concat(configuration.sourceScriptIds.join(' → '), ")"),
        range: createEmptyRange()
      }],
      success: false
    };
  }
  var sourceScriptIds = configuration.sourceScriptIds === undefined ? [scriptId] : [].concat(_toConsumableArray(configuration.sourceScriptIds), [scriptId]);
  // eslint-disable-next-line @typescript-eslint/no-use-before-define
  return compileScriptContents({
    configuration: _objectSpread2(_objectSpread2({}, configuration), {}, {
      sourceScriptIds: sourceScriptIds
    }),
    data: data,
    script: script
  });
};
/**
 * Compile an internal script identifier.
 *
 * @remarks
 * If the identifier can be successfully resolved as a script, the script is
 * compiled and returned as a {@link CompilationResultSuccess}. If an error
 * occurs in compiling it, the error is returned as a string.
 *
 * Otherwise, the identifier is not recognized as a script, and this method
 * simply returns `false`.
 */
var resolveScriptIdentifier = function resolveScriptIdentifier(_ref4) {
  var data = _ref4.data,
    configuration = _ref4.configuration,
    identifier = _ref4.identifier;
  if (configuration.scripts[identifier] === undefined) {
    return false;
  }
  var result = compileScriptRaw({
    configuration: configuration,
    data: data,
    scriptId: identifier
  });
  if (result.success) {
    return result;
  }
  return "Compilation error in resolved script \"".concat(identifier, "\": ").concat(stringifyErrors(result.errors));
};
/**
 * Return an {@link IdentifierResolutionFunction} for use in
 * {@link resolveScriptSegment}.
 *
 * @param scriptId - the `id` of the script for which the resulting
 * `IdentifierResolutionFunction` will be used.
 */
var createIdentifierResolver = function createIdentifierResolver(_ref5) {
  var data = _ref5.data,
    configuration = _ref5.configuration;
  return (
    // eslint-disable-next-line complexity
    function (identifier) {
      var _configuration$opcode;
      var opcodeResult = (_configuration$opcode = configuration.opcodes) === null || _configuration$opcode === void 0 ? void 0 : _configuration$opcode[identifier];
      if (opcodeResult !== undefined) {
        return {
          bytecode: opcodeResult,
          status: true,
          type: IdentifierResolutionType.opcode
        };
      }
      var variableResult = resolveVariableIdentifier({
        configuration: configuration,
        data: data,
        identifier: identifier
      });
      if (variableResult.status !== 'skip') {
        return variableResult.status === 'error' ? _objectSpread2(_objectSpread2(_objectSpread2({}, 'debug' in variableResult ? {
          debug: variableResult.debug
        } : {}), {}, {
          error: variableResult.error
        }, configuration.entityOwnership === undefined ? {} : {
          entityOwnership:
          // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
          configuration.entityOwnership[identifier.split('.')[0]]
        }), {}, {
          recoverable: 'recoverable' in variableResult,
          status: false,
          type: IdentifierResolutionErrorType.variable
        }) : _objectSpread2(_objectSpread2(_objectSpread2({}, 'debug' in variableResult ? {
          debug: variableResult.debug
        } : {}), {}, {
          bytecode: variableResult.bytecode
        }, 'signature' in variableResult ? {
          signature: variableResult.signature
        } : {}), {}, {
          status: true,
          type: IdentifierResolutionType.variable
        });
      }
      var scriptResult = resolveScriptIdentifier({
        configuration: configuration,
        data: data,
        identifier: identifier
      });
      if (scriptResult !== false) {
        return typeof scriptResult === 'string' ? {
          error: scriptResult,
          scriptId: identifier,
          status: false,
          type: IdentifierResolutionErrorType.script
        } : {
          bytecode: scriptResult.bytecode,
          source: scriptResult.resolve,
          status: true,
          type: IdentifierResolutionType.script
        };
      }
      return {
        error: "Unknown identifier \"".concat(identifier, "\"."),
        status: false,
        type: IdentifierResolutionErrorType.unknown
      };
    }
  );
};
/**
 * This method is generally for internal use. The {@link compileScript} method
 * is the recommended API for direct compilation.
 */
var compileScriptContents = function compileScriptContents(_ref6) {
  var data = _ref6.data,
    configuration = _ref6.configuration,
    script = _ref6.script;
  var parseResult = parseScript(script);
  if (!parseResult.status) {
    return {
      errorType: 'parse',
      errors: [{
        error: describeExpectedInput(parseResult.expected),
        range: {
          endColumn: parseResult.index.column,
          endLineNumber: parseResult.index.line,
          startColumn: parseResult.index.column,
          startLineNumber: parseResult.index.line
        }
      }],
      success: false
    };
  }
  var resolver = createIdentifierResolver({
    configuration: configuration,
    data: data
  });
  var resolvedScript = resolveScriptSegment(parseResult.value, resolver);
  var resolutionErrors = getResolutionErrors(resolvedScript);
  if (resolutionErrors.length !== 0) {
    return {
      errorType: 'resolve',
      errors: resolutionErrors,
      parse: parseResult.value,
      resolve: resolvedScript,
      success: false
    };
  }
  var reduction = reduceScript(resolvedScript, configuration.vm, configuration.createAuthenticationProgram);
  return _objectSpread2(_objectSpread2({}, reduction.errors === undefined ? {
    bytecode: reduction.bytecode,
    success: true
  } : {
    errorType: 'reduce',
    errors: reduction.errors,
    success: false
  }), {}, {
    parse: parseResult.value,
    reduce: reduction,
    resolve: resolvedScript
  });
};

/**
 * Parse, resolve, and reduce the selected script using the provided `data` and
 * `configuration`.
 *
 * Note, locktime validation only occurs if `compilationContext` is provided in
 * the configuration.
 */
// eslint-disable-next-line complexity
var compileScript = function compileScript(scriptId, data, configuration) {
  var _data$compilationCont, _data$compilationCont2, _data$compilationCont3, _configuration$unlock3, _configuration$unlock4, _configuration$lockin, _configuration$lockin2;
  var locktimeDisablingSequenceNumber = 0xffffffff;
  var lockTimeTypeBecomesTimestamp = 500000000;
  if (((_data$compilationCont = data.compilationContext) === null || _data$compilationCont === void 0 ? void 0 : _data$compilationCont.transaction.locktime) !== undefined) {
    var _configuration$unlock, _configuration$unlock2;
    if (((_configuration$unlock = configuration.unlockingScriptTimeLockTypes) === null || _configuration$unlock === void 0 ? void 0 : _configuration$unlock[scriptId]) === 'height' && data.compilationContext.transaction.locktime >= lockTimeTypeBecomesTimestamp) {
      return {
        errorType: 'parse',
        errors: [{
          error: "The script \"".concat(scriptId, "\" requires a height-based locktime (less than 500,000,000), but this transaction uses a timestamp-based locktime (\"").concat(data.compilationContext.transaction.locktime, "\")."),
          range: createEmptyRange()
        }],
        success: false
      };
    }
    if (((_configuration$unlock2 = configuration.unlockingScriptTimeLockTypes) === null || _configuration$unlock2 === void 0 ? void 0 : _configuration$unlock2[scriptId]) === 'timestamp' && data.compilationContext.transaction.locktime < lockTimeTypeBecomesTimestamp) {
      return {
        errorType: 'parse',
        errors: [{
          error: "The script \"".concat(scriptId, "\" requires a timestamp-based locktime (greater than or equal to 500,000,000), but this transaction uses a height-based locktime (\"").concat(data.compilationContext.transaction.locktime, "\")."),
          range: createEmptyRange()
        }],
        success: false
      };
    }
  }
  if (((_data$compilationCont2 = data.compilationContext) === null || _data$compilationCont2 === void 0 ? void 0 : (_data$compilationCont3 = _data$compilationCont2.transaction.inputs[data.compilationContext.inputIndex]) === null || _data$compilationCont3 === void 0 ? void 0 : _data$compilationCont3.sequenceNumber) !== undefined && ((_configuration$unlock3 = configuration.unlockingScriptTimeLockTypes) === null || _configuration$unlock3 === void 0 ? void 0 : _configuration$unlock3[scriptId]) !== undefined &&
  // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
  data.compilationContext.transaction.inputs[data.compilationContext.inputIndex].sequenceNumber === locktimeDisablingSequenceNumber) {
    return {
      errorType: 'parse',
      errors: [{
        error: "The script \"".concat(scriptId, "\" requires a locktime, but this input's sequence number is set to disable transaction locktime (0xffffffff). This will cause the OP_CHECKLOCKTIMEVERIFY operation to error when the transaction is verified. To be valid, this input must use a sequence number that does not disable locktime."),
        range: createEmptyRange()
      }],
      success: false
    };
  }
  var rawResult = compileScriptRaw({
    configuration: configuration,
    data: data,
    scriptId: scriptId
  });
  if (!rawResult.success) {
    return rawResult;
  }
  var unlocks = (_configuration$unlock4 = configuration.unlockingScripts) === null || _configuration$unlock4 === void 0 ? void 0 : _configuration$unlock4[scriptId];
  var unlockingScriptType = unlocks === undefined ? undefined : (_configuration$lockin = configuration.lockingScriptTypes) === null || _configuration$lockin === void 0 ? void 0 : _configuration$lockin[unlocks];
  var isP2shUnlock = unlockingScriptType === 'p2sh20' || unlockingScriptType === 'p2sh32';
  var lockingScriptType = (_configuration$lockin2 = configuration.lockingScriptTypes) === null || _configuration$lockin2 === void 0 ? void 0 : _configuration$lockin2[scriptId];
  var isP2shLock = lockingScriptType === 'p2sh20' || lockingScriptType === 'p2sh32';
  if (isP2shLock) {
    var transformedResult = compileScriptRaw({
      configuration: _objectSpread2(_objectSpread2({}, configuration), {}, {
        scripts: {
          p2sh20Locking: 'OP_HASH160 <$(<lockingBytecode> OP_HASH160)> OP_EQUAL',
          p2sh32Locking: 'OP_HASH256 <$(<lockingBytecode> OP_HASH256)> OP_EQUAL'
        },
        variables: {
          lockingBytecode: {
            type: 'AddressData'
          }
        }
      }),
      data: {
        bytecode: {
          lockingBytecode: rawResult.bytecode
        }
      },
      scriptId: lockingScriptType === 'p2sh20' ? 'p2sh20Locking' : 'p2sh32Locking'
    });
    if (!transformedResult.success) {
      return transformedResult;
    }
    return _objectSpread2(_objectSpread2({}, rawResult), {}, {
      bytecode: transformedResult.bytecode,
      transformed: lockingScriptType === 'p2sh20' ? 'p2sh20-locking' : 'p2sh32-locking'
    });
  }
  if (isP2shUnlock) {
    var lockingBytecodeResult = compileScriptRaw({
      configuration: configuration,
      data: data,
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      scriptId: unlocks
    });
    if (!lockingBytecodeResult.success) {
      return lockingBytecodeResult;
    }
    var _transformedResult = compileScriptRaw({
      configuration: _objectSpread2(_objectSpread2({}, configuration), {}, {
        scripts: {
          p2shUnlocking: 'unlockingBytecode <lockingBytecode>'
        },
        variables: {
          lockingBytecode: {
            type: 'AddressData'
          },
          unlockingBytecode: {
            type: 'AddressData'
          }
        }
      }),
      data: {
        bytecode: {
          lockingBytecode: lockingBytecodeResult.bytecode,
          unlockingBytecode: rawResult.bytecode
        }
      },
      scriptId: 'p2shUnlocking'
    });
    return _objectSpread2(_objectSpread2({}, rawResult), {}, {
      bytecode: _transformedResult.bytecode,
      transformed: unlockingScriptType === 'p2sh20' ? 'p2sh20-unlocking' : 'p2sh32-unlocking'
    });
  }
  return rawResult;
};

var schema38 = {
  additionalProperties: false,
  properties: {
    lockingType: {
      description: 'Indicates if P2SH20 infrastructure should be used when producing bytecode related to this script. For more information on P2SH20, see BIP16.\n\nWhen compiling locking scripts of type `p2sh20`, the result will be placed in a P2SH20 "redeem script" format: `OP_HASH160 <$(<lockingBytecode> OP_HASH160)> OP_EQUAL`\n\nWhen compiling unlocking scripts that unlock locking scripts of type `p2sh20`, the result will be transformed into the P2SH20 unlocking format: `unlockingBytecode <lockingBytecode>` (where `lockingBytecode` is the compiled bytecode of the locking script, without the "redeem script" transformation.)\n\nThe presence of the `lockingType` property indicates that this script is a locking script. It must be present on any script referenced by the `unlocks` property of another script.',
      enum: ['p2sh20', 'p2sh32', 'standard'],
      type: 'string'
    },
    name: {
      description: 'A single-line, human-readable name for this script (for use in user interfaces).',
      type: 'string'
    },
    script: {
      description: 'The script definition in CashAssembly.',
      type: 'string'
    }
  },
  required: ['lockingType', 'script'],
  type: 'object'
};
var schema41 = {
  additionalProperties: false,
  properties: {
    ageLock: {
      description: 'TODO: not yet implemented\n\nThe minimum input age required for this unlocking script to become valid.\n\nThis value is provided as a CashAssembly script that must compile to the least significant 3 bytes of the minimum sequence number required for this unlocking script to be valid (the "type bit" and the 2-byte "value" – see BIP68 for details). This script has access to all other template scripts and variables, but cyclical references will produce an error at compile time.\n\nIn supporting wallets, this value can be computed at address creation time, and the remaining time for which any UTXO remains "age-locked" can be displayed in user interfaces (by parsing the "type bit" and "value" as described in BIP68).\n\nNote, because the precise value used by `OP_CHECKSEQUENCEVERIFY` can be provided in the unlocking script, it is trivial to create an unlocking script for which a proper value for `ageLock` is not possible to determine until the spending transaction is prepared. These cases are intentionally out-of-scope for this property. Instead, `ageLock` should only be used for unlocking scripts where the expected value can be compiled at address creation time.',
      type: 'string'
    },
    estimate: {
      description: 'The identifier of the scenario to use for this unlocking script when compiling an estimated transaction.\n\nUsing estimate scenarios, it\'s possible for wallet software to compute an "estimated transaction", an invalid transaction that is guaranteed to be the same byte length as the final transaction. This length can be used to calculate the required transaction fee and assign values to the transaction\'s change output(s). Because estimate scenarios provide "estimated" values for all variables, this estimation can be done by a single entity without input from other entities.\n\nIf not provided, the default scenario will be used for estimation. The default scenario only provides values for each `Key` and `HdKey` variable, so compilations requiring other variables will produce errors. See `AuthenticationTemplateScenario.extends` for details.',
      type: 'string'
    },
    fails: {
      description: 'A list of the scenario identifiers that – when used to compile this unlocking script and the script it unlocks – result in bytecode that fails program verification.\n\nThese scenarios can be used to test this script in development and review.',
      items: {
        type: 'string'
      },
      type: 'array'
    },
    invalid: {
      description: 'A list of the scenario identifiers that – when used to compile this unlocking script and the script it unlocks – result in a compilation error.\n\nThese scenarios can be used to test this script in development and review.',
      items: {
        type: 'string'
      },
      type: 'array'
    },
    name: {
      description: 'A single-line, human-readable name for this script (for use in user interfaces).',
      type: 'string'
    },
    passes: {
      description: 'A list of the scenario identifiers that – when used to compile this unlocking script and the script it unlocks – result in bytecode that passes program verification.\n\nThese scenarios can be used to test this script in development and review.',
      items: {
        type: 'string'
      },
      type: 'array'
    },
    script: {
      description: 'The script definition in CashAssembly.',
      type: 'string'
    },
    timeLockType: {
      description: "The expected type of time locks in this script.\n\nBecause `OP_CHECKLOCKTIMEVERIFY` reads from a transaction's `locktime` property, every input to a given transaction must share the same time lock type. This differs from `OP_CHECKSEQUENCEVERIFY` in that each input has its own `sequenceNumber`, so compatibility is not required.\n\nIf a transaction includes multiple inputs using scripts with `timeLockType` defined, and the types are not compatible, generation should fail.\n\nThe `timestamp` type indicates that the transaction's locktime is provided as a UNIX timestamp (the `locktime` value is greater than or equal to `500000000`).\n\nThe `height` type indicates that the transaction's locktime is provided as a block height (the `locktime` value is less than `500000000`).\n\nIf `timeLockType` is undefined, the script is assumed to have no reliance on absolute time locks.",
      enum: ['height', 'timestamp'],
      type: 'string'
    },
    unlocks: {
      description: 'The identifier of the script that can be unlocked by this script.\n\nThe presence of the `unlocks` property indicates that this script is an unlocking script, and the script it unlocks must be a locking script.',
      type: 'string'
    }
  },
  required: ['script', 'unlocks'],
  type: 'object'
};
var schema42 = {
  description: "Allowable identifiers for authentication virtual machine versions. The `BCH` prefix identifies the Bitcoin Cash network, the `XEC` prefix identifies the eCash network, the `BSV` prefix identifies the Bitcoin SV network, and the `BTC` prefix identifies the Bitcoin Core network. VM versions are named according to the date they were deployed on the indicated network.\n\nFor each network prefix, a `_SPEC` VM version is reserved to indicate that the template requires a custom, not-yet-deployed VM version (e.g. one or more CHIPs). By convention, templates marked for `_SPEC` VMs should indicate their requirements in the template description. After deployment of the `_SPEC` VM, when template compatibility is verified, the template's `supported` array should be updated to indicate compatibility with the live VM version.",
  enum: ['BCH_2020_05', 'BCH_2021_05', 'BCH_2022_05', 'BCH_2023_05', 'BCH_SPEC', 'BSV_2020_02', 'BSV_SPEC', 'BTC_2017_08', 'BTC_SPEC', 'XEC_2020_05', 'XEC_SPEC'],
  type: 'string'
};
function validate23(data) {
  var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
    _ref$instancePath = _ref.instancePath,
    instancePath = _ref$instancePath === void 0 ? '' : _ref$instancePath;
    _ref.parentData;
    _ref.parentDataProperty;
    _ref.rootData;
  var vErrors = null;
  var errors = 0;
  var _errs0 = errors;
  var valid0 = false;
  var _errs1 = errors;
  var _errs2 = errors;
  if (errors === _errs2) {
    if (data && _typeof(data) == 'object' && !Array.isArray(data)) {
      var missing0;
      if (data.type === undefined && (missing0 = 'type')) {
        var err0 = {
          instancePath: instancePath,
          schemaPath: '#/definitions/AuthenticationTemplateAddressData/required',
          keyword: 'required',
          params: {
            missingProperty: missing0
          },
          message: "must have required property '" + missing0 + "'"
        };
        if (vErrors === null) {
          vErrors = [err0];
        } else {
          vErrors.push(err0);
        }
        errors++;
      } else {
        var _errs4 = errors;
        for (var key0 in data) {
          if (!(key0 === 'description' || key0 === 'name' || key0 === 'type')) {
            var err1 = {
              instancePath: instancePath,
              schemaPath: '#/definitions/AuthenticationTemplateAddressData/additionalProperties',
              keyword: 'additionalProperties',
              params: {
                additionalProperty: key0
              },
              message: 'must NOT have additional properties'
            };
            if (vErrors === null) {
              vErrors = [err1];
            } else {
              vErrors.push(err1);
            }
            errors++;
            break;
          }
        }
        if (_errs4 === errors) {
          if (data.description !== undefined) {
            var _errs5 = errors;
            if (typeof data.description !== 'string') {
              var err2 = {
                instancePath: instancePath + '/description',
                schemaPath: '#/definitions/AuthenticationTemplateAddressData/properties/description/type',
                keyword: 'type',
                params: {
                  type: 'string'
                },
                message: 'must be string'
              };
              if (vErrors === null) {
                vErrors = [err2];
              } else {
                vErrors.push(err2);
              }
              errors++;
            }
            var valid2 = _errs5 === errors;
          } else {
            var valid2 = true;
          }
          if (valid2) {
            if (data.name !== undefined) {
              var _errs7 = errors;
              if (typeof data.name !== 'string') {
                var err3 = {
                  instancePath: instancePath + '/name',
                  schemaPath: '#/definitions/AuthenticationTemplateAddressData/properties/name/type',
                  keyword: 'type',
                  params: {
                    type: 'string'
                  },
                  message: 'must be string'
                };
                if (vErrors === null) {
                  vErrors = [err3];
                } else {
                  vErrors.push(err3);
                }
                errors++;
              }
              var valid2 = _errs7 === errors;
            } else {
              var valid2 = true;
            }
            if (valid2) {
              if (data.type !== undefined) {
                var data2 = data.type;
                var _errs9 = errors;
                if (typeof data2 !== 'string') {
                  var err4 = {
                    instancePath: instancePath + '/type',
                    schemaPath: '#/definitions/AuthenticationTemplateAddressData/properties/type/type',
                    keyword: 'type',
                    params: {
                      type: 'string'
                    },
                    message: 'must be string'
                  };
                  if (vErrors === null) {
                    vErrors = [err4];
                  } else {
                    vErrors.push(err4);
                  }
                  errors++;
                }
                if ('AddressData' !== data2) {
                  var err5 = {
                    instancePath: instancePath + '/type',
                    schemaPath: '#/definitions/AuthenticationTemplateAddressData/properties/type/const',
                    keyword: 'const',
                    params: {
                      allowedValue: 'AddressData'
                    },
                    message: 'must be equal to constant'
                  };
                  if (vErrors === null) {
                    vErrors = [err5];
                  } else {
                    vErrors.push(err5);
                  }
                  errors++;
                }
                var valid2 = _errs9 === errors;
              } else {
                var valid2 = true;
              }
            }
          }
        }
      }
    } else {
      var err6 = {
        instancePath: instancePath,
        schemaPath: '#/definitions/AuthenticationTemplateAddressData/type',
        keyword: 'type',
        params: {
          type: 'object'
        },
        message: 'must be object'
      };
      if (vErrors === null) {
        vErrors = [err6];
      } else {
        vErrors.push(err6);
      }
      errors++;
    }
  }
  var _valid0 = _errs1 === errors;
  valid0 = valid0 || _valid0;
  if (!valid0) {
    var _errs11 = errors;
    var _errs12 = errors;
    if (errors === _errs12) {
      if (data && _typeof(data) == 'object' && !Array.isArray(data)) {
        var missing1;
        if (data.type === undefined && (missing1 = 'type')) {
          var err7 = {
            instancePath: instancePath,
            schemaPath: '#/definitions/AuthenticationTemplateHdKey/required',
            keyword: 'required',
            params: {
              missingProperty: missing1
            },
            message: "must have required property '" + missing1 + "'"
          };
          if (vErrors === null) {
            vErrors = [err7];
          } else {
            vErrors.push(err7);
          }
          errors++;
        } else {
          var _errs14 = errors;
          for (var key1 in data) {
            if (!(key1 === 'addressOffset' || key1 === 'description' || key1 === 'hdPublicKeyDerivationPath' || key1 === 'name' || key1 === 'privateDerivationPath' || key1 === 'publicDerivationPath' || key1 === 'type')) {
              var err8 = {
                instancePath: instancePath,
                schemaPath: '#/definitions/AuthenticationTemplateHdKey/additionalProperties',
                keyword: 'additionalProperties',
                params: {
                  additionalProperty: key1
                },
                message: 'must NOT have additional properties'
              };
              if (vErrors === null) {
                vErrors = [err8];
              } else {
                vErrors.push(err8);
              }
              errors++;
              break;
            }
          }
          if (_errs14 === errors) {
            if (data.addressOffset !== undefined) {
              var data3 = data.addressOffset;
              var _errs15 = errors;
              if (!(typeof data3 == 'number' && isFinite(data3))) {
                var err9 = {
                  instancePath: instancePath + '/addressOffset',
                  schemaPath: '#/definitions/AuthenticationTemplateHdKey/properties/addressOffset/type',
                  keyword: 'type',
                  params: {
                    type: 'number'
                  },
                  message: 'must be number'
                };
                if (vErrors === null) {
                  vErrors = [err9];
                } else {
                  vErrors.push(err9);
                }
                errors++;
              }
              var valid4 = _errs15 === errors;
            } else {
              var valid4 = true;
            }
            if (valid4) {
              if (data.description !== undefined) {
                var _errs17 = errors;
                if (typeof data.description !== 'string') {
                  var err10 = {
                    instancePath: instancePath + '/description',
                    schemaPath: '#/definitions/AuthenticationTemplateHdKey/properties/description/type',
                    keyword: 'type',
                    params: {
                      type: 'string'
                    },
                    message: 'must be string'
                  };
                  if (vErrors === null) {
                    vErrors = [err10];
                  } else {
                    vErrors.push(err10);
                  }
                  errors++;
                }
                var valid4 = _errs17 === errors;
              } else {
                var valid4 = true;
              }
              if (valid4) {
                if (data.hdPublicKeyDerivationPath !== undefined) {
                  var _errs19 = errors;
                  if (typeof data.hdPublicKeyDerivationPath !== 'string') {
                    var err11 = {
                      instancePath: instancePath + '/hdPublicKeyDerivationPath',
                      schemaPath: '#/definitions/AuthenticationTemplateHdKey/properties/hdPublicKeyDerivationPath/type',
                      keyword: 'type',
                      params: {
                        type: 'string'
                      },
                      message: 'must be string'
                    };
                    if (vErrors === null) {
                      vErrors = [err11];
                    } else {
                      vErrors.push(err11);
                    }
                    errors++;
                  }
                  var valid4 = _errs19 === errors;
                } else {
                  var valid4 = true;
                }
                if (valid4) {
                  if (data.name !== undefined) {
                    var _errs21 = errors;
                    if (typeof data.name !== 'string') {
                      var err12 = {
                        instancePath: instancePath + '/name',
                        schemaPath: '#/definitions/AuthenticationTemplateHdKey/properties/name/type',
                        keyword: 'type',
                        params: {
                          type: 'string'
                        },
                        message: 'must be string'
                      };
                      if (vErrors === null) {
                        vErrors = [err12];
                      } else {
                        vErrors.push(err12);
                      }
                      errors++;
                    }
                    var valid4 = _errs21 === errors;
                  } else {
                    var valid4 = true;
                  }
                  if (valid4) {
                    if (data.privateDerivationPath !== undefined) {
                      var _errs23 = errors;
                      if (typeof data.privateDerivationPath !== 'string') {
                        var err13 = {
                          instancePath: instancePath + '/privateDerivationPath',
                          schemaPath: '#/definitions/AuthenticationTemplateHdKey/properties/privateDerivationPath/type',
                          keyword: 'type',
                          params: {
                            type: 'string'
                          },
                          message: 'must be string'
                        };
                        if (vErrors === null) {
                          vErrors = [err13];
                        } else {
                          vErrors.push(err13);
                        }
                        errors++;
                      }
                      var valid4 = _errs23 === errors;
                    } else {
                      var valid4 = true;
                    }
                    if (valid4) {
                      if (data.publicDerivationPath !== undefined) {
                        var _errs25 = errors;
                        if (typeof data.publicDerivationPath !== 'string') {
                          var err14 = {
                            instancePath: instancePath + '/publicDerivationPath',
                            schemaPath: '#/definitions/AuthenticationTemplateHdKey/properties/publicDerivationPath/type',
                            keyword: 'type',
                            params: {
                              type: 'string'
                            },
                            message: 'must be string'
                          };
                          if (vErrors === null) {
                            vErrors = [err14];
                          } else {
                            vErrors.push(err14);
                          }
                          errors++;
                        }
                        var valid4 = _errs25 === errors;
                      } else {
                        var valid4 = true;
                      }
                      if (valid4) {
                        if (data.type !== undefined) {
                          var data9 = data.type;
                          var _errs27 = errors;
                          if (typeof data9 !== 'string') {
                            var err15 = {
                              instancePath: instancePath + '/type',
                              schemaPath: '#/definitions/AuthenticationTemplateHdKey/properties/type/type',
                              keyword: 'type',
                              params: {
                                type: 'string'
                              },
                              message: 'must be string'
                            };
                            if (vErrors === null) {
                              vErrors = [err15];
                            } else {
                              vErrors.push(err15);
                            }
                            errors++;
                          }
                          if ('HdKey' !== data9) {
                            var err16 = {
                              instancePath: instancePath + '/type',
                              schemaPath: '#/definitions/AuthenticationTemplateHdKey/properties/type/const',
                              keyword: 'const',
                              params: {
                                allowedValue: 'HdKey'
                              },
                              message: 'must be equal to constant'
                            };
                            if (vErrors === null) {
                              vErrors = [err16];
                            } else {
                              vErrors.push(err16);
                            }
                            errors++;
                          }
                          var valid4 = _errs27 === errors;
                        } else {
                          var valid4 = true;
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      } else {
        var err17 = {
          instancePath: instancePath,
          schemaPath: '#/definitions/AuthenticationTemplateHdKey/type',
          keyword: 'type',
          params: {
            type: 'object'
          },
          message: 'must be object'
        };
        if (vErrors === null) {
          vErrors = [err17];
        } else {
          vErrors.push(err17);
        }
        errors++;
      }
    }
    var _valid0 = _errs11 === errors;
    valid0 = valid0 || _valid0;
    if (!valid0) {
      var _errs29 = errors;
      var _errs30 = errors;
      if (errors === _errs30) {
        if (data && _typeof(data) == 'object' && !Array.isArray(data)) {
          var missing2;
          if (data.type === undefined && (missing2 = 'type')) {
            var err18 = {
              instancePath: instancePath,
              schemaPath: '#/definitions/AuthenticationTemplateKey/required',
              keyword: 'required',
              params: {
                missingProperty: missing2
              },
              message: "must have required property '" + missing2 + "'"
            };
            if (vErrors === null) {
              vErrors = [err18];
            } else {
              vErrors.push(err18);
            }
            errors++;
          } else {
            var _errs32 = errors;
            for (var key2 in data) {
              if (!(key2 === 'description' || key2 === 'name' || key2 === 'type')) {
                var err19 = {
                  instancePath: instancePath,
                  schemaPath: '#/definitions/AuthenticationTemplateKey/additionalProperties',
                  keyword: 'additionalProperties',
                  params: {
                    additionalProperty: key2
                  },
                  message: 'must NOT have additional properties'
                };
                if (vErrors === null) {
                  vErrors = [err19];
                } else {
                  vErrors.push(err19);
                }
                errors++;
                break;
              }
            }
            if (_errs32 === errors) {
              if (data.description !== undefined) {
                var _errs33 = errors;
                if (typeof data.description !== 'string') {
                  var err20 = {
                    instancePath: instancePath + '/description',
                    schemaPath: '#/definitions/AuthenticationTemplateKey/properties/description/type',
                    keyword: 'type',
                    params: {
                      type: 'string'
                    },
                    message: 'must be string'
                  };
                  if (vErrors === null) {
                    vErrors = [err20];
                  } else {
                    vErrors.push(err20);
                  }
                  errors++;
                }
                var valid6 = _errs33 === errors;
              } else {
                var valid6 = true;
              }
              if (valid6) {
                if (data.name !== undefined) {
                  var _errs35 = errors;
                  if (typeof data.name !== 'string') {
                    var err21 = {
                      instancePath: instancePath + '/name',
                      schemaPath: '#/definitions/AuthenticationTemplateKey/properties/name/type',
                      keyword: 'type',
                      params: {
                        type: 'string'
                      },
                      message: 'must be string'
                    };
                    if (vErrors === null) {
                      vErrors = [err21];
                    } else {
                      vErrors.push(err21);
                    }
                    errors++;
                  }
                  var valid6 = _errs35 === errors;
                } else {
                  var valid6 = true;
                }
                if (valid6) {
                  if (data.type !== undefined) {
                    var data12 = data.type;
                    var _errs37 = errors;
                    if (typeof data12 !== 'string') {
                      var err22 = {
                        instancePath: instancePath + '/type',
                        schemaPath: '#/definitions/AuthenticationTemplateKey/properties/type/type',
                        keyword: 'type',
                        params: {
                          type: 'string'
                        },
                        message: 'must be string'
                      };
                      if (vErrors === null) {
                        vErrors = [err22];
                      } else {
                        vErrors.push(err22);
                      }
                      errors++;
                    }
                    if ('Key' !== data12) {
                      var err23 = {
                        instancePath: instancePath + '/type',
                        schemaPath: '#/definitions/AuthenticationTemplateKey/properties/type/const',
                        keyword: 'const',
                        params: {
                          allowedValue: 'Key'
                        },
                        message: 'must be equal to constant'
                      };
                      if (vErrors === null) {
                        vErrors = [err23];
                      } else {
                        vErrors.push(err23);
                      }
                      errors++;
                    }
                    var valid6 = _errs37 === errors;
                  } else {
                    var valid6 = true;
                  }
                }
              }
            }
          }
        } else {
          var err24 = {
            instancePath: instancePath,
            schemaPath: '#/definitions/AuthenticationTemplateKey/type',
            keyword: 'type',
            params: {
              type: 'object'
            },
            message: 'must be object'
          };
          if (vErrors === null) {
            vErrors = [err24];
          } else {
            vErrors.push(err24);
          }
          errors++;
        }
      }
      var _valid0 = _errs29 === errors;
      valid0 = valid0 || _valid0;
      if (!valid0) {
        var _errs39 = errors;
        var _errs40 = errors;
        if (errors === _errs40) {
          if (data && _typeof(data) == 'object' && !Array.isArray(data)) {
            var missing3;
            if (data.type === undefined && (missing3 = 'type')) {
              var err25 = {
                instancePath: instancePath,
                schemaPath: '#/definitions/AuthenticationTemplateWalletData/required',
                keyword: 'required',
                params: {
                  missingProperty: missing3
                },
                message: "must have required property '" + missing3 + "'"
              };
              if (vErrors === null) {
                vErrors = [err25];
              } else {
                vErrors.push(err25);
              }
              errors++;
            } else {
              var _errs42 = errors;
              for (var key3 in data) {
                if (!(key3 === 'description' || key3 === 'name' || key3 === 'type')) {
                  var err26 = {
                    instancePath: instancePath,
                    schemaPath: '#/definitions/AuthenticationTemplateWalletData/additionalProperties',
                    keyword: 'additionalProperties',
                    params: {
                      additionalProperty: key3
                    },
                    message: 'must NOT have additional properties'
                  };
                  if (vErrors === null) {
                    vErrors = [err26];
                  } else {
                    vErrors.push(err26);
                  }
                  errors++;
                  break;
                }
              }
              if (_errs42 === errors) {
                if (data.description !== undefined) {
                  var _errs43 = errors;
                  if (typeof data.description !== 'string') {
                    var err27 = {
                      instancePath: instancePath + '/description',
                      schemaPath: '#/definitions/AuthenticationTemplateWalletData/properties/description/type',
                      keyword: 'type',
                      params: {
                        type: 'string'
                      },
                      message: 'must be string'
                    };
                    if (vErrors === null) {
                      vErrors = [err27];
                    } else {
                      vErrors.push(err27);
                    }
                    errors++;
                  }
                  var valid8 = _errs43 === errors;
                } else {
                  var valid8 = true;
                }
                if (valid8) {
                  if (data.name !== undefined) {
                    var _errs45 = errors;
                    if (typeof data.name !== 'string') {
                      var err28 = {
                        instancePath: instancePath + '/name',
                        schemaPath: '#/definitions/AuthenticationTemplateWalletData/properties/name/type',
                        keyword: 'type',
                        params: {
                          type: 'string'
                        },
                        message: 'must be string'
                      };
                      if (vErrors === null) {
                        vErrors = [err28];
                      } else {
                        vErrors.push(err28);
                      }
                      errors++;
                    }
                    var valid8 = _errs45 === errors;
                  } else {
                    var valid8 = true;
                  }
                  if (valid8) {
                    if (data.type !== undefined) {
                      var data15 = data.type;
                      var _errs47 = errors;
                      if (typeof data15 !== 'string') {
                        var err29 = {
                          instancePath: instancePath + '/type',
                          schemaPath: '#/definitions/AuthenticationTemplateWalletData/properties/type/type',
                          keyword: 'type',
                          params: {
                            type: 'string'
                          },
                          message: 'must be string'
                        };
                        if (vErrors === null) {
                          vErrors = [err29];
                        } else {
                          vErrors.push(err29);
                        }
                        errors++;
                      }
                      if ('WalletData' !== data15) {
                        var err30 = {
                          instancePath: instancePath + '/type',
                          schemaPath: '#/definitions/AuthenticationTemplateWalletData/properties/type/const',
                          keyword: 'const',
                          params: {
                            allowedValue: 'WalletData'
                          },
                          message: 'must be equal to constant'
                        };
                        if (vErrors === null) {
                          vErrors = [err30];
                        } else {
                          vErrors.push(err30);
                        }
                        errors++;
                      }
                      var valid8 = _errs47 === errors;
                    } else {
                      var valid8 = true;
                    }
                  }
                }
              }
            }
          } else {
            var err31 = {
              instancePath: instancePath,
              schemaPath: '#/definitions/AuthenticationTemplateWalletData/type',
              keyword: 'type',
              params: {
                type: 'object'
              },
              message: 'must be object'
            };
            if (vErrors === null) {
              vErrors = [err31];
            } else {
              vErrors.push(err31);
            }
            errors++;
          }
        }
        var _valid0 = _errs39 === errors;
        valid0 = valid0 || _valid0;
      }
    }
  }
  if (!valid0) {
    var err32 = {
      instancePath: instancePath,
      schemaPath: '#/anyOf',
      keyword: 'anyOf',
      params: {},
      message: 'must match a schema in anyOf'
    };
    if (vErrors === null) {
      vErrors = [err32];
    } else {
      vErrors.push(err32);
    }
    errors++;
    validate23.errors = vErrors;
    return false;
  } else {
    errors = _errs0;
    if (vErrors !== null) {
      if (_errs0) {
        vErrors.length = _errs0;
      } else {
        vErrors = null;
      }
    }
  }
  validate23.errors = vErrors;
  return errors === 0;
}
function validate22(data) {
  var _ref2 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
    _ref2$instancePath = _ref2.instancePath,
    instancePath = _ref2$instancePath === void 0 ? '' : _ref2$instancePath;
    _ref2.parentData;
    _ref2.parentDataProperty;
    var _ref2$rootData = _ref2.rootData,
    rootData = _ref2$rootData === void 0 ? data : _ref2$rootData;
  var vErrors = null;
  var errors = 0;
  if (errors === 0) {
    if (data && _typeof(data) == 'object' && !Array.isArray(data)) {
      var _errs1 = errors;
      for (var key0 in data) {
        if (!(key0 === 'description' || key0 === 'name' || key0 === 'scripts' || key0 === 'variables')) {
          validate22.errors = [{
            instancePath: instancePath,
            schemaPath: '#/additionalProperties',
            keyword: 'additionalProperties',
            params: {
              additionalProperty: key0
            },
            message: 'must NOT have additional properties'
          }];
          return false;
        }
      }
      if (_errs1 === errors) {
        if (data.description !== undefined) {
          var _errs2 = errors;
          if (typeof data.description !== 'string') {
            validate22.errors = [{
              instancePath: instancePath + '/description',
              schemaPath: '#/properties/description/type',
              keyword: 'type',
              params: {
                type: 'string'
              },
              message: 'must be string'
            }];
            return false;
          }
          var valid0 = _errs2 === errors;
        } else {
          var valid0 = true;
        }
        if (valid0) {
          if (data.name !== undefined) {
            var _errs4 = errors;
            if (typeof data.name !== 'string') {
              validate22.errors = [{
                instancePath: instancePath + '/name',
                schemaPath: '#/properties/name/type',
                keyword: 'type',
                params: {
                  type: 'string'
                },
                message: 'must be string'
              }];
              return false;
            }
            var valid0 = _errs4 === errors;
          } else {
            var valid0 = true;
          }
          if (valid0) {
            if (data.scripts !== undefined) {
              var data2 = data.scripts;
              var _errs6 = errors;
              if (errors === _errs6) {
                if (Array.isArray(data2)) {
                  var valid1 = true;
                  var len0 = data2.length;
                  for (var i0 = 0; i0 < len0; i0++) {
                    var _errs8 = errors;
                    if (typeof data2[i0] !== 'string') {
                      validate22.errors = [{
                        instancePath: instancePath + '/scripts/' + i0,
                        schemaPath: '#/properties/scripts/items/type',
                        keyword: 'type',
                        params: {
                          type: 'string'
                        },
                        message: 'must be string'
                      }];
                      return false;
                    }
                    var valid1 = _errs8 === errors;
                    if (!valid1) {
                      break;
                    }
                  }
                } else {
                  validate22.errors = [{
                    instancePath: instancePath + '/scripts',
                    schemaPath: '#/properties/scripts/type',
                    keyword: 'type',
                    params: {
                      type: 'array'
                    },
                    message: 'must be array'
                  }];
                  return false;
                }
              }
              var valid0 = _errs6 === errors;
            } else {
              var valid0 = true;
            }
            if (valid0) {
              if (data.variables !== undefined) {
                var data4 = data.variables;
                var _errs10 = errors;
                if (errors === _errs10) {
                  if (data4 && _typeof(data4) == 'object' && !Array.isArray(data4)) {
                    for (var key1 in data4) {
                      var _errs13 = errors;
                      if (!validate23(data4[key1], {
                        instancePath: instancePath + '/variables/' + key1.replace(/~/g, '~0').replace(/\//g, '~1'),
                        parentData: data4,
                        parentDataProperty: key1,
                        rootData: rootData
                      })) {
                        vErrors = vErrors === null ? validate23.errors : vErrors.concat(validate23.errors);
                        errors = vErrors.length;
                      }
                      var valid2 = _errs13 === errors;
                      if (!valid2) {
                        break;
                      }
                    }
                  } else {
                    validate22.errors = [{
                      instancePath: instancePath + '/variables',
                      schemaPath: '#/properties/variables/type',
                      keyword: 'type',
                      params: {
                        type: 'object'
                      },
                      message: 'must be object'
                    }];
                    return false;
                  }
                }
                var valid0 = _errs10 === errors;
              } else {
                var valid0 = true;
              }
            }
          }
        }
      }
    } else {
      validate22.errors = [{
        instancePath: instancePath,
        schemaPath: '#/type',
        keyword: 'type',
        params: {
          type: 'object'
        },
        message: 'must be object'
      }];
      return false;
    }
  }
  validate22.errors = vErrors;
  return errors === 0;
}
var schema32 = {
  additionalProperties: false,
  description: 'An example output used to define a scenario for an authentication template.',
  properties: {
    lockingBytecode: {
      anyOf: [{
        $ref: '#/definitions/AuthenticationTemplateScenarioBytecode'
      }, {
        items: {
          const: 'slot',
          type: 'string'
        },
        maxItems: 1,
        minItems: 1,
        type: 'array'
      }],
      description: 'The locking bytecode used to encumber this output.\n\n`lockingBytecode` values may be provided as a hexadecimal-encoded string or as an object describing the required compilation. If undefined, defaults to  `{}`, which uses the default values for `script` and `overrides`, respectively.\n\nOnly source outputs may specify a `lockingBytecode` of `["slot"]`; this identifies the source output in which the locking script under test will be placed. (To be valid, every scenario\'s `sourceOutputs` property must have exactly one source output slot and one input slot at the same index.)'
    },
    token: {
      additionalProperties: false,
      description: 'The CashToken contents of this output. This property is only defined if the output contains one or more tokens. For details, see `CHIP-2022-02-CashTokens`.',
      properties: {
        amount: {
          description: 'The number of fungible tokens (of `category`) held in this output.\n\nBecause `Number.MAX_SAFE_INTEGER` (`9007199254740991`) is less than the maximum token amount (`9223372036854775807`), this value may also be provided as a string, e.g. `"9223372036854775807"`.\n\nIf undefined, this defaults to: `0`.',
          type: ['number', 'string']
        },
        category: {
          description: 'The 32-byte, hexadecimal-encoded token category ID to which the token(s) in this output belong in big-endian byte order. This is the byte order typically seen in block explorers and user interfaces (as opposed to little-endian byte order, which is used in standard P2P network messages).\n\nIf undefined, this defaults to the value: `0000000000000000000000000000000000000000000000000000000000000002`',
          type: 'string'
        },
        nft: {
          additionalProperties: false,
          description: 'If present, the non-fungible token (NFT) held by this output. If the output does not include a non-fungible token, `undefined`.',
          properties: {
            capability: {
              description: 'The capability of this non-fungible token, must be either `minting`, `mutable`, or `none`.\n\nIf undefined, this defaults to: `none`.',
              enum: ['minting', 'mutable', 'none'],
              type: 'string'
            },
            commitment: {
              description: 'The hex-encoded commitment contents included in the non-fungible token held in this output.\n\nIf undefined, this defaults to: `""` (a zero-length commitment).',
              type: 'string'
            }
          },
          type: 'object'
        }
      },
      type: 'object'
    },
    valueSatoshis: {
      description: 'The value of the output in satoshis, the smallest unit of bitcoin.\n\nIn a valid transaction, this is a positive integer, from `0` to the maximum number of satoshis available to the transaction.\n\nThe maximum number of satoshis in existence is about 1/4 of `Number.MAX_SAFE_INTEGER` (`9007199254740991`), so typically, this value is defined using a `number`. However, this value may also be defined using a 16-character, hexadecimal-encoded `string`, to allow for the full range of the 64-bit unsigned, little-endian integer used to encode `valueSatoshis` in the encoded output format, e.g. `"ffffffffffffffff"`. This is useful for representing scenarios where intentionally excessive values are provided (to ensure an otherwise properly-signed transaction can never be included in the blockchain), e.g. transaction size estimations or off-chain Bitauth signatures.\n\nIf undefined, this defaults to: `0`.',
      type: ['number', 'string']
    }
  },
  type: 'object'
};
function validate28(data) {
  var _ref3 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
    _ref3$instancePath = _ref3.instancePath,
    instancePath = _ref3$instancePath === void 0 ? '' : _ref3$instancePath;
    _ref3.parentData;
    _ref3.parentDataProperty;
    _ref3.rootData;
  var vErrors = null;
  var errors = 0;
  var _errs0 = errors;
  var valid0 = false;
  var _errs1 = errors;
  if (typeof data !== 'string') {
    var err0 = {
      instancePath: instancePath,
      schemaPath: '#/anyOf/0/type',
      keyword: 'type',
      params: {
        type: 'string'
      },
      message: 'must be string'
    };
    if (vErrors === null) {
      vErrors = [err0];
    } else {
      vErrors.push(err0);
    }
    errors++;
  }
  var _valid0 = _errs1 === errors;
  valid0 = valid0 || _valid0;
  if (!valid0) {
    var _errs3 = errors;
    if (errors === _errs3) {
      if (data && _typeof(data) == 'object' && !Array.isArray(data)) {
        var _errs5 = errors;
        for (var key0 in data) {
          if (!(key0 === 'overrides' || key0 === 'script')) {
            var err1 = {
              instancePath: instancePath,
              schemaPath: '#/anyOf/1/additionalProperties',
              keyword: 'additionalProperties',
              params: {
                additionalProperty: key0
              },
              message: 'must NOT have additional properties'
            };
            if (vErrors === null) {
              vErrors = [err1];
            } else {
              vErrors.push(err1);
            }
            errors++;
            break;
          }
        }
        if (_errs5 === errors) {
          if (data.overrides !== undefined) {
            var data0 = data.overrides;
            var _errs6 = errors;
            var _errs7 = errors;
            if (errors === _errs7) {
              if (data0 && _typeof(data0) == 'object' && !Array.isArray(data0)) {
                var _errs9 = errors;
                for (var key1 in data0) {
                  if (!(key1 === 'bytecode' || key1 === 'currentBlockHeight' || key1 === 'currentBlockTime' || key1 === 'hdKeys' || key1 === 'keys')) {
                    var err2 = {
                      instancePath: instancePath + '/overrides',
                      schemaPath: '#/definitions/AuthenticationTemplateScenarioData/additionalProperties',
                      keyword: 'additionalProperties',
                      params: {
                        additionalProperty: key1
                      },
                      message: 'must NOT have additional properties'
                    };
                    if (vErrors === null) {
                      vErrors = [err2];
                    } else {
                      vErrors.push(err2);
                    }
                    errors++;
                    break;
                  }
                }
                if (_errs9 === errors) {
                  if (data0.bytecode !== undefined) {
                    var data1 = data0.bytecode;
                    var _errs10 = errors;
                    if (errors === _errs10) {
                      if (data1 && _typeof(data1) == 'object' && !Array.isArray(data1)) {
                        for (var key2 in data1) {
                          var _errs13 = errors;
                          if (typeof data1[key2] !== 'string') {
                            var err3 = {
                              instancePath: instancePath + '/overrides/bytecode/' + key2.replace(/~/g, '~0').replace(/\//g, '~1'),
                              schemaPath: '#/definitions/AuthenticationTemplateScenarioData/properties/bytecode/additionalProperties/type',
                              keyword: 'type',
                              params: {
                                type: 'string'
                              },
                              message: 'must be string'
                            };
                            if (vErrors === null) {
                              vErrors = [err3];
                            } else {
                              vErrors.push(err3);
                            }
                            errors++;
                          }
                          var valid4 = _errs13 === errors;
                          if (!valid4) {
                            break;
                          }
                        }
                      } else {
                        var err4 = {
                          instancePath: instancePath + '/overrides/bytecode',
                          schemaPath: '#/definitions/AuthenticationTemplateScenarioData/properties/bytecode/type',
                          keyword: 'type',
                          params: {
                            type: 'object'
                          },
                          message: 'must be object'
                        };
                        if (vErrors === null) {
                          vErrors = [err4];
                        } else {
                          vErrors.push(err4);
                        }
                        errors++;
                      }
                    }
                    var valid3 = _errs10 === errors;
                  } else {
                    var valid3 = true;
                  }
                  if (valid3) {
                    if (data0.currentBlockHeight !== undefined) {
                      var data3 = data0.currentBlockHeight;
                      var _errs15 = errors;
                      if (!(typeof data3 == 'number' && isFinite(data3))) {
                        var err5 = {
                          instancePath: instancePath + '/overrides/currentBlockHeight',
                          schemaPath: '#/definitions/AuthenticationTemplateScenarioData/properties/currentBlockHeight/type',
                          keyword: 'type',
                          params: {
                            type: 'number'
                          },
                          message: 'must be number'
                        };
                        if (vErrors === null) {
                          vErrors = [err5];
                        } else {
                          vErrors.push(err5);
                        }
                        errors++;
                      }
                      var valid3 = _errs15 === errors;
                    } else {
                      var valid3 = true;
                    }
                    if (valid3) {
                      if (data0.currentBlockTime !== undefined) {
                        var data4 = data0.currentBlockTime;
                        var _errs17 = errors;
                        if (!(typeof data4 == 'number' && isFinite(data4))) {
                          var err6 = {
                            instancePath: instancePath + '/overrides/currentBlockTime',
                            schemaPath: '#/definitions/AuthenticationTemplateScenarioData/properties/currentBlockTime/type',
                            keyword: 'type',
                            params: {
                              type: 'number'
                            },
                            message: 'must be number'
                          };
                          if (vErrors === null) {
                            vErrors = [err6];
                          } else {
                            vErrors.push(err6);
                          }
                          errors++;
                        }
                        var valid3 = _errs17 === errors;
                      } else {
                        var valid3 = true;
                      }
                      if (valid3) {
                        if (data0.hdKeys !== undefined) {
                          var data5 = data0.hdKeys;
                          var _errs19 = errors;
                          if (errors === _errs19) {
                            if (data5 && _typeof(data5) == 'object' && !Array.isArray(data5)) {
                              var _errs21 = errors;
                              for (var key3 in data5) {
                                if (!(key3 === 'addressIndex' || key3 === 'hdPrivateKeys' || key3 === 'hdPublicKeys')) {
                                  var err7 = {
                                    instancePath: instancePath + '/overrides/hdKeys',
                                    schemaPath: '#/definitions/AuthenticationTemplateScenarioData/properties/hdKeys/additionalProperties',
                                    keyword: 'additionalProperties',
                                    params: {
                                      additionalProperty: key3
                                    },
                                    message: 'must NOT have additional properties'
                                  };
                                  if (vErrors === null) {
                                    vErrors = [err7];
                                  } else {
                                    vErrors.push(err7);
                                  }
                                  errors++;
                                  break;
                                }
                              }
                              if (_errs21 === errors) {
                                if (data5.addressIndex !== undefined) {
                                  var data6 = data5.addressIndex;
                                  var _errs22 = errors;
                                  if (!(typeof data6 == 'number' && isFinite(data6))) {
                                    var err8 = {
                                      instancePath: instancePath + '/overrides/hdKeys/addressIndex',
                                      schemaPath: '#/definitions/AuthenticationTemplateScenarioData/properties/hdKeys/properties/addressIndex/type',
                                      keyword: 'type',
                                      params: {
                                        type: 'number'
                                      },
                                      message: 'must be number'
                                    };
                                    if (vErrors === null) {
                                      vErrors = [err8];
                                    } else {
                                      vErrors.push(err8);
                                    }
                                    errors++;
                                  }
                                  var valid5 = _errs22 === errors;
                                } else {
                                  var valid5 = true;
                                }
                                if (valid5) {
                                  if (data5.hdPrivateKeys !== undefined) {
                                    var data7 = data5.hdPrivateKeys;
                                    var _errs24 = errors;
                                    if (errors === _errs24) {
                                      if (data7 && _typeof(data7) == 'object' && !Array.isArray(data7)) {
                                        for (var key4 in data7) {
                                          var _errs27 = errors;
                                          if (typeof data7[key4] !== 'string') {
                                            var err9 = {
                                              instancePath: instancePath + '/overrides/hdKeys/hdPrivateKeys/' + key4.replace(/~/g, '~0').replace(/\//g, '~1'),
                                              schemaPath: '#/definitions/AuthenticationTemplateScenarioData/properties/hdKeys/properties/hdPrivateKeys/additionalProperties/type',
                                              keyword: 'type',
                                              params: {
                                                type: 'string'
                                              },
                                              message: 'must be string'
                                            };
                                            if (vErrors === null) {
                                              vErrors = [err9];
                                            } else {
                                              vErrors.push(err9);
                                            }
                                            errors++;
                                          }
                                          var valid6 = _errs27 === errors;
                                          if (!valid6) {
                                            break;
                                          }
                                        }
                                      } else {
                                        var err10 = {
                                          instancePath: instancePath + '/overrides/hdKeys/hdPrivateKeys',
                                          schemaPath: '#/definitions/AuthenticationTemplateScenarioData/properties/hdKeys/properties/hdPrivateKeys/type',
                                          keyword: 'type',
                                          params: {
                                            type: 'object'
                                          },
                                          message: 'must be object'
                                        };
                                        if (vErrors === null) {
                                          vErrors = [err10];
                                        } else {
                                          vErrors.push(err10);
                                        }
                                        errors++;
                                      }
                                    }
                                    var valid5 = _errs24 === errors;
                                  } else {
                                    var valid5 = true;
                                  }
                                  if (valid5) {
                                    if (data5.hdPublicKeys !== undefined) {
                                      var data9 = data5.hdPublicKeys;
                                      var _errs29 = errors;
                                      if (errors === _errs29) {
                                        if (data9 && _typeof(data9) == 'object' && !Array.isArray(data9)) {
                                          for (var key5 in data9) {
                                            var _errs32 = errors;
                                            if (typeof data9[key5] !== 'string') {
                                              var err11 = {
                                                instancePath: instancePath + '/overrides/hdKeys/hdPublicKeys/' + key5.replace(/~/g, '~0').replace(/\//g, '~1'),
                                                schemaPath: '#/definitions/AuthenticationTemplateScenarioData/properties/hdKeys/properties/hdPublicKeys/additionalProperties/type',
                                                keyword: 'type',
                                                params: {
                                                  type: 'string'
                                                },
                                                message: 'must be string'
                                              };
                                              if (vErrors === null) {
                                                vErrors = [err11];
                                              } else {
                                                vErrors.push(err11);
                                              }
                                              errors++;
                                            }
                                            var valid7 = _errs32 === errors;
                                            if (!valid7) {
                                              break;
                                            }
                                          }
                                        } else {
                                          var err12 = {
                                            instancePath: instancePath + '/overrides/hdKeys/hdPublicKeys',
                                            schemaPath: '#/definitions/AuthenticationTemplateScenarioData/properties/hdKeys/properties/hdPublicKeys/type',
                                            keyword: 'type',
                                            params: {
                                              type: 'object'
                                            },
                                            message: 'must be object'
                                          };
                                          if (vErrors === null) {
                                            vErrors = [err12];
                                          } else {
                                            vErrors.push(err12);
                                          }
                                          errors++;
                                        }
                                      }
                                      var valid5 = _errs29 === errors;
                                    } else {
                                      var valid5 = true;
                                    }
                                  }
                                }
                              }
                            } else {
                              var err13 = {
                                instancePath: instancePath + '/overrides/hdKeys',
                                schemaPath: '#/definitions/AuthenticationTemplateScenarioData/properties/hdKeys/type',
                                keyword: 'type',
                                params: {
                                  type: 'object'
                                },
                                message: 'must be object'
                              };
                              if (vErrors === null) {
                                vErrors = [err13];
                              } else {
                                vErrors.push(err13);
                              }
                              errors++;
                            }
                          }
                          var valid3 = _errs19 === errors;
                        } else {
                          var valid3 = true;
                        }
                        if (valid3) {
                          if (data0.keys !== undefined) {
                            var data11 = data0.keys;
                            var _errs34 = errors;
                            if (errors === _errs34) {
                              if (data11 && _typeof(data11) == 'object' && !Array.isArray(data11)) {
                                var _errs36 = errors;
                                for (var key6 in data11) {
                                  if (!(key6 === 'privateKeys')) {
                                    var err14 = {
                                      instancePath: instancePath + '/overrides/keys',
                                      schemaPath: '#/definitions/AuthenticationTemplateScenarioData/properties/keys/additionalProperties',
                                      keyword: 'additionalProperties',
                                      params: {
                                        additionalProperty: key6
                                      },
                                      message: 'must NOT have additional properties'
                                    };
                                    if (vErrors === null) {
                                      vErrors = [err14];
                                    } else {
                                      vErrors.push(err14);
                                    }
                                    errors++;
                                    break;
                                  }
                                }
                                if (_errs36 === errors) {
                                  if (data11.privateKeys !== undefined) {
                                    var data12 = data11.privateKeys;
                                    var _errs37 = errors;
                                    if (errors === _errs37) {
                                      if (data12 && _typeof(data12) == 'object' && !Array.isArray(data12)) {
                                        for (var key7 in data12) {
                                          var _errs40 = errors;
                                          if (typeof data12[key7] !== 'string') {
                                            var err15 = {
                                              instancePath: instancePath + '/overrides/keys/privateKeys/' + key7.replace(/~/g, '~0').replace(/\//g, '~1'),
                                              schemaPath: '#/definitions/AuthenticationTemplateScenarioData/properties/keys/properties/privateKeys/additionalProperties/type',
                                              keyword: 'type',
                                              params: {
                                                type: 'string'
                                              },
                                              message: 'must be string'
                                            };
                                            if (vErrors === null) {
                                              vErrors = [err15];
                                            } else {
                                              vErrors.push(err15);
                                            }
                                            errors++;
                                          }
                                          var valid9 = _errs40 === errors;
                                          if (!valid9) {
                                            break;
                                          }
                                        }
                                      } else {
                                        var err16 = {
                                          instancePath: instancePath + '/overrides/keys/privateKeys',
                                          schemaPath: '#/definitions/AuthenticationTemplateScenarioData/properties/keys/properties/privateKeys/type',
                                          keyword: 'type',
                                          params: {
                                            type: 'object'
                                          },
                                          message: 'must be object'
                                        };
                                        if (vErrors === null) {
                                          vErrors = [err16];
                                        } else {
                                          vErrors.push(err16);
                                        }
                                        errors++;
                                      }
                                    }
                                  }
                                }
                              } else {
                                var err17 = {
                                  instancePath: instancePath + '/overrides/keys',
                                  schemaPath: '#/definitions/AuthenticationTemplateScenarioData/properties/keys/type',
                                  keyword: 'type',
                                  params: {
                                    type: 'object'
                                  },
                                  message: 'must be object'
                                };
                                if (vErrors === null) {
                                  vErrors = [err17];
                                } else {
                                  vErrors.push(err17);
                                }
                                errors++;
                              }
                            }
                            var valid3 = _errs34 === errors;
                          } else {
                            var valid3 = true;
                          }
                        }
                      }
                    }
                  }
                }
              } else {
                var err18 = {
                  instancePath: instancePath + '/overrides',
                  schemaPath: '#/definitions/AuthenticationTemplateScenarioData/type',
                  keyword: 'type',
                  params: {
                    type: 'object'
                  },
                  message: 'must be object'
                };
                if (vErrors === null) {
                  vErrors = [err18];
                } else {
                  vErrors.push(err18);
                }
                errors++;
              }
            }
            var valid1 = _errs6 === errors;
          } else {
            var valid1 = true;
          }
          if (valid1) {
            if (data.script !== undefined) {
              var data14 = data.script;
              var _errs42 = errors;
              var _errs43 = errors;
              var valid10 = false;
              var _errs44 = errors;
              if (typeof data14 !== 'string') {
                var err19 = {
                  instancePath: instancePath + '/script',
                  schemaPath: '#/anyOf/1/properties/script/anyOf/0/type',
                  keyword: 'type',
                  params: {
                    type: 'string'
                  },
                  message: 'must be string'
                };
                if (vErrors === null) {
                  vErrors = [err19];
                } else {
                  vErrors.push(err19);
                }
                errors++;
              }
              var _valid1 = _errs44 === errors;
              valid10 = valid10 || _valid1;
              if (!valid10) {
                var _errs46 = errors;
                if (errors === _errs46) {
                  if (Array.isArray(data14)) {
                    if (data14.length > 1) {
                      var err20 = {
                        instancePath: instancePath + '/script',
                        schemaPath: '#/anyOf/1/properties/script/anyOf/1/maxItems',
                        keyword: 'maxItems',
                        params: {
                          limit: 1
                        },
                        message: 'must NOT have more than 1 items'
                      };
                      if (vErrors === null) {
                        vErrors = [err20];
                      } else {
                        vErrors.push(err20);
                      }
                      errors++;
                    } else {
                      if (data14.length < 1) {
                        var err21 = {
                          instancePath: instancePath + '/script',
                          schemaPath: '#/anyOf/1/properties/script/anyOf/1/minItems',
                          keyword: 'minItems',
                          params: {
                            limit: 1
                          },
                          message: 'must NOT have fewer than 1 items'
                        };
                        if (vErrors === null) {
                          vErrors = [err21];
                        } else {
                          vErrors.push(err21);
                        }
                        errors++;
                      } else {
                        var valid11 = true;
                        var len0 = data14.length;
                        for (var i0 = 0; i0 < len0; i0++) {
                          var data15 = data14[i0];
                          var _errs48 = errors;
                          if (typeof data15 !== 'string') {
                            var err22 = {
                              instancePath: instancePath + '/script/' + i0,
                              schemaPath: '#/anyOf/1/properties/script/anyOf/1/items/type',
                              keyword: 'type',
                              params: {
                                type: 'string'
                              },
                              message: 'must be string'
                            };
                            if (vErrors === null) {
                              vErrors = [err22];
                            } else {
                              vErrors.push(err22);
                            }
                            errors++;
                          }
                          if ('copy' !== data15) {
                            var err23 = {
                              instancePath: instancePath + '/script/' + i0,
                              schemaPath: '#/anyOf/1/properties/script/anyOf/1/items/const',
                              keyword: 'const',
                              params: {
                                allowedValue: 'copy'
                              },
                              message: 'must be equal to constant'
                            };
                            if (vErrors === null) {
                              vErrors = [err23];
                            } else {
                              vErrors.push(err23);
                            }
                            errors++;
                          }
                          var valid11 = _errs48 === errors;
                          if (!valid11) {
                            break;
                          }
                        }
                      }
                    }
                  } else {
                    var err24 = {
                      instancePath: instancePath + '/script',
                      schemaPath: '#/anyOf/1/properties/script/anyOf/1/type',
                      keyword: 'type',
                      params: {
                        type: 'array'
                      },
                      message: 'must be array'
                    };
                    if (vErrors === null) {
                      vErrors = [err24];
                    } else {
                      vErrors.push(err24);
                    }
                    errors++;
                  }
                }
                var _valid1 = _errs46 === errors;
                valid10 = valid10 || _valid1;
              }
              if (!valid10) {
                var err25 = {
                  instancePath: instancePath + '/script',
                  schemaPath: '#/anyOf/1/properties/script/anyOf',
                  keyword: 'anyOf',
                  params: {},
                  message: 'must match a schema in anyOf'
                };
                if (vErrors === null) {
                  vErrors = [err25];
                } else {
                  vErrors.push(err25);
                }
                errors++;
              } else {
                errors = _errs43;
                if (vErrors !== null) {
                  if (_errs43) {
                    vErrors.length = _errs43;
                  } else {
                    vErrors = null;
                  }
                }
              }
              var valid1 = _errs42 === errors;
            } else {
              var valid1 = true;
            }
          }
        }
      } else {
        var err26 = {
          instancePath: instancePath,
          schemaPath: '#/anyOf/1/type',
          keyword: 'type',
          params: {
            type: 'object'
          },
          message: 'must be object'
        };
        if (vErrors === null) {
          vErrors = [err26];
        } else {
          vErrors.push(err26);
        }
        errors++;
      }
    }
    var _valid0 = _errs3 === errors;
    valid0 = valid0 || _valid0;
  }
  if (!valid0) {
    var err27 = {
      instancePath: instancePath,
      schemaPath: '#/anyOf',
      keyword: 'anyOf',
      params: {},
      message: 'must match a schema in anyOf'
    };
    if (vErrors === null) {
      vErrors = [err27];
    } else {
      vErrors.push(err27);
    }
    errors++;
    validate28.errors = vErrors;
    return false;
  } else {
    errors = _errs0;
    if (vErrors !== null) {
      if (_errs0) {
        vErrors.length = _errs0;
      } else {
        vErrors = null;
      }
    }
  }
  validate28.errors = vErrors;
  return errors === 0;
}
function validate27(data) {
  var _ref4 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
    _ref4$instancePath = _ref4.instancePath,
    instancePath = _ref4$instancePath === void 0 ? '' : _ref4$instancePath;
    _ref4.parentData;
    _ref4.parentDataProperty;
    var _ref4$rootData = _ref4.rootData,
    rootData = _ref4$rootData === void 0 ? data : _ref4$rootData;
  var vErrors = null;
  var errors = 0;
  if (errors === 0) {
    if (data && _typeof(data) == 'object' && !Array.isArray(data)) {
      var _errs1 = errors;
      for (var key0 in data) {
        if (!(key0 === 'lockingBytecode' || key0 === 'token' || key0 === 'valueSatoshis')) {
          validate27.errors = [{
            instancePath: instancePath,
            schemaPath: '#/additionalProperties',
            keyword: 'additionalProperties',
            params: {
              additionalProperty: key0
            },
            message: 'must NOT have additional properties'
          }];
          return false;
        }
      }
      if (_errs1 === errors) {
        if (data.lockingBytecode !== undefined) {
          var data0 = data.lockingBytecode;
          var _errs2 = errors;
          var _errs3 = errors;
          var valid1 = false;
          var _errs4 = errors;
          if (!validate28(data0, {
            instancePath: instancePath + '/lockingBytecode',
            parentData: data,
            parentDataProperty: 'lockingBytecode',
            rootData: rootData
          })) {
            vErrors = vErrors === null ? validate28.errors : vErrors.concat(validate28.errors);
            errors = vErrors.length;
          }
          var _valid0 = _errs4 === errors;
          valid1 = valid1 || _valid0;
          if (!valid1) {
            var _errs5 = errors;
            if (errors === _errs5) {
              if (Array.isArray(data0)) {
                if (data0.length > 1) {
                  var err0 = {
                    instancePath: instancePath + '/lockingBytecode',
                    schemaPath: '#/properties/lockingBytecode/anyOf/1/maxItems',
                    keyword: 'maxItems',
                    params: {
                      limit: 1
                    },
                    message: 'must NOT have more than 1 items'
                  };
                  if (vErrors === null) {
                    vErrors = [err0];
                  } else {
                    vErrors.push(err0);
                  }
                  errors++;
                } else {
                  if (data0.length < 1) {
                    var err1 = {
                      instancePath: instancePath + '/lockingBytecode',
                      schemaPath: '#/properties/lockingBytecode/anyOf/1/minItems',
                      keyword: 'minItems',
                      params: {
                        limit: 1
                      },
                      message: 'must NOT have fewer than 1 items'
                    };
                    if (vErrors === null) {
                      vErrors = [err1];
                    } else {
                      vErrors.push(err1);
                    }
                    errors++;
                  } else {
                    var valid2 = true;
                    var len0 = data0.length;
                    for (var i0 = 0; i0 < len0; i0++) {
                      var data1 = data0[i0];
                      var _errs7 = errors;
                      if (typeof data1 !== 'string') {
                        var err2 = {
                          instancePath: instancePath + '/lockingBytecode/' + i0,
                          schemaPath: '#/properties/lockingBytecode/anyOf/1/items/type',
                          keyword: 'type',
                          params: {
                            type: 'string'
                          },
                          message: 'must be string'
                        };
                        if (vErrors === null) {
                          vErrors = [err2];
                        } else {
                          vErrors.push(err2);
                        }
                        errors++;
                      }
                      if ('slot' !== data1) {
                        var err3 = {
                          instancePath: instancePath + '/lockingBytecode/' + i0,
                          schemaPath: '#/properties/lockingBytecode/anyOf/1/items/const',
                          keyword: 'const',
                          params: {
                            allowedValue: 'slot'
                          },
                          message: 'must be equal to constant'
                        };
                        if (vErrors === null) {
                          vErrors = [err3];
                        } else {
                          vErrors.push(err3);
                        }
                        errors++;
                      }
                      var valid2 = _errs7 === errors;
                      if (!valid2) {
                        break;
                      }
                    }
                  }
                }
              } else {
                var err4 = {
                  instancePath: instancePath + '/lockingBytecode',
                  schemaPath: '#/properties/lockingBytecode/anyOf/1/type',
                  keyword: 'type',
                  params: {
                    type: 'array'
                  },
                  message: 'must be array'
                };
                if (vErrors === null) {
                  vErrors = [err4];
                } else {
                  vErrors.push(err4);
                }
                errors++;
              }
            }
            var _valid0 = _errs5 === errors;
            valid1 = valid1 || _valid0;
          }
          if (!valid1) {
            var err5 = {
              instancePath: instancePath + '/lockingBytecode',
              schemaPath: '#/properties/lockingBytecode/anyOf',
              keyword: 'anyOf',
              params: {},
              message: 'must match a schema in anyOf'
            };
            if (vErrors === null) {
              vErrors = [err5];
            } else {
              vErrors.push(err5);
            }
            errors++;
            validate27.errors = vErrors;
            return false;
          } else {
            errors = _errs3;
            if (vErrors !== null) {
              if (_errs3) {
                vErrors.length = _errs3;
              } else {
                vErrors = null;
              }
            }
          }
          var valid0 = _errs2 === errors;
        } else {
          var valid0 = true;
        }
        if (valid0) {
          if (data.token !== undefined) {
            var data2 = data.token;
            var _errs9 = errors;
            if (errors === _errs9) {
              if (data2 && _typeof(data2) == 'object' && !Array.isArray(data2)) {
                var _errs11 = errors;
                for (var key1 in data2) {
                  if (!(key1 === 'amount' || key1 === 'category' || key1 === 'nft')) {
                    validate27.errors = [{
                      instancePath: instancePath + '/token',
                      schemaPath: '#/properties/token/additionalProperties',
                      keyword: 'additionalProperties',
                      params: {
                        additionalProperty: key1
                      },
                      message: 'must NOT have additional properties'
                    }];
                    return false;
                  }
                }
                if (_errs11 === errors) {
                  if (data2.amount !== undefined) {
                    var data3 = data2.amount;
                    var _errs12 = errors;
                    if (!(typeof data3 == 'number' && isFinite(data3)) && typeof data3 !== 'string') {
                      validate27.errors = [{
                        instancePath: instancePath + '/token/amount',
                        schemaPath: '#/properties/token/properties/amount/type',
                        keyword: 'type',
                        params: {
                          type: schema32.properties.token.properties.amount.type
                        },
                        message: 'must be number,string'
                      }];
                      return false;
                    }
                    var valid3 = _errs12 === errors;
                  } else {
                    var valid3 = true;
                  }
                  if (valid3) {
                    if (data2.category !== undefined) {
                      var _errs14 = errors;
                      if (typeof data2.category !== 'string') {
                        validate27.errors = [{
                          instancePath: instancePath + '/token/category',
                          schemaPath: '#/properties/token/properties/category/type',
                          keyword: 'type',
                          params: {
                            type: 'string'
                          },
                          message: 'must be string'
                        }];
                        return false;
                      }
                      var valid3 = _errs14 === errors;
                    } else {
                      var valid3 = true;
                    }
                    if (valid3) {
                      if (data2.nft !== undefined) {
                        var data5 = data2.nft;
                        var _errs16 = errors;
                        if (errors === _errs16) {
                          if (data5 && _typeof(data5) == 'object' && !Array.isArray(data5)) {
                            var _errs18 = errors;
                            for (var key2 in data5) {
                              if (!(key2 === 'capability' || key2 === 'commitment')) {
                                validate27.errors = [{
                                  instancePath: instancePath + '/token/nft',
                                  schemaPath: '#/properties/token/properties/nft/additionalProperties',
                                  keyword: 'additionalProperties',
                                  params: {
                                    additionalProperty: key2
                                  },
                                  message: 'must NOT have additional properties'
                                }];
                                return false;
                              }
                            }
                            if (_errs18 === errors) {
                              if (data5.capability !== undefined) {
                                var data6 = data5.capability;
                                var _errs19 = errors;
                                if (typeof data6 !== 'string') {
                                  validate27.errors = [{
                                    instancePath: instancePath + '/token/nft/capability',
                                    schemaPath: '#/properties/token/properties/nft/properties/capability/type',
                                    keyword: 'type',
                                    params: {
                                      type: 'string'
                                    },
                                    message: 'must be string'
                                  }];
                                  return false;
                                }
                                if (!(data6 === 'minting' || data6 === 'mutable' || data6 === 'none')) {
                                  validate27.errors = [{
                                    instancePath: instancePath + '/token/nft/capability',
                                    schemaPath: '#/properties/token/properties/nft/properties/capability/enum',
                                    keyword: 'enum',
                                    params: {
                                      allowedValues: schema32.properties.token.properties.nft.properties.capability.enum
                                    },
                                    message: 'must be equal to one of the allowed values'
                                  }];
                                  return false;
                                }
                                var valid4 = _errs19 === errors;
                              } else {
                                var valid4 = true;
                              }
                              if (valid4) {
                                if (data5.commitment !== undefined) {
                                  var _errs21 = errors;
                                  if (typeof data5.commitment !== 'string') {
                                    validate27.errors = [{
                                      instancePath: instancePath + '/token/nft/commitment',
                                      schemaPath: '#/properties/token/properties/nft/properties/commitment/type',
                                      keyword: 'type',
                                      params: {
                                        type: 'string'
                                      },
                                      message: 'must be string'
                                    }];
                                    return false;
                                  }
                                  var valid4 = _errs21 === errors;
                                } else {
                                  var valid4 = true;
                                }
                              }
                            }
                          } else {
                            validate27.errors = [{
                              instancePath: instancePath + '/token/nft',
                              schemaPath: '#/properties/token/properties/nft/type',
                              keyword: 'type',
                              params: {
                                type: 'object'
                              },
                              message: 'must be object'
                            }];
                            return false;
                          }
                        }
                        var valid3 = _errs16 === errors;
                      } else {
                        var valid3 = true;
                      }
                    }
                  }
                }
              } else {
                validate27.errors = [{
                  instancePath: instancePath + '/token',
                  schemaPath: '#/properties/token/type',
                  keyword: 'type',
                  params: {
                    type: 'object'
                  },
                  message: 'must be object'
                }];
                return false;
              }
            }
            var valid0 = _errs9 === errors;
          } else {
            var valid0 = true;
          }
          if (valid0) {
            if (data.valueSatoshis !== undefined) {
              var data8 = data.valueSatoshis;
              var _errs23 = errors;
              if (!(typeof data8 == 'number' && isFinite(data8)) && typeof data8 !== 'string') {
                validate27.errors = [{
                  instancePath: instancePath + '/valueSatoshis',
                  schemaPath: '#/properties/valueSatoshis/type',
                  keyword: 'type',
                  params: {
                    type: schema32.properties.valueSatoshis.type
                  },
                  message: 'must be number,string'
                }];
                return false;
              }
              var valid0 = _errs23 === errors;
            } else {
              var valid0 = true;
            }
          }
        }
      }
    } else {
      validate27.errors = [{
        instancePath: instancePath,
        schemaPath: '#/type',
        keyword: 'type',
        params: {
          type: 'object'
        },
        message: 'must be object'
      }];
      return false;
    }
  }
  validate27.errors = vErrors;
  return errors === 0;
}
function validate31(data) {
  var _ref5 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
    _ref5$instancePath = _ref5.instancePath,
    instancePath = _ref5$instancePath === void 0 ? '' : _ref5$instancePath;
    _ref5.parentData;
    _ref5.parentDataProperty;
    var _ref5$rootData = _ref5.rootData,
    rootData = _ref5$rootData === void 0 ? data : _ref5$rootData;
  var vErrors = null;
  var errors = 0;
  if (errors === 0) {
    if (data && _typeof(data) == 'object' && !Array.isArray(data)) {
      var _errs1 = errors;
      for (var key0 in data) {
        if (!(key0 === 'outpointIndex' || key0 === 'outpointTransactionHash' || key0 === 'sequenceNumber' || key0 === 'unlockingBytecode')) {
          validate31.errors = [{
            instancePath: instancePath,
            schemaPath: '#/additionalProperties',
            keyword: 'additionalProperties',
            params: {
              additionalProperty: key0
            },
            message: 'must NOT have additional properties'
          }];
          return false;
        }
      }
      if (_errs1 === errors) {
        if (data.outpointIndex !== undefined) {
          var data0 = data.outpointIndex;
          var _errs2 = errors;
          if (!(typeof data0 == 'number' && isFinite(data0))) {
            validate31.errors = [{
              instancePath: instancePath + '/outpointIndex',
              schemaPath: '#/properties/outpointIndex/type',
              keyword: 'type',
              params: {
                type: 'number'
              },
              message: 'must be number'
            }];
            return false;
          }
          var valid0 = _errs2 === errors;
        } else {
          var valid0 = true;
        }
        if (valid0) {
          if (data.outpointTransactionHash !== undefined) {
            var _errs4 = errors;
            if (typeof data.outpointTransactionHash !== 'string') {
              validate31.errors = [{
                instancePath: instancePath + '/outpointTransactionHash',
                schemaPath: '#/properties/outpointTransactionHash/type',
                keyword: 'type',
                params: {
                  type: 'string'
                },
                message: 'must be string'
              }];
              return false;
            }
            var valid0 = _errs4 === errors;
          } else {
            var valid0 = true;
          }
          if (valid0) {
            if (data.sequenceNumber !== undefined) {
              var data2 = data.sequenceNumber;
              var _errs6 = errors;
              if (!(typeof data2 == 'number' && isFinite(data2))) {
                validate31.errors = [{
                  instancePath: instancePath + '/sequenceNumber',
                  schemaPath: '#/properties/sequenceNumber/type',
                  keyword: 'type',
                  params: {
                    type: 'number'
                  },
                  message: 'must be number'
                }];
                return false;
              }
              var valid0 = _errs6 === errors;
            } else {
              var valid0 = true;
            }
            if (valid0) {
              if (data.unlockingBytecode !== undefined) {
                var data3 = data.unlockingBytecode;
                var _errs8 = errors;
                var _errs9 = errors;
                var valid1 = false;
                var _errs10 = errors;
                if (!validate28(data3, {
                  instancePath: instancePath + '/unlockingBytecode',
                  parentData: data,
                  parentDataProperty: 'unlockingBytecode',
                  rootData: rootData
                })) {
                  vErrors = vErrors === null ? validate28.errors : vErrors.concat(validate28.errors);
                  errors = vErrors.length;
                }
                var _valid0 = _errs10 === errors;
                valid1 = valid1 || _valid0;
                if (!valid1) {
                  var _errs11 = errors;
                  if (errors === _errs11) {
                    if (Array.isArray(data3)) {
                      if (data3.length > 1) {
                        var err0 = {
                          instancePath: instancePath + '/unlockingBytecode',
                          schemaPath: '#/properties/unlockingBytecode/anyOf/1/maxItems',
                          keyword: 'maxItems',
                          params: {
                            limit: 1
                          },
                          message: 'must NOT have more than 1 items'
                        };
                        if (vErrors === null) {
                          vErrors = [err0];
                        } else {
                          vErrors.push(err0);
                        }
                        errors++;
                      } else {
                        if (data3.length < 1) {
                          var err1 = {
                            instancePath: instancePath + '/unlockingBytecode',
                            schemaPath: '#/properties/unlockingBytecode/anyOf/1/minItems',
                            keyword: 'minItems',
                            params: {
                              limit: 1
                            },
                            message: 'must NOT have fewer than 1 items'
                          };
                          if (vErrors === null) {
                            vErrors = [err1];
                          } else {
                            vErrors.push(err1);
                          }
                          errors++;
                        } else {
                          var valid2 = true;
                          var len0 = data3.length;
                          for (var i0 = 0; i0 < len0; i0++) {
                            var data4 = data3[i0];
                            var _errs13 = errors;
                            if (typeof data4 !== 'string') {
                              var err2 = {
                                instancePath: instancePath + '/unlockingBytecode/' + i0,
                                schemaPath: '#/properties/unlockingBytecode/anyOf/1/items/type',
                                keyword: 'type',
                                params: {
                                  type: 'string'
                                },
                                message: 'must be string'
                              };
                              if (vErrors === null) {
                                vErrors = [err2];
                              } else {
                                vErrors.push(err2);
                              }
                              errors++;
                            }
                            if ('slot' !== data4) {
                              var err3 = {
                                instancePath: instancePath + '/unlockingBytecode/' + i0,
                                schemaPath: '#/properties/unlockingBytecode/anyOf/1/items/const',
                                keyword: 'const',
                                params: {
                                  allowedValue: 'slot'
                                },
                                message: 'must be equal to constant'
                              };
                              if (vErrors === null) {
                                vErrors = [err3];
                              } else {
                                vErrors.push(err3);
                              }
                              errors++;
                            }
                            var valid2 = _errs13 === errors;
                            if (!valid2) {
                              break;
                            }
                          }
                        }
                      }
                    } else {
                      var err4 = {
                        instancePath: instancePath + '/unlockingBytecode',
                        schemaPath: '#/properties/unlockingBytecode/anyOf/1/type',
                        keyword: 'type',
                        params: {
                          type: 'array'
                        },
                        message: 'must be array'
                      };
                      if (vErrors === null) {
                        vErrors = [err4];
                      } else {
                        vErrors.push(err4);
                      }
                      errors++;
                    }
                  }
                  var _valid0 = _errs11 === errors;
                  valid1 = valid1 || _valid0;
                }
                if (!valid1) {
                  var err5 = {
                    instancePath: instancePath + '/unlockingBytecode',
                    schemaPath: '#/properties/unlockingBytecode/anyOf',
                    keyword: 'anyOf',
                    params: {},
                    message: 'must match a schema in anyOf'
                  };
                  if (vErrors === null) {
                    vErrors = [err5];
                  } else {
                    vErrors.push(err5);
                  }
                  errors++;
                  validate31.errors = vErrors;
                  return false;
                } else {
                  errors = _errs9;
                  if (vErrors !== null) {
                    if (_errs9) {
                      vErrors.length = _errs9;
                    } else {
                      vErrors = null;
                    }
                  }
                }
                var valid0 = _errs8 === errors;
              } else {
                var valid0 = true;
              }
            }
          }
        }
      }
    } else {
      validate31.errors = [{
        instancePath: instancePath,
        schemaPath: '#/type',
        keyword: 'type',
        params: {
          type: 'object'
        },
        message: 'must be object'
      }];
      return false;
    }
  }
  validate31.errors = vErrors;
  return errors === 0;
}
var schema36 = {
  additionalProperties: false,
  description: 'An example output used to define a scenario for an authentication template.',
  properties: {
    lockingBytecode: {
      $ref: '#/definitions/AuthenticationTemplateScenarioBytecode',
      description: 'The locking bytecode used to encumber this output.\n\n`lockingBytecode` values may be provided as a hexadecimal-encoded string or as an object describing the required compilation. If undefined, defaults to  `{}`, which uses the default values for `script` and `overrides`, respectively.\n\nOnly source outputs may specify a `lockingBytecode` of `["slot"]`; this identifies the source output in which the locking script under test will be placed. (To be valid, every scenario\'s `sourceOutputs` property must have exactly one source output slot and one input slot at the same index.)'
    },
    token: {
      additionalProperties: false,
      description: 'The CashToken contents of this output. This property is only defined if the output contains one or more tokens. For details, see `CHIP-2022-02-CashTokens`.',
      properties: {
        amount: {
          description: 'The number of fungible tokens (of `category`) held in this output.\n\nBecause `Number.MAX_SAFE_INTEGER` (`9007199254740991`) is less than the maximum token amount (`9223372036854775807`), this value may also be provided as a string, e.g. `"9223372036854775807"`.\n\nIf undefined, this defaults to: `0`.',
          type: ['number', 'string']
        },
        category: {
          description: 'The 32-byte, hexadecimal-encoded token category ID to which the token(s) in this output belong in big-endian byte order. This is the byte order typically seen in block explorers and user interfaces (as opposed to little-endian byte order, which is used in standard P2P network messages).\n\nIf undefined, this defaults to the value: `0000000000000000000000000000000000000000000000000000000000000002`',
          type: 'string'
        },
        nft: {
          additionalProperties: false,
          description: 'If present, the non-fungible token (NFT) held by this output. If the output does not include a non-fungible token, `undefined`.',
          properties: {
            capability: {
              description: 'The capability of this non-fungible token, must be either `minting`, `mutable`, or `none`.\n\nIf undefined, this defaults to: `none`.',
              enum: ['minting', 'mutable', 'none'],
              type: 'string'
            },
            commitment: {
              description: 'The hex-encoded commitment contents included in the non-fungible token held in this output.\n\nIf undefined, this defaults to: `""` (a zero-length commitment).',
              type: 'string'
            }
          },
          type: 'object'
        }
      },
      type: 'object'
    },
    valueSatoshis: {
      description: 'The value of the output in satoshis, the smallest unit of bitcoin.\n\nIn a valid transaction, this is a positive integer, from `0` to the maximum number of satoshis available to the transaction.\n\nThe maximum number of satoshis in existence is about 1/4 of `Number.MAX_SAFE_INTEGER` (`9007199254740991`), so typically, this value is defined using a `number`. However, this value may also be defined using a 16-character, hexadecimal-encoded `string`, to allow for the full range of the 64-bit unsigned, little-endian integer used to encode `valueSatoshis` in the encoded output format, e.g. `"ffffffffffffffff"`. This is useful for representing scenarios where intentionally excessive values are provided (to ensure an otherwise properly-signed transaction can never be included in the blockchain), e.g. transaction size estimations or off-chain Bitauth signatures.\n\nIf undefined, this defaults to: `0`.',
      type: ['number', 'string']
    }
  },
  type: 'object'
};
function validate34(data) {
  var _ref6 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
    _ref6$instancePath = _ref6.instancePath,
    instancePath = _ref6$instancePath === void 0 ? '' : _ref6$instancePath;
    _ref6.parentData;
    _ref6.parentDataProperty;
    var _ref6$rootData = _ref6.rootData,
    rootData = _ref6$rootData === void 0 ? data : _ref6$rootData;
  var vErrors = null;
  var errors = 0;
  if (errors === 0) {
    if (data && _typeof(data) == 'object' && !Array.isArray(data)) {
      var _errs1 = errors;
      for (var key0 in data) {
        if (!(key0 === 'lockingBytecode' || key0 === 'token' || key0 === 'valueSatoshis')) {
          validate34.errors = [{
            instancePath: instancePath,
            schemaPath: '#/additionalProperties',
            keyword: 'additionalProperties',
            params: {
              additionalProperty: key0
            },
            message: 'must NOT have additional properties'
          }];
          return false;
        }
      }
      if (_errs1 === errors) {
        if (data.lockingBytecode !== undefined) {
          var _errs2 = errors;
          if (!validate28(data.lockingBytecode, {
            instancePath: instancePath + '/lockingBytecode',
            parentData: data,
            parentDataProperty: 'lockingBytecode',
            rootData: rootData
          })) {
            vErrors = vErrors === null ? validate28.errors : vErrors.concat(validate28.errors);
            errors = vErrors.length;
          }
          var valid0 = _errs2 === errors;
        } else {
          var valid0 = true;
        }
        if (valid0) {
          if (data.token !== undefined) {
            var data1 = data.token;
            var _errs3 = errors;
            if (errors === _errs3) {
              if (data1 && _typeof(data1) == 'object' && !Array.isArray(data1)) {
                var _errs5 = errors;
                for (var key1 in data1) {
                  if (!(key1 === 'amount' || key1 === 'category' || key1 === 'nft')) {
                    validate34.errors = [{
                      instancePath: instancePath + '/token',
                      schemaPath: '#/properties/token/additionalProperties',
                      keyword: 'additionalProperties',
                      params: {
                        additionalProperty: key1
                      },
                      message: 'must NOT have additional properties'
                    }];
                    return false;
                  }
                }
                if (_errs5 === errors) {
                  if (data1.amount !== undefined) {
                    var data2 = data1.amount;
                    var _errs6 = errors;
                    if (!(typeof data2 == 'number' && isFinite(data2)) && typeof data2 !== 'string') {
                      validate34.errors = [{
                        instancePath: instancePath + '/token/amount',
                        schemaPath: '#/properties/token/properties/amount/type',
                        keyword: 'type',
                        params: {
                          type: schema36.properties.token.properties.amount.type
                        },
                        message: 'must be number,string'
                      }];
                      return false;
                    }
                    var valid1 = _errs6 === errors;
                  } else {
                    var valid1 = true;
                  }
                  if (valid1) {
                    if (data1.category !== undefined) {
                      var _errs8 = errors;
                      if (typeof data1.category !== 'string') {
                        validate34.errors = [{
                          instancePath: instancePath + '/token/category',
                          schemaPath: '#/properties/token/properties/category/type',
                          keyword: 'type',
                          params: {
                            type: 'string'
                          },
                          message: 'must be string'
                        }];
                        return false;
                      }
                      var valid1 = _errs8 === errors;
                    } else {
                      var valid1 = true;
                    }
                    if (valid1) {
                      if (data1.nft !== undefined) {
                        var data4 = data1.nft;
                        var _errs10 = errors;
                        if (errors === _errs10) {
                          if (data4 && _typeof(data4) == 'object' && !Array.isArray(data4)) {
                            var _errs12 = errors;
                            for (var key2 in data4) {
                              if (!(key2 === 'capability' || key2 === 'commitment')) {
                                validate34.errors = [{
                                  instancePath: instancePath + '/token/nft',
                                  schemaPath: '#/properties/token/properties/nft/additionalProperties',
                                  keyword: 'additionalProperties',
                                  params: {
                                    additionalProperty: key2
                                  },
                                  message: 'must NOT have additional properties'
                                }];
                                return false;
                              }
                            }
                            if (_errs12 === errors) {
                              if (data4.capability !== undefined) {
                                var data5 = data4.capability;
                                var _errs13 = errors;
                                if (typeof data5 !== 'string') {
                                  validate34.errors = [{
                                    instancePath: instancePath + '/token/nft/capability',
                                    schemaPath: '#/properties/token/properties/nft/properties/capability/type',
                                    keyword: 'type',
                                    params: {
                                      type: 'string'
                                    },
                                    message: 'must be string'
                                  }];
                                  return false;
                                }
                                if (!(data5 === 'minting' || data5 === 'mutable' || data5 === 'none')) {
                                  validate34.errors = [{
                                    instancePath: instancePath + '/token/nft/capability',
                                    schemaPath: '#/properties/token/properties/nft/properties/capability/enum',
                                    keyword: 'enum',
                                    params: {
                                      allowedValues: schema36.properties.token.properties.nft.properties.capability.enum
                                    },
                                    message: 'must be equal to one of the allowed values'
                                  }];
                                  return false;
                                }
                                var valid2 = _errs13 === errors;
                              } else {
                                var valid2 = true;
                              }
                              if (valid2) {
                                if (data4.commitment !== undefined) {
                                  var _errs15 = errors;
                                  if (typeof data4.commitment !== 'string') {
                                    validate34.errors = [{
                                      instancePath: instancePath + '/token/nft/commitment',
                                      schemaPath: '#/properties/token/properties/nft/properties/commitment/type',
                                      keyword: 'type',
                                      params: {
                                        type: 'string'
                                      },
                                      message: 'must be string'
                                    }];
                                    return false;
                                  }
                                  var valid2 = _errs15 === errors;
                                } else {
                                  var valid2 = true;
                                }
                              }
                            }
                          } else {
                            validate34.errors = [{
                              instancePath: instancePath + '/token/nft',
                              schemaPath: '#/properties/token/properties/nft/type',
                              keyword: 'type',
                              params: {
                                type: 'object'
                              },
                              message: 'must be object'
                            }];
                            return false;
                          }
                        }
                        var valid1 = _errs10 === errors;
                      } else {
                        var valid1 = true;
                      }
                    }
                  }
                }
              } else {
                validate34.errors = [{
                  instancePath: instancePath + '/token',
                  schemaPath: '#/properties/token/type',
                  keyword: 'type',
                  params: {
                    type: 'object'
                  },
                  message: 'must be object'
                }];
                return false;
              }
            }
            var valid0 = _errs3 === errors;
          } else {
            var valid0 = true;
          }
          if (valid0) {
            if (data.valueSatoshis !== undefined) {
              var data7 = data.valueSatoshis;
              var _errs17 = errors;
              if (!(typeof data7 == 'number' && isFinite(data7)) && typeof data7 !== 'string') {
                validate34.errors = [{
                  instancePath: instancePath + '/valueSatoshis',
                  schemaPath: '#/properties/valueSatoshis/type',
                  keyword: 'type',
                  params: {
                    type: schema36.properties.valueSatoshis.type
                  },
                  message: 'must be number,string'
                }];
                return false;
              }
              var valid0 = _errs17 === errors;
            } else {
              var valid0 = true;
            }
          }
        }
      }
    } else {
      validate34.errors = [{
        instancePath: instancePath,
        schemaPath: '#/type',
        keyword: 'type',
        params: {
          type: 'object'
        },
        message: 'must be object'
      }];
      return false;
    }
  }
  validate34.errors = vErrors;
  return errors === 0;
}
function validate26(data) {
  var _ref7 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
    _ref7$instancePath = _ref7.instancePath,
    instancePath = _ref7$instancePath === void 0 ? '' : _ref7$instancePath;
    _ref7.parentData;
    _ref7.parentDataProperty;
    var _ref7$rootData = _ref7.rootData,
    rootData = _ref7$rootData === void 0 ? data : _ref7$rootData;
  var vErrors = null;
  var errors = 0;
  if (errors === 0) {
    if (data && _typeof(data) == 'object' && !Array.isArray(data)) {
      var _errs1 = errors;
      for (var key0 in data) {
        if (!(key0 === 'data' || key0 === 'description' || key0 === 'extends' || key0 === 'name' || key0 === 'sourceOutputs' || key0 === 'transaction')) {
          validate26.errors = [{
            instancePath: instancePath,
            schemaPath: '#/additionalProperties',
            keyword: 'additionalProperties',
            params: {
              additionalProperty: key0
            },
            message: 'must NOT have additional properties'
          }];
          return false;
        }
      }
      if (_errs1 === errors) {
        if (data.data !== undefined) {
          var data0 = data.data;
          var _errs2 = errors;
          var _errs3 = errors;
          if (errors === _errs3) {
            if (data0 && _typeof(data0) == 'object' && !Array.isArray(data0)) {
              var _errs5 = errors;
              for (var key1 in data0) {
                if (!(key1 === 'bytecode' || key1 === 'currentBlockHeight' || key1 === 'currentBlockTime' || key1 === 'hdKeys' || key1 === 'keys')) {
                  validate26.errors = [{
                    instancePath: instancePath + '/data',
                    schemaPath: '#/definitions/AuthenticationTemplateScenarioData/additionalProperties',
                    keyword: 'additionalProperties',
                    params: {
                      additionalProperty: key1
                    },
                    message: 'must NOT have additional properties'
                  }];
                  return false;
                }
              }
              if (_errs5 === errors) {
                if (data0.bytecode !== undefined) {
                  var data1 = data0.bytecode;
                  var _errs6 = errors;
                  if (errors === _errs6) {
                    if (data1 && _typeof(data1) == 'object' && !Array.isArray(data1)) {
                      for (var key2 in data1) {
                        var _errs9 = errors;
                        if (typeof data1[key2] !== 'string') {
                          validate26.errors = [{
                            instancePath: instancePath + '/data/bytecode/' + key2.replace(/~/g, '~0').replace(/\//g, '~1'),
                            schemaPath: '#/definitions/AuthenticationTemplateScenarioData/properties/bytecode/additionalProperties/type',
                            keyword: 'type',
                            params: {
                              type: 'string'
                            },
                            message: 'must be string'
                          }];
                          return false;
                        }
                        var valid3 = _errs9 === errors;
                        if (!valid3) {
                          break;
                        }
                      }
                    } else {
                      validate26.errors = [{
                        instancePath: instancePath + '/data/bytecode',
                        schemaPath: '#/definitions/AuthenticationTemplateScenarioData/properties/bytecode/type',
                        keyword: 'type',
                        params: {
                          type: 'object'
                        },
                        message: 'must be object'
                      }];
                      return false;
                    }
                  }
                  var valid2 = _errs6 === errors;
                } else {
                  var valid2 = true;
                }
                if (valid2) {
                  if (data0.currentBlockHeight !== undefined) {
                    var data3 = data0.currentBlockHeight;
                    var _errs11 = errors;
                    if (!(typeof data3 == 'number' && isFinite(data3))) {
                      validate26.errors = [{
                        instancePath: instancePath + '/data/currentBlockHeight',
                        schemaPath: '#/definitions/AuthenticationTemplateScenarioData/properties/currentBlockHeight/type',
                        keyword: 'type',
                        params: {
                          type: 'number'
                        },
                        message: 'must be number'
                      }];
                      return false;
                    }
                    var valid2 = _errs11 === errors;
                  } else {
                    var valid2 = true;
                  }
                  if (valid2) {
                    if (data0.currentBlockTime !== undefined) {
                      var data4 = data0.currentBlockTime;
                      var _errs13 = errors;
                      if (!(typeof data4 == 'number' && isFinite(data4))) {
                        validate26.errors = [{
                          instancePath: instancePath + '/data/currentBlockTime',
                          schemaPath: '#/definitions/AuthenticationTemplateScenarioData/properties/currentBlockTime/type',
                          keyword: 'type',
                          params: {
                            type: 'number'
                          },
                          message: 'must be number'
                        }];
                        return false;
                      }
                      var valid2 = _errs13 === errors;
                    } else {
                      var valid2 = true;
                    }
                    if (valid2) {
                      if (data0.hdKeys !== undefined) {
                        var data5 = data0.hdKeys;
                        var _errs15 = errors;
                        if (errors === _errs15) {
                          if (data5 && _typeof(data5) == 'object' && !Array.isArray(data5)) {
                            var _errs17 = errors;
                            for (var key3 in data5) {
                              if (!(key3 === 'addressIndex' || key3 === 'hdPrivateKeys' || key3 === 'hdPublicKeys')) {
                                validate26.errors = [{
                                  instancePath: instancePath + '/data/hdKeys',
                                  schemaPath: '#/definitions/AuthenticationTemplateScenarioData/properties/hdKeys/additionalProperties',
                                  keyword: 'additionalProperties',
                                  params: {
                                    additionalProperty: key3
                                  },
                                  message: 'must NOT have additional properties'
                                }];
                                return false;
                              }
                            }
                            if (_errs17 === errors) {
                              if (data5.addressIndex !== undefined) {
                                var data6 = data5.addressIndex;
                                var _errs18 = errors;
                                if (!(typeof data6 == 'number' && isFinite(data6))) {
                                  validate26.errors = [{
                                    instancePath: instancePath + '/data/hdKeys/addressIndex',
                                    schemaPath: '#/definitions/AuthenticationTemplateScenarioData/properties/hdKeys/properties/addressIndex/type',
                                    keyword: 'type',
                                    params: {
                                      type: 'number'
                                    },
                                    message: 'must be number'
                                  }];
                                  return false;
                                }
                                var valid4 = _errs18 === errors;
                              } else {
                                var valid4 = true;
                              }
                              if (valid4) {
                                if (data5.hdPrivateKeys !== undefined) {
                                  var data7 = data5.hdPrivateKeys;
                                  var _errs20 = errors;
                                  if (errors === _errs20) {
                                    if (data7 && _typeof(data7) == 'object' && !Array.isArray(data7)) {
                                      for (var key4 in data7) {
                                        var _errs23 = errors;
                                        if (typeof data7[key4] !== 'string') {
                                          validate26.errors = [{
                                            instancePath: instancePath + '/data/hdKeys/hdPrivateKeys/' + key4.replace(/~/g, '~0').replace(/\//g, '~1'),
                                            schemaPath: '#/definitions/AuthenticationTemplateScenarioData/properties/hdKeys/properties/hdPrivateKeys/additionalProperties/type',
                                            keyword: 'type',
                                            params: {
                                              type: 'string'
                                            },
                                            message: 'must be string'
                                          }];
                                          return false;
                                        }
                                        var valid5 = _errs23 === errors;
                                        if (!valid5) {
                                          break;
                                        }
                                      }
                                    } else {
                                      validate26.errors = [{
                                        instancePath: instancePath + '/data/hdKeys/hdPrivateKeys',
                                        schemaPath: '#/definitions/AuthenticationTemplateScenarioData/properties/hdKeys/properties/hdPrivateKeys/type',
                                        keyword: 'type',
                                        params: {
                                          type: 'object'
                                        },
                                        message: 'must be object'
                                      }];
                                      return false;
                                    }
                                  }
                                  var valid4 = _errs20 === errors;
                                } else {
                                  var valid4 = true;
                                }
                                if (valid4) {
                                  if (data5.hdPublicKeys !== undefined) {
                                    var data9 = data5.hdPublicKeys;
                                    var _errs25 = errors;
                                    if (errors === _errs25) {
                                      if (data9 && _typeof(data9) == 'object' && !Array.isArray(data9)) {
                                        for (var key5 in data9) {
                                          var _errs28 = errors;
                                          if (typeof data9[key5] !== 'string') {
                                            validate26.errors = [{
                                              instancePath: instancePath + '/data/hdKeys/hdPublicKeys/' + key5.replace(/~/g, '~0').replace(/\//g, '~1'),
                                              schemaPath: '#/definitions/AuthenticationTemplateScenarioData/properties/hdKeys/properties/hdPublicKeys/additionalProperties/type',
                                              keyword: 'type',
                                              params: {
                                                type: 'string'
                                              },
                                              message: 'must be string'
                                            }];
                                            return false;
                                          }
                                          var valid6 = _errs28 === errors;
                                          if (!valid6) {
                                            break;
                                          }
                                        }
                                      } else {
                                        validate26.errors = [{
                                          instancePath: instancePath + '/data/hdKeys/hdPublicKeys',
                                          schemaPath: '#/definitions/AuthenticationTemplateScenarioData/properties/hdKeys/properties/hdPublicKeys/type',
                                          keyword: 'type',
                                          params: {
                                            type: 'object'
                                          },
                                          message: 'must be object'
                                        }];
                                        return false;
                                      }
                                    }
                                    var valid4 = _errs25 === errors;
                                  } else {
                                    var valid4 = true;
                                  }
                                }
                              }
                            }
                          } else {
                            validate26.errors = [{
                              instancePath: instancePath + '/data/hdKeys',
                              schemaPath: '#/definitions/AuthenticationTemplateScenarioData/properties/hdKeys/type',
                              keyword: 'type',
                              params: {
                                type: 'object'
                              },
                              message: 'must be object'
                            }];
                            return false;
                          }
                        }
                        var valid2 = _errs15 === errors;
                      } else {
                        var valid2 = true;
                      }
                      if (valid2) {
                        if (data0.keys !== undefined) {
                          var data11 = data0.keys;
                          var _errs30 = errors;
                          if (errors === _errs30) {
                            if (data11 && _typeof(data11) == 'object' && !Array.isArray(data11)) {
                              var _errs32 = errors;
                              for (var key6 in data11) {
                                if (!(key6 === 'privateKeys')) {
                                  validate26.errors = [{
                                    instancePath: instancePath + '/data/keys',
                                    schemaPath: '#/definitions/AuthenticationTemplateScenarioData/properties/keys/additionalProperties',
                                    keyword: 'additionalProperties',
                                    params: {
                                      additionalProperty: key6
                                    },
                                    message: 'must NOT have additional properties'
                                  }];
                                  return false;
                                }
                              }
                              if (_errs32 === errors) {
                                if (data11.privateKeys !== undefined) {
                                  var data12 = data11.privateKeys;
                                  var _errs33 = errors;
                                  if (errors === _errs33) {
                                    if (data12 && _typeof(data12) == 'object' && !Array.isArray(data12)) {
                                      for (var key7 in data12) {
                                        var _errs36 = errors;
                                        if (typeof data12[key7] !== 'string') {
                                          validate26.errors = [{
                                            instancePath: instancePath + '/data/keys/privateKeys/' + key7.replace(/~/g, '~0').replace(/\//g, '~1'),
                                            schemaPath: '#/definitions/AuthenticationTemplateScenarioData/properties/keys/properties/privateKeys/additionalProperties/type',
                                            keyword: 'type',
                                            params: {
                                              type: 'string'
                                            },
                                            message: 'must be string'
                                          }];
                                          return false;
                                        }
                                        var valid8 = _errs36 === errors;
                                        if (!valid8) {
                                          break;
                                        }
                                      }
                                    } else {
                                      validate26.errors = [{
                                        instancePath: instancePath + '/data/keys/privateKeys',
                                        schemaPath: '#/definitions/AuthenticationTemplateScenarioData/properties/keys/properties/privateKeys/type',
                                        keyword: 'type',
                                        params: {
                                          type: 'object'
                                        },
                                        message: 'must be object'
                                      }];
                                      return false;
                                    }
                                  }
                                }
                              }
                            } else {
                              validate26.errors = [{
                                instancePath: instancePath + '/data/keys',
                                schemaPath: '#/definitions/AuthenticationTemplateScenarioData/properties/keys/type',
                                keyword: 'type',
                                params: {
                                  type: 'object'
                                },
                                message: 'must be object'
                              }];
                              return false;
                            }
                          }
                          var valid2 = _errs30 === errors;
                        } else {
                          var valid2 = true;
                        }
                      }
                    }
                  }
                }
              }
            } else {
              validate26.errors = [{
                instancePath: instancePath + '/data',
                schemaPath: '#/definitions/AuthenticationTemplateScenarioData/type',
                keyword: 'type',
                params: {
                  type: 'object'
                },
                message: 'must be object'
              }];
              return false;
            }
          }
          var valid0 = _errs2 === errors;
        } else {
          var valid0 = true;
        }
        if (valid0) {
          if (data.description !== undefined) {
            var _errs38 = errors;
            if (typeof data.description !== 'string') {
              validate26.errors = [{
                instancePath: instancePath + '/description',
                schemaPath: '#/properties/description/type',
                keyword: 'type',
                params: {
                  type: 'string'
                },
                message: 'must be string'
              }];
              return false;
            }
            var valid0 = _errs38 === errors;
          } else {
            var valid0 = true;
          }
          if (valid0) {
            if (data.extends !== undefined) {
              var _errs40 = errors;
              if (typeof data.extends !== 'string') {
                validate26.errors = [{
                  instancePath: instancePath + '/extends',
                  schemaPath: '#/properties/extends/type',
                  keyword: 'type',
                  params: {
                    type: 'string'
                  },
                  message: 'must be string'
                }];
                return false;
              }
              var valid0 = _errs40 === errors;
            } else {
              var valid0 = true;
            }
            if (valid0) {
              if (data.name !== undefined) {
                var _errs42 = errors;
                if (typeof data.name !== 'string') {
                  validate26.errors = [{
                    instancePath: instancePath + '/name',
                    schemaPath: '#/properties/name/type',
                    keyword: 'type',
                    params: {
                      type: 'string'
                    },
                    message: 'must be string'
                  }];
                  return false;
                }
                var valid0 = _errs42 === errors;
              } else {
                var valid0 = true;
              }
              if (valid0) {
                if (data.sourceOutputs !== undefined) {
                  var data17 = data.sourceOutputs;
                  var _errs44 = errors;
                  if (errors === _errs44) {
                    if (Array.isArray(data17)) {
                      var valid9 = true;
                      var len0 = data17.length;
                      for (var i0 = 0; i0 < len0; i0++) {
                        var _errs46 = errors;
                        if (!validate27(data17[i0], {
                          instancePath: instancePath + '/sourceOutputs/' + i0,
                          parentData: data17,
                          parentDataProperty: i0,
                          rootData: rootData
                        })) {
                          vErrors = vErrors === null ? validate27.errors : vErrors.concat(validate27.errors);
                          errors = vErrors.length;
                        }
                        var valid9 = _errs46 === errors;
                        if (!valid9) {
                          break;
                        }
                      }
                    } else {
                      validate26.errors = [{
                        instancePath: instancePath + '/sourceOutputs',
                        schemaPath: '#/properties/sourceOutputs/type',
                        keyword: 'type',
                        params: {
                          type: 'array'
                        },
                        message: 'must be array'
                      }];
                      return false;
                    }
                  }
                  var valid0 = _errs44 === errors;
                } else {
                  var valid0 = true;
                }
                if (valid0) {
                  if (data.transaction !== undefined) {
                    var data19 = data.transaction;
                    var _errs47 = errors;
                    if (errors === _errs47) {
                      if (data19 && _typeof(data19) == 'object' && !Array.isArray(data19)) {
                        var _errs49 = errors;
                        for (var key8 in data19) {
                          if (!(key8 === 'inputs' || key8 === 'locktime' || key8 === 'outputs' || key8 === 'version')) {
                            validate26.errors = [{
                              instancePath: instancePath + '/transaction',
                              schemaPath: '#/properties/transaction/additionalProperties',
                              keyword: 'additionalProperties',
                              params: {
                                additionalProperty: key8
                              },
                              message: 'must NOT have additional properties'
                            }];
                            return false;
                          }
                        }
                        if (_errs49 === errors) {
                          if (data19.inputs !== undefined) {
                            var data20 = data19.inputs;
                            var _errs50 = errors;
                            if (errors === _errs50) {
                              if (Array.isArray(data20)) {
                                var valid11 = true;
                                var len1 = data20.length;
                                for (var i1 = 0; i1 < len1; i1++) {
                                  var _errs52 = errors;
                                  if (!validate31(data20[i1], {
                                    instancePath: instancePath + '/transaction/inputs/' + i1,
                                    parentData: data20,
                                    parentDataProperty: i1,
                                    rootData: rootData
                                  })) {
                                    vErrors = vErrors === null ? validate31.errors : vErrors.concat(validate31.errors);
                                    errors = vErrors.length;
                                  }
                                  var valid11 = _errs52 === errors;
                                  if (!valid11) {
                                    break;
                                  }
                                }
                              } else {
                                validate26.errors = [{
                                  instancePath: instancePath + '/transaction/inputs',
                                  schemaPath: '#/properties/transaction/properties/inputs/type',
                                  keyword: 'type',
                                  params: {
                                    type: 'array'
                                  },
                                  message: 'must be array'
                                }];
                                return false;
                              }
                            }
                            var valid10 = _errs50 === errors;
                          } else {
                            var valid10 = true;
                          }
                          if (valid10) {
                            if (data19.locktime !== undefined) {
                              var data22 = data19.locktime;
                              var _errs53 = errors;
                              if (!(typeof data22 == 'number' && isFinite(data22))) {
                                validate26.errors = [{
                                  instancePath: instancePath + '/transaction/locktime',
                                  schemaPath: '#/properties/transaction/properties/locktime/type',
                                  keyword: 'type',
                                  params: {
                                    type: 'number'
                                  },
                                  message: 'must be number'
                                }];
                                return false;
                              }
                              var valid10 = _errs53 === errors;
                            } else {
                              var valid10 = true;
                            }
                            if (valid10) {
                              if (data19.outputs !== undefined) {
                                var data23 = data19.outputs;
                                var _errs55 = errors;
                                if (errors === _errs55) {
                                  if (Array.isArray(data23)) {
                                    var valid12 = true;
                                    var len2 = data23.length;
                                    for (var i2 = 0; i2 < len2; i2++) {
                                      var _errs57 = errors;
                                      if (!validate34(data23[i2], {
                                        instancePath: instancePath + '/transaction/outputs/' + i2,
                                        parentData: data23,
                                        parentDataProperty: i2,
                                        rootData: rootData
                                      })) {
                                        vErrors = vErrors === null ? validate34.errors : vErrors.concat(validate34.errors);
                                        errors = vErrors.length;
                                      }
                                      var valid12 = _errs57 === errors;
                                      if (!valid12) {
                                        break;
                                      }
                                    }
                                  } else {
                                    validate26.errors = [{
                                      instancePath: instancePath + '/transaction/outputs',
                                      schemaPath: '#/properties/transaction/properties/outputs/type',
                                      keyword: 'type',
                                      params: {
                                        type: 'array'
                                      },
                                      message: 'must be array'
                                    }];
                                    return false;
                                  }
                                }
                                var valid10 = _errs55 === errors;
                              } else {
                                var valid10 = true;
                              }
                              if (valid10) {
                                if (data19.version !== undefined) {
                                  var data25 = data19.version;
                                  var _errs58 = errors;
                                  if (!(typeof data25 == 'number' && isFinite(data25))) {
                                    validate26.errors = [{
                                      instancePath: instancePath + '/transaction/version',
                                      schemaPath: '#/properties/transaction/properties/version/type',
                                      keyword: 'type',
                                      params: {
                                        type: 'number'
                                      },
                                      message: 'must be number'
                                    }];
                                    return false;
                                  }
                                  var valid10 = _errs58 === errors;
                                } else {
                                  var valid10 = true;
                                }
                              }
                            }
                          }
                        }
                      } else {
                        validate26.errors = [{
                          instancePath: instancePath + '/transaction',
                          schemaPath: '#/properties/transaction/type',
                          keyword: 'type',
                          params: {
                            type: 'object'
                          },
                          message: 'must be object'
                        }];
                        return false;
                      }
                    }
                    var valid0 = _errs47 === errors;
                  } else {
                    var valid0 = true;
                  }
                }
              }
            }
          }
        }
      }
    } else {
      validate26.errors = [{
        instancePath: instancePath,
        schemaPath: '#/type',
        keyword: 'type',
        params: {
          type: 'object'
        },
        message: 'must be object'
      }];
      return false;
    }
  }
  validate26.errors = vErrors;
  return errors === 0;
}
function validate38(data) {
  var _ref8 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
    _ref8$instancePath = _ref8.instancePath,
    instancePath = _ref8$instancePath === void 0 ? '' : _ref8$instancePath;
    _ref8.parentData;
    _ref8.parentDataProperty;
    _ref8.rootData;
  var vErrors = null;
  var errors = 0;
  {
    if (data && _typeof(data) == 'object' && !Array.isArray(data)) {
      var missing0;
      if (data.script === undefined && (missing0 = 'script') || data.tests === undefined && (missing0 = 'tests')) {
        validate38.errors = [{
          instancePath: instancePath,
          schemaPath: '#/required',
          keyword: 'required',
          params: {
            missingProperty: missing0
          },
          message: "must have required property '" + missing0 + "'"
        }];
        return false;
      } else {
        var _errs1 = errors;
        for (var key0 in data) {
          if (!(key0 === 'name' || key0 === 'pushed' || key0 === 'script' || key0 === 'tests')) {
            validate38.errors = [{
              instancePath: instancePath,
              schemaPath: '#/additionalProperties',
              keyword: 'additionalProperties',
              params: {
                additionalProperty: key0
              },
              message: 'must NOT have additional properties'
            }];
            return false;
          }
        }
        if (_errs1 === errors) {
          if (data.name !== undefined) {
            var _errs2 = errors;
            if (typeof data.name !== 'string') {
              validate38.errors = [{
                instancePath: instancePath + '/name',
                schemaPath: '#/properties/name/type',
                keyword: 'type',
                params: {
                  type: 'string'
                },
                message: 'must be string'
              }];
              return false;
            }
            var valid0 = _errs2 === errors;
          } else {
            var valid0 = true;
          }
          if (valid0) {
            if (data.pushed !== undefined) {
              var _errs4 = errors;
              if (typeof data.pushed !== 'boolean') {
                validate38.errors = [{
                  instancePath: instancePath + '/pushed',
                  schemaPath: '#/properties/pushed/type',
                  keyword: 'type',
                  params: {
                    type: 'boolean'
                  },
                  message: 'must be boolean'
                }];
                return false;
              }
              var valid0 = _errs4 === errors;
            } else {
              var valid0 = true;
            }
            if (valid0) {
              if (data.script !== undefined) {
                var _errs6 = errors;
                if (typeof data.script !== 'string') {
                  validate38.errors = [{
                    instancePath: instancePath + '/script',
                    schemaPath: '#/properties/script/type',
                    keyword: 'type',
                    params: {
                      type: 'string'
                    },
                    message: 'must be string'
                  }];
                  return false;
                }
                var valid0 = _errs6 === errors;
              } else {
                var valid0 = true;
              }
              if (valid0) {
                if (data.tests !== undefined) {
                  var data3 = data.tests;
                  var _errs8 = errors;
                  if (errors === _errs8) {
                    if (data3 && _typeof(data3) == 'object' && !Array.isArray(data3)) {
                      for (var key1 in data3) {
                        var data4 = data3[key1];
                        var _errs11 = errors;
                        var _errs12 = errors;
                        if (errors === _errs12) {
                          if (data4 && _typeof(data4) == 'object' && !Array.isArray(data4)) {
                            var missing1 = void 0;
                            if (data4.check === undefined && (missing1 = 'check')) {
                              validate38.errors = [{
                                instancePath: instancePath + '/tests/' + key1.replace(/~/g, '~0').replace(/\//g, '~1'),
                                schemaPath: '#/definitions/AuthenticationTemplateScriptTest/required',
                                keyword: 'required',
                                params: {
                                  missingProperty: missing1
                                },
                                message: "must have required property '" + missing1 + "'"
                              }];
                              return false;
                            } else {
                              var _errs14 = errors;
                              for (var key2 in data4) {
                                if (!(key2 === 'check' || key2 === 'fails' || key2 === 'invalid' || key2 === 'name' || key2 === 'passes' || key2 === 'setup')) {
                                  validate38.errors = [{
                                    instancePath: instancePath + '/tests/' + key1.replace(/~/g, '~0').replace(/\//g, '~1'),
                                    schemaPath: '#/definitions/AuthenticationTemplateScriptTest/additionalProperties',
                                    keyword: 'additionalProperties',
                                    params: {
                                      additionalProperty: key2
                                    },
                                    message: 'must NOT have additional properties'
                                  }];
                                  return false;
                                }
                              }
                              if (_errs14 === errors) {
                                if (data4.check !== undefined) {
                                  var _errs15 = errors;
                                  if (typeof data4.check !== 'string') {
                                    validate38.errors = [{
                                      instancePath: instancePath + '/tests/' + key1.replace(/~/g, '~0').replace(/\//g, '~1') + '/check',
                                      schemaPath: '#/definitions/AuthenticationTemplateScriptTest/properties/check/type',
                                      keyword: 'type',
                                      params: {
                                        type: 'string'
                                      },
                                      message: 'must be string'
                                    }];
                                    return false;
                                  }
                                  var valid3 = _errs15 === errors;
                                } else {
                                  var valid3 = true;
                                }
                                if (valid3) {
                                  if (data4.fails !== undefined) {
                                    var data6 = data4.fails;
                                    var _errs17 = errors;
                                    if (errors === _errs17) {
                                      if (Array.isArray(data6)) {
                                        var valid4 = true;
                                        var len0 = data6.length;
                                        for (var i0 = 0; i0 < len0; i0++) {
                                          var _errs19 = errors;
                                          if (typeof data6[i0] !== 'string') {
                                            validate38.errors = [{
                                              instancePath: instancePath + '/tests/' + key1.replace(/~/g, '~0').replace(/\//g, '~1') + '/fails/' + i0,
                                              schemaPath: '#/definitions/AuthenticationTemplateScriptTest/properties/fails/items/type',
                                              keyword: 'type',
                                              params: {
                                                type: 'string'
                                              },
                                              message: 'must be string'
                                            }];
                                            return false;
                                          }
                                          var valid4 = _errs19 === errors;
                                          if (!valid4) {
                                            break;
                                          }
                                        }
                                      } else {
                                        validate38.errors = [{
                                          instancePath: instancePath + '/tests/' + key1.replace(/~/g, '~0').replace(/\//g, '~1') + '/fails',
                                          schemaPath: '#/definitions/AuthenticationTemplateScriptTest/properties/fails/type',
                                          keyword: 'type',
                                          params: {
                                            type: 'array'
                                          },
                                          message: 'must be array'
                                        }];
                                        return false;
                                      }
                                    }
                                    var valid3 = _errs17 === errors;
                                  } else {
                                    var valid3 = true;
                                  }
                                  if (valid3) {
                                    if (data4.invalid !== undefined) {
                                      var data8 = data4.invalid;
                                      var _errs21 = errors;
                                      if (errors === _errs21) {
                                        if (Array.isArray(data8)) {
                                          var valid5 = true;
                                          var len1 = data8.length;
                                          for (var i1 = 0; i1 < len1; i1++) {
                                            var _errs23 = errors;
                                            if (typeof data8[i1] !== 'string') {
                                              validate38.errors = [{
                                                instancePath: instancePath + '/tests/' + key1.replace(/~/g, '~0').replace(/\//g, '~1') + '/invalid/' + i1,
                                                schemaPath: '#/definitions/AuthenticationTemplateScriptTest/properties/invalid/items/type',
                                                keyword: 'type',
                                                params: {
                                                  type: 'string'
                                                },
                                                message: 'must be string'
                                              }];
                                              return false;
                                            }
                                            var valid5 = _errs23 === errors;
                                            if (!valid5) {
                                              break;
                                            }
                                          }
                                        } else {
                                          validate38.errors = [{
                                            instancePath: instancePath + '/tests/' + key1.replace(/~/g, '~0').replace(/\//g, '~1') + '/invalid',
                                            schemaPath: '#/definitions/AuthenticationTemplateScriptTest/properties/invalid/type',
                                            keyword: 'type',
                                            params: {
                                              type: 'array'
                                            },
                                            message: 'must be array'
                                          }];
                                          return false;
                                        }
                                      }
                                      var valid3 = _errs21 === errors;
                                    } else {
                                      var valid3 = true;
                                    }
                                    if (valid3) {
                                      if (data4.name !== undefined) {
                                        var _errs25 = errors;
                                        if (typeof data4.name !== 'string') {
                                          validate38.errors = [{
                                            instancePath: instancePath + '/tests/' + key1.replace(/~/g, '~0').replace(/\//g, '~1') + '/name',
                                            schemaPath: '#/definitions/AuthenticationTemplateScriptTest/properties/name/type',
                                            keyword: 'type',
                                            params: {
                                              type: 'string'
                                            },
                                            message: 'must be string'
                                          }];
                                          return false;
                                        }
                                        var valid3 = _errs25 === errors;
                                      } else {
                                        var valid3 = true;
                                      }
                                      if (valid3) {
                                        if (data4.passes !== undefined) {
                                          var data11 = data4.passes;
                                          var _errs27 = errors;
                                          if (errors === _errs27) {
                                            if (Array.isArray(data11)) {
                                              var valid6 = true;
                                              var len2 = data11.length;
                                              for (var i2 = 0; i2 < len2; i2++) {
                                                var _errs29 = errors;
                                                if (typeof data11[i2] !== 'string') {
                                                  validate38.errors = [{
                                                    instancePath: instancePath + '/tests/' + key1.replace(/~/g, '~0').replace(/\//g, '~1') + '/passes/' + i2,
                                                    schemaPath: '#/definitions/AuthenticationTemplateScriptTest/properties/passes/items/type',
                                                    keyword: 'type',
                                                    params: {
                                                      type: 'string'
                                                    },
                                                    message: 'must be string'
                                                  }];
                                                  return false;
                                                }
                                                var valid6 = _errs29 === errors;
                                                if (!valid6) {
                                                  break;
                                                }
                                              }
                                            } else {
                                              validate38.errors = [{
                                                instancePath: instancePath + '/tests/' + key1.replace(/~/g, '~0').replace(/\//g, '~1') + '/passes',
                                                schemaPath: '#/definitions/AuthenticationTemplateScriptTest/properties/passes/type',
                                                keyword: 'type',
                                                params: {
                                                  type: 'array'
                                                },
                                                message: 'must be array'
                                              }];
                                              return false;
                                            }
                                          }
                                          var valid3 = _errs27 === errors;
                                        } else {
                                          var valid3 = true;
                                        }
                                        if (valid3) {
                                          if (data4.setup !== undefined) {
                                            var _errs31 = errors;
                                            if (typeof data4.setup !== 'string') {
                                              validate38.errors = [{
                                                instancePath: instancePath + '/tests/' + key1.replace(/~/g, '~0').replace(/\//g, '~1') + '/setup',
                                                schemaPath: '#/definitions/AuthenticationTemplateScriptTest/properties/setup/type',
                                                keyword: 'type',
                                                params: {
                                                  type: 'string'
                                                },
                                                message: 'must be string'
                                              }];
                                              return false;
                                            }
                                            var valid3 = _errs31 === errors;
                                          } else {
                                            var valid3 = true;
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          } else {
                            validate38.errors = [{
                              instancePath: instancePath + '/tests/' + key1.replace(/~/g, '~0').replace(/\//g, '~1'),
                              schemaPath: '#/definitions/AuthenticationTemplateScriptTest/type',
                              keyword: 'type',
                              params: {
                                type: 'object'
                              },
                              message: 'must be object'
                            }];
                            return false;
                          }
                        }
                        var valid1 = _errs11 === errors;
                        if (!valid1) {
                          break;
                        }
                      }
                    } else {
                      validate38.errors = [{
                        instancePath: instancePath + '/tests',
                        schemaPath: '#/properties/tests/type',
                        keyword: 'type',
                        params: {
                          type: 'object'
                        },
                        message: 'must be object'
                      }];
                      return false;
                    }
                  }
                  var valid0 = _errs8 === errors;
                } else {
                  var valid0 = true;
                }
              }
            }
          }
        }
      }
    } else {
      validate38.errors = [{
        instancePath: instancePath,
        schemaPath: '#/type',
        keyword: 'type',
        params: {
          type: 'object'
        },
        message: 'must be object'
      }];
      return false;
    }
  }
  validate38.errors = vErrors;
  return errors === 0;
}
var func4 = Object.prototype.hasOwnProperty;
function validate21(data) {
  var _ref9 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
    _ref9$instancePath = _ref9.instancePath,
    instancePath = _ref9$instancePath === void 0 ? '' : _ref9$instancePath;
    _ref9.parentData;
    _ref9.parentDataProperty;
    var _ref9$rootData = _ref9.rootData,
    rootData = _ref9$rootData === void 0 ? data : _ref9$rootData;
  var vErrors = null;
  var errors = 0;
  if (errors === 0) {
    if (data && _typeof(data) == 'object' && !Array.isArray(data)) {
      var missing0;
      if (data.entities === undefined && (missing0 = 'entities') || data.scripts === undefined && (missing0 = 'scripts') || data.supported === undefined && (missing0 = 'supported') || data.version === undefined && (missing0 = 'version')) {
        validate21.errors = [{
          instancePath: instancePath,
          schemaPath: '#/required',
          keyword: 'required',
          params: {
            missingProperty: missing0
          },
          message: "must have required property '" + missing0 + "'"
        }];
        return false;
      } else {
        var _errs1 = errors;
        for (var key0 in data) {
          if (!(key0 === '$schema' || key0 === 'description' || key0 === 'entities' || key0 === 'name' || key0 === 'scenarios' || key0 === 'scripts' || key0 === 'supported' || key0 === 'version')) {
            validate21.errors = [{
              instancePath: instancePath,
              schemaPath: '#/additionalProperties',
              keyword: 'additionalProperties',
              params: {
                additionalProperty: key0
              },
              message: 'must NOT have additional properties'
            }];
            return false;
          }
        }
        if (_errs1 === errors) {
          if (data.$schema !== undefined) {
            var _errs2 = errors;
            if (typeof data.$schema !== 'string') {
              validate21.errors = [{
                instancePath: instancePath + '/$schema',
                schemaPath: '#/properties/%24schema/type',
                keyword: 'type',
                params: {
                  type: 'string'
                },
                message: 'must be string'
              }];
              return false;
            }
            var valid0 = _errs2 === errors;
          } else {
            var valid0 = true;
          }
          if (valid0) {
            if (data.description !== undefined) {
              var _errs4 = errors;
              if (typeof data.description !== 'string') {
                validate21.errors = [{
                  instancePath: instancePath + '/description',
                  schemaPath: '#/properties/description/type',
                  keyword: 'type',
                  params: {
                    type: 'string'
                  },
                  message: 'must be string'
                }];
                return false;
              }
              var valid0 = _errs4 === errors;
            } else {
              var valid0 = true;
            }
            if (valid0) {
              if (data.entities !== undefined) {
                var data2 = data.entities;
                var _errs6 = errors;
                if (errors === _errs6) {
                  if (data2 && _typeof(data2) == 'object' && !Array.isArray(data2)) {
                    for (var key1 in data2) {
                      var _errs9 = errors;
                      if (!validate22(data2[key1], {
                        instancePath: instancePath + '/entities/' + key1.replace(/~/g, '~0').replace(/\//g, '~1'),
                        parentData: data2,
                        parentDataProperty: key1,
                        rootData: rootData
                      })) {
                        vErrors = vErrors === null ? validate22.errors : vErrors.concat(validate22.errors);
                        errors = vErrors.length;
                      }
                      var valid1 = _errs9 === errors;
                      if (!valid1) {
                        break;
                      }
                    }
                  } else {
                    validate21.errors = [{
                      instancePath: instancePath + '/entities',
                      schemaPath: '#/properties/entities/type',
                      keyword: 'type',
                      params: {
                        type: 'object'
                      },
                      message: 'must be object'
                    }];
                    return false;
                  }
                }
                var valid0 = _errs6 === errors;
              } else {
                var valid0 = true;
              }
              if (valid0) {
                if (data.name !== undefined) {
                  var _errs10 = errors;
                  if (typeof data.name !== 'string') {
                    validate21.errors = [{
                      instancePath: instancePath + '/name',
                      schemaPath: '#/properties/name/type',
                      keyword: 'type',
                      params: {
                        type: 'string'
                      },
                      message: 'must be string'
                    }];
                    return false;
                  }
                  var valid0 = _errs10 === errors;
                } else {
                  var valid0 = true;
                }
                if (valid0) {
                  if (data.scenarios !== undefined) {
                    var data5 = data.scenarios;
                    var _errs12 = errors;
                    if (errors === _errs12) {
                      if (data5 && _typeof(data5) == 'object' && !Array.isArray(data5)) {
                        for (var key2 in data5) {
                          var _errs15 = errors;
                          if (!validate26(data5[key2], {
                            instancePath: instancePath + '/scenarios/' + key2.replace(/~/g, '~0').replace(/\//g, '~1'),
                            parentData: data5,
                            parentDataProperty: key2,
                            rootData: rootData
                          })) {
                            vErrors = vErrors === null ? validate26.errors : vErrors.concat(validate26.errors);
                            errors = vErrors.length;
                          }
                          var valid2 = _errs15 === errors;
                          if (!valid2) {
                            break;
                          }
                        }
                      } else {
                        validate21.errors = [{
                          instancePath: instancePath + '/scenarios',
                          schemaPath: '#/properties/scenarios/type',
                          keyword: 'type',
                          params: {
                            type: 'object'
                          },
                          message: 'must be object'
                        }];
                        return false;
                      }
                    }
                    var valid0 = _errs12 === errors;
                  } else {
                    var valid0 = true;
                  }
                  if (valid0) {
                    if (data.scripts !== undefined) {
                      var data7 = data.scripts;
                      var _errs16 = errors;
                      if (errors === _errs16) {
                        if (data7 && _typeof(data7) == 'object' && !Array.isArray(data7)) {
                          for (var key3 in data7) {
                            var data8 = data7[key3];
                            var _errs19 = errors;
                            var _errs20 = errors;
                            var valid4 = false;
                            var _errs21 = errors;
                            var _errs22 = errors;
                            if (errors === _errs22) {
                              if (data8 && _typeof(data8) == 'object' && !Array.isArray(data8)) {
                                var missing1 = void 0;
                                if (data8.script === undefined && (missing1 = 'script')) {
                                  var err0 = {
                                    instancePath: instancePath + '/scripts/' + key3.replace(/~/g, '~0').replace(/\//g, '~1'),
                                    schemaPath: '#/definitions/AuthenticationTemplateScript/required',
                                    keyword: 'required',
                                    params: {
                                      missingProperty: missing1
                                    },
                                    message: "must have required property '" + missing1 + "'"
                                  };
                                  if (vErrors === null) {
                                    vErrors = [err0];
                                  } else {
                                    vErrors.push(err0);
                                  }
                                  errors++;
                                } else {
                                  var _errs24 = errors;
                                  for (var key4 in data8) {
                                    if (!(key4 === 'name' || key4 === 'script')) {
                                      var err1 = {
                                        instancePath: instancePath + '/scripts/' + key3.replace(/~/g, '~0').replace(/\//g, '~1'),
                                        schemaPath: '#/definitions/AuthenticationTemplateScript/additionalProperties',
                                        keyword: 'additionalProperties',
                                        params: {
                                          additionalProperty: key4
                                        },
                                        message: 'must NOT have additional properties'
                                      };
                                      if (vErrors === null) {
                                        vErrors = [err1];
                                      } else {
                                        vErrors.push(err1);
                                      }
                                      errors++;
                                      break;
                                    }
                                  }
                                  if (_errs24 === errors) {
                                    if (data8.name !== undefined) {
                                      var _errs25 = errors;
                                      if (typeof data8.name !== 'string') {
                                        var err2 = {
                                          instancePath: instancePath + '/scripts/' + key3.replace(/~/g, '~0').replace(/\//g, '~1') + '/name',
                                          schemaPath: '#/definitions/AuthenticationTemplateScript/properties/name/type',
                                          keyword: 'type',
                                          params: {
                                            type: 'string'
                                          },
                                          message: 'must be string'
                                        };
                                        if (vErrors === null) {
                                          vErrors = [err2];
                                        } else {
                                          vErrors.push(err2);
                                        }
                                        errors++;
                                      }
                                      var valid6 = _errs25 === errors;
                                    } else {
                                      var valid6 = true;
                                    }
                                    if (valid6) {
                                      if (data8.script !== undefined) {
                                        var _errs27 = errors;
                                        if (typeof data8.script !== 'string') {
                                          var err3 = {
                                            instancePath: instancePath + '/scripts/' + key3.replace(/~/g, '~0').replace(/\//g, '~1') + '/script',
                                            schemaPath: '#/definitions/AuthenticationTemplateScript/properties/script/type',
                                            keyword: 'type',
                                            params: {
                                              type: 'string'
                                            },
                                            message: 'must be string'
                                          };
                                          if (vErrors === null) {
                                            vErrors = [err3];
                                          } else {
                                            vErrors.push(err3);
                                          }
                                          errors++;
                                        }
                                        var valid6 = _errs27 === errors;
                                      } else {
                                        var valid6 = true;
                                      }
                                    }
                                  }
                                }
                              } else {
                                var err4 = {
                                  instancePath: instancePath + '/scripts/' + key3.replace(/~/g, '~0').replace(/\//g, '~1'),
                                  schemaPath: '#/definitions/AuthenticationTemplateScript/type',
                                  keyword: 'type',
                                  params: {
                                    type: 'object'
                                  },
                                  message: 'must be object'
                                };
                                if (vErrors === null) {
                                  vErrors = [err4];
                                } else {
                                  vErrors.push(err4);
                                }
                                errors++;
                              }
                            }
                            var _valid0 = _errs21 === errors;
                            valid4 = valid4 || _valid0;
                            if (!valid4) {
                              var _errs29 = errors;
                              var _errs30 = errors;
                              if (errors === _errs30) {
                                if (data8 && _typeof(data8) == 'object' && !Array.isArray(data8)) {
                                  var missing2 = void 0;
                                  if (data8.lockingType === undefined && (missing2 = 'lockingType') || data8.script === undefined && (missing2 = 'script')) {
                                    var err5 = {
                                      instancePath: instancePath + '/scripts/' + key3.replace(/~/g, '~0').replace(/\//g, '~1'),
                                      schemaPath: '#/definitions/AuthenticationTemplateScriptLocking/required',
                                      keyword: 'required',
                                      params: {
                                        missingProperty: missing2
                                      },
                                      message: "must have required property '" + missing2 + "'"
                                    };
                                    if (vErrors === null) {
                                      vErrors = [err5];
                                    } else {
                                      vErrors.push(err5);
                                    }
                                    errors++;
                                  } else {
                                    var _errs32 = errors;
                                    for (var key5 in data8) {
                                      if (!(key5 === 'lockingType' || key5 === 'name' || key5 === 'script')) {
                                        var err6 = {
                                          instancePath: instancePath + '/scripts/' + key3.replace(/~/g, '~0').replace(/\//g, '~1'),
                                          schemaPath: '#/definitions/AuthenticationTemplateScriptLocking/additionalProperties',
                                          keyword: 'additionalProperties',
                                          params: {
                                            additionalProperty: key5
                                          },
                                          message: 'must NOT have additional properties'
                                        };
                                        if (vErrors === null) {
                                          vErrors = [err6];
                                        } else {
                                          vErrors.push(err6);
                                        }
                                        errors++;
                                        break;
                                      }
                                    }
                                    if (_errs32 === errors) {
                                      if (data8.lockingType !== undefined) {
                                        var data11 = data8.lockingType;
                                        var _errs33 = errors;
                                        if (typeof data11 !== 'string') {
                                          var err7 = {
                                            instancePath: instancePath + '/scripts/' + key3.replace(/~/g, '~0').replace(/\//g, '~1') + '/lockingType',
                                            schemaPath: '#/definitions/AuthenticationTemplateScriptLocking/properties/lockingType/type',
                                            keyword: 'type',
                                            params: {
                                              type: 'string'
                                            },
                                            message: 'must be string'
                                          };
                                          if (vErrors === null) {
                                            vErrors = [err7];
                                          } else {
                                            vErrors.push(err7);
                                          }
                                          errors++;
                                        }
                                        if (!(data11 === 'p2sh20' || data11 === 'p2sh32' || data11 === 'standard')) {
                                          var err8 = {
                                            instancePath: instancePath + '/scripts/' + key3.replace(/~/g, '~0').replace(/\//g, '~1') + '/lockingType',
                                            schemaPath: '#/definitions/AuthenticationTemplateScriptLocking/properties/lockingType/enum',
                                            keyword: 'enum',
                                            params: {
                                              allowedValues: schema38.properties.lockingType.enum
                                            },
                                            message: 'must be equal to one of the allowed values'
                                          };
                                          if (vErrors === null) {
                                            vErrors = [err8];
                                          } else {
                                            vErrors.push(err8);
                                          }
                                          errors++;
                                        }
                                        var valid8 = _errs33 === errors;
                                      } else {
                                        var valid8 = true;
                                      }
                                      if (valid8) {
                                        if (data8.name !== undefined) {
                                          var _errs35 = errors;
                                          if (typeof data8.name !== 'string') {
                                            var err9 = {
                                              instancePath: instancePath + '/scripts/' + key3.replace(/~/g, '~0').replace(/\//g, '~1') + '/name',
                                              schemaPath: '#/definitions/AuthenticationTemplateScriptLocking/properties/name/type',
                                              keyword: 'type',
                                              params: {
                                                type: 'string'
                                              },
                                              message: 'must be string'
                                            };
                                            if (vErrors === null) {
                                              vErrors = [err9];
                                            } else {
                                              vErrors.push(err9);
                                            }
                                            errors++;
                                          }
                                          var valid8 = _errs35 === errors;
                                        } else {
                                          var valid8 = true;
                                        }
                                        if (valid8) {
                                          if (data8.script !== undefined) {
                                            var _errs37 = errors;
                                            if (typeof data8.script !== 'string') {
                                              var err10 = {
                                                instancePath: instancePath + '/scripts/' + key3.replace(/~/g, '~0').replace(/\//g, '~1') + '/script',
                                                schemaPath: '#/definitions/AuthenticationTemplateScriptLocking/properties/script/type',
                                                keyword: 'type',
                                                params: {
                                                  type: 'string'
                                                },
                                                message: 'must be string'
                                              };
                                              if (vErrors === null) {
                                                vErrors = [err10];
                                              } else {
                                                vErrors.push(err10);
                                              }
                                              errors++;
                                            }
                                            var valid8 = _errs37 === errors;
                                          } else {
                                            var valid8 = true;
                                          }
                                        }
                                      }
                                    }
                                  }
                                } else {
                                  var err11 = {
                                    instancePath: instancePath + '/scripts/' + key3.replace(/~/g, '~0').replace(/\//g, '~1'),
                                    schemaPath: '#/definitions/AuthenticationTemplateScriptLocking/type',
                                    keyword: 'type',
                                    params: {
                                      type: 'object'
                                    },
                                    message: 'must be object'
                                  };
                                  if (vErrors === null) {
                                    vErrors = [err11];
                                  } else {
                                    vErrors.push(err11);
                                  }
                                  errors++;
                                }
                              }
                              var _valid0 = _errs29 === errors;
                              valid4 = valid4 || _valid0;
                              if (!valid4) {
                                var _errs39 = errors;
                                if (!validate38(data8, {
                                  instancePath: instancePath + '/scripts/' + key3.replace(/~/g, '~0').replace(/\//g, '~1'),
                                  parentData: data7,
                                  parentDataProperty: key3,
                                  rootData: rootData
                                })) {
                                  vErrors = vErrors === null ? validate38.errors : vErrors.concat(validate38.errors);
                                  errors = vErrors.length;
                                }
                                var _valid0 = _errs39 === errors;
                                valid4 = valid4 || _valid0;
                                if (!valid4) {
                                  var _errs40 = errors;
                                  var _errs41 = errors;
                                  if (errors === _errs41) {
                                    if (data8 && _typeof(data8) == 'object' && !Array.isArray(data8)) {
                                      var missing3 = void 0;
                                      if (data8.script === undefined && (missing3 = 'script') || data8.unlocks === undefined && (missing3 = 'unlocks')) {
                                        var err12 = {
                                          instancePath: instancePath + '/scripts/' + key3.replace(/~/g, '~0').replace(/\//g, '~1'),
                                          schemaPath: '#/definitions/AuthenticationTemplateScriptUnlocking/required',
                                          keyword: 'required',
                                          params: {
                                            missingProperty: missing3
                                          },
                                          message: "must have required property '" + missing3 + "'"
                                        };
                                        if (vErrors === null) {
                                          vErrors = [err12];
                                        } else {
                                          vErrors.push(err12);
                                        }
                                        errors++;
                                      } else {
                                        var _errs43 = errors;
                                        for (var key6 in data8) {
                                          if (!func4.call(schema41.properties, key6)) {
                                            var err13 = {
                                              instancePath: instancePath + '/scripts/' + key3.replace(/~/g, '~0').replace(/\//g, '~1'),
                                              schemaPath: '#/definitions/AuthenticationTemplateScriptUnlocking/additionalProperties',
                                              keyword: 'additionalProperties',
                                              params: {
                                                additionalProperty: key6
                                              },
                                              message: 'must NOT have additional properties'
                                            };
                                            if (vErrors === null) {
                                              vErrors = [err13];
                                            } else {
                                              vErrors.push(err13);
                                            }
                                            errors++;
                                            break;
                                          }
                                        }
                                        if (_errs43 === errors) {
                                          if (data8.ageLock !== undefined) {
                                            var _errs44 = errors;
                                            if (typeof data8.ageLock !== 'string') {
                                              var err14 = {
                                                instancePath: instancePath + '/scripts/' + key3.replace(/~/g, '~0').replace(/\//g, '~1') + '/ageLock',
                                                schemaPath: '#/definitions/AuthenticationTemplateScriptUnlocking/properties/ageLock/type',
                                                keyword: 'type',
                                                params: {
                                                  type: 'string'
                                                },
                                                message: 'must be string'
                                              };
                                              if (vErrors === null) {
                                                vErrors = [err14];
                                              } else {
                                                vErrors.push(err14);
                                              }
                                              errors++;
                                            }
                                            var valid10 = _errs44 === errors;
                                          } else {
                                            var valid10 = true;
                                          }
                                          if (valid10) {
                                            if (data8.estimate !== undefined) {
                                              var _errs46 = errors;
                                              if (typeof data8.estimate !== 'string') {
                                                var err15 = {
                                                  instancePath: instancePath + '/scripts/' + key3.replace(/~/g, '~0').replace(/\//g, '~1') + '/estimate',
                                                  schemaPath: '#/definitions/AuthenticationTemplateScriptUnlocking/properties/estimate/type',
                                                  keyword: 'type',
                                                  params: {
                                                    type: 'string'
                                                  },
                                                  message: 'must be string'
                                                };
                                                if (vErrors === null) {
                                                  vErrors = [err15];
                                                } else {
                                                  vErrors.push(err15);
                                                }
                                                errors++;
                                              }
                                              var valid10 = _errs46 === errors;
                                            } else {
                                              var valid10 = true;
                                            }
                                            if (valid10) {
                                              if (data8.fails !== undefined) {
                                                var data16 = data8.fails;
                                                var _errs48 = errors;
                                                if (errors === _errs48) {
                                                  if (Array.isArray(data16)) {
                                                    var valid11 = true;
                                                    var len0 = data16.length;
                                                    for (var i0 = 0; i0 < len0; i0++) {
                                                      var _errs50 = errors;
                                                      if (typeof data16[i0] !== 'string') {
                                                        var err16 = {
                                                          instancePath: instancePath + '/scripts/' + key3.replace(/~/g, '~0').replace(/\//g, '~1') + '/fails/' + i0,
                                                          schemaPath: '#/definitions/AuthenticationTemplateScriptUnlocking/properties/fails/items/type',
                                                          keyword: 'type',
                                                          params: {
                                                            type: 'string'
                                                          },
                                                          message: 'must be string'
                                                        };
                                                        if (vErrors === null) {
                                                          vErrors = [err16];
                                                        } else {
                                                          vErrors.push(err16);
                                                        }
                                                        errors++;
                                                      }
                                                      var valid11 = _errs50 === errors;
                                                      if (!valid11) {
                                                        break;
                                                      }
                                                    }
                                                  } else {
                                                    var err17 = {
                                                      instancePath: instancePath + '/scripts/' + key3.replace(/~/g, '~0').replace(/\//g, '~1') + '/fails',
                                                      schemaPath: '#/definitions/AuthenticationTemplateScriptUnlocking/properties/fails/type',
                                                      keyword: 'type',
                                                      params: {
                                                        type: 'array'
                                                      },
                                                      message: 'must be array'
                                                    };
                                                    if (vErrors === null) {
                                                      vErrors = [err17];
                                                    } else {
                                                      vErrors.push(err17);
                                                    }
                                                    errors++;
                                                  }
                                                }
                                                var valid10 = _errs48 === errors;
                                              } else {
                                                var valid10 = true;
                                              }
                                              if (valid10) {
                                                if (data8.invalid !== undefined) {
                                                  var data18 = data8.invalid;
                                                  var _errs52 = errors;
                                                  if (errors === _errs52) {
                                                    if (Array.isArray(data18)) {
                                                      var valid12 = true;
                                                      var len1 = data18.length;
                                                      for (var i1 = 0; i1 < len1; i1++) {
                                                        var _errs54 = errors;
                                                        if (typeof data18[i1] !== 'string') {
                                                          var err18 = {
                                                            instancePath: instancePath + '/scripts/' + key3.replace(/~/g, '~0').replace(/\//g, '~1') + '/invalid/' + i1,
                                                            schemaPath: '#/definitions/AuthenticationTemplateScriptUnlocking/properties/invalid/items/type',
                                                            keyword: 'type',
                                                            params: {
                                                              type: 'string'
                                                            },
                                                            message: 'must be string'
                                                          };
                                                          if (vErrors === null) {
                                                            vErrors = [err18];
                                                          } else {
                                                            vErrors.push(err18);
                                                          }
                                                          errors++;
                                                        }
                                                        var valid12 = _errs54 === errors;
                                                        if (!valid12) {
                                                          break;
                                                        }
                                                      }
                                                    } else {
                                                      var err19 = {
                                                        instancePath: instancePath + '/scripts/' + key3.replace(/~/g, '~0').replace(/\//g, '~1') + '/invalid',
                                                        schemaPath: '#/definitions/AuthenticationTemplateScriptUnlocking/properties/invalid/type',
                                                        keyword: 'type',
                                                        params: {
                                                          type: 'array'
                                                        },
                                                        message: 'must be array'
                                                      };
                                                      if (vErrors === null) {
                                                        vErrors = [err19];
                                                      } else {
                                                        vErrors.push(err19);
                                                      }
                                                      errors++;
                                                    }
                                                  }
                                                  var valid10 = _errs52 === errors;
                                                } else {
                                                  var valid10 = true;
                                                }
                                                if (valid10) {
                                                  if (data8.name !== undefined) {
                                                    var _errs56 = errors;
                                                    if (typeof data8.name !== 'string') {
                                                      var err20 = {
                                                        instancePath: instancePath + '/scripts/' + key3.replace(/~/g, '~0').replace(/\//g, '~1') + '/name',
                                                        schemaPath: '#/definitions/AuthenticationTemplateScriptUnlocking/properties/name/type',
                                                        keyword: 'type',
                                                        params: {
                                                          type: 'string'
                                                        },
                                                        message: 'must be string'
                                                      };
                                                      if (vErrors === null) {
                                                        vErrors = [err20];
                                                      } else {
                                                        vErrors.push(err20);
                                                      }
                                                      errors++;
                                                    }
                                                    var valid10 = _errs56 === errors;
                                                  } else {
                                                    var valid10 = true;
                                                  }
                                                  if (valid10) {
                                                    if (data8.passes !== undefined) {
                                                      var data21 = data8.passes;
                                                      var _errs58 = errors;
                                                      if (errors === _errs58) {
                                                        if (Array.isArray(data21)) {
                                                          var valid13 = true;
                                                          var len2 = data21.length;
                                                          for (var i2 = 0; i2 < len2; i2++) {
                                                            var _errs60 = errors;
                                                            if (typeof data21[i2] !== 'string') {
                                                              var err21 = {
                                                                instancePath: instancePath + '/scripts/' + key3.replace(/~/g, '~0').replace(/\//g, '~1') + '/passes/' + i2,
                                                                schemaPath: '#/definitions/AuthenticationTemplateScriptUnlocking/properties/passes/items/type',
                                                                keyword: 'type',
                                                                params: {
                                                                  type: 'string'
                                                                },
                                                                message: 'must be string'
                                                              };
                                                              if (vErrors === null) {
                                                                vErrors = [err21];
                                                              } else {
                                                                vErrors.push(err21);
                                                              }
                                                              errors++;
                                                            }
                                                            var valid13 = _errs60 === errors;
                                                            if (!valid13) {
                                                              break;
                                                            }
                                                          }
                                                        } else {
                                                          var err22 = {
                                                            instancePath: instancePath + '/scripts/' + key3.replace(/~/g, '~0').replace(/\//g, '~1') + '/passes',
                                                            schemaPath: '#/definitions/AuthenticationTemplateScriptUnlocking/properties/passes/type',
                                                            keyword: 'type',
                                                            params: {
                                                              type: 'array'
                                                            },
                                                            message: 'must be array'
                                                          };
                                                          if (vErrors === null) {
                                                            vErrors = [err22];
                                                          } else {
                                                            vErrors.push(err22);
                                                          }
                                                          errors++;
                                                        }
                                                      }
                                                      var valid10 = _errs58 === errors;
                                                    } else {
                                                      var valid10 = true;
                                                    }
                                                    if (valid10) {
                                                      if (data8.script !== undefined) {
                                                        var _errs62 = errors;
                                                        if (typeof data8.script !== 'string') {
                                                          var err23 = {
                                                            instancePath: instancePath + '/scripts/' + key3.replace(/~/g, '~0').replace(/\//g, '~1') + '/script',
                                                            schemaPath: '#/definitions/AuthenticationTemplateScriptUnlocking/properties/script/type',
                                                            keyword: 'type',
                                                            params: {
                                                              type: 'string'
                                                            },
                                                            message: 'must be string'
                                                          };
                                                          if (vErrors === null) {
                                                            vErrors = [err23];
                                                          } else {
                                                            vErrors.push(err23);
                                                          }
                                                          errors++;
                                                        }
                                                        var valid10 = _errs62 === errors;
                                                      } else {
                                                        var valid10 = true;
                                                      }
                                                      if (valid10) {
                                                        if (data8.timeLockType !== undefined) {
                                                          var data24 = data8.timeLockType;
                                                          var _errs64 = errors;
                                                          if (typeof data24 !== 'string') {
                                                            var err24 = {
                                                              instancePath: instancePath + '/scripts/' + key3.replace(/~/g, '~0').replace(/\//g, '~1') + '/timeLockType',
                                                              schemaPath: '#/definitions/AuthenticationTemplateScriptUnlocking/properties/timeLockType/type',
                                                              keyword: 'type',
                                                              params: {
                                                                type: 'string'
                                                              },
                                                              message: 'must be string'
                                                            };
                                                            if (vErrors === null) {
                                                              vErrors = [err24];
                                                            } else {
                                                              vErrors.push(err24);
                                                            }
                                                            errors++;
                                                          }
                                                          if (!(data24 === 'height' || data24 === 'timestamp')) {
                                                            var err25 = {
                                                              instancePath: instancePath + '/scripts/' + key3.replace(/~/g, '~0').replace(/\//g, '~1') + '/timeLockType',
                                                              schemaPath: '#/definitions/AuthenticationTemplateScriptUnlocking/properties/timeLockType/enum',
                                                              keyword: 'enum',
                                                              params: {
                                                                allowedValues: schema41.properties.timeLockType.enum
                                                              },
                                                              message: 'must be equal to one of the allowed values'
                                                            };
                                                            if (vErrors === null) {
                                                              vErrors = [err25];
                                                            } else {
                                                              vErrors.push(err25);
                                                            }
                                                            errors++;
                                                          }
                                                          var valid10 = _errs64 === errors;
                                                        } else {
                                                          var valid10 = true;
                                                        }
                                                        if (valid10) {
                                                          if (data8.unlocks !== undefined) {
                                                            var _errs66 = errors;
                                                            if (typeof data8.unlocks !== 'string') {
                                                              var err26 = {
                                                                instancePath: instancePath + '/scripts/' + key3.replace(/~/g, '~0').replace(/\//g, '~1') + '/unlocks',
                                                                schemaPath: '#/definitions/AuthenticationTemplateScriptUnlocking/properties/unlocks/type',
                                                                keyword: 'type',
                                                                params: {
                                                                  type: 'string'
                                                                },
                                                                message: 'must be string'
                                                              };
                                                              if (vErrors === null) {
                                                                vErrors = [err26];
                                                              } else {
                                                                vErrors.push(err26);
                                                              }
                                                              errors++;
                                                            }
                                                            var valid10 = _errs66 === errors;
                                                          } else {
                                                            var valid10 = true;
                                                          }
                                                        }
                                                      }
                                                    }
                                                  }
                                                }
                                              }
                                            }
                                          }
                                        }
                                      }
                                    } else {
                                      var err27 = {
                                        instancePath: instancePath + '/scripts/' + key3.replace(/~/g, '~0').replace(/\//g, '~1'),
                                        schemaPath: '#/definitions/AuthenticationTemplateScriptUnlocking/type',
                                        keyword: 'type',
                                        params: {
                                          type: 'object'
                                        },
                                        message: 'must be object'
                                      };
                                      if (vErrors === null) {
                                        vErrors = [err27];
                                      } else {
                                        vErrors.push(err27);
                                      }
                                      errors++;
                                    }
                                  }
                                  var _valid0 = _errs40 === errors;
                                  valid4 = valid4 || _valid0;
                                }
                              }
                            }
                            if (!valid4) {
                              var err28 = {
                                instancePath: instancePath + '/scripts/' + key3.replace(/~/g, '~0').replace(/\//g, '~1'),
                                schemaPath: '#/properties/scripts/additionalProperties/anyOf',
                                keyword: 'anyOf',
                                params: {},
                                message: 'must match a schema in anyOf'
                              };
                              if (vErrors === null) {
                                vErrors = [err28];
                              } else {
                                vErrors.push(err28);
                              }
                              errors++;
                              validate21.errors = vErrors;
                              return false;
                            } else {
                              errors = _errs20;
                              if (vErrors !== null) {
                                if (_errs20) {
                                  vErrors.length = _errs20;
                                } else {
                                  vErrors = null;
                                }
                              }
                            }
                            var valid3 = _errs19 === errors;
                            if (!valid3) {
                              break;
                            }
                          }
                        } else {
                          validate21.errors = [{
                            instancePath: instancePath + '/scripts',
                            schemaPath: '#/properties/scripts/type',
                            keyword: 'type',
                            params: {
                              type: 'object'
                            },
                            message: 'must be object'
                          }];
                          return false;
                        }
                      }
                      var valid0 = _errs16 === errors;
                    } else {
                      var valid0 = true;
                    }
                    if (valid0) {
                      if (data.supported !== undefined) {
                        var data26 = data.supported;
                        var _errs68 = errors;
                        if (errors === _errs68) {
                          if (Array.isArray(data26)) {
                            var valid14 = true;
                            var len3 = data26.length;
                            for (var i3 = 0; i3 < len3; i3++) {
                              var data27 = data26[i3];
                              var _errs70 = errors;
                              if (typeof data27 !== 'string') {
                                validate21.errors = [{
                                  instancePath: instancePath + '/supported/' + i3,
                                  schemaPath: '#/definitions/AuthenticationVirtualMachineIdentifier/type',
                                  keyword: 'type',
                                  params: {
                                    type: 'string'
                                  },
                                  message: 'must be string'
                                }];
                                return false;
                              }
                              if (!(data27 === 'BCH_2020_05' || data27 === 'BCH_2021_05' || data27 === 'BCH_2022_05' || data27 === 'BCH_2023_05' || data27 === 'BCH_SPEC' || data27 === 'BSV_2020_02' || data27 === 'BSV_SPEC' || data27 === 'BTC_2017_08' || data27 === 'BTC_SPEC' || data27 === 'XEC_2020_05' || data27 === 'XEC_SPEC')) {
                                validate21.errors = [{
                                  instancePath: instancePath + '/supported/' + i3,
                                  schemaPath: '#/definitions/AuthenticationVirtualMachineIdentifier/enum',
                                  keyword: 'enum',
                                  params: {
                                    allowedValues: schema42.enum
                                  },
                                  message: 'must be equal to one of the allowed values'
                                }];
                                return false;
                              }
                              var valid14 = _errs70 === errors;
                              if (!valid14) {
                                break;
                              }
                            }
                          } else {
                            validate21.errors = [{
                              instancePath: instancePath + '/supported',
                              schemaPath: '#/properties/supported/type',
                              keyword: 'type',
                              params: {
                                type: 'array'
                              },
                              message: 'must be array'
                            }];
                            return false;
                          }
                        }
                        var valid0 = _errs68 === errors;
                      } else {
                        var valid0 = true;
                      }
                      if (valid0) {
                        if (data.version !== undefined) {
                          var data28 = data.version;
                          var _errs73 = errors;
                          if (!(typeof data28 == 'number' && isFinite(data28))) {
                            validate21.errors = [{
                              instancePath: instancePath + '/version',
                              schemaPath: '#/properties/version/type',
                              keyword: 'type',
                              params: {
                                type: 'number'
                              },
                              message: 'must be number'
                            }];
                            return false;
                          }
                          if (0 !== data28) {
                            validate21.errors = [{
                              instancePath: instancePath + '/version',
                              schemaPath: '#/properties/version/const',
                              keyword: 'const',
                              params: {
                                allowedValue: 0
                              },
                              message: 'must be equal to constant'
                            }];
                            return false;
                          }
                          var valid0 = _errs73 === errors;
                        } else {
                          var valid0 = true;
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    } else {
      validate21.errors = [{
        instancePath: instancePath,
        schemaPath: '#/type',
        keyword: 'type',
        params: {
          type: 'object'
        },
        message: 'must be object'
      }];
      return false;
    }
  }
  validate21.errors = vErrors;
  return errors === 0;
}
function validate20(data) {
  var _ref10 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
    _ref10$instancePath = _ref10.instancePath,
    instancePath = _ref10$instancePath === void 0 ? '' : _ref10$instancePath,
    parentData = _ref10.parentData,
    parentDataProperty = _ref10.parentDataProperty,
    _ref10$rootData = _ref10.rootData,
    rootData = _ref10$rootData === void 0 ? data : _ref10$rootData;
  var vErrors = null;
  var errors = 0;
  if (!validate21(data, {
    instancePath: instancePath,
    parentData: parentData,
    parentDataProperty: parentDataProperty,
    rootData: rootData
  })) {
    vErrors = vErrors === null ? validate21.errors : vErrors.concat(validate21.errors);
    errors = vErrors.length;
  }
  validate20.errors = vErrors;
  return errors === 0;
}

var avjErrorsToDescription = function avjErrorsToDescription(errors) {
  return (
    // TODO: translate instancePath
    errors.map(function (error) {
      return "".concat(error.instancePath, ": ").concat(error.message);
    }).join(',')
  );
};
var ajvStandaloneJsonParse = function ajvStandaloneJsonParse(untrustedJsonOrObject, validator) {
  // eslint-disable-next-line functional/no-try-statement
  try {
    var parsed = typeof untrustedJsonOrObject === 'string' ? JSON.parse(untrustedJsonOrObject) : untrustedJsonOrObject;
    if (validator(parsed)) {
      return parsed;
    }
    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
    return avjErrorsToDescription(validate20.errors);
  } catch (e) {
    return "Invalid JSON. ".concat(String(e));
  }
};

/**
 * Safely parse and validate an authentication template, returning either an
 * error message as a string or a valid {@link AuthenticationTemplate}. The
 * template may be provided either as an untrusted JSON string or as a
 * pre-parsed object.
 *
 * This method validates both the structure and the contents of a template:
 * - All properties and sub-properties are verified to be of the expected type.
 * - The template contains no unknown properties.
 * - The ID of each entity, script, and scenario is confirmed to be unique.
 * - Script IDs referenced by entities and other scripts (via `unlocks`) are
 * confirmed to exist.
 * - The derivation paths of each HdKey are validated against each other.
 *
 * This method does not validate the CashAssembly contents of scripts (by
 * attempting compilation, evaluating {@link AuthenticationTemplateScriptTest}s,
 * or testing scenario generation).
 *
 * @param untrustedJsonOrObject - the JSON string or object to validate as an
 * authentication template
 */
var importAuthenticationTemplate = function importAuthenticationTemplate(untrustedJsonOrObject) {
  var errorPrefix = "Authentication template import failed:";
  var template = ajvStandaloneJsonParse(untrustedJsonOrObject, validate20);
  if (typeof template === 'string') {
    return "".concat(errorPrefix).concat(template);
  }
  // TODO: add back other validation
  return template;
};

/* eslint-disable @typescript-eslint/no-duplicate-enum-values */
var CompilerDefaults;
(function (CompilerDefaults) {
  /**
   * The `addressIndex` used by the default scenario `data`.
   */
  CompilerDefaults[CompilerDefaults["defaultScenarioAddressIndex"] = 0] = "defaultScenarioAddressIndex";
  /**
   * The value used for `["slot"]` and `["copy"]` locking or unlocking bytecode
   * when generating a scenario and no `unlockingScriptId` is provided.
   */
  CompilerDefaults["defaultScenarioBytecode"] = "";
  /**
   *
   * The value of `currentBlockHeight` in the default authentication template
   * scenario. This is the height of the second mined block after the genesis
   * block: `000000006a625f06636b8bb6ac7b960a8d03705d1ace08b1a19da3fdcc99ddbd`.
   *
   * This default value was chosen to be low enough to simplify the debugging of
   * block height offsets while remaining differentiated from `0` and `1`, which
   * are used both as boolean return values and for control flow.
   */
  CompilerDefaults[CompilerDefaults["defaultScenarioCurrentBlockHeight"] = 2] = "defaultScenarioCurrentBlockHeight";
  /**
   * The value of `currentBlockTime` in the default authentication template
   * scenario. This is the Median Time-Past block time (BIP113) of block `2`
   * (the block used in
   * {@link CompilerDefaults.defaultScenarioCurrentBlockHeight}).
   */
  CompilerDefaults[CompilerDefaults["defaultScenarioCurrentBlockTime"] = 1231469665] = "defaultScenarioCurrentBlockTime";
  /**
   * The default `outpointTransactionHash` of inputs in scenarios.
   */
  CompilerDefaults["defaultScenarioInputOutpointTransactionHash"] = "0000000000000000000000000000000000000000000000000000000000000001";
  /**
   * The default `category` of tokens in scenarios.
   */
  CompilerDefaults["defaultScenarioOutputTokenCategory"] = "0000000000000000000000000000000000000000000000000000000000000002";
  /**
   * The default `sequenceNumber` of inputs in scenarios.
   */
  CompilerDefaults[CompilerDefaults["defaultScenarioInputSequenceNumber"] = 0] = "defaultScenarioInputSequenceNumber";
  /**
   * The default `valueSatoshis` of outputs in scenarios.
   */
  CompilerDefaults[CompilerDefaults["defaultScenarioOutputValueSatoshis"] = 0] = "defaultScenarioOutputValueSatoshis";
  /**
   * The value of `transaction.locktime` in the default authentication template
   * scenario.
   */
  CompilerDefaults[CompilerDefaults["defaultScenarioTransactionLocktime"] = 0] = "defaultScenarioTransactionLocktime";
  /**
   * The value of `transaction.version` in the default authentication template
   * scenario. Transaction version `2` enables `OP_CHECKSEQUENCEVERIFY` as
   * described in BIP68, BIP112, and BIP113.
   */
  CompilerDefaults[CompilerDefaults["defaultScenarioTransactionVersion"] = 2] = "defaultScenarioTransactionVersion";
  /**
   *s
   * If unset, each `HdKey` uses this `addressOffset`.
   */
  CompilerDefaults[CompilerDefaults["hdKeyAddressOffset"] = 0] = "hdKeyAddressOffset";
  /**
   * If unset, each `HdKey` uses this `hdPublicKeyDerivationPath`.
   */
  CompilerDefaults["hdKeyHdPublicKeyDerivationPath"] = "m";
  /**
   * If unset, each `HdKey` uses this `privateDerivationPath`.
   */
  CompilerDefaults["hdKeyPrivateDerivationPath"] = "m/i";
  /**
   * The prefix used to refer to other scenario bytecode scripts from within a
   * bytecode script. See {@link AuthenticationTemplateScenarioData.bytecode}
   * for details.
   */
  CompilerDefaults["scenarioBytecodeScriptPrefix"] = "_scenario.";
})(CompilerDefaults || (CompilerDefaults = {}));

/**
 * Attempt a series of compiler operations, skipping to the next operation if
 * the current operation returns a {@link CompilerOperationSkip} (indicating it
 * failed and can be skipped). The `finalOperation` may not be skipped, and must
 * either return {@link CompilerOperationSuccess} or
 * {@link CompilerOperationError}.
 *
 * @param operations - an array of skippable operations to try
 * @param finalOperation - a final, un-skippable operation
 */
var attemptCompilerOperations = function attemptCompilerOperations(operations, finalOperation) {
  return function (identifier, data, configuration) {
    // eslint-disable-next-line functional/no-loop-statement
    var _iterator = _createForOfIteratorHelper(operations),
      _step;
    try {
      for (_iterator.s(); !(_step = _iterator.n()).done;) {
        var operation = _step.value;
        var result = operation(identifier, data, configuration);
        if (result.status !== 'skip') return result;
      }
    } catch (err) {
      _iterator.e(err);
    } finally {
      _iterator.f();
    }
    return finalOperation(identifier, data, configuration);
  };
};
/**
 * Modify a compiler operation to verify that certain properties exist in the
 * {@link CompilationData} and {@link CompilerConfiguration} before executing
 * the provided operation. If the properties don't exist, an error message
 * is returned.
 *
 * This is useful for eliminating repetitive existence checks.
 */
var compilerOperationRequires = function compilerOperationRequires(_ref) {
  var canBeSkipped = _ref.canBeSkipped,
    dataProperties = _ref.dataProperties,
    configurationProperties = _ref.configurationProperties,
    operation = _ref.operation;
  return (
    // eslint-disable-next-line complexity
    function (identifier, data, configuration) {
      // eslint-disable-next-line functional/no-loop-statement
      var _iterator2 = _createForOfIteratorHelper(configurationProperties),
        _step2;
      try {
        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
          var property = _step2.value;
          if (configuration[property] === undefined) return canBeSkipped ? {
            status: 'skip'
          } : {
            error: "Cannot resolve \"".concat(identifier, "\" - the \"").concat(property, "\" property was not provided in the compiler configuration."),
            status: 'error'
          };
        }
        // eslint-disable-next-line functional/no-loop-statement
      } catch (err) {
        _iterator2.e(err);
      } finally {
        _iterator2.f();
      }
      var _iterator3 = _createForOfIteratorHelper(dataProperties),
        _step3;
      try {
        for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
          var _property = _step3.value;
          if (data[_property] === undefined) return canBeSkipped ? {
            status: 'skip'
          } : {
            error: "Cannot resolve \"".concat(identifier, "\" - the \"").concat(_property, "\" property was not provided in the compilation data."),
            status: 'error'
          };
        }
      } catch (err) {
        _iterator3.e(err);
      } finally {
        _iterator3.f();
      }
      return operation(identifier, data, configuration);
    }
  );
};
var compilerOperationAttemptBytecodeResolution = compilerOperationRequires({
  canBeSkipped: true,
  configurationProperties: [],
  dataProperties: ['bytecode'],
  operation: function operation(identifier, data) {
    var bytecode = data.bytecode[identifier];
    if (bytecode !== undefined) {
      return {
        bytecode: bytecode,
        status: 'success'
      };
    }
    return {
      status: 'skip'
    };
  }
});
// eslint-disable-next-line complexity
var compilerOperationHelperDeriveHdPrivateNode = function compilerOperationHelperDeriveHdPrivateNode(_ref2) {
  var _hdKey$addressOffset, _hdKey$privateDerivat;
  var addressIndex = _ref2.addressIndex,
    entityId = _ref2.entityId,
    entityHdPrivateKey = _ref2.entityHdPrivateKey,
    configuration = _ref2.configuration,
    hdKey = _ref2.hdKey,
    identifier = _ref2.identifier;
  var addressOffset = (_hdKey$addressOffset = hdKey.addressOffset) !== null && _hdKey$addressOffset !== void 0 ? _hdKey$addressOffset : CompilerDefaults.hdKeyAddressOffset;
  var privateDerivationPath = (_hdKey$privateDerivat = hdKey.privateDerivationPath) !== null && _hdKey$privateDerivat !== void 0 ? _hdKey$privateDerivat : CompilerDefaults.hdKeyPrivateDerivationPath;
  var i = addressIndex + addressOffset;
  var validPrivatePathWithIndex = /^m(?:\/(?:[0-9]+|i)'?)*$/;
  if (!validPrivatePathWithIndex.test(privateDerivationPath)) {
    return {
      error: "Could not generate ".concat(identifier, " - the path \"").concat(privateDerivationPath, "\" is not a valid \"privateDerivationPath\"."),
      status: 'error'
    };
  }
  var instancePath = privateDerivationPath.replace('i', i.toString());
  var masterContents = decodeHdPrivateKey(entityHdPrivateKey, configuration);
  if (typeof masterContents === 'string') {
    return {
      error: "Could not generate ".concat(identifier, " - the HD private key provided for ").concat(entityId, " could not be decoded: ").concat(masterContents),
      status: 'error'
    };
  }
  var instanceNode = deriveHdPath(masterContents.node, instancePath, configuration);
  if (typeof instanceNode === 'string') {
    return {
      error: "Could not generate ".concat(identifier, " - the path \"").concat(instancePath, "\" could not be derived for entity \"").concat(entityId, "\": ").concat(instanceNode),
      status: 'error'
    };
  }
  return {
    bytecode: instanceNode.privateKey,
    status: 'success'
  };
};
var compilerOperationHelperUnknownEntity = function compilerOperationHelperUnknownEntity(identifier, variableId) {
  return {
    error: "Identifier \"".concat(identifier, "\" refers to an HdKey, but the \"entityOwnership\" for \"").concat(variableId, "\" is not available in this compiler configuration."),
    status: 'error'
  };
};
var compilerOperationHelperAddressIndex = function compilerOperationHelperAddressIndex(identifier) {
  return {
    error: "Identifier \"".concat(identifier, "\" refers to an HdKey, but \"hdKeys.addressIndex\" was not provided in the compilation data."),
    status: 'error'
  };
};
var compilerOperationHelperDeriveHdKeyPrivate = function compilerOperationHelperDeriveHdKeyPrivate(_ref3) {
  var configuration = _ref3.configuration,
    hdKeys = _ref3.hdKeys,
    identifier = _ref3.identifier;
  var addressIndex = hdKeys.addressIndex,
    hdPrivateKeys = hdKeys.hdPrivateKeys;
  var _identifier$split = identifier.split('.'),
    _identifier$split2 = _slicedToArray(_identifier$split, 1),
    variableId = _identifier$split2[0];
  var entityId = configuration.entityOwnership[variableId];
  if (entityId === undefined) {
    return compilerOperationHelperUnknownEntity(identifier, variableId);
  }
  if (addressIndex === undefined) {
    return compilerOperationHelperAddressIndex(identifier);
  }
  var entityHdPrivateKey = hdPrivateKeys === undefined ? undefined : hdPrivateKeys[entityId];
  if (entityHdPrivateKey === undefined) {
    return {
      error: "Identifier \"".concat(identifier, "\" refers to an HdKey owned by \"").concat(entityId, "\", but an HD private key for this entity (or an existing signature) was not provided in the compilation data."),
      recoverable: true,
      status: 'error'
    };
  }
  /**
   * Guaranteed to be an `HdKey` if this method is reached in the compiler.
   */
  var hdKey = configuration.variables[variableId];
  return compilerOperationHelperDeriveHdPrivateNode({
    addressIndex: addressIndex,
    configuration: configuration,
    entityHdPrivateKey: entityHdPrivateKey,
    entityId: entityId,
    hdKey: hdKey,
    identifier: identifier
  });
};
/**
 * Returns `false` if the target script ID doesn't exist in the compiler
 * configuration (allows for the caller to generate the error message).
 *
 * If the compilation produced errors, returns a
 * {@link CompilerOperationErrorFatal}.
 *
 * If the compilation was successful, returns the compiled bytecode as a
 * `Uint8Array`.
 */
var compilerOperationHelperCompileScript = function compilerOperationHelperCompileScript(_ref4) {
  var targetScriptId = _ref4.targetScriptId,
    data = _ref4.data,
    configuration = _ref4.configuration;
  var signingTarget = configuration.scripts[targetScriptId];
  var compiledTarget = resolveScriptIdentifier({
    configuration: configuration,
    data: data,
    identifier: targetScriptId
  });
  if (signingTarget === undefined || compiledTarget === false) {
    return false;
  }
  if (typeof compiledTarget === 'string') {
    return {
      error: compiledTarget,
      status: 'error'
    };
  }
  return compiledTarget.bytecode;
};
/**
 * Returns either the properly generated `coveredBytecode` or a
 * {@link CompilerOperationErrorFatal}.
 */
var compilerOperationHelperGenerateCoveredBytecode = function compilerOperationHelperGenerateCoveredBytecode(_ref5) {
  var data = _ref5.data,
    configuration = _ref5.configuration,
    identifier = _ref5.identifier,
    sourceScriptIds = _ref5.sourceScriptIds,
    unlockingScripts = _ref5.unlockingScripts;
  var currentScriptId = sourceScriptIds[sourceScriptIds.length - 1];
  if (currentScriptId === undefined) {
    return {
      error: "Identifier \"".concat(identifier, "\" requires a signing serialization, but \"coveredBytecode\" cannot be determined because the compiler configuration's \"sourceScriptIds\" is empty."),
      status: 'error'
    };
  }
  var targetLockingScriptId = unlockingScripts[currentScriptId];
  if (targetLockingScriptId === undefined) {
    return {
      error: "Identifier \"".concat(identifier, "\" requires a signing serialization, but \"coveredBytecode\" cannot be determined because \"").concat(currentScriptId, "\" is not present in the compiler configuration's \"unlockingScripts\"."),
      status: 'error'
    };
  }
  var result = compilerOperationHelperCompileScript({
    configuration: configuration,
    data: data,
    targetScriptId: targetLockingScriptId
  });
  if (result === false) {
    return {
      error: "Identifier \"".concat(identifier, "\" requires a signing serialization that covers an unknown locking script, \"").concat(targetLockingScriptId, "\"."),
      status: 'error'
    };
  }
  return result;
};

var compilerOperationAddressData = compilerOperationRequires({
  canBeSkipped: false,
  configurationProperties: [],
  dataProperties: ['bytecode'],
  operation: function operation(identifier, data) {
    var bytecode = data.bytecode[identifier];
    if (bytecode !== undefined) {
      return {
        bytecode: bytecode,
        status: 'success'
      };
    }
    return {
      error: "Identifier \"".concat(identifier, "\" refers to an AddressData, but \"").concat(identifier, "\" was not provided in the CompilationData \"bytecode\"."),
      recoverable: true,
      status: 'error'
    };
  }
});
var compilerOperationWalletData = compilerOperationRequires({
  canBeSkipped: false,
  configurationProperties: [],
  dataProperties: ['bytecode'],
  operation: function operation(identifier, data) {
    var bytecode = data.bytecode[identifier];
    if (bytecode !== undefined) {
      return {
        bytecode: bytecode,
        status: 'success'
      };
    }
    return {
      error: "Identifier \"".concat(identifier, "\" refers to a WalletData, but \"").concat(identifier, "\" was not provided in the CompilationData \"bytecode\"."),
      recoverable: true,
      status: 'error'
    };
  }
});
var compilerOperationCurrentBlockTime = compilerOperationRequires({
  canBeSkipped: false,
  configurationProperties: [],
  dataProperties: ['currentBlockTime'],
  operation: function operation(_, data) {
    return {
      bytecode: numberToBinUint32LE(data.currentBlockTime),
      status: 'success'
    };
  }
});
var compilerOperationCurrentBlockHeight = compilerOperationRequires({
  canBeSkipped: false,
  configurationProperties: [],
  dataProperties: ['currentBlockHeight'],
  operation: function operation(_, data) {
    return {
      bytecode: bigIntToVmNumber(BigInt(data.currentBlockHeight)),
      status: 'success'
    };
  }
});
var compilerOperationSigningSerializationCorrespondingOutput = compilerOperationRequires({
  canBeSkipped: false,
  configurationProperties: [],
  dataProperties: ['compilationContext'],
  operation: function operation(_, data) {
    var _generateSigningSeria = generateSigningSerializationComponentsBCH(data.compilationContext),
      correspondingOutput = _generateSigningSeria.correspondingOutput;
    return correspondingOutput === undefined ? {
      bytecode: Uint8Array.of(),
      status: 'success'
    } : {
      bytecode: correspondingOutput,
      status: 'success'
    };
  }
});
var compilerOperationSigningSerializationCorrespondingOutputHash = compilerOperationRequires({
  canBeSkipped: false,
  configurationProperties: ['sha256'],
  dataProperties: ['compilationContext'],
  operation: function operation(_, data, configuration) {
    var _generateSigningSeria2 = generateSigningSerializationComponentsBCH(data.compilationContext),
      correspondingOutput = _generateSigningSeria2.correspondingOutput;
    return correspondingOutput === undefined ? {
      bytecode: Uint8Array.of(),
      status: 'success'
    } : {
      bytecode: configuration.sha256.hash(configuration.sha256.hash(correspondingOutput)),
      status: 'success'
    };
  }
});
var compilerOperationHelperSigningSerializationCoveredBytecode = function compilerOperationHelperSigningSerializationCoveredBytecode(returnLength) {
  return compilerOperationRequires({
    canBeSkipped: false,
    configurationProperties: ['sourceScriptIds', 'unlockingScripts'],
    dataProperties: ['compilationContext'],
    operation: function operation(identifier, data, configuration) {
      var unlockingScripts = configuration.unlockingScripts,
        sourceScriptIds = configuration.sourceScriptIds;
      var result = compilerOperationHelperGenerateCoveredBytecode({
        configuration: configuration,
        data: data,
        identifier: identifier,
        sourceScriptIds: sourceScriptIds,
        unlockingScripts: unlockingScripts
      });
      if ('error' in result) {
        return result;
      }
      return {
        bytecode: returnLength ? bigIntToCompactSize(BigInt(result.length)) : result,
        status: 'success'
      };
    }
  });
};
var compilerOperationSigningSerializationCoveredBytecode = compilerOperationHelperSigningSerializationCoveredBytecode(false);
var compilerOperationSigningSerializationCoveredBytecodeLength = compilerOperationHelperSigningSerializationCoveredBytecode(true);
var compilerOperationSigningSerializationLocktime = compilerOperationRequires({
  canBeSkipped: false,
  configurationProperties: [],
  dataProperties: ['compilationContext'],
  operation: function operation(_, data) {
    return {
      bytecode: numberToBinUint32LE(data.compilationContext.transaction.locktime),
      status: 'success'
    };
  }
});
var compilerOperationSigningSerializationOutpointIndex = compilerOperationRequires({
  canBeSkipped: false,
  configurationProperties: [],
  dataProperties: ['compilationContext'],
  operation: function operation(_, data) {
    return {
      bytecode: numberToBinUint32LE(
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      data.compilationContext.transaction.inputs[data.compilationContext.inputIndex].outpointIndex),
      status: 'success'
    };
  }
});
var compilerOperationSigningSerializationOutpointTransactionHash = compilerOperationRequires({
  canBeSkipped: false,
  configurationProperties: [],
  dataProperties: ['compilationContext'],
  operation: function operation(_, data) {
    return {
      bytecode:
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      data.compilationContext.transaction.inputs[data.compilationContext.inputIndex].outpointTransactionHash,
      status: 'success'
    };
  }
});
var compilerOperationSigningSerializationOutputValue = compilerOperationRequires({
  canBeSkipped: false,
  configurationProperties: [],
  dataProperties: ['compilationContext'],
  operation: function operation(_, data) {
    return {
      bytecode: valueSatoshisToBin(
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      data.compilationContext.sourceOutputs[data.compilationContext.inputIndex].valueSatoshis),
      status: 'success'
    };
  }
});
var compilerOperationSigningSerializationSequenceNumber = compilerOperationRequires({
  canBeSkipped: false,
  configurationProperties: [],
  dataProperties: ['compilationContext'],
  operation: function operation(_, data) {
    return {
      bytecode: numberToBinUint32LE(
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      data.compilationContext.transaction.inputs[data.compilationContext.inputIndex].sequenceNumber),
      status: 'success'
    };
  }
});
var compilerOperationSigningSerializationTransactionOutpoints = compilerOperationRequires({
  canBeSkipped: false,
  configurationProperties: [],
  dataProperties: ['compilationContext'],
  operation: function operation(_, data) {
    return {
      bytecode: encodeTransactionOutpoints(data.compilationContext.transaction.inputs),
      status: 'success'
    };
  }
});
var compilerOperationSigningSerializationTransactionOutpointsHash = compilerOperationRequires({
  canBeSkipped: false,
  configurationProperties: ['sha256'],
  dataProperties: ['compilationContext'],
  operation: function operation(_, data, configuration) {
    return {
      bytecode: configuration.sha256.hash(configuration.sha256.hash(encodeTransactionOutpoints(data.compilationContext.transaction.inputs))),
      status: 'success'
    };
  }
});
var compilerOperationSigningSerializationTransactionOutputs = compilerOperationRequires({
  canBeSkipped: false,
  configurationProperties: [],
  dataProperties: ['compilationContext'],
  operation: function operation(_, data) {
    return {
      bytecode: encodeTransactionOutputsForSigning(data.compilationContext.transaction.outputs),
      status: 'success'
    };
  }
});
var compilerOperationSigningSerializationTransactionOutputsHash = compilerOperationRequires({
  canBeSkipped: false,
  configurationProperties: ['sha256'],
  dataProperties: ['compilationContext'],
  operation: function operation(_, data, configuration) {
    return {
      bytecode: configuration.sha256.hash(configuration.sha256.hash(encodeTransactionOutputsForSigning(data.compilationContext.transaction.outputs))),
      status: 'success'
    };
  }
});
var compilerOperationSigningSerializationTransactionSequenceNumbers = compilerOperationRequires({
  canBeSkipped: false,
  configurationProperties: [],
  dataProperties: ['compilationContext'],
  operation: function operation(_, data) {
    return {
      bytecode: encodeTransactionInputSequenceNumbersForSigning(data.compilationContext.transaction.inputs),
      status: 'success'
    };
  }
});
var compilerOperationSigningSerializationTransactionSequenceNumbersHash = compilerOperationRequires({
  canBeSkipped: false,
  configurationProperties: ['sha256'],
  dataProperties: ['compilationContext'],
  operation: function operation(_, data, configuration) {
    return {
      bytecode: configuration.sha256.hash(configuration.sha256.hash(encodeTransactionInputSequenceNumbersForSigning(data.compilationContext.transaction.inputs))),
      status: 'success'
    };
  }
});
var compilerOperationSigningSerializationVersion = compilerOperationRequires({
  canBeSkipped: false,
  configurationProperties: [],
  dataProperties: ['compilationContext'],
  operation: function operation(_, data) {
    return {
      bytecode: numberToBinUint32LE(data.compilationContext.transaction.version),
      status: 'success'
    };
  }
});
var compilerOperationKeyPublicKeyCommon = attemptCompilerOperations([compilerOperationAttemptBytecodeResolution], compilerOperationRequires({
  canBeSkipped: false,
  configurationProperties: ['secp256k1'],
  dataProperties: ['keys'],
  operation: function operation(identifier, data, configuration) {
    var keys = data.keys;
    var secp256k1 = configuration.secp256k1;
    var privateKeys = keys.privateKeys;
    var _identifier$split = identifier.split('.'),
      _identifier$split2 = _slicedToArray(_identifier$split, 1),
      variableId = _identifier$split2[0];
    if ((privateKeys === null || privateKeys === void 0 ? void 0 : privateKeys[variableId]) !== undefined) {
      return {
        bytecode: secp256k1.derivePublicKeyCompressed(
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        privateKeys[variableId]),
        status: 'success'
      };
    }
    return {
      error: "Identifier \"".concat(identifier, "\" refers to a public key, but no public or private keys for \"").concat(variableId, "\" were provided in the compilation data."),
      recoverable: true,
      status: 'error'
    };
  }
}));
var compilerOperationHdKeyPublicKeyCommon = attemptCompilerOperations([compilerOperationAttemptBytecodeResolution], compilerOperationRequires({
  canBeSkipped: false,
  configurationProperties: ['entityOwnership', 'ripemd160', 'secp256k1', 'sha256', 'sha512', 'variables'],
  dataProperties: ['hdKeys'],
  operation:
  // eslint-disable-next-line complexity
  function operation(identifier, data, configuration) {
    var _hdKey$addressOffset, _hdKey$privateDerivat, _hdKey$publicDerivati;
    var hdKeys = data.hdKeys;
    var hdPrivateKeys = hdKeys.hdPrivateKeys,
      addressIndex = hdKeys.addressIndex,
      hdPublicKeys = hdKeys.hdPublicKeys;
    var _identifier$split3 = identifier.split('.'),
      _identifier$split4 = _slicedToArray(_identifier$split3, 1),
      variableId = _identifier$split4[0];
    var entityId = configuration.entityOwnership[variableId];
    if (entityId === undefined) {
      return compilerOperationHelperUnknownEntity(identifier, variableId);
    }
    if (addressIndex === undefined) {
      return compilerOperationHelperAddressIndex(identifier);
    }
    var entityHdPrivateKey = hdPrivateKeys === undefined ? undefined : hdPrivateKeys[entityId];
    /**
     * Guaranteed to be an `HdKey` if this method is reached in the compiler.
     */
    var hdKey = configuration.variables[variableId];
    if (entityHdPrivateKey !== undefined) {
      var privateResult = compilerOperationHelperDeriveHdPrivateNode({
        addressIndex: addressIndex,
        configuration: configuration,
        entityHdPrivateKey: entityHdPrivateKey,
        entityId: entityId,
        hdKey: hdKey,
        identifier: identifier
      });
      if (privateResult.status === 'error') return privateResult;
      return {
        bytecode: configuration.secp256k1.derivePublicKeyCompressed(privateResult.bytecode),
        status: 'success'
      };
    }
    var entityHdPublicKey = hdPublicKeys === undefined ? undefined : hdPublicKeys[entityId];
    if (entityHdPublicKey === undefined) {
      return {
        error: "Identifier \"".concat(identifier, "\" refers to an HdKey owned by \"").concat(entityId, "\", but an HD private key or HD public key for this entity was not provided in the compilation data."),
        recoverable: true,
        status: 'error'
      };
    }
    var addressOffset = (_hdKey$addressOffset = hdKey.addressOffset) !== null && _hdKey$addressOffset !== void 0 ? _hdKey$addressOffset : CompilerDefaults.hdKeyAddressOffset;
    var privateDerivationPath = (_hdKey$privateDerivat = hdKey.privateDerivationPath) !== null && _hdKey$privateDerivat !== void 0 ? _hdKey$privateDerivat : CompilerDefaults.hdKeyPrivateDerivationPath;
    var publicDerivationPath = (_hdKey$publicDerivati = hdKey.publicDerivationPath) !== null && _hdKey$publicDerivati !== void 0 ? _hdKey$publicDerivati : privateDerivationPath.replace('m', 'M');
    var validPublicPathWithIndex = /^M(?:\/(?:[0-9]+|i))*$/;
    if (!validPublicPathWithIndex.test(publicDerivationPath)) {
      return {
        error: "Could not generate ".concat(identifier, " - the path \"").concat(publicDerivationPath, "\" is not a valid \"publicDerivationPath\"."),
        status: 'error'
      };
    }
    var i = addressIndex + addressOffset;
    var instancePath = publicDerivationPath.replace('i', i.toString());
    var masterContents = decodeHdPublicKey(entityHdPublicKey, configuration);
    if (typeof masterContents === 'string') {
      return {
        error: "Could not generate \"".concat(identifier, "\" - the HD public key provided for \"").concat(entityId, "\" could not be decoded: ").concat(masterContents),
        status: 'error'
      };
    }
    var instanceNode = deriveHdPath(masterContents.node, instancePath, configuration);
    if (typeof instanceNode === 'string') {
      return {
        error: "Could not generate \"".concat(identifier, "\" - the path \"").concat(instancePath, "\" could not be derived for entity \"").concat(entityId, "\": ").concat(instanceNode),
        status: 'error'
      };
    }
    return {
      bytecode: instanceNode.publicKey,
      status: 'success'
    };
  }
}));
/* eslint-disable camelcase, @typescript-eslint/naming-convention */
var compilerOperationsCommon = {
  addressData: compilerOperationAddressData,
  currentBlockHeight: compilerOperationCurrentBlockHeight,
  currentBlockTime: compilerOperationCurrentBlockTime,
  hdKey: {
    public_key: compilerOperationHdKeyPublicKeyCommon
  },
  key: {
    public_key: compilerOperationKeyPublicKeyCommon
  },
  signingSerialization: {
    corresponding_output: compilerOperationSigningSerializationCorrespondingOutput,
    corresponding_output_hash: compilerOperationSigningSerializationCorrespondingOutputHash,
    covered_bytecode: compilerOperationSigningSerializationCoveredBytecode,
    covered_bytecode_length: compilerOperationSigningSerializationCoveredBytecodeLength,
    locktime: compilerOperationSigningSerializationLocktime,
    outpoint_index: compilerOperationSigningSerializationOutpointIndex,
    outpoint_transaction_hash: compilerOperationSigningSerializationOutpointTransactionHash,
    output_value: compilerOperationSigningSerializationOutputValue,
    sequence_number: compilerOperationSigningSerializationSequenceNumber,
    transaction_outpoints: compilerOperationSigningSerializationTransactionOutpoints,
    transaction_outpoints_hash: compilerOperationSigningSerializationTransactionOutpointsHash,
    transaction_outputs: compilerOperationSigningSerializationTransactionOutputs,
    transaction_outputs_hash: compilerOperationSigningSerializationTransactionOutputsHash,
    transaction_sequence_numbers: compilerOperationSigningSerializationTransactionSequenceNumbers,
    transaction_sequence_numbers_hash: compilerOperationSigningSerializationTransactionSequenceNumbersHash,
    version: compilerOperationSigningSerializationVersion
  },
  walletData: compilerOperationWalletData
};
/* eslint-enable camelcase, @typescript-eslint/naming-convention */

/**
 * The default `lockingBytecode` value for scenario outputs is a new empty
 * object (`{}`).
 */
var defaultScenarioOutputLockingBytecode = function defaultScenarioOutputLockingBytecode() {
  return {};
};
/**
 * Given a compiler configuration, generate the default scenario that is
 * extended by all the configuration's scenarios.
 *
 * For details on default scenario generation, see
 * {@link AuthenticationTemplateScenario.extends}.
 *
 * @param configuration - the compiler configuration from which to generate the
 * default scenario
 */
// eslint-disable-next-line complexity
var generateDefaultScenarioDefinition = function generateDefaultScenarioDefinition(configuration) {
  var variables = configuration.variables,
    entityOwnership = configuration.entityOwnership;
  var keyVariableIds = variables === undefined ? [] : Object.entries(variables).filter(function (entry) {
    return entry[1].type === 'Key';
  }).map(function (_ref) {
    var _ref2 = _slicedToArray(_ref, 1),
      id = _ref2[0];
    return id;
  });
  var entityIds = entityOwnership === undefined ? [] : Object.keys(Object.values(entityOwnership).reduce(function (all, entityId) {
    return _objectSpread2(_objectSpread2({}, all), {}, _defineProperty({}, entityId, true));
  }, {}));
  var valueMap = [].concat(_toConsumableArray(keyVariableIds), _toConsumableArray(entityIds)).sort(function (idA, idB) {
    return idA.localeCompare(idB, 'en');
  }).reduce(function (all, id, index) {
    return _objectSpread2(_objectSpread2({}, all), {}, _defineProperty({}, id, bigIntToBinUint256BEClamped(BigInt(index + 1))));
  }, {});
  var privateKeys = variables === undefined ? undefined : Object.entries(variables).reduce(function (all, _ref3) {
    var _ref4 = _slicedToArray(_ref3, 2),
      variableId = _ref4[0],
      variable = _ref4[1];
    return variable.type === 'Key' ? _objectSpread2(_objectSpread2({}, all), {}, _defineProperty({}, variableId, binToHex(valueMap[variableId]))) : all;
  }, {});
  var defaultScenario = {
    data: _objectSpread2({
      currentBlockHeight: CompilerDefaults.defaultScenarioCurrentBlockHeight,
      currentBlockTime: CompilerDefaults.defaultScenarioCurrentBlockTime
    }, privateKeys === undefined || Object.keys(privateKeys).length === 0 ? {} : {
      keys: {
        privateKeys: privateKeys
      }
    }),
    sourceOutputs: [{
      lockingBytecode: ['slot']
    }],
    transaction: {
      inputs: [{
        unlockingBytecode: ['slot']
      }],
      locktime: CompilerDefaults.defaultScenarioTransactionLocktime,
      outputs: [{
        lockingBytecode: defaultScenarioOutputLockingBytecode()
      }],
      version: CompilerDefaults.defaultScenarioTransactionVersion
    }
  };
  var hasHdKeys = variables === undefined ? false : Object.values(variables).findIndex(function (variable) {
    return variable.type === 'HdKey';
  }) !== -1;
  if (!hasHdKeys) {
    return defaultScenario;
  }
  var sha256 = configuration.sha256,
    sha512 = configuration.sha512;
  if (sha256 === undefined) {
    return 'An implementations of "sha256" is required to generate defaults for HD keys, but the "sha256" property is not included in this compiler configuration.';
  }
  if (sha512 === undefined) {
    return 'An implementations of "sha512" is required to generate defaults for HD keys, but the "sha512" property is not included in this compiler configuration.';
  }
  var crypto = {
    sha256: sha256,
    sha512: sha512
  };
  var hdPrivateKeys = entityIds.reduce(function (all, entityId) {
    /**
     * The first 5,000,000,000 seeds have been tested, scenarios are
     * unlikely to exceed this number of entities.
     */
    var assumeValid = true;
    var masterNode = deriveHdPrivateNodeFromSeed(
    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
    valueMap[entityId], assumeValid, crypto);
    var hdPrivateKey = encodeHdPrivateKey({
      network: 'mainnet',
      node: masterNode
    }, crypto);
    return _objectSpread2(_objectSpread2({}, all), {}, _defineProperty({}, entityId, hdPrivateKey));
  }, {});
  return _objectSpread2(_objectSpread2({}, defaultScenario), {}, {
    data: _objectSpread2(_objectSpread2({}, defaultScenario.data), {}, {
      hdKeys: {
        addressIndex: CompilerDefaults.defaultScenarioAddressIndex,
        hdPrivateKeys: hdPrivateKeys
      }
    })
  });
};
/**
 * Extend the `data` property of a scenario definition with values from a parent
 * scenario definition. Returns the extended value for `data`.
 *
 * @param parentData - the scenario `data` that is extended by the child
 * scenario
 * @param childData - the scenario `data` that may override values from the
 * parent scenario
 */
// eslint-disable-next-line complexity
var extendScenarioDefinitionData = function extendScenarioDefinitionData(parentData, childData) {
  var _parentData$hdKeys, _childData$hdKeys, _parentData$hdKeys2, _childData$hdKeys2, _parentData$hdKeys3, _childData$hdKeys3, _parentData$hdKeys4, _childData$hdKeys4, _parentData$keys, _childData$keys;
  return _objectSpread2(_objectSpread2(_objectSpread2(_objectSpread2(_objectSpread2({}, parentData), childData), parentData.bytecode === undefined && childData.bytecode === undefined ? {} : {
    bytecode: _objectSpread2(_objectSpread2({}, parentData.bytecode), childData.bytecode)
  }), parentData.hdKeys === undefined && childData.hdKeys === undefined ? {} : {
    hdKeys: _objectSpread2(_objectSpread2(_objectSpread2(_objectSpread2({}, parentData.hdKeys), childData.hdKeys), ((_parentData$hdKeys = parentData.hdKeys) === null || _parentData$hdKeys === void 0 ? void 0 : _parentData$hdKeys.hdPrivateKeys) === undefined && ((_childData$hdKeys = childData.hdKeys) === null || _childData$hdKeys === void 0 ? void 0 : _childData$hdKeys.hdPrivateKeys) === undefined ? {} : {
      hdPrivateKeys: _objectSpread2(_objectSpread2({}, (_parentData$hdKeys2 = parentData.hdKeys) === null || _parentData$hdKeys2 === void 0 ? void 0 : _parentData$hdKeys2.hdPrivateKeys), (_childData$hdKeys2 = childData.hdKeys) === null || _childData$hdKeys2 === void 0 ? void 0 : _childData$hdKeys2.hdPrivateKeys)
    }), ((_parentData$hdKeys3 = parentData.hdKeys) === null || _parentData$hdKeys3 === void 0 ? void 0 : _parentData$hdKeys3.hdPublicKeys) === undefined && ((_childData$hdKeys3 = childData.hdKeys) === null || _childData$hdKeys3 === void 0 ? void 0 : _childData$hdKeys3.hdPublicKeys) === undefined ? {} : {
      hdPublicKeys: _objectSpread2(_objectSpread2({}, (_parentData$hdKeys4 = parentData.hdKeys) === null || _parentData$hdKeys4 === void 0 ? void 0 : _parentData$hdKeys4.hdPublicKeys), (_childData$hdKeys4 = childData.hdKeys) === null || _childData$hdKeys4 === void 0 ? void 0 : _childData$hdKeys4.hdPublicKeys)
    })
  }), parentData.keys === undefined && childData.keys === undefined ? {} : {
    keys: {
      privateKeys: _objectSpread2(_objectSpread2({}, (_parentData$keys = parentData.keys) === null || _parentData$keys === void 0 ? void 0 : _parentData$keys.privateKeys), (_childData$keys = childData.keys) === null || _childData$keys === void 0 ? void 0 : _childData$keys.privateKeys)
    }
  });
};
/**
 * Extend a child scenario definition with values from a parent scenario
 * definition. Returns the extended values for `data`, `transaction`, and
 * `value`.
 *
 * @param parentScenario - the scenario that is extended by the child scenario
 * @param childScenario - the scenario that may override values from the parent
 * scenario
 */
// eslint-disable-next-line complexity
var extendScenarioDefinition = function extendScenarioDefinition(parentScenario, childScenario) {
  var _parentScenario$data, _childScenario$data, _childScenario$source;
  return _objectSpread2(_objectSpread2(_objectSpread2({}, parentScenario.data === undefined && childScenario.data === undefined ? {} : {
    data: extendScenarioDefinitionData((_parentScenario$data = parentScenario.data) !== null && _parentScenario$data !== void 0 ? _parentScenario$data : {}, (_childScenario$data = childScenario.data) !== null && _childScenario$data !== void 0 ? _childScenario$data : {})
  }), parentScenario.transaction === undefined && childScenario.transaction === undefined ? {} : {
    transaction: _objectSpread2(_objectSpread2({}, parentScenario.transaction), childScenario.transaction)
  }), parentScenario.sourceOutputs === undefined && childScenario.sourceOutputs === undefined ? {} : {
    sourceOutputs: (_childScenario$source = childScenario.sourceOutputs) !== null && _childScenario$source !== void 0 ? _childScenario$source : parentScenario.sourceOutputs
  });
};
/**
 * Generate the full scenario that is extended by the provided scenario
 * identifier. Scenarios for which `extends` is `undefined` extend the default
 * scenario for the provided compiler configuration.
 */
// eslint-disable-next-line complexity
var generateExtendedScenario = function generateExtendedScenario(_ref5) {
  var _configuration$scenar;
  var configuration = _ref5.configuration,
    scenarioId = _ref5.scenarioId,
    _ref5$sourceScenarioI = _ref5.sourceScenarioIds,
    sourceScenarioIds = _ref5$sourceScenarioI === void 0 ? [] : _ref5$sourceScenarioI;
  if (scenarioId === undefined) {
    return generateDefaultScenarioDefinition(configuration);
  }
  if (sourceScenarioIds.includes(scenarioId)) {
    return "Cannot extend scenario \"".concat(scenarioId, "\": scenario \"").concat(scenarioId, "\" extends itself. Scenario inheritance path: ").concat(sourceScenarioIds.join(' → '));
  }
  var scenario = (_configuration$scenar = configuration.scenarios) === null || _configuration$scenar === void 0 ? void 0 : _configuration$scenar[scenarioId];
  if (scenario === undefined) {
    return "Cannot extend scenario \"".concat(scenarioId, "\": a scenario with the identifier ").concat(scenarioId, " is not included in this compiler configuration.");
  }
  var parentScenario = scenario.extends === undefined ? generateDefaultScenarioDefinition(configuration) : generateExtendedScenario({
    configuration: configuration,
    scenarioId: scenario.extends,
    sourceScenarioIds: [].concat(_toConsumableArray(sourceScenarioIds), [scenarioId])
  });
  if (typeof parentScenario === 'string') {
    return parentScenario;
  }
  return extendScenarioDefinition(parentScenario, scenario);
};
/**
 * Derive standard {@link CompilationData} properties from an extended scenario
 * definition.
 *
 * @param definition - a scenario definition that has been extended by the
 * default scenario definition
 */
// eslint-disable-next-line complexity
var extendedScenarioDefinitionToCompilationData = function extendedScenarioDefinitionToCompilationData(definition) {
  var _definition$data$keys;
  return _objectSpread2(_objectSpread2(_objectSpread2(_objectSpread2({}, definition.data.currentBlockHeight === undefined ? {} : {
    currentBlockHeight: definition.data.currentBlockHeight
  }), definition.data.currentBlockTime === undefined ? {} : {
    currentBlockTime: definition.data.currentBlockTime
  }), definition.data.hdKeys === undefined ? {} : {
    hdKeys: _objectSpread2(_objectSpread2(_objectSpread2({}, definition.data.hdKeys.addressIndex === undefined ? {} : {
      addressIndex: definition.data.hdKeys.addressIndex
    }), definition.data.hdKeys.hdPrivateKeys !== undefined && Object.keys(definition.data.hdKeys.hdPrivateKeys).length > 0 ? {
      hdPrivateKeys: definition.data.hdKeys.hdPrivateKeys
    } : {}), definition.data.hdKeys.hdPublicKeys === undefined ? {} : {
      hdPublicKeys: definition.data.hdKeys.hdPublicKeys
    })
  }), ((_definition$data$keys = definition.data.keys) === null || _definition$data$keys === void 0 ? void 0 : _definition$data$keys.privateKeys) !== undefined && Object.keys(definition.data.keys.privateKeys).length > 0 ? {
    keys: {
      privateKeys: Object.entries(definition.data.keys.privateKeys).reduce(function (all, _ref6) {
        var _ref7 = _slicedToArray(_ref6, 2),
          id = _ref7[0],
          hex = _ref7[1];
        return _objectSpread2(_objectSpread2({}, all), {}, _defineProperty({}, id, hexToBin(hex)));
      }, {})
    }
  } : {});
};
/**
 * Extend a {@link CompilationData} object with the compiled result of the
 * bytecode scripts provided by an {@link AuthenticationTemplateScenarioData}.
 */
var extendCompilationDataWithScenarioBytecode = function extendCompilationDataWithScenarioBytecode(_ref8) {
  var compilationData = _ref8.compilationData,
    configuration = _ref8.configuration,
    scenarioDataBytecodeScripts = _ref8.scenarioDataBytecodeScripts;
  var prefixBytecodeScriptId = function prefixBytecodeScriptId(id) {
    return "".concat(CompilerDefaults.scenarioBytecodeScriptPrefix).concat(id);
  };
  var bytecodeScripts = Object.entries(scenarioDataBytecodeScripts).reduce(function (all, _ref9) {
    var _ref10 = _slicedToArray(_ref9, 2),
      id = _ref10[0],
      script = _ref10[1];
    return _objectSpread2(_objectSpread2({}, all), {}, _defineProperty({}, prefixBytecodeScriptId(id), script));
  }, {});
  var bytecodeScriptExtendedConfiguration = _objectSpread2(_objectSpread2({}, configuration), {}, {
    scripts: _objectSpread2(_objectSpread2({}, configuration.scripts), bytecodeScripts)
  });
  var bytecodeCompilations = Object.keys(scenarioDataBytecodeScripts).map(function (id) {
    var result = compileScriptRaw({
      configuration: bytecodeScriptExtendedConfiguration,
      data: compilationData,
      scriptId: prefixBytecodeScriptId(id)
    });
    if (result.success) {
      return {
        bytecode: result.bytecode,
        id: id
      };
    }
    return {
      errors: result.errors,
      id: id
    };
  });
  var failedResults = bytecodeCompilations.filter(function (result) {
    return 'errors' in result;
  });
  if (failedResults.length > 0) {
    return "".concat(failedResults.map(function (result) {
      return "Compilation error while generating bytecode for \"".concat(result.id, "\": ").concat(stringifyErrors(result.errors));
    }).join('; '));
  }
  var compiledBytecode = bytecodeCompilations.reduce(function (all, result) {
    return _objectSpread2(_objectSpread2({}, all), {}, _defineProperty({}, result.id, result.bytecode));
  }, {});
  return _objectSpread2(_objectSpread2({}, Object.keys(compiledBytecode).length > 0 ? {
    bytecode: compiledBytecode
  } : {}), compilationData);
};
/**
 * Compile a {@link AuthenticationTemplateScenarioOutput.valueSatoshis},
 * returning the `Uint8Array` result.
 */
var compileAuthenticationTemplateScenarioValueSatoshis = function compileAuthenticationTemplateScenarioValueSatoshis() {
  var valueSatoshisDefinition = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : CompilerDefaults.defaultScenarioOutputValueSatoshis;
  return typeof valueSatoshisDefinition === 'string' ? binToValueSatoshis(hexToBin(valueSatoshisDefinition)) : BigInt(valueSatoshisDefinition);
};
/**
 * Compile an {@link AuthenticationTemplateScenarioBytecode} definition for an
 * {@link AuthenticationTemplateScenario}, returning either a
 * simple `Uint8Array` result or a full CashAssembly {@link CompilationResult}.
 */
// eslint-disable-next-line complexity
var compileAuthenticationTemplateScenarioBytecode = function compileAuthenticationTemplateScenarioBytecode(_ref11) {
  var _bytecodeDefinition$o, _overriddenDataDefini;
  var bytecodeDefinition = _ref11.bytecodeDefinition,
    compilationContext = _ref11.compilationContext,
    configuration = _ref11.configuration,
    defaultOverride = _ref11.defaultOverride,
    extendedScenario = _ref11.extendedScenario,
    generateBytecode = _ref11.generateBytecode,
    lockingOrUnlockingScriptIdUnderTest = _ref11.lockingOrUnlockingScriptIdUnderTest;
  if (typeof bytecodeDefinition === 'string') {
    return hexToBin(bytecodeDefinition);
  }
  var scriptId = bytecodeDefinition.script === undefined || Array.isArray(bytecodeDefinition.script) ? lockingOrUnlockingScriptIdUnderTest : bytecodeDefinition.script;
  /**
   * The script ID to compile. If `undefined`, we are attempting to "copy" the
   * script ID in a scenario generation that does not define a locking or
   * unlocking script under test (e.g. the scenario is only used for debugging
   * values in an editor) - in these cases, simply return an empty `Uint8Array`.
   */
  if (scriptId === undefined) {
    return hexToBin('');
  }
  var overrides = (_bytecodeDefinition$o = bytecodeDefinition.overrides) !== null && _bytecodeDefinition$o !== void 0 ? _bytecodeDefinition$o : defaultOverride;
  var overriddenDataDefinition = extendScenarioDefinitionData(extendedScenario.data, overrides);
  var data = extendCompilationDataWithScenarioBytecode({
    compilationData: extendedScenarioDefinitionToCompilationData({
      data: overriddenDataDefinition
    }),
    configuration: configuration,
    scenarioDataBytecodeScripts: (_overriddenDataDefini = overriddenDataDefinition.bytecode) !== null && _overriddenDataDefini !== void 0 ? _overriddenDataDefini : {}
  });
  if (typeof data === 'string') {
    var error = "Could not compile scenario \"data.bytecode\": ".concat(data);
    return {
      errors: [{
        error: error
      }],
      success: false
    };
  }
  return generateBytecode({
    data: _objectSpread2(_objectSpread2({}, data), {}, {
      compilationContext: compilationContext
    }),
    debug: true,
    scriptId: scriptId
  });
};
/**
 * Compile a {@link AuthenticationTemplateScenarioOutput.token},
 * returning the {@link Output.token} result.
 */
// eslint-disable-next-line complexity
var compileScenarioOutputTokenData = function compileScenarioOutputTokenData(output) {
  var _output$token$amount, _output$token$categor, _output$token$nft$cap, _output$token$nft$com;
  return output.token === undefined ? {} : {
    token: _objectSpread2({
      amount: BigInt((_output$token$amount = output.token.amount) !== null && _output$token$amount !== void 0 ? _output$token$amount : 0),
      // TODO: doesn't verify length
      category: hexToBin((_output$token$categor = output.token.category) !== null && _output$token$categor !== void 0 ? _output$token$categor : CompilerDefaults.defaultScenarioOutputTokenCategory)
    }, output.token.nft === undefined ? {} : {
      nft: {
        capability: (_output$token$nft$cap = output.token.nft.capability) !== null && _output$token$nft$cap !== void 0 ? _output$token$nft$cap : 'none',
        commitment: hexToBin((_output$token$nft$com = output.token.nft.commitment) !== null && _output$token$nft$com !== void 0 ? _output$token$nft$com : '')
      }
    })
  };
};
/**
 * Generate a scenario given a compiler configuration. If neither `scenarioId`
 * or `unlockingScriptId` are provided, the default scenario for the compiler
 * configuration will be generated.
 *
 * Returns either the full `CompilationData` for the selected scenario or an
 * error message (as a `string`).
 *
 * Note, this method should typically not be used directly, use
 * {@link Compiler.generateScenario} instead.
 */
// eslint-disable-next-line complexity
var generateScenarioBCH = function generateScenarioBCH(_ref12, debug) {
  var _configuration$scenar2, _extendedScenario$dat, _extendedScenario$sou, _configuration$unlock, _sourceOutputCompilat, _transactionInputComp;
  var configuration = _ref12.configuration,
    generateBytecode = _ref12.generateBytecode,
    scenarioId = _ref12.scenarioId,
    unlockingScriptId = _ref12.unlockingScriptId,
    providedLockingScriptId = _ref12.lockingScriptId;
  var _ref13 = scenarioId === undefined ? {
      scenarioDefinition: {},
      scenarioName: "the default scenario"
    } : {
      scenarioDefinition: (_configuration$scenar2 = configuration.scenarios) === null || _configuration$scenar2 === void 0 ? void 0 : _configuration$scenar2[scenarioId],
      scenarioName: "scenario \"".concat(scenarioId, "\"")
    },
    scenarioDefinition = _ref13.scenarioDefinition,
    scenarioName = _ref13.scenarioName;
  if (scenarioDefinition === undefined) {
    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
    return "Cannot generate ".concat(scenarioName, ": a scenario definition with the identifier ").concat(scenarioId, " is not included in this compiler configuration.");
  }
  var parentScenario = generateExtendedScenario({
    configuration: configuration,
    scenarioId: scenarioId
  });
  if (typeof parentScenario === 'string') {
    return "Cannot generate ".concat(scenarioName, ": ").concat(parentScenario);
  }
  var extendedScenario = extendScenarioDefinition(parentScenario, scenarioDefinition);
  var partialCompilationData = extendedScenarioDefinitionToCompilationData(extendedScenario);
  var fullCompilationData = extendCompilationDataWithScenarioBytecode({
    compilationData: partialCompilationData,
    configuration: configuration,
    scenarioDataBytecodeScripts: (_extendedScenario$dat = extendedScenario.data.bytecode) !== null && _extendedScenario$dat !== void 0 ? _extendedScenario$dat : {}
  });
  if (typeof fullCompilationData === 'string') {
    return "Cannot generate ".concat(scenarioName, ". ").concat(fullCompilationData);
  }
  if (extendedScenario.transaction.inputs.length !== extendedScenario.sourceOutputs.length) {
    return "Cannot generate ".concat(scenarioName, ": could not match source outputs with inputs - \"sourceOutputs\" must be the same length as \"transaction.inputs\".");
  }
  var testedInputs = extendedScenario.transaction.inputs.filter(function (input) {
    return Array.isArray(input.unlockingBytecode);
  });
  if (testedInputs.length !== 1) {
    return "Cannot generate ".concat(scenarioName, ": the specific input under test in this scenario is ambiguous - \"transaction.inputs\" must include exactly one input that has \"unlockingBytecode\" set to [\"slot\"].");
  }
  var testedInputIndex = extendedScenario.transaction.inputs.findIndex(function (input) {
    return Array.isArray(input.unlockingBytecode);
  });
  var testedSourceOutputs = extendedScenario.sourceOutputs.filter(function (output) {
    return Array.isArray(output.lockingBytecode);
  });
  if (testedSourceOutputs.length !== 1) {
    return "Cannot generate ".concat(scenarioName, ": the source output unlocked by the input under test in this scenario is ambiguous - \"sourceOutputs\" must include exactly one output that has \"lockingBytecode\" set to [\"slot\"].");
  }
  if (!Array.isArray((_extendedScenario$sou = extendedScenario.sourceOutputs[testedInputIndex]) === null || _extendedScenario$sou === void 0 ? void 0 : _extendedScenario$sou.lockingBytecode)) {
    return "Cannot generate ".concat(scenarioName, ": the source output unlocked by the input under test in this scenario is ambiguous - the [\"slot\"] in \"transaction.inputs\" and \"sourceOutputs\" must be at the same index.");
  }
  if (unlockingScriptId !== undefined && providedLockingScriptId !== undefined) {
    return "Cannot generate ".concat(scenarioName, ": a scenario cannot be generated with both unlocking and locking script IDs defined. If an unlocking script is provided, the associated locking script ID must be read from the template.");
  }
  var lockingScriptId = providedLockingScriptId === undefined ? unlockingScriptId === undefined ? undefined : (_configuration$unlock = configuration.unlockingScripts) === null || _configuration$unlock === void 0 ? void 0 : _configuration$unlock[unlockingScriptId] : providedLockingScriptId;
  if (unlockingScriptId !== undefined && lockingScriptId === undefined) {
    return "Cannot generate ".concat(scenarioName, " using unlocking script \"").concat(unlockingScriptId, "\": the locking script unlocked by \"").concat(unlockingScriptId, "\" is not provided in this compiler configuration.");
  }
  var sourceOutputCompilations = extendedScenario.sourceOutputs.map(function (sourceOutput, index) {
    var _sourceOutput$locking;
    var slot = Array.isArray(sourceOutput.lockingBytecode);
    var bytecodeDefinition = slot ? lockingScriptId === undefined ? CompilerDefaults.defaultScenarioBytecode : {
      script: lockingScriptId
    } : (_sourceOutput$locking = sourceOutput.lockingBytecode) !== null && _sourceOutput$locking !== void 0 ? _sourceOutput$locking : {};
    var defaultOverride = {};
    return {
      compiled: _objectSpread2({
        lockingBytecode: compileAuthenticationTemplateScenarioBytecode({
          bytecodeDefinition: bytecodeDefinition,
          configuration: configuration,
          defaultOverride: defaultOverride,
          extendedScenario: extendedScenario,
          generateBytecode: generateBytecode,
          lockingOrUnlockingScriptIdUnderTest: lockingScriptId
        }),
        valueSatoshis: compileAuthenticationTemplateScenarioValueSatoshis(sourceOutput.valueSatoshis)
      }, compileScenarioOutputTokenData(sourceOutput)),
      index: index,
      slot: slot,
      type: 'source output'
    };
  });
  var lockingCompilation = (_sourceOutputCompilat = sourceOutputCompilations.find(function (compilation) {
    return compilation.slot;
  })) === null || _sourceOutputCompilat === void 0 ? void 0 : _sourceOutputCompilat.compiled.lockingBytecode;
  var transactionOutputCompilations = extendedScenario.transaction.outputs.map(function (transactionOutput, index) {
    var _transactionOutput$lo;
    var defaultOverride = {
      hdKeys: {
        addressIndex: 1
      }
    };
    return {
      compiled: _objectSpread2({
        lockingBytecode: compileAuthenticationTemplateScenarioBytecode({
          bytecodeDefinition: (_transactionOutput$lo = transactionOutput.lockingBytecode) !== null && _transactionOutput$lo !== void 0 ? _transactionOutput$lo : {},
          configuration: configuration,
          defaultOverride: defaultOverride,
          extendedScenario: extendedScenario,
          generateBytecode: generateBytecode,
          lockingOrUnlockingScriptIdUnderTest: lockingScriptId
        }),
        valueSatoshis: compileAuthenticationTemplateScenarioValueSatoshis(transactionOutput.valueSatoshis)
      }, compileScenarioOutputTokenData(transactionOutput)),
      index: index,
      type: 'transaction output'
    };
  });
  var outputCompilationErrors = [].concat(_toConsumableArray(sourceOutputCompilations), _toConsumableArray(transactionOutputCompilations)).reduce(function (accumulated, result) {
    if ('errors' in result.compiled.lockingBytecode) {
      return [].concat(_toConsumableArray(accumulated), _toConsumableArray(result.compiled.lockingBytecode.errors.map(function (errorObject) {
        return "Failed compilation of ".concat(result.type, " at index ").concat(result.index, ": ").concat(errorObject.error);
      })));
    }
    return accumulated;
  }, []);
  if (outputCompilationErrors.length > 0) {
    var error = "Cannot generate ".concat(scenarioName, ": ").concat(outputCompilationErrors.join(' '));
    if (debug === true) {
      return {
        lockingCompilation: lockingCompilation,
        scenario: error
      };
    }
    return error;
  }
  var sourceOutputCompilationsSuccess = sourceOutputCompilations;
  var transactionOutputCompilationsSuccess = transactionOutputCompilations;
  var extractOutput = function extractOutput(compilation) {
    var _compilation$compiled = compilation.compiled,
      lockingBytecode = _compilation$compiled.lockingBytecode,
      valueSatoshis = _compilation$compiled.valueSatoshis,
      token = _compilation$compiled.token;
    return _objectSpread2({
      lockingBytecode: 'bytecode' in lockingBytecode ? lockingBytecode.bytecode : lockingBytecode,
      valueSatoshis: valueSatoshis
    }, token === undefined ? {} : {
      token: token
    });
  };
  var sourceOutputs = sourceOutputCompilationsSuccess.map(extractOutput);
  var outputs = transactionOutputCompilationsSuccess.map(extractOutput);
  var inputsContext = extendedScenario.transaction.inputs.map(function (input, inputIndex) {
    var _input$outpointIndex, _input$outpointTransa, _input$sequenceNumber;
    return {
      outpointIndex: (_input$outpointIndex = input.outpointIndex) !== null && _input$outpointIndex !== void 0 ? _input$outpointIndex : inputIndex,
      // TODO: doesn't verify length
      outpointTransactionHash: hexToBin((_input$outpointTransa = input.outpointTransactionHash) !== null && _input$outpointTransa !== void 0 ? _input$outpointTransa : CompilerDefaults.defaultScenarioInputOutpointTransactionHash),
      sequenceNumber: (_input$sequenceNumber = input.sequenceNumber) !== null && _input$sequenceNumber !== void 0 ? _input$sequenceNumber : CompilerDefaults.defaultScenarioInputSequenceNumber,
      unlockingBytecode: undefined
    };
  });
  var transactionInputCompilations = extendedScenario.transaction.inputs.map(function (input, index) {
    var _input$unlockingBytec;
    var slot = Array.isArray(input.unlockingBytecode);
    var bytecodeDefinition = Array.isArray(input.unlockingBytecode) ? unlockingScriptId === undefined ? CompilerDefaults.defaultScenarioBytecode : {
      script: unlockingScriptId
    } : (_input$unlockingBytec = input.unlockingBytecode) !== null && _input$unlockingBytec !== void 0 ? _input$unlockingBytec : {};
    var defaultOverride = {};
    return {
      compiled: {
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        outpointIndex: inputsContext[index].outpointIndex,
        outpointTransactionHash:
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        inputsContext[index].outpointTransactionHash,
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        sequenceNumber: inputsContext[index].sequenceNumber,
        unlockingBytecode: compileAuthenticationTemplateScenarioBytecode({
          bytecodeDefinition: bytecodeDefinition,
          compilationContext: {
            inputIndex: index,
            sourceOutputs: sourceOutputs,
            transaction: {
              inputs: inputsContext,
              locktime: extendedScenario.transaction.locktime,
              outputs: outputs,
              version: extendedScenario.transaction.version
            }
          },
          configuration: configuration,
          defaultOverride: defaultOverride,
          extendedScenario: extendedScenario,
          generateBytecode: generateBytecode,
          lockingOrUnlockingScriptIdUnderTest: unlockingScriptId
        })
      },
      index: index,
      slot: slot
    };
  });
  var unlockingCompilation = (_transactionInputComp = transactionInputCompilations.find(function (compilation) {
    return compilation.slot;
  })) === null || _transactionInputComp === void 0 ? void 0 : _transactionInputComp.compiled.unlockingBytecode;
  var inputCompilationErrors = transactionInputCompilations.reduce(function (accumulated, result) {
    if ('errors' in result.compiled.unlockingBytecode) {
      return [].concat(_toConsumableArray(accumulated), _toConsumableArray(result.compiled.unlockingBytecode.errors.map(function (errorObject) {
        return "Failed compilation of input at index ".concat(result.index, ": ").concat(errorObject.error);
      })));
    }
    return accumulated;
  }, []);
  if (inputCompilationErrors.length > 0) {
    var _error = "Cannot generate ".concat(scenarioName, ": ").concat(inputCompilationErrors.join(' '));
    if (debug === true) {
      return {
        lockingCompilation: lockingCompilation,
        scenario: _error,
        unlockingCompilation: unlockingCompilation
      };
    }
    return _error;
  }
  var transactionInputCompilationsSuccess = transactionInputCompilations;
  var inputs = transactionInputCompilationsSuccess.map(function (compilation) {
    var _compilation$compiled2 = compilation.compiled,
      outpointIndex = _compilation$compiled2.outpointIndex,
      outpointTransactionHash = _compilation$compiled2.outpointTransactionHash,
      sequenceNumber = _compilation$compiled2.sequenceNumber,
      unlockingBytecode = _compilation$compiled2.unlockingBytecode;
    return {
      outpointIndex: outpointIndex,
      outpointTransactionHash: outpointTransactionHash,
      sequenceNumber: sequenceNumber,
      unlockingBytecode: 'bytecode' in unlockingBytecode ? unlockingBytecode.bytecode : unlockingBytecode
    };
  });
  var scenario = {
    data: fullCompilationData,
    program: {
      inputIndex: testedInputIndex,
      sourceOutputs: sourceOutputs,
      transaction: {
        inputs: inputs,
        locktime: extendedScenario.transaction.locktime,
        outputs: outputs,
        version: extendedScenario.transaction.version
      }
    }
  };
  return debug === true ? {
    lockingCompilation: lockingCompilation,
    scenario: scenario,
    unlockingCompilation: unlockingCompilation
  } : scenario;
};

/**
 * Create a {@link Compiler.generateBytecode} method given a compiler
 * configuration.
 */
var createCompilerGenerateBytecodeFunction = function createCompilerGenerateBytecodeFunction(compilerConfiguration) {
  return function (_ref) {
    var data = _ref.data,
      debug = _ref.debug,
      scriptId = _ref.scriptId;
    var result = compileScript(scriptId, data, compilerConfiguration);
    return debug === true ? result : result.success ? {
      bytecode: result.bytecode,
      success: true
    } : {
      errorType: result.errorType,
      errors: result.errors,
      success: false
    };
  };
};
/**
 * Create a {@link Compiler} from the provided compiler configuration. This
 * method requires a full {@link CompilerConfiguration} and does not provide any
 * crypto or VM implementations.
 *
 * @param configuration - the configuration from which to create the compiler
 */
var compilerConfigurationToCompilerBCH = function compilerConfigurationToCompilerBCH(configuration) {
  var generateBytecode = createCompilerGenerateBytecodeFunction(configuration);
  return {
    configuration: configuration,
    generateBytecode: generateBytecode,
    generateScenario: function generateScenario(_ref2) {
      var lockingScriptId = _ref2.lockingScriptId,
        unlockingScriptId = _ref2.unlockingScriptId,
        scenarioId = _ref2.scenarioId,
        debug = _ref2.debug;
      return generateScenarioBCH({
        configuration: configuration,
        generateBytecode: generateBytecode,
        lockingScriptId: lockingScriptId,
        scenarioId: scenarioId,
        unlockingScriptId: unlockingScriptId
      }, debug);
    }
  };
};
var compilerConfigurationToCompiler = compilerConfigurationToCompilerBCH;
var nullHashLength = 32;
/**
 * A common {@link createAuthenticationProgram} implementation for
 * most compilers.
 *
 * Accepts the compiled contents of an evaluation and produces a
 * {@link AuthenticationProgramCommon} that can be evaluated to produce the
 * resulting program state.
 *
 * The precise shape of the authentication program produced by this method is
 * critical to the determinism of CashAssembly evaluations for the compiler in
 * which it is used, it therefore must be standardized between compiler
 * implementations.
 *
 * @param evaluationBytecode - the compiled bytecode to incorporate in the
 * created authentication program
 */
var createAuthenticationProgramEvaluationCommon = function createAuthenticationProgramEvaluationCommon(evaluationBytecode) {
  return {
    inputIndex: 0,
    sourceOutputs: [{
      lockingBytecode: evaluationBytecode,
      valueSatoshis: 0n
    }],
    transaction: {
      inputs: [{
        outpointIndex: 0,
        outpointTransactionHash: new Uint8Array(nullHashLength),
        sequenceNumber: 0,
        unlockingBytecode: Uint8Array.of()
      }],
      locktime: 0,
      outputs: [{
        lockingBytecode: Uint8Array.of(),
        valueSatoshis: 0n
      }],
      version: 0
    }
  };
};
/**
 * Create a compiler using the default common compiler configuration. Because
 * this compiler has no access to a VM, it cannot compile evaluations.
 *
 * @param scriptsAndOverrides - a compiler configuration from which properties
 * will be used to override properties of the default common compiler
 * configuration – must include the `scripts` property
 */
var createCompilerCommon = function createCompilerCommon(scriptsAndOverrides) {
  return compilerConfigurationToCompilerBCH(_objectSpread2(_objectSpread2({}, {
    createAuthenticationProgram: createAuthenticationProgramEvaluationCommon,
    opcodes: generateBytecodeMap(Opcodes),
    operations: compilerOperationsCommon,
    ripemd160: ripemd160$1,
    secp256k1: secp256k1,
    sha256: sha256$1,
    sha512: sha512$1
  }), scriptsAndOverrides));
};
/**
 * Perform a simplified compilation on a CashAssembly script containing only hex
 * literals, bigint literals, UTF8 literals, and push statements. Scripts may
 * not contain variables/operations, evaluations, or opcode identifiers (use hex
 * literals instead).
 *
 * This is useful for accepting complex user input in advanced interfaces,
 * especially for `AddressData` and `WalletData`.
 *
 * Returns the compiled bytecode as a `Uint8Array`, or throws an error message.
 *
 * @param script - a simple CashAssembly script containing no variables or
 * evaluations
 */
var compileCashAssembly = function compileCashAssembly(script) {
  var result = createCompilerCommon({
    opcodes: {},
    operations: {},
    scripts: {
      script: script
    }
  }).generateBytecode({
    data: {},
    scriptId: 'script'
  });
  if (result.success) {
    return result.bytecode;
  }
  return "CashAssembly compilation error:".concat(result.errors.reduce(function (all, _ref3) {
    var error = _ref3.error,
      range = _ref3.range;
    return "".concat(all, " [").concat(range.startLineNumber, ", ").concat(range.startColumn, "]: ").concat(error);
  }, ''));
};
/**
 * Re-assemble a string of disassembled bytecode
 * (see {@link disassembleBytecode}).
 *
 * @param opcodes - a mapping of opcodes to their respective Uint8Array
 * representation
 * @param disassembledBytecode - the disassembled bytecode to re-assemble
 */
var assembleBytecode = function assembleBytecode(opcodes, disassembledBytecode) {
  var configuration = {
    opcodes: opcodes,
    scripts: {
      asm: disassembledBytecode
    }
  };
  return createCompilerCommon(configuration).generateBytecode({
    data: {},
    scriptId: 'asm'
  });
};
/**
 * Re-assemble a string of disassembled BCH bytecode; see
 * {@link disassembleBytecodeBCH}.
 *
 * Note, this method performs automatic minimization of push instructions.
 *
 * @param disassembledBytecode - the disassembled BCH bytecode to re-assemble
 */
var assembleBytecodeBCH = function assembleBytecodeBCH(disassembledBytecode) {
  return assembleBytecode(generateBytecodeMap(OpcodesBCH), disassembledBytecode);
};
/**
 * A convenience method to compile CashAssembly (using
 * {@link assembleBytecodeBCH}) to bytecode. If compilation fails, errors are
 * returned as a string.
 */
var cashAssemblyToBin = function cashAssemblyToBin(cashAssemblyScript) {
  var result = assembleBytecodeBCH(cashAssemblyScript);
  return result.success ? result.bytecode : "CashAssembly compilation ".concat(result.errorType, " error: ").concat(result.errors.map(function (err) {
    return err.error;
  }).join(' '));
};
/**
 * Re-assemble a string of disassembled BCH bytecode; see
 * {@link disassembleBytecodeBTC}.
 *
 * Note, this method performs automatic minimization of push instructions.
 *
 * @param disassembledBytecode - the disassembled BTC bytecode to re-assemble
 */
var assembleBytecodeBTC = function assembleBytecodeBTC(disassembledBytecode) {
  return assembleBytecode(generateBytecodeMap(OpcodesBTC), disassembledBytecode);
};
/**
 * Create a partial {@link CompilerConfiguration} from an
 * {@link AuthenticationTemplate} by extracting and formatting the `scripts` and
 * `variables` properties.
 *
 * Note, if this {@link AuthenticationTemplate} might be malformed, first
 * validate it with {@link importAuthenticationTemplate}.
 *
 * @param template - the {@link AuthenticationTemplate} from which to extract
 * the compiler configuration
 */
var authenticationTemplateToCompilerConfiguration = function authenticationTemplateToCompilerConfiguration(template) {
  /**
   * Template scripts including virtualized test scripts.
   */
  var virtualizedScripts = Object.entries(template.scripts).reduce(function (all, _ref4) {
    var _ref5 = _slicedToArray(_ref4, 2),
      scriptId = _ref5[0],
      script = _ref5[1];
    if ('tests' in script) {
      return _objectSpread2(_objectSpread2({}, all), Object.entries(script.tests).reduce(function (tests, _ref6) {
        var _test$setup, _objectSpread2$1;
        var _ref7 = _slicedToArray(_ref6, 2),
          testId = _ref7[0],
          test = _ref7[1];
        var pushTestedScript = script.pushed === true;
        var checkScriptId = "".concat(scriptId, ".").concat(testId, ".check");
        var virtualizedLockingScriptId = "".concat(scriptId, ".").concat(testId, ".lock");
        var virtualizedUnlockingScriptId = "".concat(scriptId, ".").concat(testId, ".unlock");
        return _objectSpread2(_objectSpread2({}, tests), {}, (_objectSpread2$1 = {}, _defineProperty(_objectSpread2$1, checkScriptId, {
          script: test.check
        }), _defineProperty(_objectSpread2$1, virtualizedLockingScriptId, {
          script: pushTestedScript ? "<".concat(scriptId, "> ").concat(checkScriptId) : "".concat(scriptId, " ").concat(checkScriptId)
        }), _defineProperty(_objectSpread2$1, virtualizedUnlockingScriptId, {
          script: (_test$setup = test.setup) !== null && _test$setup !== void 0 ? _test$setup : '',
          unlocks: virtualizedLockingScriptId
        }), _objectSpread2$1));
      }, {}));
    }
    return all;
  }, {});
  var allScripts = _objectSpread2(_objectSpread2({}, template.scripts), virtualizedScripts);
  var scripts = Object.entries(allScripts).reduce(function (all, _ref8) {
    var _ref9 = _slicedToArray(_ref8, 2),
      id = _ref9[0],
      def = _ref9[1];
    return _objectSpread2(_objectSpread2({}, all), {}, _defineProperty({}, id, def.script));
  }, {});
  var variables = Object.values(template.entities).reduce(function (all, entity) {
    return _objectSpread2(_objectSpread2({}, all), entity.variables);
  }, {});
  var entityOwnership = Object.entries(template.entities).reduce(function (all, _ref10) {
    var _entity$variables;
    var _ref11 = _slicedToArray(_ref10, 2),
      entityId = _ref11[0],
      entity = _ref11[1];
    return _objectSpread2(_objectSpread2({}, all), Object.keys((_entity$variables = entity.variables) !== null && _entity$variables !== void 0 ? _entity$variables : {}).reduce(function (entityVariables, variableId) {
      return _objectSpread2(_objectSpread2({}, entityVariables), {}, _defineProperty({}, variableId, entityId));
    }, {}));
  }, {});
  var unlockingScripts = Object.entries(allScripts).reduce(function (all, _ref12) {
    var _ref13 = _slicedToArray(_ref12, 2),
      id = _ref13[0],
      def = _ref13[1];
    return 'unlocks' in def && def.unlocks !== undefined ? _objectSpread2(_objectSpread2({}, all), {}, _defineProperty({}, id, def.unlocks)) : all;
  }, {});
  var unlockingScriptTimeLockTypes = Object.entries(allScripts).reduce(function (all, _ref14) {
    var _ref15 = _slicedToArray(_ref14, 2),
      id = _ref15[0],
      def = _ref15[1];
    return 'timeLockType' in def && def.timeLockType !== undefined ? _objectSpread2(_objectSpread2({}, all), {}, _defineProperty({}, id, def.timeLockType)) : all;
  }, {});
  var lockingScriptTypes = Object.entries(allScripts).reduce(function (all, _ref16) {
    var _ref17 = _slicedToArray(_ref16, 2),
      id = _ref17[0],
      def = _ref17[1];
    return 'lockingType' in def && def.lockingType !== undefined ? _objectSpread2(_objectSpread2({}, all), {}, _defineProperty({}, id, def.lockingType)) : all;
  }, {});
  var scenarios = template.scenarios === undefined ? undefined : Object.entries(template.scenarios).reduce(function (all, _ref18) {
    var _ref19 = _slicedToArray(_ref18, 2),
      id = _ref19[0],
      def = _ref19[1];
    return _objectSpread2(_objectSpread2({}, all), {}, _defineProperty({}, id, def));
  }, {});
  return _objectSpread2(_objectSpread2({
    entityOwnership: entityOwnership,
    lockingScriptTypes: lockingScriptTypes
  }, scenarios === undefined ? {} : {
    scenarios: scenarios
  }), {}, {
    scripts: scripts,
    unlockingScriptTimeLockTypes: unlockingScriptTimeLockTypes,
    unlockingScripts: unlockingScripts,
    variables: variables
  });
};

var SigningSerializationAlgorithmIdentifier;
(function (SigningSerializationAlgorithmIdentifier) {
  /**
   * A.K.A. `SIGHASH_ALL|SIGHASH_FORKID`
   */
  SigningSerializationAlgorithmIdentifier["allOutputs"] = "all_outputs";
  /**
   * A.K.A. `SIGHASH_ALL|SIGHASH_UTXOS|SIGHASH_FORKID`
   */
  SigningSerializationAlgorithmIdentifier["allOutputsAllUtxos"] = "all_outputs_all_utxos";
  /**
   * A.K.A. `SIGHASH_ALL|SIGHASH_FORKID|ANYONECANPAY`
   */
  SigningSerializationAlgorithmIdentifier["allOutputsSingleInput"] = "all_outputs_single_input";
  /**
   * A.K.A. `SIGHASH_ALL|SIGHASH_UTXOS|SIGHASH_FORKID|ANYONECANPAY`
   */
  SigningSerializationAlgorithmIdentifier["allOutputsSingleInputInvalidAllUtxos"] = "all_outputs_single_input_INVALID_all_utxos";
  /**
   * A.K.A. `SIGHASH_SINGLE|SIGHASH_FORKID`
   */
  SigningSerializationAlgorithmIdentifier["correspondingOutput"] = "corresponding_output";
  /**
   * A.K.A. `SIGHASH_SINGLE|SIGHASH_UTXOS|SIGHASH_FORKID`
   */
  SigningSerializationAlgorithmIdentifier["correspondingOutputAllUtxos"] = "corresponding_output_all_utxos";
  /**
   * A.K.A. `SIGHASH_SINGLE|SIGHASH_FORKID|ANYONECANPAY`
   */
  SigningSerializationAlgorithmIdentifier["correspondingOutputSingleInput"] = "corresponding_output_single_input";
  /**
   * A.K.A. `SIGHASH_SINGLE|SIGHASH_UTXOS|SIGHASH_FORKID|ANYONECANPAY`
   */
  SigningSerializationAlgorithmIdentifier["correspondingOutputSingleInputInvalidAllUtxos"] = "corresponding_output_single_input_INVALID_all_utxos";
  /**
   * An alias for `all_outputs_all_utxos`
   * (A.K.A. `SIGHASH_ALL|SIGHASH_UTXOS|SIGHASH_FORKID`),
   * the most secure signing serialization algorithm.
   *
   * Note that as of 2022, `all_outputs` (A.K.A. `SIGHASH_ALL|SIGHASH_FORKID`)
   * is more commonly used and is therefore a better choice for privacy in
   * common, existing contract types.
   */
  SigningSerializationAlgorithmIdentifier["default"] = "default";
  /**
   * A.K.A `SIGHASH_NONE|SIGHASH_FORKID`
   */
  SigningSerializationAlgorithmIdentifier["noOutputs"] = "no_outputs";
  /**
   * A.K.A `SIGHASH_NONE|SIGHASH_UTXOS|SIGHASH_FORKID`
   */
  SigningSerializationAlgorithmIdentifier["noOutputsAllUtxos"] = "no_outputs_all_utxos";
  /**
   * A.K.A `SIGHASH_NONE|SIGHASH_FORKID|ANYONECANPAY`
   */
  SigningSerializationAlgorithmIdentifier["noOutputsSingleInput"] = "no_outputs_single_input";
  /**
   * A.K.A. `SIGHASH_NONE|SIGHASH_UTXOS|SIGHASH_FORKID|ANYONECANPAY`
   */
  SigningSerializationAlgorithmIdentifier["noOutputsSingleInputInvalidAllUtxos"] = "no_outputs_single_input_INVALID_all_utxos";
})(SigningSerializationAlgorithmIdentifier || (SigningSerializationAlgorithmIdentifier = {}));
// eslint-disable-next-line complexity
var getSigningSerializationType = function getSigningSerializationType(algorithmIdentifier) {
  var prefix = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';
  switch (algorithmIdentifier) {
    case "".concat(prefix).concat(SigningSerializationAlgorithmIdentifier.allOutputs):
      return Uint8Array.of(SigningSerializationTypeBCH.allOutputs);
    case "".concat(prefix).concat(SigningSerializationAlgorithmIdentifier.allOutputsAllUtxos):
    case "".concat(prefix).concat(SigningSerializationAlgorithmIdentifier.default):
      return Uint8Array.of(SigningSerializationTypeBCH.allOutputsAllUtxos);
    case "".concat(prefix).concat(SigningSerializationAlgorithmIdentifier.allOutputsSingleInput):
      return Uint8Array.of(SigningSerializationTypeBCH.allOutputsSingleInput);
    case "".concat(prefix).concat(SigningSerializationAlgorithmIdentifier.allOutputsSingleInputInvalidAllUtxos):
      return Uint8Array.of(
      // eslint-disable-next-line no-bitwise
      SigningSerializationFlag.allOutputs | SigningSerializationFlag.singleInput | SigningSerializationFlag.utxos | SigningSerializationFlag.forkId);
    case "".concat(prefix).concat(SigningSerializationAlgorithmIdentifier.correspondingOutput):
      return Uint8Array.of(SigningSerializationTypeBCH.correspondingOutput);
    case "".concat(prefix).concat(SigningSerializationAlgorithmIdentifier.correspondingOutputAllUtxos):
      return Uint8Array.of(SigningSerializationTypeBCH.correspondingOutputAllUtxos);
    case "".concat(prefix).concat(SigningSerializationAlgorithmIdentifier.correspondingOutputSingleInput):
      return Uint8Array.of(SigningSerializationTypeBCH.correspondingOutputSingleInput);
    case "".concat(prefix).concat(SigningSerializationAlgorithmIdentifier.correspondingOutputSingleInputInvalidAllUtxos):
      return Uint8Array.of(
      // eslint-disable-next-line no-bitwise
      SigningSerializationFlag.correspondingOutput | SigningSerializationFlag.singleInput | SigningSerializationFlag.utxos | SigningSerializationFlag.forkId);
    case "".concat(prefix).concat(SigningSerializationAlgorithmIdentifier.noOutputs):
      return Uint8Array.of(SigningSerializationTypeBCH.noOutputs);
    case "".concat(prefix).concat(SigningSerializationAlgorithmIdentifier.noOutputsAllUtxos):
      return Uint8Array.of(SigningSerializationTypeBCH.noOutputsAllUtxos);
    case "".concat(prefix).concat(SigningSerializationAlgorithmIdentifier.noOutputsSingleInput):
      return Uint8Array.of(SigningSerializationTypeBCH.noOutputsSingleInput);
    case "".concat(prefix).concat(SigningSerializationAlgorithmIdentifier.noOutputsSingleInputInvalidAllUtxos):
      return Uint8Array.of(
      // eslint-disable-next-line no-bitwise
      SigningSerializationFlag.noOutputs | SigningSerializationFlag.singleInput | SigningSerializationFlag.utxos | SigningSerializationFlag.forkId);
    default:
      return undefined;
  }
};
var compilerOperationHelperComputeSignatureBCH = function compilerOperationHelperComputeSignatureBCH(_ref) {
  var coveredBytecode = _ref.coveredBytecode,
    identifier = _ref.identifier,
    compilationContext = _ref.compilationContext,
    operationName = _ref.operationName,
    privateKey = _ref.privateKey,
    sha256 = _ref.sha256,
    sign = _ref.sign;
  var _identifier$split = identifier.split('.'),
    _identifier$split2 = _slicedToArray(_identifier$split, 4),
    algorithm = _identifier$split2[2],
    unknown = _identifier$split2[3];
  if (unknown !== undefined) {
    return {
      error: "Unknown component in \"".concat(identifier, "\" - the fragment \"").concat(unknown, "\" is not recognized."),
      status: 'error'
    };
  }
  if (algorithm === undefined) {
    return {
      error: "Invalid signature identifier. Signatures must be of the form: \"[variable_id].".concat(operationName, ".[signing_serialization_type]\"."),
      status: 'error'
    };
  }
  var signingSerializationType = getSigningSerializationType(algorithm);
  if (signingSerializationType === undefined) {
    return {
      error: "Unknown signing serialization algorithm, \"".concat(algorithm, "\"."),
      status: 'error'
    };
  }
  var serialization = generateSigningSerializationBCH(compilationContext, {
    coveredBytecode: coveredBytecode,
    signingSerializationType: signingSerializationType
  }, sha256);
  var digest = hash256(serialization, sha256);
  var bitcoinEncodedSignature = Uint8Array.from([].concat(_toConsumableArray(sign(privateKey, digest)), _toConsumableArray(signingSerializationType)));
  return {
    bytecode: bitcoinEncodedSignature,
    signature: {
      serialization: serialization
    },
    status: 'success'
  };
};
var compilerOperationHelperHdKeySignatureBCH = function compilerOperationHelperHdKeySignatureBCH(_ref2) {
  var operationName = _ref2.operationName,
    secp256k1Method = _ref2.secp256k1Method;
  return attemptCompilerOperations([compilerOperationAttemptBytecodeResolution], compilerOperationRequires({
    canBeSkipped: false,
    configurationProperties: ['entityOwnership', 'ripemd160', 'secp256k1', 'sha256', 'sha512', 'variables', 'sourceScriptIds', 'unlockingScripts'],
    dataProperties: ['hdKeys', 'compilationContext'],
    operation: function operation(identifier, data, configuration) {
      var hdKeys = data.hdKeys,
        compilationContext = data.compilationContext;
      var secp256k1 = configuration.secp256k1,
        sha256 = configuration.sha256,
        sourceScriptIds = configuration.sourceScriptIds,
        unlockingScripts = configuration.unlockingScripts;
      var derivationResult = compilerOperationHelperDeriveHdKeyPrivate({
        configuration: configuration,
        hdKeys: hdKeys,
        identifier: identifier
      });
      if (derivationResult.status === 'error') return derivationResult;
      var result = compilerOperationHelperGenerateCoveredBytecode({
        configuration: configuration,
        data: data,
        identifier: identifier,
        sourceScriptIds: sourceScriptIds,
        unlockingScripts: unlockingScripts
      });
      if ('error' in result) {
        return result;
      }
      return compilerOperationHelperComputeSignatureBCH({
        compilationContext: compilationContext,
        coveredBytecode: result,
        identifier: identifier,
        operationName: operationName,
        privateKey: derivationResult.bytecode,
        sha256: sha256,
        sign: secp256k1[secp256k1Method]
      });
    }
  }));
};
var compilerOperationHdKeyEcdsaSignatureBCH = compilerOperationHelperHdKeySignatureBCH({
  operationName: 'signature',
  secp256k1Method: 'signMessageHashDER'
});
var compilerOperationHdKeySchnorrSignatureBCH = compilerOperationHelperHdKeySignatureBCH({
  operationName: 'schnorr_signature',
  secp256k1Method: 'signMessageHashSchnorr'
});
var compilerOperationHelperKeySignatureBCH = function compilerOperationHelperKeySignatureBCH(_ref3) {
  var operationName = _ref3.operationName,
    secp256k1Method = _ref3.secp256k1Method;
  return attemptCompilerOperations([compilerOperationAttemptBytecodeResolution], compilerOperationRequires({
    canBeSkipped: false,
    configurationProperties: ['sha256', 'secp256k1', 'unlockingScripts', 'sourceScriptIds'],
    dataProperties: ['keys', 'compilationContext'],
    operation: function operation(identifier, data, configuration) {
      var keys = data.keys,
        compilationContext = data.compilationContext;
      var secp256k1 = configuration.secp256k1,
        sha256 = configuration.sha256,
        unlockingScripts = configuration.unlockingScripts,
        sourceScriptIds = configuration.sourceScriptIds;
      var privateKeys = keys.privateKeys;
      var _identifier$split3 = identifier.split('.'),
        _identifier$split4 = _slicedToArray(_identifier$split3, 1),
        variableId = _identifier$split4[0];
      var privateKey = privateKeys === undefined ? undefined : privateKeys[variableId];
      if (privateKey === undefined) {
        return {
          error: "Identifier \"".concat(identifier, "\" refers to a Key, but a private key for \"").concat(variableId, "\" (or an existing signature) was not provided in the compilation data."),
          recoverable: true,
          status: 'error'
        };
      }
      var result = compilerOperationHelperGenerateCoveredBytecode({
        configuration: configuration,
        data: data,
        identifier: identifier,
        sourceScriptIds: sourceScriptIds,
        unlockingScripts: unlockingScripts
      });
      if ('error' in result) {
        return result;
      }
      return compilerOperationHelperComputeSignatureBCH({
        compilationContext: compilationContext,
        coveredBytecode: result,
        identifier: identifier,
        operationName: operationName,
        privateKey: privateKey,
        sha256: sha256,
        sign: secp256k1[secp256k1Method]
      });
    }
  }));
};
var compilerOperationKeyEcdsaSignatureBCH = compilerOperationHelperKeySignatureBCH({
  operationName: 'signature',
  secp256k1Method: 'signMessageHashDER'
});
var compilerOperationKeySchnorrSignatureBCH = compilerOperationHelperKeySignatureBCH({
  operationName: 'schnorr_signature',
  secp256k1Method: 'signMessageHashSchnorr'
});
var compilerOperationHelperComputeDataSignatureBCH = function compilerOperationHelperComputeDataSignatureBCH(_ref4) {
  var data = _ref4.data,
    configuration = _ref4.configuration,
    identifier = _ref4.identifier,
    operationName = _ref4.operationName,
    privateKey = _ref4.privateKey,
    sha256 = _ref4.sha256,
    sign = _ref4.sign;
  var _identifier$split5 = identifier.split('.'),
    _identifier$split6 = _slicedToArray(_identifier$split5, 4),
    scriptId = _identifier$split6[2],
    unknown = _identifier$split6[3];
  if (unknown !== undefined) {
    return {
      error: "Unknown component in \"".concat(identifier, "\" - the fragment \"").concat(unknown, "\" is not recognized."),
      status: 'error'
    };
  }
  if (scriptId === undefined) {
    return {
      error: "Invalid data signature identifier. Data signatures must be of the form: \"[variable_id].".concat(operationName, ".[target_script_id]\"."),
      status: 'error'
    };
  }
  var result = compilerOperationHelperCompileScript({
    configuration: configuration,
    data: data,
    targetScriptId: scriptId
  });
  if (result === false) {
    return {
      error: "Data signature tried to sign an unknown target script, \"".concat(scriptId, "\"."),
      status: 'error'
    };
  }
  if ('error' in result) {
    return result;
  }
  var digest = sha256.hash(result);
  return {
    bytecode: sign(privateKey, digest),
    signature: {
      digest: digest,
      message: result
    },
    status: 'success'
  };
};
var compilerOperationHelperKeyDataSignatureBCH = function compilerOperationHelperKeyDataSignatureBCH(_ref5) {
  var operationName = _ref5.operationName,
    secp256k1Method = _ref5.secp256k1Method;
  return attemptCompilerOperations([compilerOperationAttemptBytecodeResolution], compilerOperationRequires({
    canBeSkipped: false,
    configurationProperties: ['sha256', 'secp256k1'],
    dataProperties: ['keys'],
    operation: function operation(identifier, data, configuration) {
      var keys = data.keys;
      var secp256k1 = configuration.secp256k1,
        sha256 = configuration.sha256;
      var privateKeys = keys.privateKeys;
      var _identifier$split7 = identifier.split('.'),
        _identifier$split8 = _slicedToArray(_identifier$split7, 1),
        variableId = _identifier$split8[0];
      var privateKey = privateKeys === undefined ? undefined : privateKeys[variableId];
      if (privateKey === undefined) {
        return {
          error: "Identifier \"".concat(identifier, "\" refers to a Key, but a private key for \"").concat(variableId, "\" (or an existing signature) was not provided in the compilation data."),
          recoverable: true,
          status: 'error'
        };
      }
      return compilerOperationHelperComputeDataSignatureBCH({
        configuration: configuration,
        data: data,
        identifier: identifier,
        operationName: operationName,
        privateKey: privateKey,
        sha256: sha256,
        sign: secp256k1[secp256k1Method]
      });
    }
  }));
};
var compilerOperationKeyEcdsaDataSignatureBCH = compilerOperationHelperKeyDataSignatureBCH({
  operationName: 'data_signature',
  secp256k1Method: 'signMessageHashDER'
});
var compilerOperationKeySchnorrDataSignatureBCH = compilerOperationHelperKeyDataSignatureBCH({
  operationName: 'schnorr_data_signature',
  secp256k1Method: 'signMessageHashSchnorr'
});
var compilerOperationHelperHdKeyDataSignatureBCH = function compilerOperationHelperHdKeyDataSignatureBCH(_ref6) {
  var operationName = _ref6.operationName,
    secp256k1Method = _ref6.secp256k1Method;
  return attemptCompilerOperations([compilerOperationAttemptBytecodeResolution], compilerOperationRequires({
    canBeSkipped: false,
    configurationProperties: ['entityOwnership', 'ripemd160', 'secp256k1', 'sha256', 'sha512', 'variables'],
    dataProperties: ['hdKeys'],
    operation: function operation(identifier, data, configuration) {
      var hdKeys = data.hdKeys;
      var secp256k1 = configuration.secp256k1,
        sha256 = configuration.sha256;
      var derivationResult = compilerOperationHelperDeriveHdKeyPrivate({
        configuration: configuration,
        hdKeys: hdKeys,
        identifier: identifier
      });
      if (derivationResult.status === 'error') return derivationResult;
      return compilerOperationHelperComputeDataSignatureBCH({
        configuration: configuration,
        data: data,
        identifier: identifier,
        operationName: operationName,
        privateKey: derivationResult.bytecode,
        sha256: sha256,
        sign: secp256k1[secp256k1Method]
      });
    }
  }));
};
var compilerOperationHdKeyEcdsaDataSignatureBCH = compilerOperationHelperHdKeyDataSignatureBCH({
  operationName: 'data_signature',
  secp256k1Method: 'signMessageHashDER'
});
var compilerOperationHdKeySchnorrDataSignatureBCH = compilerOperationHelperHdKeyDataSignatureBCH({
  operationName: 'schnorr_data_signature',
  secp256k1Method: 'signMessageHashSchnorr'
});
var compilerOperationSigningSerializationFullBCH = compilerOperationRequires({
  canBeSkipped: false,
  configurationProperties: ['sha256', 'sourceScriptIds', 'unlockingScripts'],
  dataProperties: ['compilationContext'],
  operation: function operation(identifier, data, configuration) {
    var _identifier$split9 = identifier.split('.'),
      _identifier$split10 = _slicedToArray(_identifier$split9, 3),
      algorithmOrComponent = _identifier$split10[1],
      unknownPart = _identifier$split10[2];
    if (algorithmOrComponent === undefined) {
      return {
        error: "Invalid signing serialization operation. Include the desired component or algorithm, e.g. \"signing_serialization.version\".",
        status: 'error'
      };
    }
    if (unknownPart !== undefined) {
      return {
        error: "Unknown component in \"".concat(identifier, "\" - the fragment \"").concat(unknownPart, "\" is not recognized."),
        status: 'error'
      };
    }
    var signingSerializationType = getSigningSerializationType(algorithmOrComponent, 'full_');
    if (signingSerializationType === undefined) {
      return {
        error: "Unknown signing serialization algorithm, \"".concat(algorithmOrComponent, "\"."),
        status: 'error'
      };
    }
    var sha256 = configuration.sha256,
      sourceScriptIds = configuration.sourceScriptIds,
      unlockingScripts = configuration.unlockingScripts;
    var result = compilerOperationHelperGenerateCoveredBytecode({
      configuration: configuration,
      data: data,
      identifier: identifier,
      sourceScriptIds: sourceScriptIds,
      unlockingScripts: unlockingScripts
    });
    if ('error' in result) {
      return result;
    }
    var compilationContext = data.compilationContext;
    return {
      bytecode: generateSigningSerializationBCH(compilationContext, {
        coveredBytecode: result,
        signingSerializationType: signingSerializationType
      }, sha256),
      status: 'success'
    };
  }
});
/* eslint-disable camelcase, @typescript-eslint/naming-convention */
var compilerOperationsBCH = _objectSpread2(_objectSpread2({}, compilerOperationsCommon), {}, {
  hdKey: {
    data_signature: compilerOperationHdKeyEcdsaDataSignatureBCH,
    public_key: compilerOperationsCommon.hdKey.public_key,
    schnorr_data_signature: compilerOperationHdKeySchnorrDataSignatureBCH,
    schnorr_signature: compilerOperationHdKeySchnorrSignatureBCH,
    signature: compilerOperationHdKeyEcdsaSignatureBCH
  },
  key: {
    data_signature: compilerOperationKeyEcdsaDataSignatureBCH,
    public_key: compilerOperationsCommon.key.public_key,
    schnorr_data_signature: compilerOperationKeySchnorrDataSignatureBCH,
    schnorr_signature: compilerOperationKeySchnorrSignatureBCH,
    signature: compilerOperationKeyEcdsaSignatureBCH
  },
  signingSerialization: _objectSpread2(_objectSpread2({}, compilerOperationsCommon.signingSerialization), {}, {
    full_all_outputs: compilerOperationSigningSerializationFullBCH,
    full_all_outputs_all_utxos: compilerOperationSigningSerializationFullBCH,
    full_all_outputs_single_input: compilerOperationSigningSerializationFullBCH,
    full_all_outputs_single_input_INVALID_all_utxos: compilerOperationSigningSerializationFullBCH,
    full_corresponding_output: compilerOperationSigningSerializationFullBCH,
    full_corresponding_output_all_utxos: compilerOperationSigningSerializationFullBCH,
    full_corresponding_output_single_input: compilerOperationSigningSerializationFullBCH,
    full_corresponding_output_single_input_INVALID_all_utxos: compilerOperationSigningSerializationFullBCH,
    full_default: compilerOperationSigningSerializationFullBCH,
    full_no_outputs: compilerOperationSigningSerializationFullBCH,
    full_no_outputs_all_utxos: compilerOperationSigningSerializationFullBCH,
    full_no_outputs_single_input: compilerOperationSigningSerializationFullBCH,
    full_no_outputs_single_input_INVALID_all_utxos: compilerOperationSigningSerializationFullBCH
  })
});
/**
 * Create a compiler using the default BCH compiler configuration.
 *
 * Internally instantiates the necessary crypto and VM implementations – use
 * {@link compilerConfigurationToCompilerBCH} for more control.
 *
 * @param configuration - a compiler configuration from which properties
 * will be used to override properties of the default BCH configuration – must
 * include the `scripts` property
 */
var createCompilerBCH = function createCompilerBCH(configuration) {
  return compilerConfigurationToCompilerBCH(_objectSpread2(_objectSpread2({}, {
    createAuthenticationProgram: createAuthenticationProgramEvaluationCommon,
    opcodes: generateBytecodeMap(OpcodesBCHCHIPs),
    operations: compilerOperationsBCH,
    ripemd160: ripemd160$1,
    secp256k1: secp256k1,
    sha256: sha256$1,
    sha512: sha512$1,
    vm: configuration.vm === undefined ? createVirtualMachineBCH() : configuration.vm
  }), configuration));
};
var createCompiler = createCompilerBCH;
/**
 * Create a BCH `Compiler` from an `AuthenticationTemplate` and an optional set
 * of overrides.
 * @param template - the `AuthenticationTemplate` from which to create the BCH
 * compiler
 * @param overrides - a compiler configuration from which properties will be
 * used to override properties of the default BCH configuration
 */
var authenticationTemplateToCompilerBCH = function authenticationTemplateToCompilerBCH(template, overrides) {
  return createCompilerBCH(_objectSpread2(_objectSpread2({}, overrides), authenticationTemplateToCompilerConfiguration(template)));
};

/**
 * A standard single-factor authentication template that uses
 * Pay-to-Public-Key-Hash (P2PKH), the most common authentication scheme in use
 * on the network.
 *
 * This P2PKH template uses BCH Schnorr signatures, reducing the size of
 * transactions.
 *
 * Note, this authentication template uses only a single `Key`. For HD key
 * support, see {@link authenticationTemplateP2pkhHd}.
 */
var authenticationTemplateP2pkhNonHd = {
  $schema: 'https://bitauth.com/schemas/authentication-template-v0.schema.json',
  description: 'A standard single-factor authentication template that uses Pay-to-Public-Key-Hash (P2PKH), the most common authentication scheme in use on the network.\n\nThis P2PKH template uses BCH Schnorr signatures, reducing the size of transactions.',
  entities: {
    owner: {
      description: 'The individual who can spend from this wallet.',
      name: 'Owner',
      scripts: ['lock', 'unlock'],
      variables: {
        key: {
          description: 'The private key that controls this wallet.',
          name: 'Key',
          type: 'Key'
        }
      }
    }
  },
  name: 'Single Signature (P2PKH)',
  scripts: {
    lock: {
      lockingType: 'standard',
      name: 'P2PKH Lock',
      script: 'OP_DUP\nOP_HASH160 <$(<key.public_key> OP_HASH160\n)> OP_EQUALVERIFY\nOP_CHECKSIG'
    },
    unlock: {
      name: 'Unlock',
      script: '<key.schnorr_signature.all_outputs>\n<key.public_key>',
      unlocks: 'lock'
    }
  },
  supported: ['BCH_2020_05', 'BCH_2021_05', 'BCH_2022_05'],
  version: 0
};
/**
 * A standard single-factor authentication template that uses
 * Pay-to-Public-Key-Hash (P2PKH), the most common authentication scheme in use
 * on the network.
 *
 * This P2PKH template uses BCH Schnorr signatures, reducing the size of
 * transactions.
 *
 * Because the template uses a Hierarchical Deterministic (HD) key, it also
 * supports watch-only clients.
 */
var authenticationTemplateP2pkh = {
  $schema: 'https://bitauth.com/schemas/authentication-template-v0.schema.json',
  description: 'A standard single-factor authentication template that uses Pay-to-Public-Key-Hash (P2PKH), the most common authentication scheme in use on the network.\n\nThis P2PKH template uses BCH Schnorr signatures, reducing the size of transactions. Because the template uses a Hierarchical Deterministic (HD) key, it also supports watch-only clients.',
  entities: {
    owner: {
      description: 'The individual who can spend from this wallet.',
      name: 'Owner',
      scripts: ['lock', 'unlock'],
      variables: {
        key: {
          description: 'The private key that controls this wallet.',
          name: 'Key',
          type: 'HdKey'
        }
      }
    }
  },
  name: 'Single Signature (P2PKH)',
  scripts: {
    lock: {
      lockingType: 'standard',
      name: 'P2PKH Lock',
      script: 'OP_DUP\nOP_HASH160 <$(<key.public_key> OP_HASH160\n)> OP_EQUALVERIFY\nOP_CHECKSIG'
    },
    unlock: {
      name: 'Unlock',
      script: '<key.schnorr_signature.all_outputs>\n<key.public_key>',
      unlocks: 'lock'
    }
  },
  supported: ['BCH_2020_05', 'BCH_2021_05', 'BCH_2022_05'],
  version: 0
};

/**
 * Derive the P2PKH locking bytecode at the provided index of the provided HD
 * private key.
 */
var hdPrivateKeyToP2pkhLockingBytecode = function hdPrivateKeyToP2pkhLockingBytecode(_ref) {
  var addressIndex = _ref.addressIndex,
    hdKey = _ref.hdKey;
  var compiler = authenticationTemplateToCompilerBCH(importAuthenticationTemplate(authenticationTemplateP2pkh));
  var lockingBytecode = compiler.generateBytecode({
    data: {
      hdKeys: {
        addressIndex: addressIndex,
        hdPrivateKeys: {
          owner: hdKey
        }
      }
    },
    scriptId: 'lock'
  });
  return lockingBytecode.bytecode;
};
/**
 * Derive the P2PKH address at the provided index of the provided HD
 * private key.
 */
var hdPrivateKeyToP2pkhAddress = function hdPrivateKeyToP2pkhAddress(_ref2) {
  var addressIndex = _ref2.addressIndex,
    hdKey = _ref2.hdKey,
    _ref2$prefix = _ref2.prefix,
    prefix = _ref2$prefix === void 0 ? 'bitcoincash' : _ref2$prefix;
  return lockingBytecodeToCashAddress(hdPrivateKeyToP2pkhLockingBytecode({
    addressIndex: addressIndex,
    hdKey: hdKey
  }), prefix);
};

var returnFailedCompilationDirective = function returnFailedCompilationDirective(_ref) {
  var index = _ref.index,
    result = _ref.result,
    type = _ref.type;
  return _objectSpread2(_objectSpread2({
    errors: result.errors.map(function (error) {
      return _objectSpread2(_objectSpread2({}, error), {}, {
        error: "Failed compilation of ".concat(type, " directive at index \"").concat(index, "\": ").concat(error.error)
      });
    }),
    index: index
  }, result.errorType === 'parse' ? {} : {
    resolved: result.resolve
  }), {}, {
    type: type
  });
};
// eslint-disable-next-line complexity
var compileOutputTemplate = function compileOutputTemplate(_ref2) {
  var outputTemplate = _ref2.outputTemplate,
    index = _ref2.index;
  if ('script' in outputTemplate.lockingBytecode) {
    var directive = outputTemplate.lockingBytecode;
    var data = directive.data === undefined ? {} : directive.data;
    var result = directive.compiler.generateBytecode({
      data: data,
      debug: true,
      scriptId: directive.script
    });
    return result.success ? _objectSpread2(_objectSpread2({
      lockingBytecode: result.bytecode
    }, outputTemplate.token === undefined ? {} : {
      token: outputTemplate.token
    }), {}, {
      valueSatoshis: outputTemplate.valueSatoshis
    }) : returnFailedCompilationDirective({
      index: index,
      result: result,
      type: 'locking'
    });
  }
  return _objectSpread2(_objectSpread2({
    lockingBytecode: outputTemplate.lockingBytecode.slice()
  }, outputTemplate.token === undefined ? {} : {
    token: outputTemplate.token
  }), {}, {
    valueSatoshis: outputTemplate.valueSatoshis
  });
};
var compileInputTemplate = function compileInputTemplate(_ref3) {
  var inputTemplate = _ref3.inputTemplate,
    index = _ref3.index,
    template = _ref3.template,
    outputs = _ref3.outputs;
  if ('script' in inputTemplate.unlockingBytecode) {
    var directive = inputTemplate.unlockingBytecode;
    // TODO: workaround, replace by migrating to PST format
    var sourceOutputs = [];
    // eslint-disable-next-line functional/no-expression-statement, functional/immutable-data
    sourceOutputs[index] = _objectSpread2(_objectSpread2({
      lockingBytecode: Uint8Array.of()
    }, inputTemplate.unlockingBytecode.token === undefined ? {} : {
      token: inputTemplate.unlockingBytecode.token
    }), {}, {
      valueSatoshis: inputTemplate.unlockingBytecode.valueSatoshis
    });
    var result = directive.compiler.generateBytecode({
      data: _objectSpread2(_objectSpread2({}, directive.data), {}, {
        compilationContext: {
          inputIndex: index,
          sourceOutputs: sourceOutputs,
          transaction: {
            inputs: template.inputs,
            locktime: template.locktime,
            outputs: outputs,
            version: template.version
          }
        }
      }),
      debug: true,
      scriptId: directive.script
    });
    return result.success ? {
      outpointIndex: inputTemplate.outpointIndex,
      outpointTransactionHash: inputTemplate.outpointTransactionHash.slice(),
      sequenceNumber: inputTemplate.sequenceNumber,
      unlockingBytecode: result.bytecode
    } : returnFailedCompilationDirective({
      index: index,
      result: result,
      type: 'unlocking'
    });
  }
  return {
    outpointIndex: inputTemplate.outpointIndex,
    outpointTransactionHash: inputTemplate.outpointTransactionHash.slice(),
    sequenceNumber: inputTemplate.sequenceNumber,
    unlockingBytecode: inputTemplate.unlockingBytecode.slice()
  };
};
/**
 * Generate a `Transaction` given a `TransactionTemplate` and any applicable
 * compilers and compilation data.
 *
 * Returns either a `Transaction` or an array of compilation errors.
 *
 * For each `CompilationDirective`, the `compilationContext` property will be
 * automatically provided to the compiler. All other necessary `CompilationData`
 * properties must be specified in the `TransactionTemplate`.
 *
 * @param template - the `TransactionTemplate` from which to create the
 * `Transaction`
 */
var generateTransaction = function generateTransaction(template) {
  var outputResults = template.outputs.map(function (outputTemplate, index) {
    return compileOutputTemplate({
      index: index,
      outputTemplate: outputTemplate
    });
  });
  var outputCompilationErrors = outputResults.filter(function (result) {
    return 'errors' in result;
  });
  if (outputCompilationErrors.length > 0) {
    var outputCompletions = outputResults.map(function (result, index) {
      return 'lockingBytecode' in result ? {
        index: index,
        output: result,
        type: 'output'
      } : result;
    }).filter(function (result) {
      return 'output' in result;
    });
    return {
      completions: outputCompletions,
      errors: outputCompilationErrors,
      stage: 'outputs',
      success: false
    };
  }
  var outputs = outputResults;
  var inputResults = template.inputs.map(function (inputTemplate, index) {
    return compileInputTemplate({
      index: index,
      inputTemplate: inputTemplate,
      outputs: outputs,
      template: template
    });
  });
  var inputCompilationErrors = inputResults.filter(function (result) {
    return 'errors' in result;
  });
  if (inputCompilationErrors.length > 0) {
    var inputCompletions = inputResults.map(function (result, index) {
      return 'unlockingBytecode' in result ? {
        index: index,
        input: result,
        type: 'input'
      } : result;
    }).filter(function (result) {
      return 'input' in result;
    });
    return {
      completions: inputCompletions,
      errors: inputCompilationErrors,
      stage: 'inputs',
      success: false
    };
  }
  var inputs = inputResults;
  return {
    success: true,
    transaction: {
      inputs: inputs,
      locktime: template.locktime,
      outputs: outputs,
      version: template.version
    }
  };
};
/**
 * TODO: fundamentally unsound, migrate to PST format
 *
 * Extract a map of successfully resolved variables to their resolved bytecode.
 *
 * @param transactionGenerationError - a transaction generation attempt where
 * `success` is `false`
 */
var extractResolvedVariables = function extractResolvedVariables(transactionGenerationError) {
  return transactionGenerationError.errors.reduce(function (all, error) {
    return error.resolved === undefined ? all : _objectSpread2(_objectSpread2({}, all), extractResolvedVariableBytecodeMap(error.resolved));
  }, {});
};
/**
 * TODO: fundamentally unsound, migrate to PST format
 *
 * Given an unsuccessful transaction generation result, extract a map of the
 * identifiers missing from the compilation mapped to the entity that owns each
 * variable.
 *
 * Returns `false` if any errors are fatal (the error either cannot be resolved
 * by providing a variable, or the entity ownership of the required variable was
 * not provided in the compilation data).
 *
 * @param transactionGenerationError - a transaction generation result where
 * `success` is `false`
 */
var extractMissingVariables = function extractMissingVariables(transactionGenerationError) {
  var allErrors = transactionGenerationError.errors.reduce(function (all, error) {
    return [].concat(_toConsumableArray(all), _toConsumableArray(error.errors));
  }, []);
  if (!allErrorsAreRecoverable(allErrors)) {
    return false;
  }
  return allErrors.reduce(function (all, error) {
    return _objectSpread2(_objectSpread2({}, all), {}, _defineProperty({}, error.missingIdentifier, error.owningEntity));
  }, {});
};
/**
 * TODO: fundamentally unsound, migrate to PST format
 *
 * Safely extend a compilation data with resolutions provided by other entities
 * (via `extractResolvedVariables`).
 *
 * It is security-critical that compilation data only be extended with expected
 * identifiers from the proper owning entity of each variable. See
 * `CompilationData.bytecode` for details.
 *
 * Returns `false` if any errors are fatal (the error either cannot be resolved
 * by providing a variable, or the entity ownership of the required variable was
 * not provided in the compilation data).
 *
 * @remarks
 * To determine which identifiers are required by a given compilation, the
 * compilation is first attempted with only trusted variables: variables owned
 * or previously verified (like `WalletData`) by the compiling entity. If this
 * compilation produces a `TransactionGenerationError`, the error can be
 * provided to `safelyExtendCompilationData`, along with the trusted compilation
 * data and a mapping of untrusted resolutions (where the result of
 * `extractResolvedVariables` is assigned to the entity ID of the entity from
 * which they were received).
 *
 * The first compilation must use only trusted compilation data
 */
var safelyExtendCompilationData = function safelyExtendCompilationData(transactionGenerationError, trustedCompilationData, untrustedResolutions) {
  var missing = extractMissingVariables(transactionGenerationError);
  if (missing === false) return false;
  var selectedResolutions = Object.entries(missing).reduce(function (all, _ref4) {
    var _ref5 = _slicedToArray(_ref4, 2),
      identifier = _ref5[0],
      entityId = _ref5[1];
    var entityResolution = untrustedResolutions[entityId];
    if (entityResolution === undefined) {
      return all;
    }
    var resolution = entityResolution[identifier];
    if (resolution === undefined) {
      return all;
    }
    return _objectSpread2(_objectSpread2({}, all), {}, _defineProperty({}, identifier, resolution));
  }, {});
  return _objectSpread2(_objectSpread2({}, trustedCompilationData), {}, {
    bytecode: _objectSpread2(_objectSpread2({}, selectedResolutions), trustedCompilationData.bytecode)
  });
};

var simpleP2pkhOutput = {
  lockingBytecode: {
    script: 'lockP2pkh'
  },
  valueSatoshis: 10000
};
var simpleP2pkhInput = {
  unlockingBytecode: {
    script: 'unlockP2pkh'
  }
};
var vmbTestOutput = {
  lockingBytecode: {
    script: 'vmbTestNullData'
  },
  valueSatoshis: 0
};
var slotOutput = {
  lockingBytecode: ['slot'],
  valueSatoshis: 10000
};
var slotInput = {
  unlockingBytecode: ['slot']
};
var slot1Scenario = {
  sourceOutputs: [simpleP2pkhOutput, slotOutput],
  transaction: {
    inputs: [simpleP2pkhInput, slotInput],
    outputs: [vmbTestOutput]
  }
};

/**
 * Not used currently, but these are the defaults that inform
 * {@link supportedTestSetOverridesBCH}.
 */
var vmbTestDefinitionDefaultBehaviorBCH = ['nop2sh_nonstandard', 'p2sh20_standard', 'p2sh32_ignore'];
/**
 * Given one of these values and the
 * {@link vmbTestDefinitionDefaultBehaviorBCH}, return these test plans.
 */
var supportedTestSetOverridesBCH = {
  /* eslint-disable camelcase */
  '': [{
    mode: 'nonP2SH',
    sets: ['2022_nonstandard']
  }, {
    mode: 'P2SH20',
    sets: ['2022_standard']
  }],
  /**
   * `chip_*` values exclude the marked test from
   * {@link vmbTestDefinitionDefaultBehaviorBCH}.
   */
  chip_cashtokens: [{
    mode: 'nonP2SH',
    sets: ['before_chip_cashtokens_invalid', 'chip_cashtokens_nonstandard']
  }, {
    mode: 'P2SH20',
    sets: ['before_chip_cashtokens_invalid', 'chip_cashtokens_standard']
  }, {
    mode: 'P2SH32',
    sets: ['before_chip_cashtokens_invalid', 'chip_cashtokens_standard']
  }],
  'chip_cashtokens,2022_p2sh32_nonstandard': [{
    mode: 'nonP2SH',
    sets: ['before_chip_cashtokens_invalid', 'chip_cashtokens_nonstandard']
  }, {
    mode: 'P2SH20',
    sets: ['before_chip_cashtokens_invalid', 'chip_cashtokens_standard']
  }, {
    mode: 'P2SH32',
    sets: ['before_chip_cashtokens_nonstandard', 'chip_cashtokens_standard']
  }],
  chip_cashtokens_invalid: [{
    mode: 'nonP2SH',
    sets: ['before_chip_cashtokens_invalid', 'chip_cashtokens_invalid']
  }, {
    mode: 'P2SH20',
    sets: ['before_chip_cashtokens_invalid', 'chip_cashtokens_invalid']
  }, {
    mode: 'P2SH32',
    sets: ['before_chip_cashtokens_invalid', 'chip_cashtokens_invalid']
  }],
  'chip_cashtokens_invalid,2022_p2sh32_nonstandard': [{
    mode: 'nonP2SH',
    sets: ['before_chip_cashtokens_invalid', 'chip_cashtokens_invalid']
  }, {
    mode: 'P2SH20',
    sets: ['before_chip_cashtokens_invalid', 'chip_cashtokens_invalid']
  }, {
    mode: 'P2SH32',
    sets: ['before_chip_cashtokens_nonstandard', 'chip_cashtokens_invalid']
  }],
  chip_loops: [{
    mode: 'nonP2SH',
    sets: ['chip_loops_nonstandard']
  }, {
    mode: 'P2SH20',
    sets: ['chip_loops_standard']
  }],
  chip_loops_invalid: [{
    mode: 'nonP2SH',
    sets: ['chip_loops_invalid']
  }, {
    mode: 'P2SH20',
    sets: ['chip_loops_invalid']
  }],
  'default,chip_cashtokens': [{
    mode: 'nonP2SH',
    sets: ['2022_nonstandard', 'before_chip_cashtokens_nonstandard', 'chip_cashtokens_nonstandard']
  }, {
    mode: 'P2SH20',
    sets: ['2022_standard', 'before_chip_cashtokens_standard', 'chip_cashtokens_standard']
  }, {
    mode: 'P2SH32',
    sets: ['chip_cashtokens_standard']
  }],
  invalid: [{
    mode: 'nonP2SH',
    sets: ['2022_invalid']
  }, {
    mode: 'P2SH20',
    sets: ['2022_invalid']
  }],
  'invalid,2022_p2sh32_nonstandard,chip_cashtokens': [{
    mode: 'nonP2SH',
    sets: ['2022_invalid', 'before_chip_cashtokens_invalid', 'chip_cashtokens_nonstandard']
  }, {
    mode: 'P2SH20',
    sets: ['2022_invalid', 'before_chip_cashtokens_invalid', 'chip_cashtokens_standard']
  }, {
    mode: 'P2SH32',
    sets: ['2022_nonstandard', 'before_chip_cashtokens_nonstandard', 'chip_cashtokens_standard']
  }],
  'invalid,2022_p2sh32_nonstandard,chip_cashtokens_invalid': [{
    mode: 'nonP2SH',
    sets: ['2022_invalid', 'before_chip_cashtokens_invalid', 'chip_cashtokens_invalid']
  }, {
    mode: 'P2SH20',
    sets: ['2022_invalid', 'before_chip_cashtokens_invalid', 'chip_cashtokens_invalid']
  }, {
    mode: 'P2SH32',
    sets: ['2022_nonstandard', 'before_chip_cashtokens_nonstandard', 'chip_cashtokens_invalid']
  }],
  'invalid,2022_p2sh32_nonstandard,chip_cashtokens_nonstandard': [{
    mode: 'nonP2SH',
    sets: ['2022_invalid', 'before_chip_cashtokens_invalid', 'chip_cashtokens_nonstandard']
  }, {
    mode: 'P2SH20',
    sets: ['2022_invalid', 'before_chip_cashtokens_invalid', 'chip_cashtokens_nonstandard']
  }, {
    mode: 'P2SH32',
    sets: ['2022_nonstandard', 'before_chip_cashtokens_nonstandard', 'chip_cashtokens_nonstandard']
  }],
  'invalid,chip_cashtokens': [{
    mode: 'nonP2SH',
    sets: ['2022_invalid', 'before_chip_cashtokens_invalid', 'chip_cashtokens_nonstandard']
  }, {
    mode: 'P2SH20',
    sets: ['2022_invalid', 'before_chip_cashtokens_invalid', 'chip_cashtokens_standard']
  }, {
    mode: 'P2SH32',
    sets: ['2022_invalid', 'before_chip_cashtokens_invalid', 'chip_cashtokens_standard']
  }],
  'invalid,chip_cashtokens,chip_cashtokens_p2sh20_nonstandard,chip_cashtokens_p2sh32_nonstandard': [{
    mode: 'nonP2SH',
    sets: ['2022_invalid', 'before_chip_cashtokens_invalid', 'chip_cashtokens_nonstandard']
  }, {
    mode: 'P2SH20',
    sets: ['2022_invalid', 'before_chip_cashtokens_invalid', 'chip_cashtokens_nonstandard']
  }, {
    mode: 'P2SH32',
    sets: ['2022_invalid', 'before_chip_cashtokens_invalid', 'chip_cashtokens_nonstandard']
  }],
  'invalid,chip_cashtokens,chip_cashtokens_p2sh32_nonstandard': [{
    mode: 'nonP2SH',
    sets: ['2022_invalid', 'before_chip_cashtokens_invalid', 'chip_cashtokens_nonstandard']
  }, {
    mode: 'P2SH20',
    sets: ['2022_invalid', 'before_chip_cashtokens_invalid', 'chip_cashtokens_standard']
  }, {
    mode: 'P2SH32',
    sets: ['2022_invalid', 'before_chip_cashtokens_invalid', 'chip_cashtokens_nonstandard']
  }],
  'invalid,chip_cashtokens,nop2sh_invalid': [{
    mode: 'nonP2SH',
    sets: ['2022_invalid', 'before_chip_cashtokens_invalid', 'chip_cashtokens_invalid']
  }, {
    mode: 'P2SH20',
    sets: ['2022_invalid', 'before_chip_cashtokens_invalid', 'chip_cashtokens_standard']
  }, {
    mode: 'P2SH32',
    sets: ['2022_invalid', 'before_chip_cashtokens_invalid', 'chip_cashtokens_standard']
  }],
  'invalid,chip_cashtokens,p2sh_ignore': [{
    mode: 'nonP2SH',
    sets: ['2022_invalid', 'before_chip_cashtokens_invalid', 'chip_cashtokens_nonstandard']
  }],
  'invalid,chip_cashtokens_invalid': [{
    mode: 'nonP2SH',
    sets: ['2022_invalid', 'before_chip_cashtokens_invalid', 'chip_cashtokens_invalid']
  }, {
    mode: 'P2SH20',
    sets: ['2022_invalid', 'before_chip_cashtokens_invalid', 'chip_cashtokens_invalid']
  }, {
    mode: 'P2SH32',
    sets: ['2022_invalid', 'before_chip_cashtokens_invalid', 'chip_cashtokens_invalid']
  }],
  'invalid,chip_cashtokens_invalid,p2sh_ignore': [{
    mode: 'nonP2SH',
    sets: ['2022_invalid', 'before_chip_cashtokens_invalid', 'chip_cashtokens_invalid']
  }],
  'invalid,nop2sh_nonstandard': [{
    mode: 'nonP2SH',
    sets: ['2022_nonstandard']
  }, {
    mode: 'P2SH20',
    sets: ['2022_invalid']
  }],
  'invalid,p2sh20_standard': [{
    mode: 'nonP2SH',
    sets: ['2022_invalid']
  }, {
    mode: 'P2SH20',
    sets: ['2022_standard']
  }],
  'invalid,p2sh_ignore': [{
    mode: 'nonP2SH',
    sets: ['2022_invalid']
  }],
  'invalid,p2sh_nonstandard,chip_cashtokens': [{
    mode: 'nonP2SH',
    sets: ['2022_invalid', 'before_chip_cashtokens_invalid', 'chip_cashtokens_nonstandard']
  }, {
    mode: 'P2SH20',
    sets: ['2022_nonstandard', 'before_chip_cashtokens_nonstandard', 'chip_cashtokens_standard']
  }, {
    mode: 'P2SH32',
    sets: ['2022_nonstandard', 'before_chip_cashtokens_nonstandard', 'chip_cashtokens_standard']
  }],
  'invalid,p2sh_nonstandard,chip_cashtokens_invalid': [{
    mode: 'nonP2SH',
    sets: ['2022_invalid', 'before_chip_cashtokens_invalid', 'chip_cashtokens_invalid']
  }, {
    mode: 'P2SH20',
    sets: ['2022_nonstandard', 'before_chip_cashtokens_nonstandard', 'chip_cashtokens_invalid']
  }, {
    mode: 'P2SH32',
    sets: ['2022_nonstandard', 'before_chip_cashtokens_nonstandard', 'chip_cashtokens_invalid']
  }],
  'invalid,p2sh_standard': [{
    mode: 'nonP2SH',
    sets: ['2022_invalid']
  }, {
    mode: 'P2SH20',
    sets: ['2022_standard']
  }],
  nonstandard: [{
    mode: 'nonP2SH',
    sets: ['2022_nonstandard']
  }, {
    mode: 'P2SH20',
    sets: ['2022_nonstandard']
  }],
  'nonstandard,chip_cashtokens': [{
    mode: 'nonP2SH',
    sets: ['2022_nonstandard', 'before_chip_cashtokens_nonstandard', 'chip_cashtokens_nonstandard']
  }, {
    mode: 'P2SH20',
    sets: ['2022_nonstandard', 'before_chip_cashtokens_nonstandard', 'chip_cashtokens_standard']
  }, {
    mode: 'P2SH32',
    sets: ['2022_nonstandard', 'before_chip_cashtokens_nonstandard', 'chip_cashtokens_standard']
  }],
  'nonstandard,chip_cashtokens,chip_cashtokens_p2sh20_nonstandard,chip_cashtokens_p2sh32_nonstandard': [{
    mode: 'nonP2SH',
    sets: ['2022_nonstandard', 'before_chip_cashtokens_nonstandard', 'chip_cashtokens_nonstandard']
  }, {
    mode: 'P2SH20',
    sets: ['2022_nonstandard', 'before_chip_cashtokens_nonstandard', 'chip_cashtokens_nonstandard']
  }, {
    mode: 'P2SH32',
    sets: ['2022_nonstandard', 'before_chip_cashtokens_nonstandard', 'chip_cashtokens_nonstandard']
  }],
  'nonstandard,chip_cashtokens,chip_cashtokens_p2sh32_nonstandard': [{
    mode: 'nonP2SH',
    sets: ['2022_nonstandard', 'before_chip_cashtokens_nonstandard', 'chip_cashtokens_nonstandard']
  }, {
    mode: 'P2SH20',
    sets: ['2022_nonstandard', 'before_chip_cashtokens_nonstandard', 'chip_cashtokens_standard']
  }, {
    mode: 'P2SH32',
    sets: ['2022_nonstandard', 'before_chip_cashtokens_nonstandard', 'chip_cashtokens_nonstandard']
  }],
  'nonstandard,chip_cashtokens_invalid': [{
    mode: 'nonP2SH',
    sets: ['2022_nonstandard', 'before_chip_cashtokens_nonstandard', 'chip_cashtokens_invalid']
  }, {
    mode: 'P2SH20',
    sets: ['2022_nonstandard', 'before_chip_cashtokens_nonstandard', 'chip_cashtokens_invalid']
  }, {
    mode: 'P2SH32',
    sets: ['2022_nonstandard', 'before_chip_cashtokens_nonstandard', 'chip_cashtokens_invalid']
  }],
  'nonstandard,p2sh_ignore': [{
    mode: 'nonP2SH',
    sets: ['2022_nonstandard']
  }],
  'nonstandard,p2sh_invalid': [{
    mode: 'nonP2SH',
    sets: ['2022_nonstandard']
  }, {
    mode: 'P2SH20',
    sets: ['2022_invalid']
  }],
  nop2sh_invalid: [{
    mode: 'nonP2SH',
    sets: ['2022_invalid']
  }, {
    mode: 'P2SH20',
    sets: ['2022_standard']
  }],
  p2sh_ignore: [{
    mode: 'nonP2SH',
    sets: ['2022_nonstandard']
  }],
  p2sh_invalid: [{
    mode: 'nonP2SH',
    sets: ['2022_nonstandard']
  }, {
    mode: 'P2SH20',
    sets: ['2022_invalid']
  }]
  /* eslint-enable camelcase */
};
/**
 * Short IDs use bech32 encoding, so birthday collisions will happen
 * approximately every `Math.sqrt(2 * (32 ** defaultShortIdLength))` tests.
 */
var defaultShortIdLength = 5;
var planTestsBCH = function planTestsBCH(labels
// eslint-disable-next-line @typescript-eslint/no-non-null-assertion
) {
  return supportedTestSetOverridesBCH[(labels !== null && labels !== void 0 ? labels : []).join(',')];
};
/**
 * Given a VMB test definition, generate a full VMB test vector. Note, this
 * method throws immediately on the first test vector generation failure.
 */
var vmbTestDefinitionToVmbTests = function vmbTestDefinitionToVmbTests(testDefinition) {
  var _scenarios;
  var groupName = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';
  var shortIdLength = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : defaultShortIdLength;
  var _testDefinition = _slicedToArray(testDefinition, 6),
    unlockingScript = _testDefinition[0],
    redeemOrLockingScript = _testDefinition[1],
    testDescription = _testDefinition[2],
    testSetOverrideLabels = _testDefinition[3],
    scenarioOverride = _testDefinition[4],
    additionalScripts = _testDefinition[5];
  var scenarioId = 'test';
  var testGenerationPlan = planTestsBCH(testSetOverrideLabels);
  var scenarioDefinition = _objectSpread2({
    extends: 'vmb_default'
  }, scenarioOverride);
  var configuration = authenticationTemplateToCompilerConfiguration({
    entities: {
      tester: {
        variables: {
          key1: {
            type: 'HdKey'
          }
        }
      }
    },
    scenarios: (_scenarios = {}, _defineProperty(_scenarios, scenarioId, scenarioDefinition), _defineProperty(_scenarios, "vmb_default", slot1Scenario), _scenarios),
    scripts: _objectSpread2(_objectSpread2({}, additionalScripts), {}, {
      lockEmptyP2sh20: {
        lockingType: 'p2sh20',
        script: ''
      },
      lockP2pkh: {
        lockingType: 'standard',
        script: 'OP_DUP OP_HASH160 <$(<key1.public_key> OP_HASH160)> OP_EQUALVERIFY OP_CHECKSIG'
      },
      lockP2sh20: {
        lockingType: 'p2sh20',
        script: redeemOrLockingScript
      },
      lockP2sh32: {
        lockingType: 'p2sh32',
        script: redeemOrLockingScript
      },
      lockStandard: {
        lockingType: 'standard',
        script: redeemOrLockingScript
      },
      unlockEmptyP2sh20: {
        script: '<1>',
        unlocks: 'lockEmptyP2sh20'
      },
      unlockP2pkh: {
        /**
         * Uses `corresponding_output_single_input` to reuse the same signature
         * as much as possible (making VMB test files more compressible).
         */
        script: '<key1.schnorr_signature.corresponding_output_single_input> <key1.public_key>',
        unlocks: 'lockP2pkh'
      },
      unlockP2sh20: {
        script: unlockingScript,
        unlocks: 'lockP2sh20'
      },
      unlockP2sh32: {
        script: unlockingScript,
        unlocks: 'lockP2sh32'
      },
      unlockStandard: {
        script: unlockingScript,
        unlocks: 'lockStandard'
      },
      vmbTestNullData: {
        lockingType: 'standard',
        script: 'OP_RETURN <"vmb_test">'
      }
    }),
    supported: ['BCH_2022_05'],
    version: 0
  });
  var compiler = createCompilerBCH(configuration);
  var tests = testGenerationPlan.map(function (planItem) {
    var description = "".concat(groupName, ": ").concat(testDescription, " (").concat(planItem.mode, ")");
    var result = compiler.generateScenario({
      debug: true,
      scenarioId: scenarioId,
      unlockingScriptId: {
        // eslint-disable-next-line @typescript-eslint/naming-convention
        P2SH20: 'unlockP2sh20',
        // eslint-disable-next-line @typescript-eslint/naming-convention
        P2SH32: 'unlockP2sh32',
        nonP2SH: 'unlockStandard'
      }[planItem.mode]
    });
    if (typeof result === 'string') {
      // eslint-disable-next-line functional/no-throw-statement
      throw new Error("Error while generating \"".concat(description, "\" - ").concat(result));
    }
    if (typeof result.scenario === 'string') {
      // eslint-disable-next-line functional/no-throw-statement
      throw new Error("Error while generating \"".concat(description, "\" - ").concat(result.scenario));
    }
    var encodedTx = encodeTransaction(result.scenario.program.transaction);
    var encodedSourceOutputs = encodeTransactionOutputs(result.scenario.program.sourceOutputs);
    var shortId = encodeBech32(regroupBits({
      bin: sha256$1.hash(flattenBinArray([encodedTx, encodedSourceOutputs])),
      resultWordLength: 5,
      sourceWordLength: 8
    })).slice(0, shortIdLength);
    var testCase = [shortId, description, unlockingScript, redeemOrLockingScript, binToHex(encodedTx), binToHex(encodedSourceOutputs), planItem.sets];
    return result.scenario.program.inputIndex === 0 ? testCase : [].concat(testCase, [result.scenario.program.inputIndex]);
  });
  return tests;
};
var vmbTestGroupToVmbTests = function vmbTestGroupToVmbTests(testGroup) {
  return testGroup[1].map(function (testDefinition) {
    return vmbTestDefinitionToVmbTests(testDefinition, testGroup[0]);
  });
};
/**
 * Partition a master test list (produced by {@link vmbTestGroupToVmbTests} or
 * {@link vmbTestDefinitionToVmbTests}) into sets. E.g.:
 * ```ts
 * const definitions: VmbTestDefinitionGroup[] = [...]
 * const master = [
 *   vmbTestDefinitionToVmbTests(...),
 *   vmbTestDefinitionToVmbTests(...),
 * ];
 * const partitioned = vmbTestPartitionMasterTestList(master);
 * ```
 * Or:
 * ```ts
 * const definitions: VmbTestDefinitionGroup[] = [...]
 * const master = definitions.map(vmbTestGroupToVmbTests).flat(2);
 * const partitioned = vmbTestPartitionMasterTestList(master);
 * ```
 * Tests are aggregated by set into a map of test sets (e.g. to export to
 * separate files).
 */
var vmbTestPartitionMasterTestList = function vmbTestPartitionMasterTestList(masterTestList) {
  return masterTestList.reduce(function (accumulatedTestSets, testCase) {
    var _testCase = _slicedToArray(testCase, 8),
      shortId = _testCase[0],
      testDescription = _testCase[1],
      unlockingScriptAsm = _testCase[2],
      redeemOrLockingScriptAsm = _testCase[3],
      testTransactionHex = _testCase[4],
      sourceOutputsHex = _testCase[5],
      testSets = _testCase[6],
      inputIndex = _testCase[7];
    var withoutSets = [shortId, testDescription, unlockingScriptAsm, redeemOrLockingScriptAsm, testTransactionHex, sourceOutputsHex].concat(_toConsumableArray(inputIndex === undefined ? [] : [inputIndex]));
    // eslint-disable-next-line functional/no-return-void, functional/no-expression-statement
    testSets.forEach(function (testSet) {
      var _accumulatedTestSets$;
      // eslint-disable-next-line functional/immutable-data, functional/no-expression-statement
      accumulatedTestSets[testSet] = [].concat(_toConsumableArray((_accumulatedTestSets$ = accumulatedTestSets[testSet]) !== null && _accumulatedTestSets$ !== void 0 ? _accumulatedTestSets$ : []), [withoutSets]);
    });
    return accumulatedTestSets;
  }, {});
};

var build = /*#__PURE__*/Object.freeze({
  __proto__: null,
  get Base58AddressFormatVersion () { return Base58AddressFormatVersion; },
  encodeBase58AddressFormat: encodeBase58AddressFormat,
  encodeBase58Address: encodeBase58Address,
  get Base58AddressError () { return Base58AddressError; },
  decodeBase58AddressFormat: decodeBase58AddressFormat,
  decodeBase58Address: decodeBase58Address$1,
  bech32CharacterSet: bech32CharacterSet,
  bech32CharacterSetIndex: bech32CharacterSetIndex,
  get BitRegroupingError () { return BitRegroupingError; },
  regroupBits: regroupBits,
  encodeBech32: encodeBech32,
  decodeBech32: decodeBech32,
  isBech32CharacterSet: isBech32CharacterSet,
  get Bech32DecodingError () { return Bech32DecodingError; },
  bech32PaddedToBin: bech32PaddedToBin,
  binToBech32Padded: binToBech32Padded,
  get CashAddressNetworkPrefix () { return CashAddressNetworkPrefix; },
  get CashAddressVersionByte () { return CashAddressVersionByte; },
  get CashAddressType () { return CashAddressType; },
  get CashAddressTypeBits () { return CashAddressTypeBits; },
  cashAddressTypeToTypeBits: cashAddressTypeToTypeBits,
  cashAddressTypeBitsToType: cashAddressTypeBitsToType,
  cashAddressSizeBitsToLength: cashAddressSizeBitsToLength,
  cashAddressLengthToSizeBits: cashAddressLengthToSizeBits,
  encodeCashAddressVersionByte: encodeCashAddressVersionByte,
  get CashAddressVersionByteDecodingError () { return CashAddressVersionByteDecodingError; },
  decodeCashAddressVersionByte: decodeCashAddressVersionByte,
  maskCashAddressPrefix: maskCashAddressPrefix,
  cashAddressPolynomialModulo: cashAddressPolynomialModulo,
  cashAddressChecksumToUint5Array: cashAddressChecksumToUint5Array,
  encodeCashAddressFormat: encodeCashAddressFormat,
  get CashAddressEncodingError () { return CashAddressEncodingError; },
  isValidCashAddressPayloadLength: isValidCashAddressPayloadLength,
  encodeCashAddressNonStandard: encodeCashAddressNonStandard,
  encodeCashAddress: encodeCashAddress,
  get CashAddressDecodingError () { return CashAddressDecodingError; },
  decodeCashAddressFormat: decodeCashAddressFormat,
  decodeCashAddressNonStandard: decodeCashAddressNonStandard,
  decodeCashAddress: decodeCashAddress$1,
  decodeCashAddressFormatWithoutPrefix: decodeCashAddressFormatWithoutPrefix,
  cashAddressPolynomialToCashAddress: cashAddressPolynomialToCashAddress,
  get CashAddressCorrectionError () { return CashAddressCorrectionError; },
  attemptCashAddressFormatErrorCorrection: attemptCashAddressFormatErrorCorrection,
  get LockingBytecodeType () { return LockingBytecodeType; },
  isPayToPublicKeyUncompressed: isPayToPublicKeyUncompressed,
  isPayToPublicKeyCompressed: isPayToPublicKeyCompressed,
  isPayToPublicKey: isPayToPublicKey,
  isPayToPublicKeyHash: isPayToPublicKeyHash,
  isPayToScriptHash20: isPayToScriptHash20,
  isPayToScriptHash32: isPayToScriptHash32,
  lockingBytecodeToAddressContents: lockingBytecodeToAddressContents,
  encodeLockingBytecodeP2pkh: encodeLockingBytecodeP2pkh,
  encodeLockingBytecodeP2sh20: encodeLockingBytecodeP2sh20,
  encodeLockingBytecodeP2sh32: encodeLockingBytecodeP2sh32,
  encodeLockingBytecodeP2pk: encodeLockingBytecodeP2pk,
  addressContentsToLockingBytecode: addressContentsToLockingBytecode,
  lockingBytecodeToCashAddress: lockingBytecodeToCashAddress,
  get LockingBytecodeGenerationError () { return LockingBytecodeGenerationError; },
  cashAddressToLockingBytecode: cashAddressToLockingBytecode,
  lockingBytecodeToBase58Address: lockingBytecodeToBase58Address,
  base58AddressToLockingBytecode: base58AddressToLockingBytecode,
  instantiateRustWasm: instantiateRustWasm,
  ripemd160Base64Bytes: ripemd160Base64Bytes,
  get ContextFlag () { return ContextFlag; },
  get CompressionFlag () { return CompressionFlag; },
  instantiateSecp256k1WasmBytes: instantiateSecp256k1WasmBytes,
  getEmbeddedSecp256k1Binary: getEmbeddedSecp256k1Binary,
  instantiateSecp256k1Wasm: instantiateSecp256k1Wasm,
  sha1Base64Bytes: sha1Base64Bytes,
  sha256Base64Bytes: sha256Base64Bytes,
  sha512Base64Bytes: sha512Base64Bytes,
  hash160: hash160,
  hash256: hash256,
  ripemd160: ripemd160$1,
  secp256k1: secp256k1,
  sha1: sha1$1,
  sha256: sha256$1,
  sha512: sha512$1,
  instantiateHmacFunction: instantiateHmacFunction,
  hmacSha256: hmacSha256,
  hmacSha512: hmacSha512,
  instantiateRipemd160Bytes: instantiateRipemd160Bytes,
  getEmbeddedRipemd160Binary: getEmbeddedRipemd160Binary,
  instantiateRipemd160: instantiateRipemd160,
  get Secp256k1Error () { return Secp256k1Error; },
  instantiateSecp256k1Bytes: instantiateSecp256k1Bytes,
  instantiateSecp256k1: instantiateSecp256k1,
  instantiateSha1Bytes: instantiateSha1Bytes,
  getEmbeddedSha1Binary: getEmbeddedSha1Binary,
  instantiateSha1: instantiateSha1,
  instantiateSha256Bytes: instantiateSha256Bytes,
  getEmbeddedSha256Binary: getEmbeddedSha256Binary,
  instantiateSha256: instantiateSha256,
  instantiateSha512Bytes: instantiateSha512Bytes,
  getEmbeddedSha512Binary: getEmbeddedSha512Binary,
  instantiateSha512: instantiateSha512,
  get BaseConversionError () { return BaseConversionError; },
  createBaseConverter: createBaseConverter,
  bitcoinBase58Alphabet: bitcoinBase58Alphabet,
  base58ToBin: base58ToBin,
  binToBase58: binToBase58,
  isBase64: isBase64,
  base64ToBin: base64ToBin,
  binToBase64: binToBase64,
  binStringToBin: binStringToBin,
  binToBinString: binToBinString,
  isBinString: isBinString,
  formatError: formatError$1,
  unknownValue: unknownValue,
  range: range,
  splitEvery: splitEvery,
  hexToBin: hexToBin,
  isHex: isHex,
  binToHex: binToHex,
  swapEndianness: swapEndianness,
  flattenBinArray: flattenBinArray,
  binsAreEqual: binsAreEqual,
  stringify: stringify,
  sortObjectKeys: sortObjectKeys,
  stringifyTestVector: stringifyTestVector,
  numberToBinUintLE: numberToBinUintLE,
  binToFixedLength: binToFixedLength,
  numberToBinUint16LEClamped: numberToBinUint16LEClamped,
  numberToBinUint32LEClamped: numberToBinUint32LEClamped,
  numberToBinUint16LE: numberToBinUint16LE,
  numberToBinInt16LE: numberToBinInt16LE,
  numberToBinInt32LE: numberToBinInt32LE,
  binToNumberInt16LE: binToNumberInt16LE,
  binToNumberInt32LE: binToNumberInt32LE,
  numberToBinUint16BE: numberToBinUint16BE,
  numberToBinUint32LE: numberToBinUint32LE,
  numberToBinUint32BE: numberToBinUint32BE,
  bigIntToBinUintLE: bigIntToBinUintLE,
  bigIntToBinUint64LEClamped: bigIntToBinUint64LEClamped,
  bigIntToBinUint64LE: bigIntToBinUint64LE,
  numberToBinInt32TwosCompliment: numberToBinInt32TwosCompliment,
  binToNumberUintLE: binToNumberUintLE,
  binToNumberUint16LE: binToNumberUint16LE,
  binToNumberUint32LE: binToNumberUint32LE,
  binToBigIntUintBE: binToBigIntUintBE,
  binToBigIntUint256BE: binToBigIntUint256BE,
  bigIntToBinUint256BEClamped: bigIntToBinUint256BEClamped,
  binToBigIntUintLE: binToBigIntUintLE,
  binToBigIntUint64LE: binToBigIntUint64LE,
  binToValueSatoshis: binToValueSatoshis,
  valueSatoshisToBin: valueSatoshisToBin,
  compactSizePrefixToSize: compactSizePrefixToSize,
  get CompactSizeError () { return CompactSizeError; },
  readCompactSize: readCompactSize,
  bigIntToCompactSize: bigIntToCompactSize,
  readCompactSizeMinimal: readCompactSizeMinimal,
  compactSizeToBigInt: compactSizeToBigInt,
  int32SignedToUnsigned: int32SignedToUnsigned,
  int32UnsignedToSigned: int32UnsignedToSigned,
  readMultiple: readMultiple,
  get ReadItemCountError () { return ReadItemCountError; },
  readItemCount: readItemCount,
  minimumLocktimeTimestamp: minimumLocktimeTimestamp,
  maximumLocktimeTimestamp: maximumLocktimeTimestamp,
  minimumLocktimeDate: minimumLocktimeDate,
  maximumLocktimeDate: maximumLocktimeDate,
  get LocktimeError () { return LocktimeError; },
  dateToLocktime: dateToLocktime,
  locktimeToDate: locktimeToDate,
  dateToLocktimeBin: dateToLocktimeBin,
  decodeLocktime: decodeLocktime,
  utf8ToBin: utf8ToBin,
  binToUtf8: binToUtf8,
  deriveHdPrivateNodeFromSeed: deriveHdPrivateNodeFromSeed,
  deriveHdPrivateNodeIdentifier: deriveHdPrivateNodeIdentifier,
  deriveHdPublicNodeIdentifier: deriveHdPublicNodeIdentifier,
  get HdKeyVersion () { return HdKeyVersion; },
  get HdKeyDecodingError () { return HdKeyDecodingError; },
  decodeHdKey: decodeHdKey,
  decodeHdPrivateKey: decodeHdPrivateKey,
  decodeHdPublicKey: decodeHdPublicKey,
  hdPrivateKeyToIdentifier: hdPrivateKeyToIdentifier,
  hdPublicKeyToIdentifier: hdPublicKeyToIdentifier,
  encodeHdPrivateKey: encodeHdPrivateKey,
  encodeHdPublicKey: encodeHdPublicKey,
  deriveHdPublicNode: deriveHdPublicNode,
  get HdNodeDerivationError () { return HdNodeDerivationError; },
  deriveHdPrivateNodeChild: deriveHdPrivateNodeChild,
  deriveHdPublicNodeChild: deriveHdPublicNodeChild,
  deriveHdPath: deriveHdPath,
  get HdNodeCrackingError () { return HdNodeCrackingError; },
  crackHdPrivateNodeFromHdPublicNodeAndChildPrivateNode: crackHdPrivateNodeFromHdPublicNodeAndChildPrivateNode,
  validateSecp256k1PrivateKey: validateSecp256k1PrivateKey,
  generatePrivateKey: generatePrivateKey,
  get WalletImportFormatError () { return WalletImportFormatError; },
  encodePrivateKeyWif: encodePrivateKeyWif,
  decodePrivateKeyWif: decodePrivateKeyWif,
  compileScript: compileScript,
  mergeRanges: mergeRanges,
  containsRange: containsRange,
  getResolutionErrors: getResolutionErrors,
  allErrorsAreRecoverable: allErrorsAreRecoverable,
  extractBytecodeResolutions: extractBytecodeResolutions,
  extractResolvedVariableBytecodeMap: extractResolvedVariableBytecodeMap,
  stringifyErrors: stringifyErrors,
  extractEvaluationSamples: extractEvaluationSamples,
  extractEvaluationSamplesRecursive: extractEvaluationSamplesRecursive,
  extractUnexecutedRanges: extractUnexecutedRanges,
  summarizeStack: summarizeStack,
  summarizeDebugTrace: summarizeDebugTrace,
  stringifyDebugTraceSummary: stringifyDebugTraceSummary,
  get IdentifierResolutionType () { return IdentifierResolutionType; },
  get IdentifierResolutionErrorType () { return IdentifierResolutionErrorType; },
  parseScript: parseScript,
  verifyCashAssemblyEvaluationState: verifyCashAssemblyEvaluationState,
  reduceScript: reduceScript,
  resolveScriptSegment: resolveScriptSegment,
  get BuiltInVariables () { return BuiltInVariables; },
  resolveVariableIdentifier: resolveVariableIdentifier,
  describeExpectedInput: describeExpectedInput,
  createEmptyRange: createEmptyRange,
  compileScriptRaw: compileScriptRaw,
  resolveScriptIdentifier: resolveScriptIdentifier,
  createIdentifierResolver: createIdentifierResolver,
  compileScriptContents: compileScriptContents,
  get ReadBytesError () { return ReadBytesError; },
  readBytes: readBytes,
  get ReadUint32LEError () { return ReadUint32LEError; },
  readUint32LE: readUint32LE,
  get ReadUint64LEError () { return ReadUint64LEError; },
  readUint64LE: readUint64LE,
  get CompactSizePrefixedBinError () { return CompactSizePrefixedBinError; },
  readCompactSizePrefixedBin: readCompactSizePrefixedBin,
  readRemainingBytes: readRemainingBytes,
  encodeTransactionInput: encodeTransactionInput,
  get TransactionDecodingError () { return TransactionDecodingError; },
  readTransactionInput: readTransactionInput,
  encodeTransactionInputs: encodeTransactionInputs,
  readTransactionInputs: readTransactionInputs,
  nftCapabilityNumberToLabel: nftCapabilityNumberToLabel,
  nftCapabilityLabelToNumber: nftCapabilityLabelToNumber,
  get CashTokenDecodingError () { return CashTokenDecodingError; },
  readTokenAmount: readTokenAmount,
  readTokenPrefix: readTokenPrefix,
  readLockingBytecodeWithPrefix: readLockingBytecodeWithPrefix,
  readTransactionOutput: readTransactionOutput,
  encodeTokenPrefix: encodeTokenPrefix,
  encodeTransactionOutput: encodeTransactionOutput,
  readTransactionOutputs: readTransactionOutputs,
  encodeTransactionOutputs: encodeTransactionOutputs,
  readTransactionCommon: readTransactionCommon,
  readTransaction: readTransaction,
  readTransactionOutputNonTokenAware: readTransactionOutputNonTokenAware,
  readTransactionOutputsNonTokenAware: readTransactionOutputsNonTokenAware,
  readTransactionNonTokenAware: readTransactionNonTokenAware,
  decodeTransactionCommon: decodeTransactionCommon,
  decodeTransactionBCH: decodeTransactionBCH,
  decodeTransaction: decodeTransaction,
  decodeTransactionUnsafeCommon: decodeTransactionUnsafeCommon,
  decodeTransactionUnsafeBCH: decodeTransactionUnsafeBCH,
  decodeTransactionUnsafe: decodeTransactionUnsafe,
  encodeTransactionCommon: encodeTransactionCommon,
  encodeTransactionBCH: encodeTransactionBCH,
  encodeTransaction: encodeTransaction,
  cloneTransactionInputsCommon: cloneTransactionInputsCommon,
  cloneTransactionOutputsCommon: cloneTransactionOutputsCommon,
  cloneTransactionCommon: cloneTransactionCommon,
  hashTransactionP2pOrder: hashTransactionP2pOrder,
  hashTransactionUiOrder: hashTransactionUiOrder,
  hashTransaction: hashTransaction,
  encodeTransactionOutpoints: encodeTransactionOutpoints,
  encodeTransactionOutputsForSigning: encodeTransactionOutputsForSigning,
  encodeTransactionInputSequenceNumbersForSigning: encodeTransactionInputSequenceNumbersForSigning,
  get NonFungibleTokenCapability () { return NonFungibleTokenCapability; },
  excessiveSatoshis: excessiveSatoshis,
  importAuthenticationTemplate: importAuthenticationTemplate,
  get SigningSerializationAlgorithmIdentifier () { return SigningSerializationAlgorithmIdentifier; },
  compilerOperationHelperComputeSignatureBCH: compilerOperationHelperComputeSignatureBCH,
  compilerOperationHelperHdKeySignatureBCH: compilerOperationHelperHdKeySignatureBCH,
  compilerOperationHdKeyEcdsaSignatureBCH: compilerOperationHdKeyEcdsaSignatureBCH,
  compilerOperationHdKeySchnorrSignatureBCH: compilerOperationHdKeySchnorrSignatureBCH,
  compilerOperationHelperKeySignatureBCH: compilerOperationHelperKeySignatureBCH,
  compilerOperationKeyEcdsaSignatureBCH: compilerOperationKeyEcdsaSignatureBCH,
  compilerOperationKeySchnorrSignatureBCH: compilerOperationKeySchnorrSignatureBCH,
  compilerOperationHelperComputeDataSignatureBCH: compilerOperationHelperComputeDataSignatureBCH,
  compilerOperationHelperKeyDataSignatureBCH: compilerOperationHelperKeyDataSignatureBCH,
  compilerOperationKeyEcdsaDataSignatureBCH: compilerOperationKeyEcdsaDataSignatureBCH,
  compilerOperationKeySchnorrDataSignatureBCH: compilerOperationKeySchnorrDataSignatureBCH,
  compilerOperationHelperHdKeyDataSignatureBCH: compilerOperationHelperHdKeyDataSignatureBCH,
  compilerOperationHdKeyEcdsaDataSignatureBCH: compilerOperationHdKeyEcdsaDataSignatureBCH,
  compilerOperationHdKeySchnorrDataSignatureBCH: compilerOperationHdKeySchnorrDataSignatureBCH,
  compilerOperationSigningSerializationFullBCH: compilerOperationSigningSerializationFullBCH,
  compilerOperationsBCH: compilerOperationsBCH,
  createCompilerBCH: createCompilerBCH,
  createCompiler: createCompiler,
  authenticationTemplateToCompilerBCH: authenticationTemplateToCompilerBCH,
  get CompilerDefaults () { return CompilerDefaults; },
  attemptCompilerOperations: attemptCompilerOperations,
  compilerOperationRequires: compilerOperationRequires,
  compilerOperationAttemptBytecodeResolution: compilerOperationAttemptBytecodeResolution,
  compilerOperationHelperDeriveHdPrivateNode: compilerOperationHelperDeriveHdPrivateNode,
  compilerOperationHelperUnknownEntity: compilerOperationHelperUnknownEntity,
  compilerOperationHelperAddressIndex: compilerOperationHelperAddressIndex,
  compilerOperationHelperDeriveHdKeyPrivate: compilerOperationHelperDeriveHdKeyPrivate,
  compilerOperationHelperCompileScript: compilerOperationHelperCompileScript,
  compilerOperationHelperGenerateCoveredBytecode: compilerOperationHelperGenerateCoveredBytecode,
  compilerOperationAddressData: compilerOperationAddressData,
  compilerOperationWalletData: compilerOperationWalletData,
  compilerOperationCurrentBlockTime: compilerOperationCurrentBlockTime,
  compilerOperationCurrentBlockHeight: compilerOperationCurrentBlockHeight,
  compilerOperationSigningSerializationCorrespondingOutput: compilerOperationSigningSerializationCorrespondingOutput,
  compilerOperationSigningSerializationCorrespondingOutputHash: compilerOperationSigningSerializationCorrespondingOutputHash,
  compilerOperationSigningSerializationCoveredBytecode: compilerOperationSigningSerializationCoveredBytecode,
  compilerOperationSigningSerializationCoveredBytecodeLength: compilerOperationSigningSerializationCoveredBytecodeLength,
  compilerOperationSigningSerializationLocktime: compilerOperationSigningSerializationLocktime,
  compilerOperationSigningSerializationOutpointIndex: compilerOperationSigningSerializationOutpointIndex,
  compilerOperationSigningSerializationOutpointTransactionHash: compilerOperationSigningSerializationOutpointTransactionHash,
  compilerOperationSigningSerializationOutputValue: compilerOperationSigningSerializationOutputValue,
  compilerOperationSigningSerializationSequenceNumber: compilerOperationSigningSerializationSequenceNumber,
  compilerOperationSigningSerializationTransactionOutpoints: compilerOperationSigningSerializationTransactionOutpoints,
  compilerOperationSigningSerializationTransactionOutpointsHash: compilerOperationSigningSerializationTransactionOutpointsHash,
  compilerOperationSigningSerializationTransactionOutputs: compilerOperationSigningSerializationTransactionOutputs,
  compilerOperationSigningSerializationTransactionOutputsHash: compilerOperationSigningSerializationTransactionOutputsHash,
  compilerOperationSigningSerializationTransactionSequenceNumbers: compilerOperationSigningSerializationTransactionSequenceNumbers,
  compilerOperationSigningSerializationTransactionSequenceNumbersHash: compilerOperationSigningSerializationTransactionSequenceNumbersHash,
  compilerOperationSigningSerializationVersion: compilerOperationSigningSerializationVersion,
  compilerOperationKeyPublicKeyCommon: compilerOperationKeyPublicKeyCommon,
  compilerOperationHdKeyPublicKeyCommon: compilerOperationHdKeyPublicKeyCommon,
  compilerOperationsCommon: compilerOperationsCommon,
  createCompilerGenerateBytecodeFunction: createCompilerGenerateBytecodeFunction,
  compilerConfigurationToCompilerBCH: compilerConfigurationToCompilerBCH,
  compilerConfigurationToCompiler: compilerConfigurationToCompiler,
  createAuthenticationProgramEvaluationCommon: createAuthenticationProgramEvaluationCommon,
  createCompilerCommon: createCompilerCommon,
  compileCashAssembly: compileCashAssembly,
  assembleBytecode: assembleBytecode,
  assembleBytecodeBCH: assembleBytecodeBCH,
  cashAssemblyToBin: cashAssemblyToBin,
  assembleBytecodeBTC: assembleBytecodeBTC,
  authenticationTemplateToCompilerConfiguration: authenticationTemplateToCompilerConfiguration,
  generateDefaultScenarioDefinition: generateDefaultScenarioDefinition,
  extendScenarioDefinitionData: extendScenarioDefinitionData,
  extendScenarioDefinition: extendScenarioDefinition,
  generateExtendedScenario: generateExtendedScenario,
  extendedScenarioDefinitionToCompilationData: extendedScenarioDefinitionToCompilationData,
  extendCompilationDataWithScenarioBytecode: extendCompilationDataWithScenarioBytecode,
  compileAuthenticationTemplateScenarioValueSatoshis: compileAuthenticationTemplateScenarioValueSatoshis,
  compileAuthenticationTemplateScenarioBytecode: compileAuthenticationTemplateScenarioBytecode,
  compileScenarioOutputTokenData: compileScenarioOutputTokenData,
  generateScenarioBCH: generateScenarioBCH,
  hdPrivateKeyToP2pkhLockingBytecode: hdPrivateKeyToP2pkhLockingBytecode,
  hdPrivateKeyToP2pkhAddress: hdPrivateKeyToP2pkhAddress,
  authenticationTemplateP2pkhNonHd: authenticationTemplateP2pkhNonHd,
  authenticationTemplateP2pkh: authenticationTemplateP2pkh,
  compileOutputTemplate: compileOutputTemplate,
  compileInputTemplate: compileInputTemplate,
  generateTransaction: generateTransaction,
  extractResolvedVariables: extractResolvedVariables,
  extractMissingVariables: extractMissingVariables,
  safelyExtendCompilationData: safelyExtendCompilationData,
  get OpcodeDescriptionsXEC () { return OpcodeDescriptionsXEC; },
  createInstructionSetXEC: createInstructionSetXEC,
  get OpcodesXEC () { return OpcodesXEC; },
  get ConsensusXEC () { return ConsensusXEC; },
  createVirtualMachineXEC: createVirtualMachineXEC,
  bitcoinSatoshiOpcodes: bitcoinSatoshiOpcodes,
  assembleBitcoinSatoshiScript: assembleBitcoinSatoshiScript,
  get OpcodeDescriptionsBCH2022 () { return OpcodeDescriptionsBCH2022; },
  get AuthenticationErrorBCH2022 () { return AuthenticationErrorBCH2022; },
  createInstructionSetBCH2022: createInstructionSetBCH2022,
  get OpcodesBCH2022 () { return OpcodesBCH2022; },
  createTestAuthenticationProgramBCH: createTestAuthenticationProgramBCH,
  createVirtualMachineBCH2022: createVirtualMachineBCH2022,
  get ConsensusBCH2023 () { return ConsensusBCH2023; },
  SigningSerializationTypesBCH2023: SigningSerializationTypesBCH2023,
  opCheckSigBCH2023: opCheckSigBCH2023,
  opCheckMultiSigBCH2023: opCheckMultiSigBCH2023,
  opCheckSigVerifyBCH2023: opCheckSigVerifyBCH2023,
  opCheckMultiSigVerifyBCH2023: opCheckMultiSigVerifyBCH2023,
  get OpcodeDescriptionsBCH2023 () { return OpcodeDescriptionsBCH2023; },
  OpcodeDescriptionsBCH: OpcodeDescriptionsBCH,
  OpcodeDescriptions: OpcodeDescriptions,
  get AuthenticationErrorBCH2023 () { return AuthenticationErrorBCH2023; },
  AuthenticationErrorBCH: AuthenticationErrorBCH,
  createInstructionSetBCH2023: createInstructionSetBCH2023,
  createInstructionSetBCH: createInstructionSetBCH,
  get OpcodesBCH2023 () { return OpcodesBCH2023; },
  OpcodesBCH: OpcodesBCH,
  Opcodes: Opcodes,
  extractGenesisCategories: extractGenesisCategories,
  extractSourceOutputTokenData: extractSourceOutputTokenData,
  extractTransactionOutputTokenData: extractTransactionOutputTokenData,
  verifyTransactionTokens: verifyTransactionTokens,
  pushTokenExtendedCategory: pushTokenExtendedCategory,
  pushTokenCommitment: pushTokenCommitment,
  pushTokenAmount: pushTokenAmount,
  opUtxoTokenCategory: opUtxoTokenCategory,
  opUtxoTokenCommitment: opUtxoTokenCommitment,
  opUtxoTokenAmount: opUtxoTokenAmount,
  opOutputTokenCategory: opOutputTokenCategory,
  opOutputTokenCommitment: opOutputTokenCommitment,
  opOutputTokenAmount: opOutputTokenAmount,
  createVirtualMachineBCH2023: createVirtualMachineBCH2023,
  createVirtualMachineBCH: createVirtualMachineBCH,
  hashDigestIterations: hashDigestIterations,
  incrementHashDigestIterations: incrementHashDigestIterations,
  opRipemd160ChipLimits: opRipemd160ChipLimits,
  opSha1ChipLimits: opSha1ChipLimits,
  opSha256ChipLimits: opSha256ChipLimits,
  opHash160ChipLimits: opHash160ChipLimits,
  opHash256ChipLimits: opHash256ChipLimits,
  opCheckSigChipLimits: opCheckSigChipLimits,
  opCheckMultiSigChipLimits: opCheckMultiSigChipLimits,
  opCheckSigVerifyChipLimits: opCheckSigVerifyChipLimits,
  opCheckMultiSigVerifyChipLimits: opCheckMultiSigVerifyChipLimits,
  opCheckDataSigChipLimits: opCheckDataSigChipLimits,
  opCheckDataSigVerifyChipLimits: opCheckDataSigVerifyChipLimits,
  get OpcodeDescriptionsBCHCHIPs () { return OpcodeDescriptionsBCHCHIPs; },
  get AuthenticationErrorBCHCHIPs () { return AuthenticationErrorBCHCHIPs; },
  createInstructionSetBCHCHIPs: createInstructionSetBCHCHIPs,
  conditionallyEvaluateChipLoops: conditionallyEvaluateChipLoops,
  undefinedOperationChipLoops: undefinedOperationChipLoops,
  pushOperationChipLoops: pushOperationChipLoops,
  pushToControlStackChipLoops: pushToControlStackChipLoops,
  opIfChipLoops: opIfChipLoops,
  opNotIfChipLoops: opNotIfChipLoops,
  opEndIfChipLoops: opEndIfChipLoops,
  opElseChipLoops: opElseChipLoops,
  opBegin: opBegin,
  opUntil: opUntil,
  get OpcodesBCHCHIPs () { return OpcodesBCHCHIPs; },
  get ConsensusBCHCHIPs () { return ConsensusBCHCHIPs; },
  cloneAuthenticationProgramStateBCHCHIPs: cloneAuthenticationProgramStateBCHCHIPs,
  createAuthenticationProgramStateBCHCHIPs: createAuthenticationProgramStateBCHCHIPs,
  createVirtualMachineBCHCHIPs: createVirtualMachineBCHCHIPs,
  get OpcodeDescriptionsBTC () { return OpcodeDescriptionsBTC; },
  get OpcodesBTC () { return OpcodesBTC; },
  op1Add: op1Add,
  op1Sub: op1Sub,
  opNegate: opNegate,
  opAbs: opAbs,
  opNot: opNot,
  op0NotEqual: op0NotEqual,
  opAdd: opAdd,
  opSub: opSub,
  opBoolAnd: opBoolAnd,
  opBoolOr: opBoolOr,
  opNumEqual: opNumEqual,
  opNumEqualVerify: opNumEqualVerify,
  opNumNotEqual: opNumNotEqual,
  opLessThan: opLessThan,
  opLessThanOrEqual: opLessThanOrEqual,
  opGreaterThan: opGreaterThan,
  opGreaterThanOrEqual: opGreaterThanOrEqual,
  opMin: opMin,
  opMax: opMax,
  opWithin: opWithin,
  opMul: opMul,
  opDiv: opDiv,
  opMod: opMod,
  opEqual: opEqual,
  opEqualVerify: opEqualVerify,
  bitwiseOperation: bitwiseOperation,
  opAnd: opAnd,
  opOr: opOr,
  opXor: opXor,
  incrementOperationCount: incrementOperationCount,
  conditionallyEvaluate: conditionallyEvaluate,
  mapOverOperations: mapOverOperations,
  useOneStackItem: useOneStackItem,
  useTwoStackItems: useTwoStackItems,
  useThreeStackItems: useThreeStackItems,
  useFourStackItems: useFourStackItems,
  useSixStackItems: useSixStackItems,
  useOneVmNumber: useOneVmNumber,
  useTwoVmNumbers: useTwoVmNumbers,
  useThreeVmNumbers: useThreeVmNumbers,
  pushToStack: pushToStack,
  pushToStackChecked: pushToStackChecked,
  pushToStackVmNumber: pushToStackVmNumber,
  pushToStackVmNumberChecked: pushToStackVmNumberChecked,
  combineOperations: combineOperations,
  undefinedOperation: undefinedOperation,
  checkLimitsCommon: checkLimitsCommon,
  cloneStack: cloneStack,
  createAuthenticationProgramStateCommon: createAuthenticationProgramStateCommon,
  cloneAuthenticationProgramCommon: cloneAuthenticationProgramCommon,
  cloneAuthenticationProgramStateCommon: cloneAuthenticationProgramStateCommon,
  cloneAuthenticationProgramStateBCH: cloneAuthenticationProgramStateBCH,
  cloneAuthenticationProgramState: cloneAuthenticationProgramState,
  createCompilationContextCommonTesting: createCompilationContextCommonTesting,
  get ConsensusCommon () { return ConsensusCommon; },
  SigningSerializationTypesCommon: SigningSerializationTypesCommon,
  SigningSerializationTypesBCH: SigningSerializationTypesBCH,
  ConsensusBCH: ConsensusBCH,
  opRipemd160: opRipemd160,
  opSha1: opSha1,
  opSha256: opSha256,
  opHash160: opHash160,
  opHash256: opHash256,
  opCodeSeparator: opCodeSeparator,
  opCheckSig: opCheckSig,
  opCheckMultiSig: opCheckMultiSig,
  opCheckSigVerify: opCheckSigVerify,
  opCheckMultiSigVerify: opCheckMultiSigVerify,
  isValidSignatureEncodingBCHRaw: isValidSignatureEncodingBCHRaw,
  opCheckDataSig: opCheckDataSig,
  opCheckDataSigVerify: opCheckDataSigVerify,
  opReverseBytes: opReverseBytes,
  isValidSignatureEncodingDER: isValidSignatureEncodingDER,
  isValidSignatureEncodingBCHTransaction: isValidSignatureEncodingBCHTransaction,
  decodeBitcoinSignature: decodeBitcoinSignature,
  get AuthenticationErrorCommon () { return AuthenticationErrorCommon; },
  applyError: applyError,
  opVerify: opVerify,
  reservedOperation: reservedOperation,
  opReturn: opReturn,
  opIf: opIf,
  opNotIf: opNotIf,
  opEndIf: opEndIf,
  opElse: opElse,
  opCat: opCat,
  opSplit: opSplit,
  padMinimallyEncodedVmNumber: padMinimallyEncodedVmNumber,
  opNum2Bin: opNum2Bin,
  opBin2Num: opBin2Num,
  opInputIndex: opInputIndex,
  opActiveBytecode: opActiveBytecode,
  opTxVersion: opTxVersion,
  opTxInputCount: opTxInputCount,
  opTxOutputCount: opTxOutputCount,
  opTxLocktime: opTxLocktime,
  useTransactionUtxo: useTransactionUtxo,
  opUtxoValue: opUtxoValue,
  opUtxoBytecode: opUtxoBytecode,
  useTransactionInput: useTransactionInput,
  opOutpointTxHash: opOutpointTxHash,
  opOutpointIndex: opOutpointIndex,
  opInputBytecode: opInputBytecode,
  opInputSequenceNumber: opInputSequenceNumber,
  useTransactionOutput: useTransactionOutput,
  opOutputValue: opOutputValue,
  opOutputBytecode: opOutputBytecode,
  authenticationInstructionIsMalformed: authenticationInstructionIsMalformed,
  authenticationInstructionsAreMalformed: authenticationInstructionsAreMalformed,
  authenticationInstructionsArePushInstructions: authenticationInstructionsArePushInstructions,
  decodeLittleEndianNumber: decodeLittleEndianNumber,
  opcodeToPushLength: opcodeToPushLength,
  decodeAuthenticationInstruction: decodeAuthenticationInstruction,
  cloneAuthenticationInstruction: cloneAuthenticationInstruction,
  decodeAuthenticationInstructions: decodeAuthenticationInstructions,
  disassembleAuthenticationInstructionMalformed: disassembleAuthenticationInstructionMalformed,
  disassembleAuthenticationInstruction: disassembleAuthenticationInstruction,
  disassembleAuthenticationInstructionMaybeMalformed: disassembleAuthenticationInstructionMaybeMalformed,
  disassembleAuthenticationInstructionsMaybeMalformed: disassembleAuthenticationInstructionsMaybeMalformed,
  disassembleBytecode: disassembleBytecode,
  disassembleBytecodeBCH: disassembleBytecodeBCH,
  disassembleBytecodeBTC: disassembleBytecodeBTC,
  generateBytecodeMap: generateBytecodeMap,
  encodeAuthenticationInstruction: encodeAuthenticationInstruction,
  encodeAuthenticationInstructionMalformed: encodeAuthenticationInstructionMalformed,
  encodeAuthenticationInstructionMaybeMalformed: encodeAuthenticationInstructionMaybeMalformed,
  encodeAuthenticationInstructions: encodeAuthenticationInstructions,
  encodeAuthenticationInstructionsMaybeMalformed: encodeAuthenticationInstructionsMaybeMalformed,
  get VmNumberError () { return VmNumberError; },
  isVmNumberError: isVmNumberError,
  vmNumberToBigInt: vmNumberToBigInt,
  bigIntToVmNumber: bigIntToVmNumber,
  stackItemIsTruthy: stackItemIsTruthy,
  booleanToVmNumber: booleanToVmNumber,
  isPushOperation: isPushOperation,
  isPushOnly: isPushOnly,
  isPushOnlyAccurate: isPushOnlyAccurate,
  isArbitraryDataOutput: isArbitraryDataOutput,
  getMinimumFee: getMinimumFee,
  getDustThreshold: getDustThreshold,
  isDustOutput: isDustOutput,
  isValidUncompressedPublicKeyEncoding: isValidUncompressedPublicKeyEncoding,
  isValidCompressedPublicKeyEncoding: isValidCompressedPublicKeyEncoding,
  isValidPublicKeyEncoding: isValidPublicKeyEncoding,
  pushNumberOpcodeToNumber: pushNumberOpcodeToNumber,
  isSimpleMultisig: isSimpleMultisig,
  isStandardMultisig: isStandardMultisig,
  isStandardOutputBytecode: isStandardOutputBytecode,
  isStandardOutputBytecode2023: isStandardOutputBytecode2023,
  isWitnessProgram: isWitnessProgram,
  opNop: opNop,
  opNopDisallowed: opNopDisallowed,
  disabledOperation: disabledOperation,
  encodeDataPush: encodeDataPush,
  isMinimalDataPush: isMinimalDataPush,
  pushOperation: pushOperation,
  pushNumberOperation: pushNumberOperation,
  get SigningSerializationFlag () { return SigningSerializationFlag; },
  get SigningSerializationType () { return SigningSerializationType; },
  SigningSerializationTypeBCH: SigningSerializationTypeBCH,
  hashPrevouts: hashPrevouts,
  hashUtxos: hashUtxos,
  hashSequence: hashSequence,
  hashOutputs: hashOutputs,
  encodeSigningSerializationBCH: encodeSigningSerializationBCH,
  generateSigningSerializationComponentsBCH: generateSigningSerializationComponentsBCH,
  generateSigningSerializationBCH: generateSigningSerializationBCH,
  isLegacySigningSerialization: isLegacySigningSerialization,
  opToAltStack: opToAltStack,
  opFromAltStack: opFromAltStack,
  op2Drop: op2Drop,
  op2Dup: op2Dup,
  op3Dup: op3Dup,
  op2Over: op2Over,
  op2Rot: op2Rot,
  op2Swap: op2Swap,
  opIfDup: opIfDup,
  opDepth: opDepth,
  opDrop: opDrop,
  opDup: opDup,
  opNip: opNip,
  opOver: opOver,
  opPick: opPick,
  opRoll: opRoll,
  opRot: opRot,
  opSwap: opSwap,
  opTuck: opTuck,
  opSize: opSize,
  useLocktime: useLocktime,
  opCheckLockTimeVerify: opCheckLockTimeVerify,
  opCheckSequenceVerify: opCheckSequenceVerify,
  createAuthenticationVirtualMachine: createAuthenticationVirtualMachine,
  vmbTestDefinitionDefaultBehaviorBCH: vmbTestDefinitionDefaultBehaviorBCH,
  supportedTestSetOverridesBCH: supportedTestSetOverridesBCH,
  vmbTestDefinitionToVmbTests: vmbTestDefinitionToVmbTests,
  vmbTestGroupToVmbTests: vmbTestGroupToVmbTests,
  vmbTestPartitionMasterTestList: vmbTestPartitionMasterTestList
});

var require$$0$2 = /*@__PURE__*/getAugmentedNamespace(build);

var inherits_browser = {exports: {}};

if (typeof Object.create === 'function') {
  // implementation from standard node.js 'util' module
  inherits_browser.exports = function inherits(ctor, superCtor) {
    if (superCtor) {
      ctor.super_ = superCtor;
      ctor.prototype = Object.create(superCtor.prototype, {
        constructor: {
          value: ctor,
          enumerable: false,
          writable: true,
          configurable: true
        }
      });
    }
  };
} else {
  // old school shim for old browsers
  inherits_browser.exports = function inherits(ctor, superCtor) {
    if (superCtor) {
      ctor.super_ = superCtor;
      var TempCtor = function TempCtor() {};
      TempCtor.prototype = superCtor.prototype;
      ctor.prototype = new TempCtor();
      ctor.prototype.constructor = ctor;
    }
  };
}
var inherits_browserExports = inherits_browser.exports;

var safeBuffer = {exports: {}};

var global$1 = typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {};

var lookup$1 = [];
var revLookup$1 = [];
var Arr$1 = typeof Uint8Array !== 'undefined' ? Uint8Array : Array;
var inited = false;
function init() {
  inited = true;
  var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
  for (var i = 0, len = code.length; i < len; ++i) {
    lookup$1[i] = code[i];
    revLookup$1[code.charCodeAt(i)] = i;
  }
  revLookup$1['-'.charCodeAt(0)] = 62;
  revLookup$1['_'.charCodeAt(0)] = 63;
}
function toByteArray$1(b64) {
  if (!inited) {
    init();
  }
  var i, j, l, tmp, placeHolders, arr;
  var len = b64.length;
  if (len % 4 > 0) {
    throw new Error('Invalid string. Length must be a multiple of 4');
  }

  // the number of equal signs (place holders)
  // if there are two placeholders, than the two characters before it
  // represent one byte
  // if there is only one, then the three characters before it represent 2 bytes
  // this is just a cheap hack to not do indexOf twice
  placeHolders = b64[len - 2] === '=' ? 2 : b64[len - 1] === '=' ? 1 : 0;

  // base64 is 4/3 + up to two characters of the original data
  arr = new Arr$1(len * 3 / 4 - placeHolders);

  // if there are placeholders, only get up to the last complete 4 chars
  l = placeHolders > 0 ? len - 4 : len;
  var L = 0;
  for (i = 0, j = 0; i < l; i += 4, j += 3) {
    tmp = revLookup$1[b64.charCodeAt(i)] << 18 | revLookup$1[b64.charCodeAt(i + 1)] << 12 | revLookup$1[b64.charCodeAt(i + 2)] << 6 | revLookup$1[b64.charCodeAt(i + 3)];
    arr[L++] = tmp >> 16 & 0xFF;
    arr[L++] = tmp >> 8 & 0xFF;
    arr[L++] = tmp & 0xFF;
  }
  if (placeHolders === 2) {
    tmp = revLookup$1[b64.charCodeAt(i)] << 2 | revLookup$1[b64.charCodeAt(i + 1)] >> 4;
    arr[L++] = tmp & 0xFF;
  } else if (placeHolders === 1) {
    tmp = revLookup$1[b64.charCodeAt(i)] << 10 | revLookup$1[b64.charCodeAt(i + 1)] << 4 | revLookup$1[b64.charCodeAt(i + 2)] >> 2;
    arr[L++] = tmp >> 8 & 0xFF;
    arr[L++] = tmp & 0xFF;
  }
  return arr;
}
function tripletToBase64$1(num) {
  return lookup$1[num >> 18 & 0x3F] + lookup$1[num >> 12 & 0x3F] + lookup$1[num >> 6 & 0x3F] + lookup$1[num & 0x3F];
}
function encodeChunk$1(uint8, start, end) {
  var tmp;
  var output = [];
  for (var i = start; i < end; i += 3) {
    tmp = (uint8[i] << 16) + (uint8[i + 1] << 8) + uint8[i + 2];
    output.push(tripletToBase64$1(tmp));
  }
  return output.join('');
}
function fromByteArray$1(uint8) {
  if (!inited) {
    init();
  }
  var tmp;
  var len = uint8.length;
  var extraBytes = len % 3; // if we have 1 byte left, pad 2 bytes
  var output = '';
  var parts = [];
  var maxChunkLength = 16383; // must be multiple of 3

  // go through the array every three bytes, we'll deal with trailing stuff later
  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
    parts.push(encodeChunk$1(uint8, i, i + maxChunkLength > len2 ? len2 : i + maxChunkLength));
  }

  // pad the end with zeros, but make sure to not forget the extra bytes
  if (extraBytes === 1) {
    tmp = uint8[len - 1];
    output += lookup$1[tmp >> 2];
    output += lookup$1[tmp << 4 & 0x3F];
    output += '==';
  } else if (extraBytes === 2) {
    tmp = (uint8[len - 2] << 8) + uint8[len - 1];
    output += lookup$1[tmp >> 10];
    output += lookup$1[tmp >> 4 & 0x3F];
    output += lookup$1[tmp << 2 & 0x3F];
    output += '=';
  }
  parts.push(output);
  return parts.join('');
}
function read(buffer, offset, isLE, mLen, nBytes) {
  var e, m;
  var eLen = nBytes * 8 - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var nBits = -7;
  var i = isLE ? nBytes - 1 : 0;
  var d = isLE ? -1 : 1;
  var s = buffer[offset + i];
  i += d;
  e = s & (1 << -nBits) - 1;
  s >>= -nBits;
  nBits += eLen;
  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}
  m = e & (1 << -nBits) - 1;
  e >>= -nBits;
  nBits += mLen;
  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}
  if (e === 0) {
    e = 1 - eBias;
  } else if (e === eMax) {
    return m ? NaN : (s ? -1 : 1) * Infinity;
  } else {
    m = m + Math.pow(2, mLen);
    e = e - eBias;
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
}
function write(buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c;
  var eLen = nBytes * 8 - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
  var i = isLE ? 0 : nBytes - 1;
  var d = isLE ? 1 : -1;
  var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
  value = Math.abs(value);
  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0;
    e = eMax;
  } else {
    e = Math.floor(Math.log(value) / Math.LN2);
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--;
      c *= 2;
    }
    if (e + eBias >= 1) {
      value += rt / c;
    } else {
      value += rt * Math.pow(2, 1 - eBias);
    }
    if (value * c >= 2) {
      e++;
      c /= 2;
    }
    if (e + eBias >= eMax) {
      m = 0;
      e = eMax;
    } else if (e + eBias >= 1) {
      m = (value * c - 1) * Math.pow(2, mLen);
      e = e + eBias;
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
      e = 0;
    }
  }
  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}
  e = e << mLen | m;
  eLen += mLen;
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}
  buffer[offset + i - d] |= s * 128;
}
var toString = {}.toString;
var isArray$1 = Array.isArray || function (arr) {
  return toString.call(arr) == '[object Array]';
};

/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
 * @license  MIT
 */

var INSPECT_MAX_BYTES = 50;

/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Use Object implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * Due to various browser bugs, sometimes the Object implementation will be used even
 * when the browser supports typed arrays.
 *
 * Note:
 *
 *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,
 *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.
 *
 *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.
 *
 *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of
 *     incorrect length in some situations.

 * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they
 * get the Object implementation, which is slower but behaves correctly.
 */
Buffer$d.TYPED_ARRAY_SUPPORT = global$1.TYPED_ARRAY_SUPPORT !== undefined ? global$1.TYPED_ARRAY_SUPPORT : true;

/*
 * Export kMaxLength after typed array support is determined.
 */
var _kMaxLength = kMaxLength();
function kMaxLength() {
  return Buffer$d.TYPED_ARRAY_SUPPORT ? 0x7fffffff : 0x3fffffff;
}
function createBuffer(that, length) {
  if (kMaxLength() < length) {
    throw new RangeError('Invalid typed array length');
  }
  if (Buffer$d.TYPED_ARRAY_SUPPORT) {
    // Return an augmented `Uint8Array` instance, for best performance
    that = new Uint8Array(length);
    that.__proto__ = Buffer$d.prototype;
  } else {
    // Fallback: Return an object instance of the Buffer class
    if (that === null) {
      that = new Buffer$d(length);
    }
    that.length = length;
  }
  return that;
}

/**
 * The Buffer constructor returns instances of `Uint8Array` that have their
 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
 * returns a single octet.
 *
 * The `Uint8Array` prototype remains unmodified.
 */

function Buffer$d(arg, encodingOrOffset, length) {
  if (!Buffer$d.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer$d)) {
    return new Buffer$d(arg, encodingOrOffset, length);
  }

  // Common case.
  if (typeof arg === 'number') {
    if (typeof encodingOrOffset === 'string') {
      throw new Error('If encoding is specified then the first argument must be a string');
    }
    return allocUnsafe(this, arg);
  }
  return from(this, arg, encodingOrOffset, length);
}
Buffer$d.poolSize = 8192; // not used by this implementation

// TODO: Legacy, not needed anymore. Remove in next major version.
Buffer$d._augment = function (arr) {
  arr.__proto__ = Buffer$d.prototype;
  return arr;
};
function from(that, value, encodingOrOffset, length) {
  if (typeof value === 'number') {
    throw new TypeError('"value" argument must not be a number');
  }
  if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {
    return fromArrayBuffer(that, value, encodingOrOffset, length);
  }
  if (typeof value === 'string') {
    return fromString(that, value, encodingOrOffset);
  }
  return fromObject(that, value);
}

/**
 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
 * if value is a number.
 * Buffer.from(str[, encoding])
 * Buffer.from(array)
 * Buffer.from(buffer)
 * Buffer.from(arrayBuffer[, byteOffset[, length]])
 **/
Buffer$d.from = function (value, encodingOrOffset, length) {
  return from(null, value, encodingOrOffset, length);
};
if (Buffer$d.TYPED_ARRAY_SUPPORT) {
  Buffer$d.prototype.__proto__ = Uint8Array.prototype;
  Buffer$d.__proto__ = Uint8Array;
}
function assertSize(size) {
  if (typeof size !== 'number') {
    throw new TypeError('"size" argument must be a number');
  } else if (size < 0) {
    throw new RangeError('"size" argument must not be negative');
  }
}
function alloc(that, size, fill, encoding) {
  assertSize(size);
  if (size <= 0) {
    return createBuffer(that, size);
  }
  if (fill !== undefined) {
    // Only pay attention to encoding if it's a string. This
    // prevents accidentally sending in a number that would
    // be interpretted as a start offset.
    return typeof encoding === 'string' ? createBuffer(that, size).fill(fill, encoding) : createBuffer(that, size).fill(fill);
  }
  return createBuffer(that, size);
}

/**
 * Creates a new filled Buffer instance.
 * alloc(size[, fill[, encoding]])
 **/
Buffer$d.alloc = function (size, fill, encoding) {
  return alloc(null, size, fill, encoding);
};
function allocUnsafe(that, size) {
  assertSize(size);
  that = createBuffer(that, size < 0 ? 0 : checked(size) | 0);
  if (!Buffer$d.TYPED_ARRAY_SUPPORT) {
    for (var i = 0; i < size; ++i) {
      that[i] = 0;
    }
  }
  return that;
}

/**
 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
 * */
Buffer$d.allocUnsafe = function (size) {
  return allocUnsafe(null, size);
};
/**
 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
 */
Buffer$d.allocUnsafeSlow = function (size) {
  return allocUnsafe(null, size);
};
function fromString(that, string, encoding) {
  if (typeof encoding !== 'string' || encoding === '') {
    encoding = 'utf8';
  }
  if (!Buffer$d.isEncoding(encoding)) {
    throw new TypeError('"encoding" must be a valid string encoding');
  }
  var length = byteLength$1(string, encoding) | 0;
  that = createBuffer(that, length);
  var actual = that.write(string, encoding);
  if (actual !== length) {
    // Writing a hex string, for example, that contains invalid characters will
    // cause everything after the first invalid character to be ignored. (e.g.
    // 'abxxcd' will be treated as 'ab')
    that = that.slice(0, actual);
  }
  return that;
}
function fromArrayLike(that, array) {
  var length = array.length < 0 ? 0 : checked(array.length) | 0;
  that = createBuffer(that, length);
  for (var i = 0; i < length; i += 1) {
    that[i] = array[i] & 255;
  }
  return that;
}
function fromArrayBuffer(that, array, byteOffset, length) {
  array.byteLength; // this throws if `array` is not a valid ArrayBuffer

  if (byteOffset < 0 || array.byteLength < byteOffset) {
    throw new RangeError('\'offset\' is out of bounds');
  }
  if (array.byteLength < byteOffset + (length || 0)) {
    throw new RangeError('\'length\' is out of bounds');
  }
  if (byteOffset === undefined && length === undefined) {
    array = new Uint8Array(array);
  } else if (length === undefined) {
    array = new Uint8Array(array, byteOffset);
  } else {
    array = new Uint8Array(array, byteOffset, length);
  }
  if (Buffer$d.TYPED_ARRAY_SUPPORT) {
    // Return an augmented `Uint8Array` instance, for best performance
    that = array;
    that.__proto__ = Buffer$d.prototype;
  } else {
    // Fallback: Return an object instance of the Buffer class
    that = fromArrayLike(that, array);
  }
  return that;
}
function fromObject(that, obj) {
  if (internalIsBuffer(obj)) {
    var len = checked(obj.length) | 0;
    that = createBuffer(that, len);
    if (that.length === 0) {
      return that;
    }
    obj.copy(that, 0, 0, len);
    return that;
  }
  if (obj) {
    if (typeof ArrayBuffer !== 'undefined' && obj.buffer instanceof ArrayBuffer || 'length' in obj) {
      if (typeof obj.length !== 'number' || isnan(obj.length)) {
        return createBuffer(that, 0);
      }
      return fromArrayLike(that, obj);
    }
    if (obj.type === 'Buffer' && isArray$1(obj.data)) {
      return fromArrayLike(that, obj.data);
    }
  }
  throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.');
}
function checked(length) {
  // Note: cannot use `length < kMaxLength()` here because that fails when
  // length is NaN (which is otherwise coerced to zero.)
  if (length >= kMaxLength()) {
    throw new RangeError('Attempt to allocate Buffer larger than maximum ' + 'size: 0x' + kMaxLength().toString(16) + ' bytes');
  }
  return length | 0;
}
function SlowBuffer(length) {
  if (+length != length) {
    // eslint-disable-line eqeqeq
    length = 0;
  }
  return Buffer$d.alloc(+length);
}
Buffer$d.isBuffer = isBuffer$1;
function internalIsBuffer(b) {
  return !!(b != null && b._isBuffer);
}
Buffer$d.compare = function compare(a, b) {
  if (!internalIsBuffer(a) || !internalIsBuffer(b)) {
    throw new TypeError('Arguments must be Buffers');
  }
  if (a === b) return 0;
  var x = a.length;
  var y = b.length;
  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
    if (a[i] !== b[i]) {
      x = a[i];
      y = b[i];
      break;
    }
  }
  if (x < y) return -1;
  if (y < x) return 1;
  return 0;
};
Buffer$d.isEncoding = function isEncoding(encoding) {
  switch (String(encoding).toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'latin1':
    case 'binary':
    case 'base64':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return true;
    default:
      return false;
  }
};
Buffer$d.concat = function concat(list, length) {
  if (!isArray$1(list)) {
    throw new TypeError('"list" argument must be an Array of Buffers');
  }
  if (list.length === 0) {
    return Buffer$d.alloc(0);
  }
  var i;
  if (length === undefined) {
    length = 0;
    for (i = 0; i < list.length; ++i) {
      length += list[i].length;
    }
  }
  var buffer = Buffer$d.allocUnsafe(length);
  var pos = 0;
  for (i = 0; i < list.length; ++i) {
    var buf = list[i];
    if (!internalIsBuffer(buf)) {
      throw new TypeError('"list" argument must be an Array of Buffers');
    }
    buf.copy(buffer, pos);
    pos += buf.length;
  }
  return buffer;
};
function byteLength$1(string, encoding) {
  if (internalIsBuffer(string)) {
    return string.length;
  }
  if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'function' && (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {
    return string.byteLength;
  }
  if (typeof string !== 'string') {
    string = '' + string;
  }
  var len = string.length;
  if (len === 0) return 0;

  // Use a for loop to avoid recursion
  var loweredCase = false;
  for (;;) {
    switch (encoding) {
      case 'ascii':
      case 'latin1':
      case 'binary':
        return len;
      case 'utf8':
      case 'utf-8':
      case undefined:
        return utf8ToBytes(string).length;
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return len * 2;
      case 'hex':
        return len >>> 1;
      case 'base64':
        return base64ToBytes(string).length;
      default:
        if (loweredCase) return utf8ToBytes(string).length; // assume utf8
        encoding = ('' + encoding).toLowerCase();
        loweredCase = true;
    }
  }
}
Buffer$d.byteLength = byteLength$1;
function slowToString(encoding, start, end) {
  var loweredCase = false;

  // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
  // property of a typed array.

  // This behaves neither like String nor Uint8Array in that we set start/end
  // to their upper/lower bounds if the value passed is out of range.
  // undefined is handled specially as per ECMA-262 6th Edition,
  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
  if (start === undefined || start < 0) {
    start = 0;
  }
  // Return early if start > this.length. Done here to prevent potential uint32
  // coercion fail below.
  if (start > this.length) {
    return '';
  }
  if (end === undefined || end > this.length) {
    end = this.length;
  }
  if (end <= 0) {
    return '';
  }

  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.
  end >>>= 0;
  start >>>= 0;
  if (end <= start) {
    return '';
  }
  if (!encoding) encoding = 'utf8';
  while (true) {
    switch (encoding) {
      case 'hex':
        return hexSlice(this, start, end);
      case 'utf8':
      case 'utf-8':
        return utf8Slice(this, start, end);
      case 'ascii':
        return asciiSlice(this, start, end);
      case 'latin1':
      case 'binary':
        return latin1Slice(this, start, end);
      case 'base64':
        return base64Slice(this, start, end);
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return utf16leSlice(this, start, end);
      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding);
        encoding = (encoding + '').toLowerCase();
        loweredCase = true;
    }
  }
}

// The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect
// Buffer instances.
Buffer$d.prototype._isBuffer = true;
function swap(b, n, m) {
  var i = b[n];
  b[n] = b[m];
  b[m] = i;
}
Buffer$d.prototype.swap16 = function swap16() {
  var len = this.length;
  if (len % 2 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 16-bits');
  }
  for (var i = 0; i < len; i += 2) {
    swap(this, i, i + 1);
  }
  return this;
};
Buffer$d.prototype.swap32 = function swap32() {
  var len = this.length;
  if (len % 4 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 32-bits');
  }
  for (var i = 0; i < len; i += 4) {
    swap(this, i, i + 3);
    swap(this, i + 1, i + 2);
  }
  return this;
};
Buffer$d.prototype.swap64 = function swap64() {
  var len = this.length;
  if (len % 8 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 64-bits');
  }
  for (var i = 0; i < len; i += 8) {
    swap(this, i, i + 7);
    swap(this, i + 1, i + 6);
    swap(this, i + 2, i + 5);
    swap(this, i + 3, i + 4);
  }
  return this;
};
Buffer$d.prototype.toString = function toString() {
  var length = this.length | 0;
  if (length === 0) return '';
  if (arguments.length === 0) return utf8Slice(this, 0, length);
  return slowToString.apply(this, arguments);
};
Buffer$d.prototype.equals = function equals(b) {
  if (!internalIsBuffer(b)) throw new TypeError('Argument must be a Buffer');
  if (this === b) return true;
  return Buffer$d.compare(this, b) === 0;
};
Buffer$d.prototype.inspect = function inspect() {
  var str = '';
  var max = INSPECT_MAX_BYTES;
  if (this.length > 0) {
    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ');
    if (this.length > max) str += ' ... ';
  }
  return '<Buffer ' + str + '>';
};
Buffer$d.prototype.compare = function compare(target, start, end, thisStart, thisEnd) {
  if (!internalIsBuffer(target)) {
    throw new TypeError('Argument must be a Buffer');
  }
  if (start === undefined) {
    start = 0;
  }
  if (end === undefined) {
    end = target ? target.length : 0;
  }
  if (thisStart === undefined) {
    thisStart = 0;
  }
  if (thisEnd === undefined) {
    thisEnd = this.length;
  }
  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
    throw new RangeError('out of range index');
  }
  if (thisStart >= thisEnd && start >= end) {
    return 0;
  }
  if (thisStart >= thisEnd) {
    return -1;
  }
  if (start >= end) {
    return 1;
  }
  start >>>= 0;
  end >>>= 0;
  thisStart >>>= 0;
  thisEnd >>>= 0;
  if (this === target) return 0;
  var x = thisEnd - thisStart;
  var y = end - start;
  var len = Math.min(x, y);
  var thisCopy = this.slice(thisStart, thisEnd);
  var targetCopy = target.slice(start, end);
  for (var i = 0; i < len; ++i) {
    if (thisCopy[i] !== targetCopy[i]) {
      x = thisCopy[i];
      y = targetCopy[i];
      break;
    }
  }
  if (x < y) return -1;
  if (y < x) return 1;
  return 0;
};

// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
// OR the last index of `val` in `buffer` at offset <= `byteOffset`.
//
// Arguments:
// - buffer - a Buffer to search
// - val - a string, Buffer, or number
// - byteOffset - an index into `buffer`; will be clamped to an int32
// - encoding - an optional encoding, relevant is val is a string
// - dir - true for indexOf, false for lastIndexOf
function bidirectionalIndexOf(buffer, val, byteOffset, encoding, dir) {
  // Empty buffer means no match
  if (buffer.length === 0) return -1;

  // Normalize byteOffset
  if (typeof byteOffset === 'string') {
    encoding = byteOffset;
    byteOffset = 0;
  } else if (byteOffset > 0x7fffffff) {
    byteOffset = 0x7fffffff;
  } else if (byteOffset < -0x80000000) {
    byteOffset = -0x80000000;
  }
  byteOffset = +byteOffset; // Coerce to Number.
  if (isNaN(byteOffset)) {
    // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
    byteOffset = dir ? 0 : buffer.length - 1;
  }

  // Normalize byteOffset: negative offsets start from the end of the buffer
  if (byteOffset < 0) byteOffset = buffer.length + byteOffset;
  if (byteOffset >= buffer.length) {
    if (dir) return -1;else byteOffset = buffer.length - 1;
  } else if (byteOffset < 0) {
    if (dir) byteOffset = 0;else return -1;
  }

  // Normalize val
  if (typeof val === 'string') {
    val = Buffer$d.from(val, encoding);
  }

  // Finally, search either indexOf (if dir is true) or lastIndexOf
  if (internalIsBuffer(val)) {
    // Special case: looking for empty string/buffer always fails
    if (val.length === 0) {
      return -1;
    }
    return arrayIndexOf(buffer, val, byteOffset, encoding, dir);
  } else if (typeof val === 'number') {
    val = val & 0xFF; // Search for a byte value [0-255]
    if (Buffer$d.TYPED_ARRAY_SUPPORT && typeof Uint8Array.prototype.indexOf === 'function') {
      if (dir) {
        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset);
      } else {
        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset);
      }
    }
    return arrayIndexOf(buffer, [val], byteOffset, encoding, dir);
  }
  throw new TypeError('val must be string, number or Buffer');
}
function arrayIndexOf(arr, val, byteOffset, encoding, dir) {
  var indexSize = 1;
  var arrLength = arr.length;
  var valLength = val.length;
  if (encoding !== undefined) {
    encoding = String(encoding).toLowerCase();
    if (encoding === 'ucs2' || encoding === 'ucs-2' || encoding === 'utf16le' || encoding === 'utf-16le') {
      if (arr.length < 2 || val.length < 2) {
        return -1;
      }
      indexSize = 2;
      arrLength /= 2;
      valLength /= 2;
      byteOffset /= 2;
    }
  }
  function read(buf, i) {
    if (indexSize === 1) {
      return buf[i];
    } else {
      return buf.readUInt16BE(i * indexSize);
    }
  }
  var i;
  if (dir) {
    var foundIndex = -1;
    for (i = byteOffset; i < arrLength; i++) {
      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
        if (foundIndex === -1) foundIndex = i;
        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize;
      } else {
        if (foundIndex !== -1) i -= i - foundIndex;
        foundIndex = -1;
      }
    }
  } else {
    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength;
    for (i = byteOffset; i >= 0; i--) {
      var found = true;
      for (var j = 0; j < valLength; j++) {
        if (read(arr, i + j) !== read(val, j)) {
          found = false;
          break;
        }
      }
      if (found) return i;
    }
  }
  return -1;
}
Buffer$d.prototype.includes = function includes(val, byteOffset, encoding) {
  return this.indexOf(val, byteOffset, encoding) !== -1;
};
Buffer$d.prototype.indexOf = function indexOf(val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, true);
};
Buffer$d.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, false);
};
function hexWrite(buf, string, offset, length) {
  offset = Number(offset) || 0;
  var remaining = buf.length - offset;
  if (!length) {
    length = remaining;
  } else {
    length = Number(length);
    if (length > remaining) {
      length = remaining;
    }
  }

  // must be an even number of digits
  var strLen = string.length;
  if (strLen % 2 !== 0) throw new TypeError('Invalid hex string');
  if (length > strLen / 2) {
    length = strLen / 2;
  }
  for (var i = 0; i < length; ++i) {
    var parsed = parseInt(string.substr(i * 2, 2), 16);
    if (isNaN(parsed)) return i;
    buf[offset + i] = parsed;
  }
  return i;
}
function utf8Write(buf, string, offset, length) {
  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length);
}
function asciiWrite(buf, string, offset, length) {
  return blitBuffer(asciiToBytes(string), buf, offset, length);
}
function latin1Write(buf, string, offset, length) {
  return asciiWrite(buf, string, offset, length);
}
function base64Write(buf, string, offset, length) {
  return blitBuffer(base64ToBytes(string), buf, offset, length);
}
function ucs2Write(buf, string, offset, length) {
  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length);
}
Buffer$d.prototype.write = function write(string, offset, length, encoding) {
  // Buffer#write(string)
  if (offset === undefined) {
    encoding = 'utf8';
    length = this.length;
    offset = 0;
    // Buffer#write(string, encoding)
  } else if (length === undefined && typeof offset === 'string') {
    encoding = offset;
    length = this.length;
    offset = 0;
    // Buffer#write(string, offset[, length][, encoding])
  } else if (isFinite(offset)) {
    offset = offset | 0;
    if (isFinite(length)) {
      length = length | 0;
      if (encoding === undefined) encoding = 'utf8';
    } else {
      encoding = length;
      length = undefined;
    }
    // legacy write(string, encoding, offset, length) - remove in v0.13
  } else {
    throw new Error('Buffer.write(string, encoding, offset[, length]) is no longer supported');
  }
  var remaining = this.length - offset;
  if (length === undefined || length > remaining) length = remaining;
  if (string.length > 0 && (length < 0 || offset < 0) || offset > this.length) {
    throw new RangeError('Attempt to write outside buffer bounds');
  }
  if (!encoding) encoding = 'utf8';
  var loweredCase = false;
  for (;;) {
    switch (encoding) {
      case 'hex':
        return hexWrite(this, string, offset, length);
      case 'utf8':
      case 'utf-8':
        return utf8Write(this, string, offset, length);
      case 'ascii':
        return asciiWrite(this, string, offset, length);
      case 'latin1':
      case 'binary':
        return latin1Write(this, string, offset, length);
      case 'base64':
        // Warning: maxLength not taken into account in base64Write
        return base64Write(this, string, offset, length);
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return ucs2Write(this, string, offset, length);
      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding);
        encoding = ('' + encoding).toLowerCase();
        loweredCase = true;
    }
  }
};
Buffer$d.prototype.toJSON = function toJSON() {
  return {
    type: 'Buffer',
    data: Array.prototype.slice.call(this._arr || this, 0)
  };
};
function base64Slice(buf, start, end) {
  if (start === 0 && end === buf.length) {
    return fromByteArray$1(buf);
  } else {
    return fromByteArray$1(buf.slice(start, end));
  }
}
function utf8Slice(buf, start, end) {
  end = Math.min(buf.length, end);
  var res = [];
  var i = start;
  while (i < end) {
    var firstByte = buf[i];
    var codePoint = null;
    var bytesPerSequence = firstByte > 0xEF ? 4 : firstByte > 0xDF ? 3 : firstByte > 0xBF ? 2 : 1;
    if (i + bytesPerSequence <= end) {
      var secondByte, thirdByte, fourthByte, tempCodePoint;
      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 0x80) {
            codePoint = firstByte;
          }
          break;
        case 2:
          secondByte = buf[i + 1];
          if ((secondByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0x1F) << 0x6 | secondByte & 0x3F;
            if (tempCodePoint > 0x7F) {
              codePoint = tempCodePoint;
            }
          }
          break;
        case 3:
          secondByte = buf[i + 1];
          thirdByte = buf[i + 2];
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | thirdByte & 0x3F;
            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
              codePoint = tempCodePoint;
            }
          }
          break;
        case 4:
          secondByte = buf[i + 1];
          thirdByte = buf[i + 2];
          fourthByte = buf[i + 3];
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | fourthByte & 0x3F;
            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
              codePoint = tempCodePoint;
            }
          }
      }
    }
    if (codePoint === null) {
      // we did not generate a valid codePoint so insert a
      // replacement char (U+FFFD) and advance only 1 byte
      codePoint = 0xFFFD;
      bytesPerSequence = 1;
    } else if (codePoint > 0xFFFF) {
      // encode to utf16 (surrogate pair dance)
      codePoint -= 0x10000;
      res.push(codePoint >>> 10 & 0x3FF | 0xD800);
      codePoint = 0xDC00 | codePoint & 0x3FF;
    }
    res.push(codePoint);
    i += bytesPerSequence;
  }
  return decodeCodePointsArray(res);
}

// Based on http://stackoverflow.com/a/22747272/680742, the browser with
// the lowest limit is Chrome, with 0x10000 args.
// We go 1 magnitude less, for safety
var MAX_ARGUMENTS_LENGTH = 0x1000;
function decodeCodePointsArray(codePoints) {
  var len = codePoints.length;
  if (len <= MAX_ARGUMENTS_LENGTH) {
    return String.fromCharCode.apply(String, codePoints); // avoid extra slice()
  }

  // Decode in chunks to avoid "call stack size exceeded".
  var res = '';
  var i = 0;
  while (i < len) {
    res += String.fromCharCode.apply(String, codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH));
  }
  return res;
}
function asciiSlice(buf, start, end) {
  var ret = '';
  end = Math.min(buf.length, end);
  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i] & 0x7F);
  }
  return ret;
}
function latin1Slice(buf, start, end) {
  var ret = '';
  end = Math.min(buf.length, end);
  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i]);
  }
  return ret;
}
function hexSlice(buf, start, end) {
  var len = buf.length;
  if (!start || start < 0) start = 0;
  if (!end || end < 0 || end > len) end = len;
  var out = '';
  for (var i = start; i < end; ++i) {
    out += toHex(buf[i]);
  }
  return out;
}
function utf16leSlice(buf, start, end) {
  var bytes = buf.slice(start, end);
  var res = '';
  for (var i = 0; i < bytes.length; i += 2) {
    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);
  }
  return res;
}
Buffer$d.prototype.slice = function slice(start, end) {
  var len = this.length;
  start = ~~start;
  end = end === undefined ? len : ~~end;
  if (start < 0) {
    start += len;
    if (start < 0) start = 0;
  } else if (start > len) {
    start = len;
  }
  if (end < 0) {
    end += len;
    if (end < 0) end = 0;
  } else if (end > len) {
    end = len;
  }
  if (end < start) end = start;
  var newBuf;
  if (Buffer$d.TYPED_ARRAY_SUPPORT) {
    newBuf = this.subarray(start, end);
    newBuf.__proto__ = Buffer$d.prototype;
  } else {
    var sliceLen = end - start;
    newBuf = new Buffer$d(sliceLen, undefined);
    for (var i = 0; i < sliceLen; ++i) {
      newBuf[i] = this[i + start];
    }
  }
  return newBuf;
};

/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */
function checkOffset(offset, ext, length) {
  if (offset % 1 !== 0 || offset < 0) throw new RangeError('offset is not uint');
  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length');
}
Buffer$d.prototype.readUIntLE = function readUIntLE(offset, byteLength, noAssert) {
  offset = offset | 0;
  byteLength = byteLength | 0;
  if (!noAssert) checkOffset(offset, byteLength, this.length);
  var val = this[offset];
  var mul = 1;
  var i = 0;
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul;
  }
  return val;
};
Buffer$d.prototype.readUIntBE = function readUIntBE(offset, byteLength, noAssert) {
  offset = offset | 0;
  byteLength = byteLength | 0;
  if (!noAssert) {
    checkOffset(offset, byteLength, this.length);
  }
  var val = this[offset + --byteLength];
  var mul = 1;
  while (byteLength > 0 && (mul *= 0x100)) {
    val += this[offset + --byteLength] * mul;
  }
  return val;
};
Buffer$d.prototype.readUInt8 = function readUInt8(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 1, this.length);
  return this[offset];
};
Buffer$d.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length);
  return this[offset] | this[offset + 1] << 8;
};
Buffer$d.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length);
  return this[offset] << 8 | this[offset + 1];
};
Buffer$d.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length);
  return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 0x1000000;
};
Buffer$d.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length);
  return this[offset] * 0x1000000 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);
};
Buffer$d.prototype.readIntLE = function readIntLE(offset, byteLength, noAssert) {
  offset = offset | 0;
  byteLength = byteLength | 0;
  if (!noAssert) checkOffset(offset, byteLength, this.length);
  var val = this[offset];
  var mul = 1;
  var i = 0;
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul;
  }
  mul *= 0x80;
  if (val >= mul) val -= Math.pow(2, 8 * byteLength);
  return val;
};
Buffer$d.prototype.readIntBE = function readIntBE(offset, byteLength, noAssert) {
  offset = offset | 0;
  byteLength = byteLength | 0;
  if (!noAssert) checkOffset(offset, byteLength, this.length);
  var i = byteLength;
  var mul = 1;
  var val = this[offset + --i];
  while (i > 0 && (mul *= 0x100)) {
    val += this[offset + --i] * mul;
  }
  mul *= 0x80;
  if (val >= mul) val -= Math.pow(2, 8 * byteLength);
  return val;
};
Buffer$d.prototype.readInt8 = function readInt8(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 1, this.length);
  if (!(this[offset] & 0x80)) return this[offset];
  return (0xff - this[offset] + 1) * -1;
};
Buffer$d.prototype.readInt16LE = function readInt16LE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length);
  var val = this[offset] | this[offset + 1] << 8;
  return val & 0x8000 ? val | 0xFFFF0000 : val;
};
Buffer$d.prototype.readInt16BE = function readInt16BE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length);
  var val = this[offset + 1] | this[offset] << 8;
  return val & 0x8000 ? val | 0xFFFF0000 : val;
};
Buffer$d.prototype.readInt32LE = function readInt32LE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length);
  return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;
};
Buffer$d.prototype.readInt32BE = function readInt32BE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length);
  return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];
};
Buffer$d.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length);
  return read(this, offset, true, 23, 4);
};
Buffer$d.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length);
  return read(this, offset, false, 23, 4);
};
Buffer$d.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 8, this.length);
  return read(this, offset, true, 52, 8);
};
Buffer$d.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 8, this.length);
  return read(this, offset, false, 52, 8);
};
function checkInt(buf, value, offset, ext, max, min) {
  if (!internalIsBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance');
  if (value > max || value < min) throw new RangeError('"value" argument is out of bounds');
  if (offset + ext > buf.length) throw new RangeError('Index out of range');
}
Buffer$d.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength, noAssert) {
  value = +value;
  offset = offset | 0;
  byteLength = byteLength | 0;
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1;
    checkInt(this, value, offset, byteLength, maxBytes, 0);
  }
  var mul = 1;
  var i = 0;
  this[offset] = value & 0xFF;
  while (++i < byteLength && (mul *= 0x100)) {
    this[offset + i] = value / mul & 0xFF;
  }
  return offset + byteLength;
};
Buffer$d.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength, noAssert) {
  value = +value;
  offset = offset | 0;
  byteLength = byteLength | 0;
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1;
    checkInt(this, value, offset, byteLength, maxBytes, 0);
  }
  var i = byteLength - 1;
  var mul = 1;
  this[offset + i] = value & 0xFF;
  while (--i >= 0 && (mul *= 0x100)) {
    this[offset + i] = value / mul & 0xFF;
  }
  return offset + byteLength;
};
Buffer$d.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0);
  if (!Buffer$d.TYPED_ARRAY_SUPPORT) value = Math.floor(value);
  this[offset] = value & 0xff;
  return offset + 1;
};
function objectWriteUInt16(buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffff + value + 1;
  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {
    buf[offset + i] = (value & 0xff << 8 * (littleEndian ? i : 1 - i)) >>> (littleEndian ? i : 1 - i) * 8;
  }
}
Buffer$d.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);
  if (Buffer$d.TYPED_ARRAY_SUPPORT) {
    this[offset] = value & 0xff;
    this[offset + 1] = value >>> 8;
  } else {
    objectWriteUInt16(this, value, offset, true);
  }
  return offset + 2;
};
Buffer$d.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);
  if (Buffer$d.TYPED_ARRAY_SUPPORT) {
    this[offset] = value >>> 8;
    this[offset + 1] = value & 0xff;
  } else {
    objectWriteUInt16(this, value, offset, false);
  }
  return offset + 2;
};
function objectWriteUInt32(buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffffffff + value + 1;
  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {
    buf[offset + i] = value >>> (littleEndian ? i : 3 - i) * 8 & 0xff;
  }
}
Buffer$d.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);
  if (Buffer$d.TYPED_ARRAY_SUPPORT) {
    this[offset + 3] = value >>> 24;
    this[offset + 2] = value >>> 16;
    this[offset + 1] = value >>> 8;
    this[offset] = value & 0xff;
  } else {
    objectWriteUInt32(this, value, offset, true);
  }
  return offset + 4;
};
Buffer$d.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);
  if (Buffer$d.TYPED_ARRAY_SUPPORT) {
    this[offset] = value >>> 24;
    this[offset + 1] = value >>> 16;
    this[offset + 2] = value >>> 8;
    this[offset + 3] = value & 0xff;
  } else {
    objectWriteUInt32(this, value, offset, false);
  }
  return offset + 4;
};
Buffer$d.prototype.writeIntLE = function writeIntLE(value, offset, byteLength, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1);
    checkInt(this, value, offset, byteLength, limit - 1, -limit);
  }
  var i = 0;
  var mul = 1;
  var sub = 0;
  this[offset] = value & 0xFF;
  while (++i < byteLength && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
      sub = 1;
    }
    this[offset + i] = (value / mul >> 0) - sub & 0xFF;
  }
  return offset + byteLength;
};
Buffer$d.prototype.writeIntBE = function writeIntBE(value, offset, byteLength, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1);
    checkInt(this, value, offset, byteLength, limit - 1, -limit);
  }
  var i = byteLength - 1;
  var mul = 1;
  var sub = 0;
  this[offset + i] = value & 0xFF;
  while (--i >= 0 && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
      sub = 1;
    }
    this[offset + i] = (value / mul >> 0) - sub & 0xFF;
  }
  return offset + byteLength;
};
Buffer$d.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80);
  if (!Buffer$d.TYPED_ARRAY_SUPPORT) value = Math.floor(value);
  if (value < 0) value = 0xff + value + 1;
  this[offset] = value & 0xff;
  return offset + 1;
};
Buffer$d.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000);
  if (Buffer$d.TYPED_ARRAY_SUPPORT) {
    this[offset] = value & 0xff;
    this[offset + 1] = value >>> 8;
  } else {
    objectWriteUInt16(this, value, offset, true);
  }
  return offset + 2;
};
Buffer$d.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000);
  if (Buffer$d.TYPED_ARRAY_SUPPORT) {
    this[offset] = value >>> 8;
    this[offset + 1] = value & 0xff;
  } else {
    objectWriteUInt16(this, value, offset, false);
  }
  return offset + 2;
};
Buffer$d.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);
  if (Buffer$d.TYPED_ARRAY_SUPPORT) {
    this[offset] = value & 0xff;
    this[offset + 1] = value >>> 8;
    this[offset + 2] = value >>> 16;
    this[offset + 3] = value >>> 24;
  } else {
    objectWriteUInt32(this, value, offset, true);
  }
  return offset + 4;
};
Buffer$d.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);
  if (value < 0) value = 0xffffffff + value + 1;
  if (Buffer$d.TYPED_ARRAY_SUPPORT) {
    this[offset] = value >>> 24;
    this[offset + 1] = value >>> 16;
    this[offset + 2] = value >>> 8;
    this[offset + 3] = value & 0xff;
  } else {
    objectWriteUInt32(this, value, offset, false);
  }
  return offset + 4;
};
function checkIEEE754(buf, value, offset, ext, max, min) {
  if (offset + ext > buf.length) throw new RangeError('Index out of range');
  if (offset < 0) throw new RangeError('Index out of range');
}
function writeFloat(buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 4);
  }
  write(buf, value, offset, littleEndian, 23, 4);
  return offset + 4;
}
Buffer$d.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {
  return writeFloat(this, value, offset, true, noAssert);
};
Buffer$d.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {
  return writeFloat(this, value, offset, false, noAssert);
};
function writeDouble(buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 8);
  }
  write(buf, value, offset, littleEndian, 52, 8);
  return offset + 8;
}
Buffer$d.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {
  return writeDouble(this, value, offset, true, noAssert);
};
Buffer$d.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {
  return writeDouble(this, value, offset, false, noAssert);
};

// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer$d.prototype.copy = function copy(target, targetStart, start, end) {
  if (!start) start = 0;
  if (!end && end !== 0) end = this.length;
  if (targetStart >= target.length) targetStart = target.length;
  if (!targetStart) targetStart = 0;
  if (end > 0 && end < start) end = start;

  // Copy 0 bytes; we're done
  if (end === start) return 0;
  if (target.length === 0 || this.length === 0) return 0;

  // Fatal error conditions
  if (targetStart < 0) {
    throw new RangeError('targetStart out of bounds');
  }
  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds');
  if (end < 0) throw new RangeError('sourceEnd out of bounds');

  // Are we oob?
  if (end > this.length) end = this.length;
  if (target.length - targetStart < end - start) {
    end = target.length - targetStart + start;
  }
  var len = end - start;
  var i;
  if (this === target && start < targetStart && targetStart < end) {
    // descending copy from end
    for (i = len - 1; i >= 0; --i) {
      target[i + targetStart] = this[i + start];
    }
  } else if (len < 1000 || !Buffer$d.TYPED_ARRAY_SUPPORT) {
    // ascending copy from start
    for (i = 0; i < len; ++i) {
      target[i + targetStart] = this[i + start];
    }
  } else {
    Uint8Array.prototype.set.call(target, this.subarray(start, start + len), targetStart);
  }
  return len;
};

// Usage:
//    buffer.fill(number[, offset[, end]])
//    buffer.fill(buffer[, offset[, end]])
//    buffer.fill(string[, offset[, end]][, encoding])
Buffer$d.prototype.fill = function fill(val, start, end, encoding) {
  // Handle string cases:
  if (typeof val === 'string') {
    if (typeof start === 'string') {
      encoding = start;
      start = 0;
      end = this.length;
    } else if (typeof end === 'string') {
      encoding = end;
      end = this.length;
    }
    if (val.length === 1) {
      var code = val.charCodeAt(0);
      if (code < 256) {
        val = code;
      }
    }
    if (encoding !== undefined && typeof encoding !== 'string') {
      throw new TypeError('encoding must be a string');
    }
    if (typeof encoding === 'string' && !Buffer$d.isEncoding(encoding)) {
      throw new TypeError('Unknown encoding: ' + encoding);
    }
  } else if (typeof val === 'number') {
    val = val & 255;
  }

  // Invalid ranges are not set to a default, so can range check early.
  if (start < 0 || this.length < start || this.length < end) {
    throw new RangeError('Out of range index');
  }
  if (end <= start) {
    return this;
  }
  start = start >>> 0;
  end = end === undefined ? this.length : end >>> 0;
  if (!val) val = 0;
  var i;
  if (typeof val === 'number') {
    for (i = start; i < end; ++i) {
      this[i] = val;
    }
  } else {
    var bytes = internalIsBuffer(val) ? val : utf8ToBytes(new Buffer$d(val, encoding).toString());
    var len = bytes.length;
    for (i = 0; i < end - start; ++i) {
      this[i + start] = bytes[i % len];
    }
  }
  return this;
};

// HELPER FUNCTIONS
// ================

var INVALID_BASE64_RE = /[^+\/0-9A-Za-z-_]/g;
function base64clean(str) {
  // Node strips out invalid characters like \n and \t from the string, base64-js does not
  str = stringtrim(str).replace(INVALID_BASE64_RE, '');
  // Node converts strings with length < 2 to ''
  if (str.length < 2) return '';
  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
  while (str.length % 4 !== 0) {
    str = str + '=';
  }
  return str;
}
function stringtrim(str) {
  if (str.trim) return str.trim();
  return str.replace(/^\s+|\s+$/g, '');
}
function toHex(n) {
  if (n < 16) return '0' + n.toString(16);
  return n.toString(16);
}
function utf8ToBytes(string, units) {
  units = units || Infinity;
  var codePoint;
  var length = string.length;
  var leadSurrogate = null;
  var bytes = [];
  for (var i = 0; i < length; ++i) {
    codePoint = string.charCodeAt(i);

    // is surrogate component
    if (codePoint > 0xD7FF && codePoint < 0xE000) {
      // last char was a lead
      if (!leadSurrogate) {
        // no lead yet
        if (codePoint > 0xDBFF) {
          // unexpected trail
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
          continue;
        } else if (i + 1 === length) {
          // unpaired lead
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
          continue;
        }

        // valid lead
        leadSurrogate = codePoint;
        continue;
      }

      // 2 leads in a row
      if (codePoint < 0xDC00) {
        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
        leadSurrogate = codePoint;
        continue;
      }

      // valid surrogate pair
      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000;
    } else if (leadSurrogate) {
      // valid bmp char, but last char was a lead
      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
    }
    leadSurrogate = null;

    // encode utf8
    if (codePoint < 0x80) {
      if ((units -= 1) < 0) break;
      bytes.push(codePoint);
    } else if (codePoint < 0x800) {
      if ((units -= 2) < 0) break;
      bytes.push(codePoint >> 0x6 | 0xC0, codePoint & 0x3F | 0x80);
    } else if (codePoint < 0x10000) {
      if ((units -= 3) < 0) break;
      bytes.push(codePoint >> 0xC | 0xE0, codePoint >> 0x6 & 0x3F | 0x80, codePoint & 0x3F | 0x80);
    } else if (codePoint < 0x110000) {
      if ((units -= 4) < 0) break;
      bytes.push(codePoint >> 0x12 | 0xF0, codePoint >> 0xC & 0x3F | 0x80, codePoint >> 0x6 & 0x3F | 0x80, codePoint & 0x3F | 0x80);
    } else {
      throw new Error('Invalid code point');
    }
  }
  return bytes;
}
function asciiToBytes(str) {
  var byteArray = [];
  for (var i = 0; i < str.length; ++i) {
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF);
  }
  return byteArray;
}
function utf16leToBytes(str, units) {
  var c, hi, lo;
  var byteArray = [];
  for (var i = 0; i < str.length; ++i) {
    if ((units -= 2) < 0) break;
    c = str.charCodeAt(i);
    hi = c >> 8;
    lo = c % 256;
    byteArray.push(lo);
    byteArray.push(hi);
  }
  return byteArray;
}
function base64ToBytes(str) {
  return toByteArray$1(base64clean(str));
}
function blitBuffer(src, dst, offset, length) {
  for (var i = 0; i < length; ++i) {
    if (i + offset >= dst.length || i >= src.length) break;
    dst[i + offset] = src[i];
  }
  return i;
}
function isnan(val) {
  return val !== val; // eslint-disable-line no-self-compare
}

// the following is from is-buffer, also by Feross Aboukhadijeh and with same lisence
// The _isBuffer check is for Safari 5-7 support, because it's missing
// Object.prototype.constructor. Remove this eventually
function isBuffer$1(obj) {
  return obj != null && (!!obj._isBuffer || isFastBuffer(obj) || isSlowBuffer(obj));
}
function isFastBuffer(obj) {
  return !!obj.constructor && typeof obj.constructor.isBuffer === 'function' && obj.constructor.isBuffer(obj);
}

// For Node v0.10 support. Remove this eventually.
function isSlowBuffer(obj) {
  return typeof obj.readFloatLE === 'function' && typeof obj.slice === 'function' && isFastBuffer(obj.slice(0, 0));
}

var bufferEs6 = /*#__PURE__*/Object.freeze({
  __proto__: null,
  Buffer: Buffer$d,
  INSPECT_MAX_BYTES: INSPECT_MAX_BYTES,
  SlowBuffer: SlowBuffer,
  isBuffer: isBuffer$1,
  kMaxLength: _kMaxLength
});

var require$$0$1 = /*@__PURE__*/getAugmentedNamespace(bufferEs6);

/*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
safeBuffer.exports;
(function (module, exports) {
  /* eslint-disable node/no-deprecated-api */
  var buffer = require$$0$1;
  var Buffer = buffer.Buffer;

  // alternative to using Object.keys for old browsers
  function copyProps(src, dst) {
    for (var key in src) {
      dst[key] = src[key];
    }
  }
  if (Buffer.from && Buffer.alloc && Buffer.allocUnsafe && Buffer.allocUnsafeSlow) {
    module.exports = buffer;
  } else {
    // Copy properties from require('buffer')
    copyProps(buffer, exports);
    exports.Buffer = SafeBuffer;
  }
  function SafeBuffer(arg, encodingOrOffset, length) {
    return Buffer(arg, encodingOrOffset, length);
  }
  SafeBuffer.prototype = Object.create(Buffer.prototype);

  // Copy static methods from Buffer
  copyProps(Buffer, SafeBuffer);
  SafeBuffer.from = function (arg, encodingOrOffset, length) {
    if (typeof arg === 'number') {
      throw new TypeError('Argument must not be a number');
    }
    return Buffer(arg, encodingOrOffset, length);
  };
  SafeBuffer.alloc = function (size, fill, encoding) {
    if (typeof size !== 'number') {
      throw new TypeError('Argument must be a number');
    }
    var buf = Buffer(size);
    if (fill !== undefined) {
      if (typeof encoding === 'string') {
        buf.fill(fill, encoding);
      } else {
        buf.fill(fill);
      }
    } else {
      buf.fill(0);
    }
    return buf;
  };
  SafeBuffer.allocUnsafe = function (size) {
    if (typeof size !== 'number') {
      throw new TypeError('Argument must be a number');
    }
    return Buffer(size);
  };
  SafeBuffer.allocUnsafeSlow = function (size) {
    if (typeof size !== 'number') {
      throw new TypeError('Argument must be a number');
    }
    return buffer.SlowBuffer(size);
  };
})(safeBuffer, safeBuffer.exports);
var safeBufferExports = safeBuffer.exports;

var readableBrowser = {exports: {}};

// shim for using process in browser
// based off https://github.com/defunctzombie/node-process/blob/master/browser.js

function defaultSetTimout() {
  throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout() {
  throw new Error('clearTimeout has not been defined');
}
var cachedSetTimeout = defaultSetTimout;
var cachedClearTimeout = defaultClearTimeout;
if (typeof global$1.setTimeout === 'function') {
  cachedSetTimeout = setTimeout;
}
if (typeof global$1.clearTimeout === 'function') {
  cachedClearTimeout = clearTimeout;
}
function runTimeout(fun) {
  if (cachedSetTimeout === setTimeout) {
    //normal enviroments in sane situations
    return setTimeout(fun, 0);
  }
  // if setTimeout wasn't available but was latter defined
  if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
    cachedSetTimeout = setTimeout;
    return setTimeout(fun, 0);
  }
  try {
    // when when somebody has screwed with setTimeout but no I.E. maddness
    return cachedSetTimeout(fun, 0);
  } catch (e) {
    try {
      // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
      return cachedSetTimeout.call(null, fun, 0);
    } catch (e) {
      // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
      return cachedSetTimeout.call(this, fun, 0);
    }
  }
}
function runClearTimeout(marker) {
  if (cachedClearTimeout === clearTimeout) {
    //normal enviroments in sane situations
    return clearTimeout(marker);
  }
  // if clearTimeout wasn't available but was latter defined
  if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
    cachedClearTimeout = clearTimeout;
    return clearTimeout(marker);
  }
  try {
    // when when somebody has screwed with setTimeout but no I.E. maddness
    return cachedClearTimeout(marker);
  } catch (e) {
    try {
      // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
      return cachedClearTimeout.call(null, marker);
    } catch (e) {
      // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
      // Some versions of I.E. have different rules for clearTimeout vs setTimeout
      return cachedClearTimeout.call(this, marker);
    }
  }
}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;
function cleanUpNextTick() {
  if (!draining || !currentQueue) {
    return;
  }
  draining = false;
  if (currentQueue.length) {
    queue = currentQueue.concat(queue);
  } else {
    queueIndex = -1;
  }
  if (queue.length) {
    drainQueue();
  }
}
function drainQueue() {
  if (draining) {
    return;
  }
  var timeout = runTimeout(cleanUpNextTick);
  draining = true;
  var len = queue.length;
  while (len) {
    currentQueue = queue;
    queue = [];
    while (++queueIndex < len) {
      if (currentQueue) {
        currentQueue[queueIndex].run();
      }
    }
    queueIndex = -1;
    len = queue.length;
  }
  currentQueue = null;
  draining = false;
  runClearTimeout(timeout);
}
function nextTick(fun) {
  var args = new Array(arguments.length - 1);
  if (arguments.length > 1) {
    for (var i = 1; i < arguments.length; i++) {
      args[i - 1] = arguments[i];
    }
  }
  queue.push(new Item(fun, args));
  if (queue.length === 1 && !draining) {
    runTimeout(drainQueue);
  }
}
// v8 likes predictible objects
function Item(fun, array) {
  this.fun = fun;
  this.array = array;
}
Item.prototype.run = function () {
  this.fun.apply(null, this.array);
};
var title = 'browser';
var platform = 'browser';
var browser$2 = true;
var env = {};
var argv = [];
var version = ''; // empty string to avoid regexp issues
var versions = {};
var release = {};
var config$1 = {};
function noop$2() {}
var on = noop$2;
var addListener = noop$2;
var once$2 = noop$2;
var off = noop$2;
var removeListener = noop$2;
var removeAllListeners = noop$2;
var emit = noop$2;
function binding(name) {
  throw new Error('process.binding is not supported');
}
function cwd() {
  return '/';
}
function chdir(dir) {
  throw new Error('process.chdir is not supported');
}
function umask() {
  return 0;
}

// from https://github.com/kumavis/browser-process-hrtime/blob/master/index.js
var performance = global$1.performance || {};
var performanceNow = performance.now || performance.mozNow || performance.msNow || performance.oNow || performance.webkitNow || function () {
  return new Date().getTime();
};

// generate timestamp or delta
// see http://nodejs.org/api/process.html#process_process_hrtime
function hrtime(previousTimestamp) {
  var clocktime = performanceNow.call(performance) * 1e-3;
  var seconds = Math.floor(clocktime);
  var nanoseconds = Math.floor(clocktime % 1 * 1e9);
  if (previousTimestamp) {
    seconds = seconds - previousTimestamp[0];
    nanoseconds = nanoseconds - previousTimestamp[1];
    if (nanoseconds < 0) {
      seconds--;
      nanoseconds += 1e9;
    }
  }
  return [seconds, nanoseconds];
}
var startTime = new Date();
function uptime() {
  var currentTime = new Date();
  var dif = currentTime - startTime;
  return dif / 1000;
}
var browser$1$1 = {
  nextTick: nextTick,
  title: title,
  browser: browser$2,
  env: env,
  argv: argv,
  version: version,
  versions: versions,
  on: on,
  addListener: addListener,
  once: once$2,
  off: off,
  removeListener: removeListener,
  removeAllListeners: removeAllListeners,
  emit: emit,
  binding: binding,
  cwd: cwd,
  chdir: chdir,
  umask: umask,
  hrtime: hrtime,
  platform: platform,
  release: release,
  config: config$1,
  uptime: uptime
};
var process = browser$1$1;

var domain;

// This constructor is used to store event handlers. Instantiating this is
// faster than explicitly calling `Object.create(null)` to get a "clean" empty
// object (tested with v8 v4.9).
function EventHandlers() {}
EventHandlers.prototype = Object.create(null);
function EventEmitter() {
  EventEmitter.init.call(this);
}

// nodejs oddity
// require('events') === require('events').EventEmitter
EventEmitter.EventEmitter = EventEmitter;
EventEmitter.usingDomains = false;
EventEmitter.prototype.domain = undefined;
EventEmitter.prototype._events = undefined;
EventEmitter.prototype._maxListeners = undefined;

// By default EventEmitters will print a warning if more than 10 listeners are
// added to it. This is a useful default which helps finding memory leaks.
EventEmitter.defaultMaxListeners = 10;
EventEmitter.init = function () {
  this.domain = null;
  if (EventEmitter.usingDomains) {
    // if there is an active domain, then attach to it.
    if (domain.active ) ;
  }
  if (!this._events || this._events === Object.getPrototypeOf(this)._events) {
    this._events = new EventHandlers();
    this._eventsCount = 0;
  }
  this._maxListeners = this._maxListeners || undefined;
};

// Obviously not all Emitters should be limited to 10. This function allows
// that to be increased. Set to zero for unlimited.
EventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {
  if (typeof n !== 'number' || n < 0 || isNaN(n)) throw new TypeError('"n" argument must be a positive number');
  this._maxListeners = n;
  return this;
};
function $getMaxListeners(that) {
  if (that._maxListeners === undefined) return EventEmitter.defaultMaxListeners;
  return that._maxListeners;
}
EventEmitter.prototype.getMaxListeners = function getMaxListeners() {
  return $getMaxListeners(this);
};

// These standalone emit* functions are used to optimize calling of event
// handlers for fast cases because emit() itself often has a variable number of
// arguments and can be deoptimized because of that. These functions always have
// the same number of arguments and thus do not get deoptimized, so the code
// inside them can execute faster.
function emitNone(handler, isFn, self) {
  if (isFn) handler.call(self);else {
    var len = handler.length;
    var listeners = arrayClone(handler, len);
    for (var i = 0; i < len; ++i) listeners[i].call(self);
  }
}
function emitOne(handler, isFn, self, arg1) {
  if (isFn) handler.call(self, arg1);else {
    var len = handler.length;
    var listeners = arrayClone(handler, len);
    for (var i = 0; i < len; ++i) listeners[i].call(self, arg1);
  }
}
function emitTwo(handler, isFn, self, arg1, arg2) {
  if (isFn) handler.call(self, arg1, arg2);else {
    var len = handler.length;
    var listeners = arrayClone(handler, len);
    for (var i = 0; i < len; ++i) listeners[i].call(self, arg1, arg2);
  }
}
function emitThree(handler, isFn, self, arg1, arg2, arg3) {
  if (isFn) handler.call(self, arg1, arg2, arg3);else {
    var len = handler.length;
    var listeners = arrayClone(handler, len);
    for (var i = 0; i < len; ++i) listeners[i].call(self, arg1, arg2, arg3);
  }
}
function emitMany(handler, isFn, self, args) {
  if (isFn) handler.apply(self, args);else {
    var len = handler.length;
    var listeners = arrayClone(handler, len);
    for (var i = 0; i < len; ++i) listeners[i].apply(self, args);
  }
}
EventEmitter.prototype.emit = function emit(type) {
  var er, handler, len, args, i, events, domain;
  var doError = type === 'error';
  events = this._events;
  if (events) doError = doError && events.error == null;else if (!doError) return false;
  domain = this.domain;

  // If there is no 'error' event listener then throw.
  if (doError) {
    er = arguments[1];
    if (domain) {
      if (!er) er = new Error('Uncaught, unspecified "error" event');
      er.domainEmitter = this;
      er.domain = domain;
      er.domainThrown = false;
      domain.emit('error', er);
    } else if (er instanceof Error) {
      throw er; // Unhandled 'error' event
    } else {
      // At least give some kind of context to the user
      var err = new Error('Uncaught, unspecified "error" event. (' + er + ')');
      err.context = er;
      throw err;
    }
    return false;
  }
  handler = events[type];
  if (!handler) return false;
  var isFn = typeof handler === 'function';
  len = arguments.length;
  switch (len) {
    // fast cases
    case 1:
      emitNone(handler, isFn, this);
      break;
    case 2:
      emitOne(handler, isFn, this, arguments[1]);
      break;
    case 3:
      emitTwo(handler, isFn, this, arguments[1], arguments[2]);
      break;
    case 4:
      emitThree(handler, isFn, this, arguments[1], arguments[2], arguments[3]);
      break;
    // slower
    default:
      args = new Array(len - 1);
      for (i = 1; i < len; i++) args[i - 1] = arguments[i];
      emitMany(handler, isFn, this, args);
  }
  return true;
};
function _addListener(target, type, listener, prepend) {
  var m;
  var events;
  var existing;
  if (typeof listener !== 'function') throw new TypeError('"listener" argument must be a function');
  events = target._events;
  if (!events) {
    events = target._events = new EventHandlers();
    target._eventsCount = 0;
  } else {
    // To avoid recursion in the case that type === "newListener"! Before
    // adding it to the listeners, first emit "newListener".
    if (events.newListener) {
      target.emit('newListener', type, listener.listener ? listener.listener : listener);

      // Re-assign `events` because a newListener handler could have caused the
      // this._events to be assigned to a new object
      events = target._events;
    }
    existing = events[type];
  }
  if (!existing) {
    // Optimize the case of one listener. Don't need the extra array object.
    existing = events[type] = listener;
    ++target._eventsCount;
  } else {
    if (typeof existing === 'function') {
      // Adding the second element, need to change to array.
      existing = events[type] = prepend ? [listener, existing] : [existing, listener];
    } else {
      // If we've already got an array, just append.
      if (prepend) {
        existing.unshift(listener);
      } else {
        existing.push(listener);
      }
    }

    // Check for listener leak
    if (!existing.warned) {
      m = $getMaxListeners(target);
      if (m && m > 0 && existing.length > m) {
        existing.warned = true;
        var w = new Error('Possible EventEmitter memory leak detected. ' + existing.length + ' ' + type + ' listeners added. ' + 'Use emitter.setMaxListeners() to increase limit');
        w.name = 'MaxListenersExceededWarning';
        w.emitter = target;
        w.type = type;
        w.count = existing.length;
        emitWarning(w);
      }
    }
  }
  return target;
}
function emitWarning(e) {
  typeof console.warn === 'function' ? console.warn(e) : console.log(e);
}
EventEmitter.prototype.addListener = function addListener(type, listener) {
  return _addListener(this, type, listener, false);
};
EventEmitter.prototype.on = EventEmitter.prototype.addListener;
EventEmitter.prototype.prependListener = function prependListener(type, listener) {
  return _addListener(this, type, listener, true);
};
function _onceWrap(target, type, listener) {
  var fired = false;
  function g() {
    target.removeListener(type, g);
    if (!fired) {
      fired = true;
      listener.apply(target, arguments);
    }
  }
  g.listener = listener;
  return g;
}
EventEmitter.prototype.once = function once(type, listener) {
  if (typeof listener !== 'function') throw new TypeError('"listener" argument must be a function');
  this.on(type, _onceWrap(this, type, listener));
  return this;
};
EventEmitter.prototype.prependOnceListener = function prependOnceListener(type, listener) {
  if (typeof listener !== 'function') throw new TypeError('"listener" argument must be a function');
  this.prependListener(type, _onceWrap(this, type, listener));
  return this;
};

// emits a 'removeListener' event iff the listener was removed
EventEmitter.prototype.removeListener = function removeListener(type, listener) {
  var list, events, position, i, originalListener;
  if (typeof listener !== 'function') throw new TypeError('"listener" argument must be a function');
  events = this._events;
  if (!events) return this;
  list = events[type];
  if (!list) return this;
  if (list === listener || list.listener && list.listener === listener) {
    if (--this._eventsCount === 0) this._events = new EventHandlers();else {
      delete events[type];
      if (events.removeListener) this.emit('removeListener', type, list.listener || listener);
    }
  } else if (typeof list !== 'function') {
    position = -1;
    for (i = list.length; i-- > 0;) {
      if (list[i] === listener || list[i].listener && list[i].listener === listener) {
        originalListener = list[i].listener;
        position = i;
        break;
      }
    }
    if (position < 0) return this;
    if (list.length === 1) {
      list[0] = undefined;
      if (--this._eventsCount === 0) {
        this._events = new EventHandlers();
        return this;
      } else {
        delete events[type];
      }
    } else {
      spliceOne(list, position);
    }
    if (events.removeListener) this.emit('removeListener', type, originalListener || listener);
  }
  return this;
};
EventEmitter.prototype.removeAllListeners = function removeAllListeners(type) {
  var listeners, events;
  events = this._events;
  if (!events) return this;

  // not listening for removeListener, no need to emit
  if (!events.removeListener) {
    if (arguments.length === 0) {
      this._events = new EventHandlers();
      this._eventsCount = 0;
    } else if (events[type]) {
      if (--this._eventsCount === 0) this._events = new EventHandlers();else delete events[type];
    }
    return this;
  }

  // emit removeListener for all listeners on all events
  if (arguments.length === 0) {
    var keys = Object.keys(events);
    for (var i = 0, key; i < keys.length; ++i) {
      key = keys[i];
      if (key === 'removeListener') continue;
      this.removeAllListeners(key);
    }
    this.removeAllListeners('removeListener');
    this._events = new EventHandlers();
    this._eventsCount = 0;
    return this;
  }
  listeners = events[type];
  if (typeof listeners === 'function') {
    this.removeListener(type, listeners);
  } else if (listeners) {
    // LIFO order
    do {
      this.removeListener(type, listeners[listeners.length - 1]);
    } while (listeners[0]);
  }
  return this;
};
EventEmitter.prototype.listeners = function listeners(type) {
  var evlistener;
  var ret;
  var events = this._events;
  if (!events) ret = [];else {
    evlistener = events[type];
    if (!evlistener) ret = [];else if (typeof evlistener === 'function') ret = [evlistener.listener || evlistener];else ret = unwrapListeners(evlistener);
  }
  return ret;
};
EventEmitter.listenerCount = function (emitter, type) {
  if (typeof emitter.listenerCount === 'function') {
    return emitter.listenerCount(type);
  } else {
    return listenerCount$1.call(emitter, type);
  }
};
EventEmitter.prototype.listenerCount = listenerCount$1;
function listenerCount$1(type) {
  var events = this._events;
  if (events) {
    var evlistener = events[type];
    if (typeof evlistener === 'function') {
      return 1;
    } else if (evlistener) {
      return evlistener.length;
    }
  }
  return 0;
}
EventEmitter.prototype.eventNames = function eventNames() {
  return this._eventsCount > 0 ? Reflect.ownKeys(this._events) : [];
};

// About 1.5x faster than the two-arg version of Array#splice().
function spliceOne(list, index) {
  for (var i = index, k = i + 1, n = list.length; k < n; i += 1, k += 1) list[i] = list[k];
  list.pop();
}
function arrayClone(arr, i) {
  var copy = new Array(i);
  while (i--) copy[i] = arr[i];
  return copy;
}
function unwrapListeners(arr) {
  var ret = new Array(arr.length);
  for (var i = 0; i < ret.length; ++i) {
    ret[i] = arr[i].listener || arr[i];
  }
  return ret;
}

var events = /*#__PURE__*/Object.freeze({
  __proto__: null,
  'default': EventEmitter,
  EventEmitter: EventEmitter
});

var require$$0 = /*@__PURE__*/getAugmentedNamespace(events);

var streamBrowser = require$$0.EventEmitter;

var inherits$b;
if (typeof Object.create === 'function') {
  inherits$b = function inherits(ctor, superCtor) {
    // implementation from standard node.js 'util' module
    ctor.super_ = superCtor;
    ctor.prototype = Object.create(superCtor.prototype, {
      constructor: {
        value: ctor,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
  };
} else {
  inherits$b = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor;
    var TempCtor = function TempCtor() {};
    TempCtor.prototype = superCtor.prototype;
    ctor.prototype = new TempCtor();
    ctor.prototype.constructor = ctor;
  };
}
var inherits$c = inherits$b;

var formatRegExp = /%[sdj%]/g;
function format(f) {
  if (!isString(f)) {
    var objects = [];
    for (var i = 0; i < arguments.length; i++) {
      objects.push(inspect(arguments[i]));
    }
    return objects.join(' ');
  }
  var i = 1;
  var args = arguments;
  var len = args.length;
  var str = String(f).replace(formatRegExp, function (x) {
    if (x === '%%') return '%';
    if (i >= len) return x;
    switch (x) {
      case '%s':
        return String(args[i++]);
      case '%d':
        return Number(args[i++]);
      case '%j':
        try {
          return JSON.stringify(args[i++]);
        } catch (_) {
          return '[Circular]';
        }
      default:
        return x;
    }
  });
  for (var x = args[i]; i < len; x = args[++i]) {
    if (isNull(x) || !isObject(x)) {
      str += ' ' + x;
    } else {
      str += ' ' + inspect(x);
    }
  }
  return str;
}

// Mark that a method should not be used.
// Returns a modified function which warns once by default.
// If --no-deprecation is set, then it is a no-op.
function deprecate$1(fn, msg) {
  // Allow for deprecating things in the process of starting up.
  if (isUndefined(global$1.process)) {
    return function () {
      return deprecate$1(fn, msg).apply(this, arguments);
    };
  }
  if (process.noDeprecation === true) {
    return fn;
  }
  var warned = false;
  function deprecated() {
    if (!warned) {
      if (process.throwDeprecation) {
        throw new Error(msg);
      } else if (process.traceDeprecation) {
        console.trace(msg);
      } else {
        console.error(msg);
      }
      warned = true;
    }
    return fn.apply(this, arguments);
  }
  return deprecated;
}
var debugs = {};
var debugEnviron;
function debuglog(set) {
  if (isUndefined(debugEnviron)) debugEnviron = process.env.NODE_DEBUG || '';
  set = set.toUpperCase();
  if (!debugs[set]) {
    if (new RegExp('\\b' + set + '\\b', 'i').test(debugEnviron)) {
      var pid = 0;
      debugs[set] = function () {
        var msg = format.apply(null, arguments);
        console.error('%s %d: %s', set, pid, msg);
      };
    } else {
      debugs[set] = function () {};
    }
  }
  return debugs[set];
}

/**
 * Echos the value of a value. Trys to print the value out
 * in the best way possible given the different types.
 *
 * @param {Object} obj The object to print out.
 * @param {Object} opts Optional options object that alters the output.
 */
/* legacy: obj, showHidden, depth, colors*/
function inspect(obj, opts) {
  // default options
  var ctx = {
    seen: [],
    stylize: stylizeNoColor
  };
  // legacy...
  if (arguments.length >= 3) ctx.depth = arguments[2];
  if (arguments.length >= 4) ctx.colors = arguments[3];
  if (isBoolean(opts)) {
    // legacy...
    ctx.showHidden = opts;
  } else if (opts) {
    // got an "options" object
    _extend(ctx, opts);
  }
  // set default options
  if (isUndefined(ctx.showHidden)) ctx.showHidden = false;
  if (isUndefined(ctx.depth)) ctx.depth = 2;
  if (isUndefined(ctx.colors)) ctx.colors = false;
  if (isUndefined(ctx.customInspect)) ctx.customInspect = true;
  if (ctx.colors) ctx.stylize = stylizeWithColor;
  return formatValue(ctx, obj, ctx.depth);
}

// http://en.wikipedia.org/wiki/ANSI_escape_code#graphics
inspect.colors = {
  'bold': [1, 22],
  'italic': [3, 23],
  'underline': [4, 24],
  'inverse': [7, 27],
  'white': [37, 39],
  'grey': [90, 39],
  'black': [30, 39],
  'blue': [34, 39],
  'cyan': [36, 39],
  'green': [32, 39],
  'magenta': [35, 39],
  'red': [31, 39],
  'yellow': [33, 39]
};

// Don't use 'blue' not visible on cmd.exe
inspect.styles = {
  'special': 'cyan',
  'number': 'yellow',
  'boolean': 'yellow',
  'undefined': 'grey',
  'null': 'bold',
  'string': 'green',
  'date': 'magenta',
  // "name": intentionally not styling
  'regexp': 'red'
};
function stylizeWithColor(str, styleType) {
  var style = inspect.styles[styleType];
  if (style) {
    return "\x1B[" + inspect.colors[style][0] + 'm' + str + "\x1B[" + inspect.colors[style][1] + 'm';
  } else {
    return str;
  }
}
function stylizeNoColor(str, styleType) {
  return str;
}
function arrayToHash(array) {
  var hash = {};
  array.forEach(function (val, idx) {
    hash[val] = true;
  });
  return hash;
}
function formatValue(ctx, value, recurseTimes) {
  // Provide a hook for user-specified inspect functions.
  // Check that value is an object with an inspect function on it
  if (ctx.customInspect && value && isFunction(value.inspect) &&
  // Filter out the util module, it's inspect function is special
  value.inspect !== inspect &&
  // Also filter out any prototype objects using the circular check.
  !(value.constructor && value.constructor.prototype === value)) {
    var ret = value.inspect(recurseTimes, ctx);
    if (!isString(ret)) {
      ret = formatValue(ctx, ret, recurseTimes);
    }
    return ret;
  }

  // Primitive types cannot have properties
  var primitive = formatPrimitive(ctx, value);
  if (primitive) {
    return primitive;
  }

  // Look up the keys of the object.
  var keys = Object.keys(value);
  var visibleKeys = arrayToHash(keys);
  if (ctx.showHidden) {
    keys = Object.getOwnPropertyNames(value);
  }

  // IE doesn't make error fields non-enumerable
  // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx
  if (isError(value) && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {
    return formatError(value);
  }

  // Some type of object without properties can be shortcutted.
  if (keys.length === 0) {
    if (isFunction(value)) {
      var name = value.name ? ': ' + value.name : '';
      return ctx.stylize('[Function' + name + ']', 'special');
    }
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    }
    if (isDate(value)) {
      return ctx.stylize(Date.prototype.toString.call(value), 'date');
    }
    if (isError(value)) {
      return formatError(value);
    }
  }
  var base = '',
    array = false,
    braces = ['{', '}'];

  // Make Array say that they are Array
  if (isArray(value)) {
    array = true;
    braces = ['[', ']'];
  }

  // Make functions say that they are functions
  if (isFunction(value)) {
    var n = value.name ? ': ' + value.name : '';
    base = ' [Function' + n + ']';
  }

  // Make RegExps say that they are RegExps
  if (isRegExp(value)) {
    base = ' ' + RegExp.prototype.toString.call(value);
  }

  // Make dates with properties first say the date
  if (isDate(value)) {
    base = ' ' + Date.prototype.toUTCString.call(value);
  }

  // Make error with message first say the error
  if (isError(value)) {
    base = ' ' + formatError(value);
  }
  if (keys.length === 0 && (!array || value.length == 0)) {
    return braces[0] + base + braces[1];
  }
  if (recurseTimes < 0) {
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    } else {
      return ctx.stylize('[Object]', 'special');
    }
  }
  ctx.seen.push(value);
  var output;
  if (array) {
    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
  } else {
    output = keys.map(function (key) {
      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
    });
  }
  ctx.seen.pop();
  return reduceToSingleString(output, base, braces);
}
function formatPrimitive(ctx, value) {
  if (isUndefined(value)) return ctx.stylize('undefined', 'undefined');
  if (isString(value)) {
    var simple = '\'' + JSON.stringify(value).replace(/^"|"$/g, '').replace(/'/g, "\\'").replace(/\\"/g, '"') + '\'';
    return ctx.stylize(simple, 'string');
  }
  if (isNumber(value)) return ctx.stylize('' + value, 'number');
  if (isBoolean(value)) return ctx.stylize('' + value, 'boolean');
  // For some reason typeof null is "object", so special case here.
  if (isNull(value)) return ctx.stylize('null', 'null');
}
function formatError(value) {
  return '[' + Error.prototype.toString.call(value) + ']';
}
function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
  var output = [];
  for (var i = 0, l = value.length; i < l; ++i) {
    if (hasOwnProperty(value, String(i))) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys, String(i), true));
    } else {
      output.push('');
    }
  }
  keys.forEach(function (key) {
    if (!key.match(/^\d+$/)) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys, key, true));
    }
  });
  return output;
}
function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
  var name, str, desc;
  desc = Object.getOwnPropertyDescriptor(value, key) || {
    value: value[key]
  };
  if (desc.get) {
    if (desc.set) {
      str = ctx.stylize('[Getter/Setter]', 'special');
    } else {
      str = ctx.stylize('[Getter]', 'special');
    }
  } else {
    if (desc.set) {
      str = ctx.stylize('[Setter]', 'special');
    }
  }
  if (!hasOwnProperty(visibleKeys, key)) {
    name = '[' + key + ']';
  }
  if (!str) {
    if (ctx.seen.indexOf(desc.value) < 0) {
      if (isNull(recurseTimes)) {
        str = formatValue(ctx, desc.value, null);
      } else {
        str = formatValue(ctx, desc.value, recurseTimes - 1);
      }
      if (str.indexOf('\n') > -1) {
        if (array) {
          str = str.split('\n').map(function (line) {
            return '  ' + line;
          }).join('\n').substr(2);
        } else {
          str = '\n' + str.split('\n').map(function (line) {
            return '   ' + line;
          }).join('\n');
        }
      }
    } else {
      str = ctx.stylize('[Circular]', 'special');
    }
  }
  if (isUndefined(name)) {
    if (array && key.match(/^\d+$/)) {
      return str;
    }
    name = JSON.stringify('' + key);
    if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
      name = name.substr(1, name.length - 2);
      name = ctx.stylize(name, 'name');
    } else {
      name = name.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'");
      name = ctx.stylize(name, 'string');
    }
  }
  return name + ': ' + str;
}
function reduceToSingleString(output, base, braces) {
  var length = output.reduce(function (prev, cur) {
    if (cur.indexOf('\n') >= 0) ;
    return prev + cur.replace(/\u001b\[\d\d?m/g, '').length + 1;
  }, 0);
  if (length > 60) {
    return braces[0] + (base === '' ? '' : base + '\n ') + ' ' + output.join(',\n  ') + ' ' + braces[1];
  }
  return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];
}

// NOTE: These type checking functions intentionally don't use `instanceof`
// because it is fragile and can be easily faked with `Object.create()`.
function isArray(ar) {
  return Array.isArray(ar);
}
function isBoolean(arg) {
  return typeof arg === 'boolean';
}
function isNull(arg) {
  return arg === null;
}
function isNullOrUndefined(arg) {
  return arg == null;
}
function isNumber(arg) {
  return typeof arg === 'number';
}
function isString(arg) {
  return typeof arg === 'string';
}
function isSymbol(arg) {
  return _typeof(arg) === 'symbol';
}
function isUndefined(arg) {
  return arg === void 0;
}
function isRegExp(re) {
  return isObject(re) && objectToString(re) === '[object RegExp]';
}
function isObject(arg) {
  return _typeof(arg) === 'object' && arg !== null;
}
function isDate(d) {
  return isObject(d) && objectToString(d) === '[object Date]';
}
function isError(e) {
  return isObject(e) && (objectToString(e) === '[object Error]' || e instanceof Error);
}
function isFunction(arg) {
  return typeof arg === 'function';
}
function isPrimitive(arg) {
  return arg === null || typeof arg === 'boolean' || typeof arg === 'number' || typeof arg === 'string' || _typeof(arg) === 'symbol' ||
  // ES6 symbol
  typeof arg === 'undefined';
}
function isBuffer(maybeBuf) {
  return Buffer$d.isBuffer(maybeBuf);
}
function objectToString(o) {
  return Object.prototype.toString.call(o);
}
function pad(n) {
  return n < 10 ? '0' + n.toString(10) : n.toString(10);
}
var months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];

// 26 Feb 16:19:34
function timestamp() {
  var d = new Date();
  var time = [pad(d.getHours()), pad(d.getMinutes()), pad(d.getSeconds())].join(':');
  return [d.getDate(), months[d.getMonth()], time].join(' ');
}

// log is just a thin wrapper to console.log that prepends a timestamp
function log() {
  console.log('%s - %s', timestamp(), format.apply(null, arguments));
}
function _extend(origin, add) {
  // Don't do anything if add isn't an object
  if (!add || !isObject(add)) return origin;
  var keys = Object.keys(add);
  var i = keys.length;
  while (i--) {
    origin[keys[i]] = add[keys[i]];
  }
  return origin;
}
function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}
var util = {
  inherits: inherits$c,
  _extend: _extend,
  log: log,
  isBuffer: isBuffer,
  isPrimitive: isPrimitive,
  isFunction: isFunction,
  isError: isError,
  isDate: isDate,
  isObject: isObject,
  isRegExp: isRegExp,
  isUndefined: isUndefined,
  isSymbol: isSymbol,
  isString: isString,
  isNumber: isNumber,
  isNullOrUndefined: isNullOrUndefined,
  isNull: isNull,
  isBoolean: isBoolean,
  isArray: isArray,
  inspect: inspect,
  deprecate: deprecate$1,
  format: format,
  debuglog: debuglog
};

var util$1 = /*#__PURE__*/Object.freeze({
  __proto__: null,
  format: format,
  deprecate: deprecate$1,
  debuglog: debuglog,
  inspect: inspect,
  isArray: isArray,
  isBoolean: isBoolean,
  isNull: isNull,
  isNullOrUndefined: isNullOrUndefined,
  isNumber: isNumber,
  isString: isString,
  isSymbol: isSymbol,
  isUndefined: isUndefined,
  isRegExp: isRegExp,
  isObject: isObject,
  isDate: isDate,
  isError: isError,
  isFunction: isFunction,
  isPrimitive: isPrimitive,
  isBuffer: isBuffer,
  log: log,
  inherits: inherits$c,
  _extend: _extend,
  'default': util
});

var require$$3 = /*@__PURE__*/getAugmentedNamespace(util$1);

var buffer_list;
var hasRequiredBuffer_list;
function requireBuffer_list() {
  if (hasRequiredBuffer_list) return buffer_list;
  hasRequiredBuffer_list = 1;
  function ownKeys(object, enumerableOnly) {
    var keys = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      enumerableOnly && (symbols = symbols.filter(function (sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      })), keys.push.apply(keys, symbols);
    }
    return keys;
  }
  function _objectSpread(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = null != arguments[i] ? arguments[i] : {};
      i % 2 ? ownKeys(Object(source), !0).forEach(function (key) {
        _defineProperty(target, key, source[key]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
    return target;
  }
  function _defineProperty(obj, key, value) {
    key = _toPropertyKey(key);
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }
    return obj;
  }
  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }
  function _defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);
    }
  }
  function _createClass(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties(Constructor, staticProps);
    Object.defineProperty(Constructor, "prototype", {
      writable: false
    });
    return Constructor;
  }
  function _toPropertyKey(arg) {
    var key = _toPrimitive(arg, "string");
    return _typeof(key) === "symbol" ? key : String(key);
  }
  function _toPrimitive(input, hint) {
    if (_typeof(input) !== "object" || input === null) return input;
    var prim = input[Symbol.toPrimitive];
    if (prim !== undefined) {
      var res = prim.call(input, hint || "default");
      if (_typeof(res) !== "object") return res;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return (hint === "string" ? String : Number)(input);
  }
  var _require = require$$0$1,
    Buffer = _require.Buffer;
  var _require2 = require$$3,
    inspect = _require2.inspect;
  var custom = inspect && inspect.custom || 'inspect';
  function copyBuffer(src, target, offset) {
    Buffer.prototype.copy.call(src, target, offset);
  }
  buffer_list = /*#__PURE__*/function () {
    function BufferList() {
      _classCallCheck(this, BufferList);
      this.head = null;
      this.tail = null;
      this.length = 0;
    }
    _createClass(BufferList, [{
      key: "push",
      value: function push(v) {
        var entry = {
          data: v,
          next: null
        };
        if (this.length > 0) this.tail.next = entry;else this.head = entry;
        this.tail = entry;
        ++this.length;
      }
    }, {
      key: "unshift",
      value: function unshift(v) {
        var entry = {
          data: v,
          next: this.head
        };
        if (this.length === 0) this.tail = entry;
        this.head = entry;
        ++this.length;
      }
    }, {
      key: "shift",
      value: function shift() {
        if (this.length === 0) return;
        var ret = this.head.data;
        if (this.length === 1) this.head = this.tail = null;else this.head = this.head.next;
        --this.length;
        return ret;
      }
    }, {
      key: "clear",
      value: function clear() {
        this.head = this.tail = null;
        this.length = 0;
      }
    }, {
      key: "join",
      value: function join(s) {
        if (this.length === 0) return '';
        var p = this.head;
        var ret = '' + p.data;
        while (p = p.next) ret += s + p.data;
        return ret;
      }
    }, {
      key: "concat",
      value: function concat(n) {
        if (this.length === 0) return Buffer.alloc(0);
        var ret = Buffer.allocUnsafe(n >>> 0);
        var p = this.head;
        var i = 0;
        while (p) {
          copyBuffer(p.data, ret, i);
          i += p.data.length;
          p = p.next;
        }
        return ret;
      }

      // Consumes a specified amount of bytes or characters from the buffered data.
    }, {
      key: "consume",
      value: function consume(n, hasStrings) {
        var ret;
        if (n < this.head.data.length) {
          // `slice` is the same for buffers and strings.
          ret = this.head.data.slice(0, n);
          this.head.data = this.head.data.slice(n);
        } else if (n === this.head.data.length) {
          // First chunk is a perfect match.
          ret = this.shift();
        } else {
          // Result spans more than one buffer.
          ret = hasStrings ? this._getString(n) : this._getBuffer(n);
        }
        return ret;
      }
    }, {
      key: "first",
      value: function first() {
        return this.head.data;
      }

      // Consumes a specified amount of characters from the buffered data.
    }, {
      key: "_getString",
      value: function _getString(n) {
        var p = this.head;
        var c = 1;
        var ret = p.data;
        n -= ret.length;
        while (p = p.next) {
          var str = p.data;
          var nb = n > str.length ? str.length : n;
          if (nb === str.length) ret += str;else ret += str.slice(0, n);
          n -= nb;
          if (n === 0) {
            if (nb === str.length) {
              ++c;
              if (p.next) this.head = p.next;else this.head = this.tail = null;
            } else {
              this.head = p;
              p.data = str.slice(nb);
            }
            break;
          }
          ++c;
        }
        this.length -= c;
        return ret;
      }

      // Consumes a specified amount of bytes from the buffered data.
    }, {
      key: "_getBuffer",
      value: function _getBuffer(n) {
        var ret = Buffer.allocUnsafe(n);
        var p = this.head;
        var c = 1;
        p.data.copy(ret);
        n -= p.data.length;
        while (p = p.next) {
          var buf = p.data;
          var nb = n > buf.length ? buf.length : n;
          buf.copy(ret, ret.length - n, 0, nb);
          n -= nb;
          if (n === 0) {
            if (nb === buf.length) {
              ++c;
              if (p.next) this.head = p.next;else this.head = this.tail = null;
            } else {
              this.head = p;
              p.data = buf.slice(nb);
            }
            break;
          }
          ++c;
        }
        this.length -= c;
        return ret;
      }

      // Make sure the linked list only shows the minimal necessary information.
    }, {
      key: custom,
      value: function value(_, options) {
        return inspect(this, _objectSpread(_objectSpread({}, options), {}, {
          // Only inspect one level.
          depth: 0,
          // It should not recurse.
          customInspect: false
        }));
      }
    }]);
    return BufferList;
  }();
  return buffer_list;
}

// undocumented cb() API, needed for core, not for public API
function destroy(err, cb) {
  var _this = this;
  var readableDestroyed = this._readableState && this._readableState.destroyed;
  var writableDestroyed = this._writableState && this._writableState.destroyed;
  if (readableDestroyed || writableDestroyed) {
    if (cb) {
      cb(err);
    } else if (err) {
      if (!this._writableState) {
        process.nextTick(emitErrorNT, this, err);
      } else if (!this._writableState.errorEmitted) {
        this._writableState.errorEmitted = true;
        process.nextTick(emitErrorNT, this, err);
      }
    }
    return this;
  }

  // we set destroyed to true before firing error callbacks in order
  // to make it re-entrance safe in case destroy() is called within callbacks

  if (this._readableState) {
    this._readableState.destroyed = true;
  }

  // if this is a duplex stream mark the writable part as destroyed as well
  if (this._writableState) {
    this._writableState.destroyed = true;
  }
  this._destroy(err || null, function (err) {
    if (!cb && err) {
      if (!_this._writableState) {
        process.nextTick(emitErrorAndCloseNT, _this, err);
      } else if (!_this._writableState.errorEmitted) {
        _this._writableState.errorEmitted = true;
        process.nextTick(emitErrorAndCloseNT, _this, err);
      } else {
        process.nextTick(emitCloseNT, _this);
      }
    } else if (cb) {
      process.nextTick(emitCloseNT, _this);
      cb(err);
    } else {
      process.nextTick(emitCloseNT, _this);
    }
  });
  return this;
}
function emitErrorAndCloseNT(self, err) {
  emitErrorNT(self, err);
  emitCloseNT(self);
}
function emitCloseNT(self) {
  if (self._writableState && !self._writableState.emitClose) return;
  if (self._readableState && !self._readableState.emitClose) return;
  self.emit('close');
}
function undestroy() {
  if (this._readableState) {
    this._readableState.destroyed = false;
    this._readableState.reading = false;
    this._readableState.ended = false;
    this._readableState.endEmitted = false;
  }
  if (this._writableState) {
    this._writableState.destroyed = false;
    this._writableState.ended = false;
    this._writableState.ending = false;
    this._writableState.finalCalled = false;
    this._writableState.prefinished = false;
    this._writableState.finished = false;
    this._writableState.errorEmitted = false;
  }
}
function emitErrorNT(self, err) {
  self.emit('error', err);
}
function errorOrDestroy(stream, err) {
  // We have tests that rely on errors being emitted
  // in the same tick, so changing this is semver major.
  // For now when you opt-in to autoDestroy we allow
  // the error to be emitted nextTick. In a future
  // semver major update we should change the default to this.

  var rState = stream._readableState;
  var wState = stream._writableState;
  if (rState && rState.autoDestroy || wState && wState.autoDestroy) stream.destroy(err);else stream.emit('error', err);
}
var destroy_1 = {
  destroy: destroy,
  undestroy: undestroy,
  errorOrDestroy: errorOrDestroy
};

var errorsBrowser = {};

function _inheritsLoose(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);
  subClass.prototype.constructor = subClass;
  subClass.__proto__ = superClass;
}
var codes = {};
function createErrorType(code, message, Base) {
  if (!Base) {
    Base = Error;
  }
  function getMessage(arg1, arg2, arg3) {
    if (typeof message === 'string') {
      return message;
    } else {
      return message(arg1, arg2, arg3);
    }
  }
  var NodeError = /*#__PURE__*/
  function (_Base) {
    _inheritsLoose(NodeError, _Base);
    function NodeError(arg1, arg2, arg3) {
      return _Base.call(this, getMessage(arg1, arg2, arg3)) || this;
    }
    return NodeError;
  }(Base);
  NodeError.prototype.name = Base.name;
  NodeError.prototype.code = code;
  codes[code] = NodeError;
} // https://github.com/nodejs/node/blob/v10.8.0/lib/internal/errors.js

function oneOf(expected, thing) {
  if (Array.isArray(expected)) {
    var len = expected.length;
    expected = expected.map(function (i) {
      return String(i);
    });
    if (len > 2) {
      return "one of ".concat(thing, " ").concat(expected.slice(0, len - 1).join(', '), ", or ") + expected[len - 1];
    } else if (len === 2) {
      return "one of ".concat(thing, " ").concat(expected[0], " or ").concat(expected[1]);
    } else {
      return "of ".concat(thing, " ").concat(expected[0]);
    }
  } else {
    return "of ".concat(thing, " ").concat(String(expected));
  }
} // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/startsWith

function startsWith(str, search, pos) {
  return str.substr(!pos || pos < 0 ? 0 : +pos, search.length) === search;
} // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/endsWith

function endsWith(str, search, this_len) {
  if (this_len === undefined || this_len > str.length) {
    this_len = str.length;
  }
  return str.substring(this_len - search.length, this_len) === search;
} // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/includes

function includes(str, search, start) {
  if (typeof start !== 'number') {
    start = 0;
  }
  if (start + search.length > str.length) {
    return false;
  } else {
    return str.indexOf(search, start) !== -1;
  }
}
createErrorType('ERR_INVALID_OPT_VALUE', function (name, value) {
  return 'The value "' + value + '" is invalid for option "' + name + '"';
}, TypeError);
createErrorType('ERR_INVALID_ARG_TYPE', function (name, expected, actual) {
  // determiner: 'must be' or 'must not be'
  var determiner;
  if (typeof expected === 'string' && startsWith(expected, 'not ')) {
    determiner = 'must not be';
    expected = expected.replace(/^not /, '');
  } else {
    determiner = 'must be';
  }
  var msg;
  if (endsWith(name, ' argument')) {
    // For cases like 'first argument'
    msg = "The ".concat(name, " ").concat(determiner, " ").concat(oneOf(expected, 'type'));
  } else {
    var type = includes(name, '.') ? 'property' : 'argument';
    msg = "The \"".concat(name, "\" ").concat(type, " ").concat(determiner, " ").concat(oneOf(expected, 'type'));
  }
  msg += ". Received type ".concat(_typeof(actual));
  return msg;
}, TypeError);
createErrorType('ERR_STREAM_PUSH_AFTER_EOF', 'stream.push() after EOF');
createErrorType('ERR_METHOD_NOT_IMPLEMENTED', function (name) {
  return 'The ' + name + ' method is not implemented';
});
createErrorType('ERR_STREAM_PREMATURE_CLOSE', 'Premature close');
createErrorType('ERR_STREAM_DESTROYED', function (name) {
  return 'Cannot call ' + name + ' after a stream was destroyed';
});
createErrorType('ERR_MULTIPLE_CALLBACK', 'Callback called multiple times');
createErrorType('ERR_STREAM_CANNOT_PIPE', 'Cannot pipe, not readable');
createErrorType('ERR_STREAM_WRITE_AFTER_END', 'write after end');
createErrorType('ERR_STREAM_NULL_VALUES', 'May not write null values to stream', TypeError);
createErrorType('ERR_UNKNOWN_ENCODING', function (arg) {
  return 'Unknown encoding: ' + arg;
}, TypeError);
createErrorType('ERR_STREAM_UNSHIFT_AFTER_END_EVENT', 'stream.unshift() after end event');
errorsBrowser.codes = codes;

var ERR_INVALID_OPT_VALUE = errorsBrowser.codes.ERR_INVALID_OPT_VALUE;
function highWaterMarkFrom(options, isDuplex, duplexKey) {
  return options.highWaterMark != null ? options.highWaterMark : isDuplex ? options[duplexKey] : null;
}
function getHighWaterMark(state, options, duplexKey, isDuplex) {
  var hwm = highWaterMarkFrom(options, isDuplex, duplexKey);
  if (hwm != null) {
    if (!(isFinite(hwm) && Math.floor(hwm) === hwm) || hwm < 0) {
      var name = isDuplex ? duplexKey : 'highWaterMark';
      throw new ERR_INVALID_OPT_VALUE(name, hwm);
    }
    return Math.floor(hwm);
  }

  // Default value
  return state.objectMode ? 16 : 16 * 1024;
}
var state = {
  getHighWaterMark: getHighWaterMark
};

/**
 * Module exports.
 */

var browser$1 = deprecate;

/**
 * Mark that a method should not be used.
 * Returns a modified function which warns once by default.
 *
 * If `localStorage.noDeprecation = true` is set, then it is a no-op.
 *
 * If `localStorage.throwDeprecation = true` is set, then deprecated functions
 * will throw an Error when invoked.
 *
 * If `localStorage.traceDeprecation = true` is set, then deprecated functions
 * will invoke `console.trace()` instead of `console.error()`.
 *
 * @param {Function} fn - the function to deprecate
 * @param {String} msg - the string to print to the console when `fn` is invoked
 * @returns {Function} a new "deprecated" version of `fn`
 * @api public
 */

function deprecate(fn, msg) {
  if (config('noDeprecation')) {
    return fn;
  }
  var warned = false;
  function deprecated() {
    if (!warned) {
      if (config('throwDeprecation')) {
        throw new Error(msg);
      } else if (config('traceDeprecation')) {
        console.trace(msg);
      } else {
        console.warn(msg);
      }
      warned = true;
    }
    return fn.apply(this, arguments);
  }
  return deprecated;
}

/**
 * Checks `localStorage` for boolean values for the given `name`.
 *
 * @param {String} name
 * @returns {Boolean}
 * @api private
 */

function config(name) {
  // accessing global.localStorage can trigger a DOMException in sandboxed iframes
  try {
    if (!commonjsGlobal.localStorage) return false;
  } catch (_) {
    return false;
  }
  var val = commonjsGlobal.localStorage[name];
  if (null == val) return false;
  return String(val).toLowerCase() === 'true';
}

var _stream_writable;
var hasRequired_stream_writable;
function require_stream_writable() {
  if (hasRequired_stream_writable) return _stream_writable;
  hasRequired_stream_writable = 1;
  _stream_writable = Writable;

  // It seems a linked list but it is not
  // there will be only 2 of these for each stream
  function CorkedRequest(state) {
    var _this = this;
    this.next = null;
    this.entry = null;
    this.finish = function () {
      onCorkedFinish(_this, state);
    };
  }
  /* </replacement> */

  /*<replacement>*/
  var Duplex;
  /*</replacement>*/

  Writable.WritableState = WritableState;

  /*<replacement>*/
  var internalUtil = {
    deprecate: browser$1
  };
  /*</replacement>*/

  /*<replacement>*/
  var Stream = streamBrowser;
  /*</replacement>*/

  var Buffer = require$$0$1.Buffer;
  var OurUint8Array = (typeof commonjsGlobal !== 'undefined' ? commonjsGlobal : typeof window !== 'undefined' ? window : typeof self !== 'undefined' ? self : {}).Uint8Array || function () {};
  function _uint8ArrayToBuffer(chunk) {
    return Buffer.from(chunk);
  }
  function _isUint8Array(obj) {
    return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;
  }
  var destroyImpl = destroy_1;
  var _require = state,
    getHighWaterMark = _require.getHighWaterMark;
  var _require$codes = errorsBrowser.codes,
    ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE,
    ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED,
    ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK,
    ERR_STREAM_CANNOT_PIPE = _require$codes.ERR_STREAM_CANNOT_PIPE,
    ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED,
    ERR_STREAM_NULL_VALUES = _require$codes.ERR_STREAM_NULL_VALUES,
    ERR_STREAM_WRITE_AFTER_END = _require$codes.ERR_STREAM_WRITE_AFTER_END,
    ERR_UNKNOWN_ENCODING = _require$codes.ERR_UNKNOWN_ENCODING;
  var errorOrDestroy = destroyImpl.errorOrDestroy;
  inherits_browserExports(Writable, Stream);
  function nop() {}
  function WritableState(options, stream, isDuplex) {
    Duplex = Duplex || require_stream_duplex();
    options = options || {};

    // Duplex streams are both readable and writable, but share
    // the same options object.
    // However, some cases require setting options to different
    // values for the readable and the writable sides of the duplex stream,
    // e.g. options.readableObjectMode vs. options.writableObjectMode, etc.
    if (typeof isDuplex !== 'boolean') isDuplex = stream instanceof Duplex;

    // object stream flag to indicate whether or not this stream
    // contains buffers or objects.
    this.objectMode = !!options.objectMode;
    if (isDuplex) this.objectMode = this.objectMode || !!options.writableObjectMode;

    // the point at which write() starts returning false
    // Note: 0 is a valid value, means that we always return false if
    // the entire buffer is not flushed immediately on write()
    this.highWaterMark = getHighWaterMark(this, options, 'writableHighWaterMark', isDuplex);

    // if _final has been called
    this.finalCalled = false;

    // drain event flag.
    this.needDrain = false;
    // at the start of calling end()
    this.ending = false;
    // when end() has been called, and returned
    this.ended = false;
    // when 'finish' is emitted
    this.finished = false;

    // has it been destroyed
    this.destroyed = false;

    // should we decode strings into buffers before passing to _write?
    // this is here so that some node-core streams can optimize string
    // handling at a lower level.
    var noDecode = options.decodeStrings === false;
    this.decodeStrings = !noDecode;

    // Crypto is kind of old and crusty.  Historically, its default string
    // encoding is 'binary' so we have to make this configurable.
    // Everything else in the universe uses 'utf8', though.
    this.defaultEncoding = options.defaultEncoding || 'utf8';

    // not an actual buffer we keep track of, but a measurement
    // of how much we're waiting to get pushed to some underlying
    // socket or file.
    this.length = 0;

    // a flag to see when we're in the middle of a write.
    this.writing = false;

    // when true all writes will be buffered until .uncork() call
    this.corked = 0;

    // a flag to be able to tell if the onwrite cb is called immediately,
    // or on a later tick.  We set this to true at first, because any
    // actions that shouldn't happen until "later" should generally also
    // not happen before the first write call.
    this.sync = true;

    // a flag to know if we're processing previously buffered items, which
    // may call the _write() callback in the same tick, so that we don't
    // end up in an overlapped onwrite situation.
    this.bufferProcessing = false;

    // the callback that's passed to _write(chunk,cb)
    this.onwrite = function (er) {
      onwrite(stream, er);
    };

    // the callback that the user supplies to write(chunk,encoding,cb)
    this.writecb = null;

    // the amount that is being written when _write is called.
    this.writelen = 0;
    this.bufferedRequest = null;
    this.lastBufferedRequest = null;

    // number of pending user-supplied write callbacks
    // this must be 0 before 'finish' can be emitted
    this.pendingcb = 0;

    // emit prefinish if the only thing we're waiting for is _write cbs
    // This is relevant for synchronous Transform streams
    this.prefinished = false;

    // True if the error was already emitted and should not be thrown again
    this.errorEmitted = false;

    // Should close be emitted on destroy. Defaults to true.
    this.emitClose = options.emitClose !== false;

    // Should .destroy() be called after 'finish' (and potentially 'end')
    this.autoDestroy = !!options.autoDestroy;

    // count buffered requests
    this.bufferedRequestCount = 0;

    // allocate the first CorkedRequest, there is always
    // one allocated and free to use, and we maintain at most two
    this.corkedRequestsFree = new CorkedRequest(this);
  }
  WritableState.prototype.getBuffer = function getBuffer() {
    var current = this.bufferedRequest;
    var out = [];
    while (current) {
      out.push(current);
      current = current.next;
    }
    return out;
  };
  (function () {
    try {
      Object.defineProperty(WritableState.prototype, 'buffer', {
        get: internalUtil.deprecate(function writableStateBufferGetter() {
          return this.getBuffer();
        }, '_writableState.buffer is deprecated. Use _writableState.getBuffer ' + 'instead.', 'DEP0003')
      });
    } catch (_) {}
  })();

  // Test _writableState for inheritance to account for Duplex streams,
  // whose prototype chain only points to Readable.
  var realHasInstance;
  if (typeof Symbol === 'function' && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === 'function') {
    realHasInstance = Function.prototype[Symbol.hasInstance];
    Object.defineProperty(Writable, Symbol.hasInstance, {
      value: function value(object) {
        if (realHasInstance.call(this, object)) return true;
        if (this !== Writable) return false;
        return object && object._writableState instanceof WritableState;
      }
    });
  } else {
    realHasInstance = function realHasInstance(object) {
      return object instanceof this;
    };
  }
  function Writable(options) {
    Duplex = Duplex || require_stream_duplex();

    // Writable ctor is applied to Duplexes, too.
    // `realHasInstance` is necessary because using plain `instanceof`
    // would return false, as no `_writableState` property is attached.

    // Trying to use the custom `instanceof` for Writable here will also break the
    // Node.js LazyTransform implementation, which has a non-trivial getter for
    // `_writableState` that would lead to infinite recursion.

    // Checking for a Stream.Duplex instance is faster here instead of inside
    // the WritableState constructor, at least with V8 6.5
    var isDuplex = this instanceof Duplex;
    if (!isDuplex && !realHasInstance.call(Writable, this)) return new Writable(options);
    this._writableState = new WritableState(options, this, isDuplex);

    // legacy.
    this.writable = true;
    if (options) {
      if (typeof options.write === 'function') this._write = options.write;
      if (typeof options.writev === 'function') this._writev = options.writev;
      if (typeof options.destroy === 'function') this._destroy = options.destroy;
      if (typeof options.final === 'function') this._final = options.final;
    }
    Stream.call(this);
  }

  // Otherwise people can pipe Writable streams, which is just wrong.
  Writable.prototype.pipe = function () {
    errorOrDestroy(this, new ERR_STREAM_CANNOT_PIPE());
  };
  function writeAfterEnd(stream, cb) {
    var er = new ERR_STREAM_WRITE_AFTER_END();
    // TODO: defer error events consistently everywhere, not just the cb
    errorOrDestroy(stream, er);
    process.nextTick(cb, er);
  }

  // Checks that a user-supplied chunk is valid, especially for the particular
  // mode the stream is in. Currently this means that `null` is never accepted
  // and undefined/non-string values are only allowed in object mode.
  function validChunk(stream, state, chunk, cb) {
    var er;
    if (chunk === null) {
      er = new ERR_STREAM_NULL_VALUES();
    } else if (typeof chunk !== 'string' && !state.objectMode) {
      er = new ERR_INVALID_ARG_TYPE('chunk', ['string', 'Buffer'], chunk);
    }
    if (er) {
      errorOrDestroy(stream, er);
      process.nextTick(cb, er);
      return false;
    }
    return true;
  }
  Writable.prototype.write = function (chunk, encoding, cb) {
    var state = this._writableState;
    var ret = false;
    var isBuf = !state.objectMode && _isUint8Array(chunk);
    if (isBuf && !Buffer.isBuffer(chunk)) {
      chunk = _uint8ArrayToBuffer(chunk);
    }
    if (typeof encoding === 'function') {
      cb = encoding;
      encoding = null;
    }
    if (isBuf) encoding = 'buffer';else if (!encoding) encoding = state.defaultEncoding;
    if (typeof cb !== 'function') cb = nop;
    if (state.ending) writeAfterEnd(this, cb);else if (isBuf || validChunk(this, state, chunk, cb)) {
      state.pendingcb++;
      ret = writeOrBuffer(this, state, isBuf, chunk, encoding, cb);
    }
    return ret;
  };
  Writable.prototype.cork = function () {
    this._writableState.corked++;
  };
  Writable.prototype.uncork = function () {
    var state = this._writableState;
    if (state.corked) {
      state.corked--;
      if (!state.writing && !state.corked && !state.bufferProcessing && state.bufferedRequest) clearBuffer(this, state);
    }
  };
  Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
    // node::ParseEncoding() requires lower case.
    if (typeof encoding === 'string') encoding = encoding.toLowerCase();
    if (!(['hex', 'utf8', 'utf-8', 'ascii', 'binary', 'base64', 'ucs2', 'ucs-2', 'utf16le', 'utf-16le', 'raw'].indexOf((encoding + '').toLowerCase()) > -1)) throw new ERR_UNKNOWN_ENCODING(encoding);
    this._writableState.defaultEncoding = encoding;
    return this;
  };
  Object.defineProperty(Writable.prototype, 'writableBuffer', {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get() {
      return this._writableState && this._writableState.getBuffer();
    }
  });
  function decodeChunk(state, chunk, encoding) {
    if (!state.objectMode && state.decodeStrings !== false && typeof chunk === 'string') {
      chunk = Buffer.from(chunk, encoding);
    }
    return chunk;
  }
  Object.defineProperty(Writable.prototype, 'writableHighWaterMark', {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get() {
      return this._writableState.highWaterMark;
    }
  });

  // if we're already writing something, then just put this
  // in the queue, and wait our turn.  Otherwise, call _write
  // If we return false, then we need a drain event, so set that flag.
  function writeOrBuffer(stream, state, isBuf, chunk, encoding, cb) {
    if (!isBuf) {
      var newChunk = decodeChunk(state, chunk, encoding);
      if (chunk !== newChunk) {
        isBuf = true;
        encoding = 'buffer';
        chunk = newChunk;
      }
    }
    var len = state.objectMode ? 1 : chunk.length;
    state.length += len;
    var ret = state.length < state.highWaterMark;
    // we must ensure that previous needDrain will not be reset to false.
    if (!ret) state.needDrain = true;
    if (state.writing || state.corked) {
      var last = state.lastBufferedRequest;
      state.lastBufferedRequest = {
        chunk: chunk,
        encoding: encoding,
        isBuf: isBuf,
        callback: cb,
        next: null
      };
      if (last) {
        last.next = state.lastBufferedRequest;
      } else {
        state.bufferedRequest = state.lastBufferedRequest;
      }
      state.bufferedRequestCount += 1;
    } else {
      doWrite(stream, state, false, len, chunk, encoding, cb);
    }
    return ret;
  }
  function doWrite(stream, state, writev, len, chunk, encoding, cb) {
    state.writelen = len;
    state.writecb = cb;
    state.writing = true;
    state.sync = true;
    if (state.destroyed) state.onwrite(new ERR_STREAM_DESTROYED('write'));else if (writev) stream._writev(chunk, state.onwrite);else stream._write(chunk, encoding, state.onwrite);
    state.sync = false;
  }
  function onwriteError(stream, state, sync, er, cb) {
    --state.pendingcb;
    if (sync) {
      // defer the callback if we are being called synchronously
      // to avoid piling up things on the stack
      process.nextTick(cb, er);
      // this can emit finish, and it will always happen
      // after error
      process.nextTick(finishMaybe, stream, state);
      stream._writableState.errorEmitted = true;
      errorOrDestroy(stream, er);
    } else {
      // the caller expect this to happen before if
      // it is async
      cb(er);
      stream._writableState.errorEmitted = true;
      errorOrDestroy(stream, er);
      // this can emit finish, but finish must
      // always follow error
      finishMaybe(stream, state);
    }
  }
  function onwriteStateUpdate(state) {
    state.writing = false;
    state.writecb = null;
    state.length -= state.writelen;
    state.writelen = 0;
  }
  function onwrite(stream, er) {
    var state = stream._writableState;
    var sync = state.sync;
    var cb = state.writecb;
    if (typeof cb !== 'function') throw new ERR_MULTIPLE_CALLBACK();
    onwriteStateUpdate(state);
    if (er) onwriteError(stream, state, sync, er, cb);else {
      // Check if we're actually ready to finish, but don't emit yet
      var finished = needFinish(state) || stream.destroyed;
      if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {
        clearBuffer(stream, state);
      }
      if (sync) {
        process.nextTick(afterWrite, stream, state, finished, cb);
      } else {
        afterWrite(stream, state, finished, cb);
      }
    }
  }
  function afterWrite(stream, state, finished, cb) {
    if (!finished) onwriteDrain(stream, state);
    state.pendingcb--;
    cb();
    finishMaybe(stream, state);
  }

  // Must force callback to be called on nextTick, so that we don't
  // emit 'drain' before the write() consumer gets the 'false' return
  // value, and has a chance to attach a 'drain' listener.
  function onwriteDrain(stream, state) {
    if (state.length === 0 && state.needDrain) {
      state.needDrain = false;
      stream.emit('drain');
    }
  }

  // if there's something in the buffer waiting, then process it
  function clearBuffer(stream, state) {
    state.bufferProcessing = true;
    var entry = state.bufferedRequest;
    if (stream._writev && entry && entry.next) {
      // Fast case, write everything using _writev()
      var l = state.bufferedRequestCount;
      var buffer = new Array(l);
      var holder = state.corkedRequestsFree;
      holder.entry = entry;
      var count = 0;
      var allBuffers = true;
      while (entry) {
        buffer[count] = entry;
        if (!entry.isBuf) allBuffers = false;
        entry = entry.next;
        count += 1;
      }
      buffer.allBuffers = allBuffers;
      doWrite(stream, state, true, state.length, buffer, '', holder.finish);

      // doWrite is almost always async, defer these to save a bit of time
      // as the hot path ends with doWrite
      state.pendingcb++;
      state.lastBufferedRequest = null;
      if (holder.next) {
        state.corkedRequestsFree = holder.next;
        holder.next = null;
      } else {
        state.corkedRequestsFree = new CorkedRequest(state);
      }
      state.bufferedRequestCount = 0;
    } else {
      // Slow case, write chunks one-by-one
      while (entry) {
        var chunk = entry.chunk;
        var encoding = entry.encoding;
        var cb = entry.callback;
        var len = state.objectMode ? 1 : chunk.length;
        doWrite(stream, state, false, len, chunk, encoding, cb);
        entry = entry.next;
        state.bufferedRequestCount--;
        // if we didn't call the onwrite immediately, then
        // it means that we need to wait until it does.
        // also, that means that the chunk and cb are currently
        // being processed, so move the buffer counter past them.
        if (state.writing) {
          break;
        }
      }
      if (entry === null) state.lastBufferedRequest = null;
    }
    state.bufferedRequest = entry;
    state.bufferProcessing = false;
  }
  Writable.prototype._write = function (chunk, encoding, cb) {
    cb(new ERR_METHOD_NOT_IMPLEMENTED('_write()'));
  };
  Writable.prototype._writev = null;
  Writable.prototype.end = function (chunk, encoding, cb) {
    var state = this._writableState;
    if (typeof chunk === 'function') {
      cb = chunk;
      chunk = null;
      encoding = null;
    } else if (typeof encoding === 'function') {
      cb = encoding;
      encoding = null;
    }
    if (chunk !== null && chunk !== undefined) this.write(chunk, encoding);

    // .end() fully uncorks
    if (state.corked) {
      state.corked = 1;
      this.uncork();
    }

    // ignore unnecessary end() calls.
    if (!state.ending) endWritable(this, state, cb);
    return this;
  };
  Object.defineProperty(Writable.prototype, 'writableLength', {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get() {
      return this._writableState.length;
    }
  });
  function needFinish(state) {
    return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
  }
  function callFinal(stream, state) {
    stream._final(function (err) {
      state.pendingcb--;
      if (err) {
        errorOrDestroy(stream, err);
      }
      state.prefinished = true;
      stream.emit('prefinish');
      finishMaybe(stream, state);
    });
  }
  function prefinish(stream, state) {
    if (!state.prefinished && !state.finalCalled) {
      if (typeof stream._final === 'function' && !state.destroyed) {
        state.pendingcb++;
        state.finalCalled = true;
        process.nextTick(callFinal, stream, state);
      } else {
        state.prefinished = true;
        stream.emit('prefinish');
      }
    }
  }
  function finishMaybe(stream, state) {
    var need = needFinish(state);
    if (need) {
      prefinish(stream, state);
      if (state.pendingcb === 0) {
        state.finished = true;
        stream.emit('finish');
        if (state.autoDestroy) {
          // In case of duplex streams we need a way to detect
          // if the readable side is ready for autoDestroy as well
          var rState = stream._readableState;
          if (!rState || rState.autoDestroy && rState.endEmitted) {
            stream.destroy();
          }
        }
      }
    }
    return need;
  }
  function endWritable(stream, state, cb) {
    state.ending = true;
    finishMaybe(stream, state);
    if (cb) {
      if (state.finished) process.nextTick(cb);else stream.once('finish', cb);
    }
    state.ended = true;
    stream.writable = false;
  }
  function onCorkedFinish(corkReq, state, err) {
    var entry = corkReq.entry;
    corkReq.entry = null;
    while (entry) {
      var cb = entry.callback;
      state.pendingcb--;
      cb(err);
      entry = entry.next;
    }

    // reuse the free corkReq.
    state.corkedRequestsFree.next = corkReq;
  }
  Object.defineProperty(Writable.prototype, 'destroyed', {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get() {
      if (this._writableState === undefined) {
        return false;
      }
      return this._writableState.destroyed;
    },
    set: function set(value) {
      // we ignore the value if the stream
      // has not been initialized yet
      if (!this._writableState) {
        return;
      }

      // backward compatibility, the user is explicitly
      // managing destroyed
      this._writableState.destroyed = value;
    }
  });
  Writable.prototype.destroy = destroyImpl.destroy;
  Writable.prototype._undestroy = destroyImpl.undestroy;
  Writable.prototype._destroy = function (err, cb) {
    cb(err);
  };
  return _stream_writable;
}

var _stream_duplex;
var hasRequired_stream_duplex;
function require_stream_duplex() {
  if (hasRequired_stream_duplex) return _stream_duplex;
  hasRequired_stream_duplex = 1;

  /*<replacement>*/
  var objectKeys = Object.keys || function (obj) {
    var keys = [];
    for (var key in obj) keys.push(key);
    return keys;
  };
  /*</replacement>*/

  _stream_duplex = Duplex;
  var Readable = require_stream_readable();
  var Writable = require_stream_writable();
  inherits_browserExports(Duplex, Readable);
  {
    // Allow the keys array to be GC'ed.
    var keys = objectKeys(Writable.prototype);
    for (var v = 0; v < keys.length; v++) {
      var method = keys[v];
      if (!Duplex.prototype[method]) Duplex.prototype[method] = Writable.prototype[method];
    }
  }
  function Duplex(options) {
    if (!(this instanceof Duplex)) return new Duplex(options);
    Readable.call(this, options);
    Writable.call(this, options);
    this.allowHalfOpen = true;
    if (options) {
      if (options.readable === false) this.readable = false;
      if (options.writable === false) this.writable = false;
      if (options.allowHalfOpen === false) {
        this.allowHalfOpen = false;
        this.once('end', onend);
      }
    }
  }
  Object.defineProperty(Duplex.prototype, 'writableHighWaterMark', {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get() {
      return this._writableState.highWaterMark;
    }
  });
  Object.defineProperty(Duplex.prototype, 'writableBuffer', {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get() {
      return this._writableState && this._writableState.getBuffer();
    }
  });
  Object.defineProperty(Duplex.prototype, 'writableLength', {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get() {
      return this._writableState.length;
    }
  });

  // the no-half-open enforcer
  function onend() {
    // If the writable side ended, then we're ok.
    if (this._writableState.ended) return;

    // no more data can be written.
    // But allow more writes to happen in this tick.
    process.nextTick(onEndNT, this);
  }
  function onEndNT(self) {
    self.end();
  }
  Object.defineProperty(Duplex.prototype, 'destroyed', {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get() {
      if (this._readableState === undefined || this._writableState === undefined) {
        return false;
      }
      return this._readableState.destroyed && this._writableState.destroyed;
    },
    set: function set(value) {
      // we ignore the value if the stream
      // has not been initialized yet
      if (this._readableState === undefined || this._writableState === undefined) {
        return;
      }

      // backward compatibility, the user is explicitly
      // managing destroyed
      this._readableState.destroyed = value;
      this._writableState.destroyed = value;
    }
  });
  return _stream_duplex;
}

var string_decoder = {};

var hasRequiredString_decoder;
function requireString_decoder() {
  if (hasRequiredString_decoder) return string_decoder;
  hasRequiredString_decoder = 1;

  /*<replacement>*/

  var Buffer = safeBufferExports.Buffer;
  /*</replacement>*/

  var isEncoding = Buffer.isEncoding || function (encoding) {
    encoding = '' + encoding;
    switch (encoding && encoding.toLowerCase()) {
      case 'hex':
      case 'utf8':
      case 'utf-8':
      case 'ascii':
      case 'binary':
      case 'base64':
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
      case 'raw':
        return true;
      default:
        return false;
    }
  };
  function _normalizeEncoding(enc) {
    if (!enc) return 'utf8';
    var retried;
    while (true) {
      switch (enc) {
        case 'utf8':
        case 'utf-8':
          return 'utf8';
        case 'ucs2':
        case 'ucs-2':
        case 'utf16le':
        case 'utf-16le':
          return 'utf16le';
        case 'latin1':
        case 'binary':
          return 'latin1';
        case 'base64':
        case 'ascii':
        case 'hex':
          return enc;
        default:
          if (retried) return; // undefined
          enc = ('' + enc).toLowerCase();
          retried = true;
      }
    }
  }

  // Do not cache `Buffer.isEncoding` when checking encoding names as some
  // modules monkey-patch it to support additional encodings
  function normalizeEncoding(enc) {
    var nenc = _normalizeEncoding(enc);
    if (typeof nenc !== 'string' && (Buffer.isEncoding === isEncoding || !isEncoding(enc))) throw new Error('Unknown encoding: ' + enc);
    return nenc || enc;
  }

  // StringDecoder provides an interface for efficiently splitting a series of
  // buffers into a series of JS strings without breaking apart multi-byte
  // characters.
  string_decoder.StringDecoder = StringDecoder;
  function StringDecoder(encoding) {
    this.encoding = normalizeEncoding(encoding);
    var nb;
    switch (this.encoding) {
      case 'utf16le':
        this.text = utf16Text;
        this.end = utf16End;
        nb = 4;
        break;
      case 'utf8':
        this.fillLast = utf8FillLast;
        nb = 4;
        break;
      case 'base64':
        this.text = base64Text;
        this.end = base64End;
        nb = 3;
        break;
      default:
        this.write = simpleWrite;
        this.end = simpleEnd;
        return;
    }
    this.lastNeed = 0;
    this.lastTotal = 0;
    this.lastChar = Buffer.allocUnsafe(nb);
  }
  StringDecoder.prototype.write = function (buf) {
    if (buf.length === 0) return '';
    var r;
    var i;
    if (this.lastNeed) {
      r = this.fillLast(buf);
      if (r === undefined) return '';
      i = this.lastNeed;
      this.lastNeed = 0;
    } else {
      i = 0;
    }
    if (i < buf.length) return r ? r + this.text(buf, i) : this.text(buf, i);
    return r || '';
  };
  StringDecoder.prototype.end = utf8End;

  // Returns only complete characters in a Buffer
  StringDecoder.prototype.text = utf8Text;

  // Attempts to complete a partial non-UTF-8 character using bytes from a Buffer
  StringDecoder.prototype.fillLast = function (buf) {
    if (this.lastNeed <= buf.length) {
      buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);
      return this.lastChar.toString(this.encoding, 0, this.lastTotal);
    }
    buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length);
    this.lastNeed -= buf.length;
  };

  // Checks the type of a UTF-8 byte, whether it's ASCII, a leading byte, or a
  // continuation byte. If an invalid byte is detected, -2 is returned.
  function utf8CheckByte(byte) {
    if (byte <= 0x7F) return 0;else if (byte >> 5 === 0x06) return 2;else if (byte >> 4 === 0x0E) return 3;else if (byte >> 3 === 0x1E) return 4;
    return byte >> 6 === 0x02 ? -1 : -2;
  }

  // Checks at most 3 bytes at the end of a Buffer in order to detect an
  // incomplete multi-byte UTF-8 character. The total number of bytes (2, 3, or 4)
  // needed to complete the UTF-8 character (if applicable) are returned.
  function utf8CheckIncomplete(self, buf, i) {
    var j = buf.length - 1;
    if (j < i) return 0;
    var nb = utf8CheckByte(buf[j]);
    if (nb >= 0) {
      if (nb > 0) self.lastNeed = nb - 1;
      return nb;
    }
    if (--j < i || nb === -2) return 0;
    nb = utf8CheckByte(buf[j]);
    if (nb >= 0) {
      if (nb > 0) self.lastNeed = nb - 2;
      return nb;
    }
    if (--j < i || nb === -2) return 0;
    nb = utf8CheckByte(buf[j]);
    if (nb >= 0) {
      if (nb > 0) {
        if (nb === 2) nb = 0;else self.lastNeed = nb - 3;
      }
      return nb;
    }
    return 0;
  }

  // Validates as many continuation bytes for a multi-byte UTF-8 character as
  // needed or are available. If we see a non-continuation byte where we expect
  // one, we "replace" the validated continuation bytes we've seen so far with
  // a single UTF-8 replacement character ('\ufffd'), to match v8's UTF-8 decoding
  // behavior. The continuation byte check is included three times in the case
  // where all of the continuation bytes for a character exist in the same buffer.
  // It is also done this way as a slight performance increase instead of using a
  // loop.
  function utf8CheckExtraBytes(self, buf, p) {
    if ((buf[0] & 0xC0) !== 0x80) {
      self.lastNeed = 0;
      return "\uFFFD";
    }
    if (self.lastNeed > 1 && buf.length > 1) {
      if ((buf[1] & 0xC0) !== 0x80) {
        self.lastNeed = 1;
        return "\uFFFD";
      }
      if (self.lastNeed > 2 && buf.length > 2) {
        if ((buf[2] & 0xC0) !== 0x80) {
          self.lastNeed = 2;
          return "\uFFFD";
        }
      }
    }
  }

  // Attempts to complete a multi-byte UTF-8 character using bytes from a Buffer.
  function utf8FillLast(buf) {
    var p = this.lastTotal - this.lastNeed;
    var r = utf8CheckExtraBytes(this, buf);
    if (r !== undefined) return r;
    if (this.lastNeed <= buf.length) {
      buf.copy(this.lastChar, p, 0, this.lastNeed);
      return this.lastChar.toString(this.encoding, 0, this.lastTotal);
    }
    buf.copy(this.lastChar, p, 0, buf.length);
    this.lastNeed -= buf.length;
  }

  // Returns all complete UTF-8 characters in a Buffer. If the Buffer ended on a
  // partial character, the character's bytes are buffered until the required
  // number of bytes are available.
  function utf8Text(buf, i) {
    var total = utf8CheckIncomplete(this, buf, i);
    if (!this.lastNeed) return buf.toString('utf8', i);
    this.lastTotal = total;
    var end = buf.length - (total - this.lastNeed);
    buf.copy(this.lastChar, 0, end);
    return buf.toString('utf8', i, end);
  }

  // For UTF-8, a replacement character is added when ending on a partial
  // character.
  function utf8End(buf) {
    var r = buf && buf.length ? this.write(buf) : '';
    if (this.lastNeed) return r + "\uFFFD";
    return r;
  }

  // UTF-16LE typically needs two bytes per character, but even if we have an even
  // number of bytes available, we need to check if we end on a leading/high
  // surrogate. In that case, we need to wait for the next two bytes in order to
  // decode the last character properly.
  function utf16Text(buf, i) {
    if ((buf.length - i) % 2 === 0) {
      var r = buf.toString('utf16le', i);
      if (r) {
        var c = r.charCodeAt(r.length - 1);
        if (c >= 0xD800 && c <= 0xDBFF) {
          this.lastNeed = 2;
          this.lastTotal = 4;
          this.lastChar[0] = buf[buf.length - 2];
          this.lastChar[1] = buf[buf.length - 1];
          return r.slice(0, -1);
        }
      }
      return r;
    }
    this.lastNeed = 1;
    this.lastTotal = 2;
    this.lastChar[0] = buf[buf.length - 1];
    return buf.toString('utf16le', i, buf.length - 1);
  }

  // For UTF-16LE we do not explicitly append special replacement characters if we
  // end on a partial character, we simply let v8 handle that.
  function utf16End(buf) {
    var r = buf && buf.length ? this.write(buf) : '';
    if (this.lastNeed) {
      var end = this.lastTotal - this.lastNeed;
      return r + this.lastChar.toString('utf16le', 0, end);
    }
    return r;
  }
  function base64Text(buf, i) {
    var n = (buf.length - i) % 3;
    if (n === 0) return buf.toString('base64', i);
    this.lastNeed = 3 - n;
    this.lastTotal = 3;
    if (n === 1) {
      this.lastChar[0] = buf[buf.length - 1];
    } else {
      this.lastChar[0] = buf[buf.length - 2];
      this.lastChar[1] = buf[buf.length - 1];
    }
    return buf.toString('base64', i, buf.length - n);
  }
  function base64End(buf) {
    var r = buf && buf.length ? this.write(buf) : '';
    if (this.lastNeed) return r + this.lastChar.toString('base64', 0, 3 - this.lastNeed);
    return r;
  }

  // Pass bytes on through for single-byte encodings (e.g. ascii, latin1, hex)
  function simpleWrite(buf) {
    return buf.toString(this.encoding);
  }
  function simpleEnd(buf) {
    return buf && buf.length ? this.write(buf) : '';
  }
  return string_decoder;
}

var ERR_STREAM_PREMATURE_CLOSE = errorsBrowser.codes.ERR_STREAM_PREMATURE_CLOSE;
function once$1(callback) {
  var called = false;
  return function () {
    if (called) return;
    called = true;
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    callback.apply(this, args);
  };
}
function noop$1() {}
function isRequest$1(stream) {
  return stream.setHeader && typeof stream.abort === 'function';
}
function eos$1(stream, opts, callback) {
  if (typeof opts === 'function') return eos$1(stream, null, opts);
  if (!opts) opts = {};
  callback = once$1(callback || noop$1);
  var readable = opts.readable || opts.readable !== false && stream.readable;
  var writable = opts.writable || opts.writable !== false && stream.writable;
  var onlegacyfinish = function onlegacyfinish() {
    if (!stream.writable) onfinish();
  };
  var writableEnded = stream._writableState && stream._writableState.finished;
  var onfinish = function onfinish() {
    writable = false;
    writableEnded = true;
    if (!readable) callback.call(stream);
  };
  var readableEnded = stream._readableState && stream._readableState.endEmitted;
  var onend = function onend() {
    readable = false;
    readableEnded = true;
    if (!writable) callback.call(stream);
  };
  var onerror = function onerror(err) {
    callback.call(stream, err);
  };
  var onclose = function onclose() {
    var err;
    if (readable && !readableEnded) {
      if (!stream._readableState || !stream._readableState.ended) err = new ERR_STREAM_PREMATURE_CLOSE();
      return callback.call(stream, err);
    }
    if (writable && !writableEnded) {
      if (!stream._writableState || !stream._writableState.ended) err = new ERR_STREAM_PREMATURE_CLOSE();
      return callback.call(stream, err);
    }
  };
  var onrequest = function onrequest() {
    stream.req.on('finish', onfinish);
  };
  if (isRequest$1(stream)) {
    stream.on('complete', onfinish);
    stream.on('abort', onclose);
    if (stream.req) onrequest();else stream.on('request', onrequest);
  } else if (writable && !stream._writableState) {
    // legacy streams
    stream.on('end', onlegacyfinish);
    stream.on('close', onlegacyfinish);
  }
  stream.on('end', onend);
  stream.on('finish', onfinish);
  if (opts.error !== false) stream.on('error', onerror);
  stream.on('close', onclose);
  return function () {
    stream.removeListener('complete', onfinish);
    stream.removeListener('abort', onclose);
    stream.removeListener('request', onrequest);
    if (stream.req) stream.req.removeListener('finish', onfinish);
    stream.removeListener('end', onlegacyfinish);
    stream.removeListener('close', onlegacyfinish);
    stream.removeListener('finish', onfinish);
    stream.removeListener('end', onend);
    stream.removeListener('error', onerror);
    stream.removeListener('close', onclose);
  };
}
var endOfStream = eos$1;

var async_iterator;
var hasRequiredAsync_iterator;
function requireAsync_iterator() {
  if (hasRequiredAsync_iterator) return async_iterator;
  hasRequiredAsync_iterator = 1;
  var _Object$setPrototypeO;
  function _defineProperty(obj, key, value) {
    key = _toPropertyKey(key);
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }
    return obj;
  }
  function _toPropertyKey(arg) {
    var key = _toPrimitive(arg, "string");
    return _typeof(key) === "symbol" ? key : String(key);
  }
  function _toPrimitive(input, hint) {
    if (_typeof(input) !== "object" || input === null) return input;
    var prim = input[Symbol.toPrimitive];
    if (prim !== undefined) {
      var res = prim.call(input, hint || "default");
      if (_typeof(res) !== "object") return res;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return (hint === "string" ? String : Number)(input);
  }
  var finished = endOfStream;
  var kLastResolve = Symbol('lastResolve');
  var kLastReject = Symbol('lastReject');
  var kError = Symbol('error');
  var kEnded = Symbol('ended');
  var kLastPromise = Symbol('lastPromise');
  var kHandlePromise = Symbol('handlePromise');
  var kStream = Symbol('stream');
  function createIterResult(value, done) {
    return {
      value: value,
      done: done
    };
  }
  function readAndResolve(iter) {
    var resolve = iter[kLastResolve];
    if (resolve !== null) {
      var data = iter[kStream].read();
      // we defer if data is null
      // we can be expecting either 'end' or
      // 'error'
      if (data !== null) {
        iter[kLastPromise] = null;
        iter[kLastResolve] = null;
        iter[kLastReject] = null;
        resolve(createIterResult(data, false));
      }
    }
  }
  function onReadable(iter) {
    // we wait for the next tick, because it might
    // emit an error with process.nextTick
    process.nextTick(readAndResolve, iter);
  }
  function wrapForNext(lastPromise, iter) {
    return function (resolve, reject) {
      lastPromise.then(function () {
        if (iter[kEnded]) {
          resolve(createIterResult(undefined, true));
          return;
        }
        iter[kHandlePromise](resolve, reject);
      }, reject);
    };
  }
  var AsyncIteratorPrototype = Object.getPrototypeOf(function () {});
  var ReadableStreamAsyncIteratorPrototype = Object.setPrototypeOf((_Object$setPrototypeO = {
    get stream() {
      return this[kStream];
    },
    next: function next() {
      var _this = this;
      // if we have detected an error in the meanwhile
      // reject straight away
      var error = this[kError];
      if (error !== null) {
        return Promise.reject(error);
      }
      if (this[kEnded]) {
        return Promise.resolve(createIterResult(undefined, true));
      }
      if (this[kStream].destroyed) {
        // We need to defer via nextTick because if .destroy(err) is
        // called, the error will be emitted via nextTick, and
        // we cannot guarantee that there is no error lingering around
        // waiting to be emitted.
        return new Promise(function (resolve, reject) {
          process.nextTick(function () {
            if (_this[kError]) {
              reject(_this[kError]);
            } else {
              resolve(createIterResult(undefined, true));
            }
          });
        });
      }

      // if we have multiple next() calls
      // we will wait for the previous Promise to finish
      // this logic is optimized to support for await loops,
      // where next() is only called once at a time
      var lastPromise = this[kLastPromise];
      var promise;
      if (lastPromise) {
        promise = new Promise(wrapForNext(lastPromise, this));
      } else {
        // fast path needed to support multiple this.push()
        // without triggering the next() queue
        var data = this[kStream].read();
        if (data !== null) {
          return Promise.resolve(createIterResult(data, false));
        }
        promise = new Promise(this[kHandlePromise]);
      }
      this[kLastPromise] = promise;
      return promise;
    }
  }, _defineProperty(_Object$setPrototypeO, Symbol.asyncIterator, function () {
    return this;
  }), _defineProperty(_Object$setPrototypeO, "return", function _return() {
    var _this2 = this;
    // destroy(err, cb) is a private API
    // we can guarantee we have that here, because we control the
    // Readable class this is attached to
    return new Promise(function (resolve, reject) {
      _this2[kStream].destroy(null, function (err) {
        if (err) {
          reject(err);
          return;
        }
        resolve(createIterResult(undefined, true));
      });
    });
  }), _Object$setPrototypeO), AsyncIteratorPrototype);
  var createReadableStreamAsyncIterator = function createReadableStreamAsyncIterator(stream) {
    var _Object$create;
    var iterator = Object.create(ReadableStreamAsyncIteratorPrototype, (_Object$create = {}, _defineProperty(_Object$create, kStream, {
      value: stream,
      writable: true
    }), _defineProperty(_Object$create, kLastResolve, {
      value: null,
      writable: true
    }), _defineProperty(_Object$create, kLastReject, {
      value: null,
      writable: true
    }), _defineProperty(_Object$create, kError, {
      value: null,
      writable: true
    }), _defineProperty(_Object$create, kEnded, {
      value: stream._readableState.endEmitted,
      writable: true
    }), _defineProperty(_Object$create, kHandlePromise, {
      value: function value(resolve, reject) {
        var data = iterator[kStream].read();
        if (data) {
          iterator[kLastPromise] = null;
          iterator[kLastResolve] = null;
          iterator[kLastReject] = null;
          resolve(createIterResult(data, false));
        } else {
          iterator[kLastResolve] = resolve;
          iterator[kLastReject] = reject;
        }
      },
      writable: true
    }), _Object$create));
    iterator[kLastPromise] = null;
    finished(stream, function (err) {
      if (err && err.code !== 'ERR_STREAM_PREMATURE_CLOSE') {
        var reject = iterator[kLastReject];
        // reject if we are waiting for data in the Promise
        // returned by next() and store the error
        if (reject !== null) {
          iterator[kLastPromise] = null;
          iterator[kLastResolve] = null;
          iterator[kLastReject] = null;
          reject(err);
        }
        iterator[kError] = err;
        return;
      }
      var resolve = iterator[kLastResolve];
      if (resolve !== null) {
        iterator[kLastPromise] = null;
        iterator[kLastResolve] = null;
        iterator[kLastReject] = null;
        resolve(createIterResult(undefined, true));
      }
      iterator[kEnded] = true;
    });
    stream.on('readable', onReadable.bind(null, iterator));
    return iterator;
  };
  async_iterator = createReadableStreamAsyncIterator;
  return async_iterator;
}

var fromBrowser;
var hasRequiredFromBrowser;
function requireFromBrowser() {
  if (hasRequiredFromBrowser) return fromBrowser;
  hasRequiredFromBrowser = 1;
  fromBrowser = function fromBrowser() {
    throw new Error('Readable.from is not available in the browser');
  };
  return fromBrowser;
}

var _stream_readable;
var hasRequired_stream_readable;
function require_stream_readable() {
  if (hasRequired_stream_readable) return _stream_readable;
  hasRequired_stream_readable = 1;
  _stream_readable = Readable;

  /*<replacement>*/
  var Duplex;
  /*</replacement>*/

  Readable.ReadableState = ReadableState;

  /*<replacement>*/
  require$$0.EventEmitter;
  var EElistenerCount = function EElistenerCount(emitter, type) {
    return emitter.listeners(type).length;
  };
  /*</replacement>*/

  /*<replacement>*/
  var Stream = streamBrowser;
  /*</replacement>*/

  var Buffer = require$$0$1.Buffer;
  var OurUint8Array = (typeof commonjsGlobal !== 'undefined' ? commonjsGlobal : typeof window !== 'undefined' ? window : typeof self !== 'undefined' ? self : {}).Uint8Array || function () {};
  function _uint8ArrayToBuffer(chunk) {
    return Buffer.from(chunk);
  }
  function _isUint8Array(obj) {
    return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;
  }

  /*<replacement>*/
  var debugUtil = require$$3;
  var debug;
  if (debugUtil && debugUtil.debuglog) {
    debug = debugUtil.debuglog('stream');
  } else {
    debug = function debug() {};
  }
  /*</replacement>*/

  var BufferList = requireBuffer_list();
  var destroyImpl = destroy_1;
  var _require = state,
    getHighWaterMark = _require.getHighWaterMark;
  var _require$codes = errorsBrowser.codes,
    ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE,
    ERR_STREAM_PUSH_AFTER_EOF = _require$codes.ERR_STREAM_PUSH_AFTER_EOF,
    ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED,
    ERR_STREAM_UNSHIFT_AFTER_END_EVENT = _require$codes.ERR_STREAM_UNSHIFT_AFTER_END_EVENT;

  // Lazy loaded to improve the startup performance.
  var StringDecoder;
  var createReadableStreamAsyncIterator;
  var from;
  inherits_browserExports(Readable, Stream);
  var errorOrDestroy = destroyImpl.errorOrDestroy;
  var kProxyEvents = ['error', 'close', 'destroy', 'pause', 'resume'];
  function prependListener(emitter, event, fn) {
    // Sadly this is not cacheable as some libraries bundle their own
    // event emitter implementation with them.
    if (typeof emitter.prependListener === 'function') return emitter.prependListener(event, fn);

    // This is a hack to make sure that our error handler is attached before any
    // userland ones.  NEVER DO THIS. This is here only because this code needs
    // to continue to work with older versions of Node.js that do not include
    // the prependListener() method. The goal is to eventually remove this hack.
    if (!emitter._events || !emitter._events[event]) emitter.on(event, fn);else if (Array.isArray(emitter._events[event])) emitter._events[event].unshift(fn);else emitter._events[event] = [fn, emitter._events[event]];
  }
  function ReadableState(options, stream, isDuplex) {
    Duplex = Duplex || require_stream_duplex();
    options = options || {};

    // Duplex streams are both readable and writable, but share
    // the same options object.
    // However, some cases require setting options to different
    // values for the readable and the writable sides of the duplex stream.
    // These options can be provided separately as readableXXX and writableXXX.
    if (typeof isDuplex !== 'boolean') isDuplex = stream instanceof Duplex;

    // object stream flag. Used to make read(n) ignore n and to
    // make all the buffer merging and length checks go away
    this.objectMode = !!options.objectMode;
    if (isDuplex) this.objectMode = this.objectMode || !!options.readableObjectMode;

    // the point at which it stops calling _read() to fill the buffer
    // Note: 0 is a valid value, means "don't call _read preemptively ever"
    this.highWaterMark = getHighWaterMark(this, options, 'readableHighWaterMark', isDuplex);

    // A linked list is used to store data chunks instead of an array because the
    // linked list can remove elements from the beginning faster than
    // array.shift()
    this.buffer = new BufferList();
    this.length = 0;
    this.pipes = null;
    this.pipesCount = 0;
    this.flowing = null;
    this.ended = false;
    this.endEmitted = false;
    this.reading = false;

    // a flag to be able to tell if the event 'readable'/'data' is emitted
    // immediately, or on a later tick.  We set this to true at first, because
    // any actions that shouldn't happen until "later" should generally also
    // not happen before the first read call.
    this.sync = true;

    // whenever we return null, then we set a flag to say
    // that we're awaiting a 'readable' event emission.
    this.needReadable = false;
    this.emittedReadable = false;
    this.readableListening = false;
    this.resumeScheduled = false;
    this.paused = true;

    // Should close be emitted on destroy. Defaults to true.
    this.emitClose = options.emitClose !== false;

    // Should .destroy() be called after 'end' (and potentially 'finish')
    this.autoDestroy = !!options.autoDestroy;

    // has it been destroyed
    this.destroyed = false;

    // Crypto is kind of old and crusty.  Historically, its default string
    // encoding is 'binary' so we have to make this configurable.
    // Everything else in the universe uses 'utf8', though.
    this.defaultEncoding = options.defaultEncoding || 'utf8';

    // the number of writers that are awaiting a drain event in .pipe()s
    this.awaitDrain = 0;

    // if true, a maybeReadMore has been scheduled
    this.readingMore = false;
    this.decoder = null;
    this.encoding = null;
    if (options.encoding) {
      if (!StringDecoder) StringDecoder = requireString_decoder().StringDecoder;
      this.decoder = new StringDecoder(options.encoding);
      this.encoding = options.encoding;
    }
  }
  function Readable(options) {
    Duplex = Duplex || require_stream_duplex();
    if (!(this instanceof Readable)) return new Readable(options);

    // Checking for a Stream.Duplex instance is faster here instead of inside
    // the ReadableState constructor, at least with V8 6.5
    var isDuplex = this instanceof Duplex;
    this._readableState = new ReadableState(options, this, isDuplex);

    // legacy
    this.readable = true;
    if (options) {
      if (typeof options.read === 'function') this._read = options.read;
      if (typeof options.destroy === 'function') this._destroy = options.destroy;
    }
    Stream.call(this);
  }
  Object.defineProperty(Readable.prototype, 'destroyed', {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get() {
      if (this._readableState === undefined) {
        return false;
      }
      return this._readableState.destroyed;
    },
    set: function set(value) {
      // we ignore the value if the stream
      // has not been initialized yet
      if (!this._readableState) {
        return;
      }

      // backward compatibility, the user is explicitly
      // managing destroyed
      this._readableState.destroyed = value;
    }
  });
  Readable.prototype.destroy = destroyImpl.destroy;
  Readable.prototype._undestroy = destroyImpl.undestroy;
  Readable.prototype._destroy = function (err, cb) {
    cb(err);
  };

  // Manually shove something into the read() buffer.
  // This returns true if the highWaterMark has not been hit yet,
  // similar to how Writable.write() returns true if you should
  // write() some more.
  Readable.prototype.push = function (chunk, encoding) {
    var state = this._readableState;
    var skipChunkCheck;
    if (!state.objectMode) {
      if (typeof chunk === 'string') {
        encoding = encoding || state.defaultEncoding;
        if (encoding !== state.encoding) {
          chunk = Buffer.from(chunk, encoding);
          encoding = '';
        }
        skipChunkCheck = true;
      }
    } else {
      skipChunkCheck = true;
    }
    return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);
  };

  // Unshift should *always* be something directly out of read()
  Readable.prototype.unshift = function (chunk) {
    return readableAddChunk(this, chunk, null, true, false);
  };
  function readableAddChunk(stream, chunk, encoding, addToFront, skipChunkCheck) {
    debug('readableAddChunk', chunk);
    var state = stream._readableState;
    if (chunk === null) {
      state.reading = false;
      onEofChunk(stream, state);
    } else {
      var er;
      if (!skipChunkCheck) er = chunkInvalid(state, chunk);
      if (er) {
        errorOrDestroy(stream, er);
      } else if (state.objectMode || chunk && chunk.length > 0) {
        if (typeof chunk !== 'string' && !state.objectMode && Object.getPrototypeOf(chunk) !== Buffer.prototype) {
          chunk = _uint8ArrayToBuffer(chunk);
        }
        if (addToFront) {
          if (state.endEmitted) errorOrDestroy(stream, new ERR_STREAM_UNSHIFT_AFTER_END_EVENT());else addChunk(stream, state, chunk, true);
        } else if (state.ended) {
          errorOrDestroy(stream, new ERR_STREAM_PUSH_AFTER_EOF());
        } else if (state.destroyed) {
          return false;
        } else {
          state.reading = false;
          if (state.decoder && !encoding) {
            chunk = state.decoder.write(chunk);
            if (state.objectMode || chunk.length !== 0) addChunk(stream, state, chunk, false);else maybeReadMore(stream, state);
          } else {
            addChunk(stream, state, chunk, false);
          }
        }
      } else if (!addToFront) {
        state.reading = false;
        maybeReadMore(stream, state);
      }
    }

    // We can push more data if we are below the highWaterMark.
    // Also, if we have no data yet, we can stand some more bytes.
    // This is to work around cases where hwm=0, such as the repl.
    return !state.ended && (state.length < state.highWaterMark || state.length === 0);
  }
  function addChunk(stream, state, chunk, addToFront) {
    if (state.flowing && state.length === 0 && !state.sync) {
      state.awaitDrain = 0;
      stream.emit('data', chunk);
    } else {
      // update the buffer info.
      state.length += state.objectMode ? 1 : chunk.length;
      if (addToFront) state.buffer.unshift(chunk);else state.buffer.push(chunk);
      if (state.needReadable) emitReadable(stream);
    }
    maybeReadMore(stream, state);
  }
  function chunkInvalid(state, chunk) {
    var er;
    if (!_isUint8Array(chunk) && typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {
      er = new ERR_INVALID_ARG_TYPE('chunk', ['string', 'Buffer', 'Uint8Array'], chunk);
    }
    return er;
  }
  Readable.prototype.isPaused = function () {
    return this._readableState.flowing === false;
  };

  // backwards compatibility.
  Readable.prototype.setEncoding = function (enc) {
    if (!StringDecoder) StringDecoder = requireString_decoder().StringDecoder;
    var decoder = new StringDecoder(enc);
    this._readableState.decoder = decoder;
    // If setEncoding(null), decoder.encoding equals utf8
    this._readableState.encoding = this._readableState.decoder.encoding;

    // Iterate over current buffer to convert already stored Buffers:
    var p = this._readableState.buffer.head;
    var content = '';
    while (p !== null) {
      content += decoder.write(p.data);
      p = p.next;
    }
    this._readableState.buffer.clear();
    if (content !== '') this._readableState.buffer.push(content);
    this._readableState.length = content.length;
    return this;
  };

  // Don't raise the hwm > 1GB
  var MAX_HWM = 0x40000000;
  function computeNewHighWaterMark(n) {
    if (n >= MAX_HWM) {
      // TODO(ronag): Throw ERR_VALUE_OUT_OF_RANGE.
      n = MAX_HWM;
    } else {
      // Get the next highest power of 2 to prevent increasing hwm excessively in
      // tiny amounts
      n--;
      n |= n >>> 1;
      n |= n >>> 2;
      n |= n >>> 4;
      n |= n >>> 8;
      n |= n >>> 16;
      n++;
    }
    return n;
  }

  // This function is designed to be inlinable, so please take care when making
  // changes to the function body.
  function howMuchToRead(n, state) {
    if (n <= 0 || state.length === 0 && state.ended) return 0;
    if (state.objectMode) return 1;
    if (n !== n) {
      // Only flow one buffer at a time
      if (state.flowing && state.length) return state.buffer.head.data.length;else return state.length;
    }
    // If we're asking for more than the current hwm, then raise the hwm.
    if (n > state.highWaterMark) state.highWaterMark = computeNewHighWaterMark(n);
    if (n <= state.length) return n;
    // Don't have enough
    if (!state.ended) {
      state.needReadable = true;
      return 0;
    }
    return state.length;
  }

  // you can override either this method, or the async _read(n) below.
  Readable.prototype.read = function (n) {
    debug('read', n);
    n = parseInt(n, 10);
    var state = this._readableState;
    var nOrig = n;
    if (n !== 0) state.emittedReadable = false;

    // if we're doing read(0) to trigger a readable event, but we
    // already have a bunch of data in the buffer, then just trigger
    // the 'readable' event and move on.
    if (n === 0 && state.needReadable && ((state.highWaterMark !== 0 ? state.length >= state.highWaterMark : state.length > 0) || state.ended)) {
      debug('read: emitReadable', state.length, state.ended);
      if (state.length === 0 && state.ended) endReadable(this);else emitReadable(this);
      return null;
    }
    n = howMuchToRead(n, state);

    // if we've ended, and we're now clear, then finish it up.
    if (n === 0 && state.ended) {
      if (state.length === 0) endReadable(this);
      return null;
    }

    // All the actual chunk generation logic needs to be
    // *below* the call to _read.  The reason is that in certain
    // synthetic stream cases, such as passthrough streams, _read
    // may be a completely synchronous operation which may change
    // the state of the read buffer, providing enough data when
    // before there was *not* enough.
    //
    // So, the steps are:
    // 1. Figure out what the state of things will be after we do
    // a read from the buffer.
    //
    // 2. If that resulting state will trigger a _read, then call _read.
    // Note that this may be asynchronous, or synchronous.  Yes, it is
    // deeply ugly to write APIs this way, but that still doesn't mean
    // that the Readable class should behave improperly, as streams are
    // designed to be sync/async agnostic.
    // Take note if the _read call is sync or async (ie, if the read call
    // has returned yet), so that we know whether or not it's safe to emit
    // 'readable' etc.
    //
    // 3. Actually pull the requested chunks out of the buffer and return.

    // if we need a readable event, then we need to do some reading.
    var doRead = state.needReadable;
    debug('need readable', doRead);

    // if we currently have less than the highWaterMark, then also read some
    if (state.length === 0 || state.length - n < state.highWaterMark) {
      doRead = true;
      debug('length less than watermark', doRead);
    }

    // however, if we've ended, then there's no point, and if we're already
    // reading, then it's unnecessary.
    if (state.ended || state.reading) {
      doRead = false;
      debug('reading or ended', doRead);
    } else if (doRead) {
      debug('do read');
      state.reading = true;
      state.sync = true;
      // if the length is currently zero, then we *need* a readable event.
      if (state.length === 0) state.needReadable = true;
      // call internal read method
      this._read(state.highWaterMark);
      state.sync = false;
      // If _read pushed data synchronously, then `reading` will be false,
      // and we need to re-evaluate how much data we can return to the user.
      if (!state.reading) n = howMuchToRead(nOrig, state);
    }
    var ret;
    if (n > 0) ret = fromList(n, state);else ret = null;
    if (ret === null) {
      state.needReadable = state.length <= state.highWaterMark;
      n = 0;
    } else {
      state.length -= n;
      state.awaitDrain = 0;
    }
    if (state.length === 0) {
      // If we have nothing in the buffer, then we want to know
      // as soon as we *do* get something into the buffer.
      if (!state.ended) state.needReadable = true;

      // If we tried to read() past the EOF, then emit end on the next tick.
      if (nOrig !== n && state.ended) endReadable(this);
    }
    if (ret !== null) this.emit('data', ret);
    return ret;
  };
  function onEofChunk(stream, state) {
    debug('onEofChunk');
    if (state.ended) return;
    if (state.decoder) {
      var chunk = state.decoder.end();
      if (chunk && chunk.length) {
        state.buffer.push(chunk);
        state.length += state.objectMode ? 1 : chunk.length;
      }
    }
    state.ended = true;
    if (state.sync) {
      // if we are sync, wait until next tick to emit the data.
      // Otherwise we risk emitting data in the flow()
      // the readable code triggers during a read() call
      emitReadable(stream);
    } else {
      // emit 'readable' now to make sure it gets picked up.
      state.needReadable = false;
      if (!state.emittedReadable) {
        state.emittedReadable = true;
        emitReadable_(stream);
      }
    }
  }

  // Don't emit readable right away in sync mode, because this can trigger
  // another read() call => stack overflow.  This way, it might trigger
  // a nextTick recursion warning, but that's not so bad.
  function emitReadable(stream) {
    var state = stream._readableState;
    debug('emitReadable', state.needReadable, state.emittedReadable);
    state.needReadable = false;
    if (!state.emittedReadable) {
      debug('emitReadable', state.flowing);
      state.emittedReadable = true;
      process.nextTick(emitReadable_, stream);
    }
  }
  function emitReadable_(stream) {
    var state = stream._readableState;
    debug('emitReadable_', state.destroyed, state.length, state.ended);
    if (!state.destroyed && (state.length || state.ended)) {
      stream.emit('readable');
      state.emittedReadable = false;
    }

    // The stream needs another readable event if
    // 1. It is not flowing, as the flow mechanism will take
    //    care of it.
    // 2. It is not ended.
    // 3. It is below the highWaterMark, so we can schedule
    //    another readable later.
    state.needReadable = !state.flowing && !state.ended && state.length <= state.highWaterMark;
    flow(stream);
  }

  // at this point, the user has presumably seen the 'readable' event,
  // and called read() to consume some data.  that may have triggered
  // in turn another _read(n) call, in which case reading = true if
  // it's in progress.
  // However, if we're not ended, or reading, and the length < hwm,
  // then go ahead and try to read some more preemptively.
  function maybeReadMore(stream, state) {
    if (!state.readingMore) {
      state.readingMore = true;
      process.nextTick(maybeReadMore_, stream, state);
    }
  }
  function maybeReadMore_(stream, state) {
    // Attempt to read more data if we should.
    //
    // The conditions for reading more data are (one of):
    // - Not enough data buffered (state.length < state.highWaterMark). The loop
    //   is responsible for filling the buffer with enough data if such data
    //   is available. If highWaterMark is 0 and we are not in the flowing mode
    //   we should _not_ attempt to buffer any extra data. We'll get more data
    //   when the stream consumer calls read() instead.
    // - No data in the buffer, and the stream is in flowing mode. In this mode
    //   the loop below is responsible for ensuring read() is called. Failing to
    //   call read here would abort the flow and there's no other mechanism for
    //   continuing the flow if the stream consumer has just subscribed to the
    //   'data' event.
    //
    // In addition to the above conditions to keep reading data, the following
    // conditions prevent the data from being read:
    // - The stream has ended (state.ended).
    // - There is already a pending 'read' operation (state.reading). This is a
    //   case where the the stream has called the implementation defined _read()
    //   method, but they are processing the call asynchronously and have _not_
    //   called push() with new data. In this case we skip performing more
    //   read()s. The execution ends in this method again after the _read() ends
    //   up calling push() with more data.
    while (!state.reading && !state.ended && (state.length < state.highWaterMark || state.flowing && state.length === 0)) {
      var len = state.length;
      debug('maybeReadMore read 0');
      stream.read(0);
      if (len === state.length)
        // didn't get any data, stop spinning.
        break;
    }
    state.readingMore = false;
  }

  // abstract method.  to be overridden in specific implementation classes.
  // call cb(er, data) where data is <= n in length.
  // for virtual (non-string, non-buffer) streams, "length" is somewhat
  // arbitrary, and perhaps not very meaningful.
  Readable.prototype._read = function (n) {
    errorOrDestroy(this, new ERR_METHOD_NOT_IMPLEMENTED('_read()'));
  };
  Readable.prototype.pipe = function (dest, pipeOpts) {
    var src = this;
    var state = this._readableState;
    switch (state.pipesCount) {
      case 0:
        state.pipes = dest;
        break;
      case 1:
        state.pipes = [state.pipes, dest];
        break;
      default:
        state.pipes.push(dest);
        break;
    }
    state.pipesCount += 1;
    debug('pipe count=%d opts=%j', state.pipesCount, pipeOpts);
    var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;
    var endFn = doEnd ? onend : unpipe;
    if (state.endEmitted) process.nextTick(endFn);else src.once('end', endFn);
    dest.on('unpipe', onunpipe);
    function onunpipe(readable, unpipeInfo) {
      debug('onunpipe');
      if (readable === src) {
        if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
          unpipeInfo.hasUnpiped = true;
          cleanup();
        }
      }
    }
    function onend() {
      debug('onend');
      dest.end();
    }

    // when the dest drains, it reduces the awaitDrain counter
    // on the source.  This would be more elegant with a .once()
    // handler in flow(), but adding and removing repeatedly is
    // too slow.
    var ondrain = pipeOnDrain(src);
    dest.on('drain', ondrain);
    var cleanedUp = false;
    function cleanup() {
      debug('cleanup');
      // cleanup event handlers once the pipe is broken
      dest.removeListener('close', onclose);
      dest.removeListener('finish', onfinish);
      dest.removeListener('drain', ondrain);
      dest.removeListener('error', onerror);
      dest.removeListener('unpipe', onunpipe);
      src.removeListener('end', onend);
      src.removeListener('end', unpipe);
      src.removeListener('data', ondata);
      cleanedUp = true;

      // if the reader is waiting for a drain event from this
      // specific writer, then it would cause it to never start
      // flowing again.
      // So, if this is awaiting a drain, then we just call it now.
      // If we don't know, then assume that we are waiting for one.
      if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain)) ondrain();
    }
    src.on('data', ondata);
    function ondata(chunk) {
      debug('ondata');
      var ret = dest.write(chunk);
      debug('dest.write', ret);
      if (ret === false) {
        // If the user unpiped during `dest.write()`, it is possible
        // to get stuck in a permanently paused state if that write
        // also returned false.
        // => Check whether `dest` is still a piping destination.
        if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {
          debug('false write response, pause', state.awaitDrain);
          state.awaitDrain++;
        }
        src.pause();
      }
    }

    // if the dest has an error, then stop piping into it.
    // however, don't suppress the throwing behavior for this.
    function onerror(er) {
      debug('onerror', er);
      unpipe();
      dest.removeListener('error', onerror);
      if (EElistenerCount(dest, 'error') === 0) errorOrDestroy(dest, er);
    }

    // Make sure our error handler is attached before userland ones.
    prependListener(dest, 'error', onerror);

    // Both close and finish should trigger unpipe, but only once.
    function onclose() {
      dest.removeListener('finish', onfinish);
      unpipe();
    }
    dest.once('close', onclose);
    function onfinish() {
      debug('onfinish');
      dest.removeListener('close', onclose);
      unpipe();
    }
    dest.once('finish', onfinish);
    function unpipe() {
      debug('unpipe');
      src.unpipe(dest);
    }

    // tell the dest that it's being piped to
    dest.emit('pipe', src);

    // start the flow if it hasn't been started already.
    if (!state.flowing) {
      debug('pipe resume');
      src.resume();
    }
    return dest;
  };
  function pipeOnDrain(src) {
    return function pipeOnDrainFunctionResult() {
      var state = src._readableState;
      debug('pipeOnDrain', state.awaitDrain);
      if (state.awaitDrain) state.awaitDrain--;
      if (state.awaitDrain === 0 && EElistenerCount(src, 'data')) {
        state.flowing = true;
        flow(src);
      }
    };
  }
  Readable.prototype.unpipe = function (dest) {
    var state = this._readableState;
    var unpipeInfo = {
      hasUnpiped: false
    };

    // if we're not piping anywhere, then do nothing.
    if (state.pipesCount === 0) return this;

    // just one destination.  most common case.
    if (state.pipesCount === 1) {
      // passed in one, but it's not the right one.
      if (dest && dest !== state.pipes) return this;
      if (!dest) dest = state.pipes;

      // got a match.
      state.pipes = null;
      state.pipesCount = 0;
      state.flowing = false;
      if (dest) dest.emit('unpipe', this, unpipeInfo);
      return this;
    }

    // slow case. multiple pipe destinations.

    if (!dest) {
      // remove all.
      var dests = state.pipes;
      var len = state.pipesCount;
      state.pipes = null;
      state.pipesCount = 0;
      state.flowing = false;
      for (var i = 0; i < len; i++) dests[i].emit('unpipe', this, {
        hasUnpiped: false
      });
      return this;
    }

    // try to find the right one.
    var index = indexOf(state.pipes, dest);
    if (index === -1) return this;
    state.pipes.splice(index, 1);
    state.pipesCount -= 1;
    if (state.pipesCount === 1) state.pipes = state.pipes[0];
    dest.emit('unpipe', this, unpipeInfo);
    return this;
  };

  // set up data events if they are asked for
  // Ensure readable listeners eventually get something
  Readable.prototype.on = function (ev, fn) {
    var res = Stream.prototype.on.call(this, ev, fn);
    var state = this._readableState;
    if (ev === 'data') {
      // update readableListening so that resume() may be a no-op
      // a few lines down. This is needed to support once('readable').
      state.readableListening = this.listenerCount('readable') > 0;

      // Try start flowing on next tick if stream isn't explicitly paused
      if (state.flowing !== false) this.resume();
    } else if (ev === 'readable') {
      if (!state.endEmitted && !state.readableListening) {
        state.readableListening = state.needReadable = true;
        state.flowing = false;
        state.emittedReadable = false;
        debug('on readable', state.length, state.reading);
        if (state.length) {
          emitReadable(this);
        } else if (!state.reading) {
          process.nextTick(nReadingNextTick, this);
        }
      }
    }
    return res;
  };
  Readable.prototype.addListener = Readable.prototype.on;
  Readable.prototype.removeListener = function (ev, fn) {
    var res = Stream.prototype.removeListener.call(this, ev, fn);
    if (ev === 'readable') {
      // We need to check if there is someone still listening to
      // readable and reset the state. However this needs to happen
      // after readable has been emitted but before I/O (nextTick) to
      // support once('readable', fn) cycles. This means that calling
      // resume within the same tick will have no
      // effect.
      process.nextTick(updateReadableListening, this);
    }
    return res;
  };
  Readable.prototype.removeAllListeners = function (ev) {
    var res = Stream.prototype.removeAllListeners.apply(this, arguments);
    if (ev === 'readable' || ev === undefined) {
      // We need to check if there is someone still listening to
      // readable and reset the state. However this needs to happen
      // after readable has been emitted but before I/O (nextTick) to
      // support once('readable', fn) cycles. This means that calling
      // resume within the same tick will have no
      // effect.
      process.nextTick(updateReadableListening, this);
    }
    return res;
  };
  function updateReadableListening(self) {
    var state = self._readableState;
    state.readableListening = self.listenerCount('readable') > 0;
    if (state.resumeScheduled && !state.paused) {
      // flowing needs to be set to true now, otherwise
      // the upcoming resume will not flow.
      state.flowing = true;

      // crude way to check if we should resume
    } else if (self.listenerCount('data') > 0) {
      self.resume();
    }
  }
  function nReadingNextTick(self) {
    debug('readable nexttick read 0');
    self.read(0);
  }

  // pause() and resume() are remnants of the legacy readable stream API
  // If the user uses them, then switch into old mode.
  Readable.prototype.resume = function () {
    var state = this._readableState;
    if (!state.flowing) {
      debug('resume');
      // we flow only if there is no one listening
      // for readable, but we still have to call
      // resume()
      state.flowing = !state.readableListening;
      resume(this, state);
    }
    state.paused = false;
    return this;
  };
  function resume(stream, state) {
    if (!state.resumeScheduled) {
      state.resumeScheduled = true;
      process.nextTick(resume_, stream, state);
    }
  }
  function resume_(stream, state) {
    debug('resume', state.reading);
    if (!state.reading) {
      stream.read(0);
    }
    state.resumeScheduled = false;
    stream.emit('resume');
    flow(stream);
    if (state.flowing && !state.reading) stream.read(0);
  }
  Readable.prototype.pause = function () {
    debug('call pause flowing=%j', this._readableState.flowing);
    if (this._readableState.flowing !== false) {
      debug('pause');
      this._readableState.flowing = false;
      this.emit('pause');
    }
    this._readableState.paused = true;
    return this;
  };
  function flow(stream) {
    var state = stream._readableState;
    debug('flow', state.flowing);
    while (state.flowing && stream.read() !== null);
  }

  // wrap an old-style stream as the async data source.
  // This is *not* part of the readable stream interface.
  // It is an ugly unfortunate mess of history.
  Readable.prototype.wrap = function (stream) {
    var _this = this;
    var state = this._readableState;
    var paused = false;
    stream.on('end', function () {
      debug('wrapped end');
      if (state.decoder && !state.ended) {
        var chunk = state.decoder.end();
        if (chunk && chunk.length) _this.push(chunk);
      }
      _this.push(null);
    });
    stream.on('data', function (chunk) {
      debug('wrapped data');
      if (state.decoder) chunk = state.decoder.write(chunk);

      // don't skip over falsy values in objectMode
      if (state.objectMode && (chunk === null || chunk === undefined)) return;else if (!state.objectMode && (!chunk || !chunk.length)) return;
      var ret = _this.push(chunk);
      if (!ret) {
        paused = true;
        stream.pause();
      }
    });

    // proxy all the other methods.
    // important when wrapping filters and duplexes.
    for (var i in stream) {
      if (this[i] === undefined && typeof stream[i] === 'function') {
        this[i] = function methodWrap(method) {
          return function methodWrapReturnFunction() {
            return stream[method].apply(stream, arguments);
          };
        }(i);
      }
    }

    // proxy certain important events.
    for (var n = 0; n < kProxyEvents.length; n++) {
      stream.on(kProxyEvents[n], this.emit.bind(this, kProxyEvents[n]));
    }

    // when we try to consume some more bytes, simply unpause the
    // underlying stream.
    this._read = function (n) {
      debug('wrapped _read', n);
      if (paused) {
        paused = false;
        stream.resume();
      }
    };
    return this;
  };
  if (typeof Symbol === 'function') {
    Readable.prototype[Symbol.asyncIterator] = function () {
      if (createReadableStreamAsyncIterator === undefined) {
        createReadableStreamAsyncIterator = requireAsync_iterator();
      }
      return createReadableStreamAsyncIterator(this);
    };
  }
  Object.defineProperty(Readable.prototype, 'readableHighWaterMark', {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get() {
      return this._readableState.highWaterMark;
    }
  });
  Object.defineProperty(Readable.prototype, 'readableBuffer', {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get() {
      return this._readableState && this._readableState.buffer;
    }
  });
  Object.defineProperty(Readable.prototype, 'readableFlowing', {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get() {
      return this._readableState.flowing;
    },
    set: function set(state) {
      if (this._readableState) {
        this._readableState.flowing = state;
      }
    }
  });

  // exposed for testing purposes only.
  Readable._fromList = fromList;
  Object.defineProperty(Readable.prototype, 'readableLength', {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get() {
      return this._readableState.length;
    }
  });

  // Pluck off n bytes from an array of buffers.
  // Length is the combined lengths of all the buffers in the list.
  // This function is designed to be inlinable, so please take care when making
  // changes to the function body.
  function fromList(n, state) {
    // nothing buffered
    if (state.length === 0) return null;
    var ret;
    if (state.objectMode) ret = state.buffer.shift();else if (!n || n >= state.length) {
      // read it all, truncate the list
      if (state.decoder) ret = state.buffer.join('');else if (state.buffer.length === 1) ret = state.buffer.first();else ret = state.buffer.concat(state.length);
      state.buffer.clear();
    } else {
      // read part of list
      ret = state.buffer.consume(n, state.decoder);
    }
    return ret;
  }
  function endReadable(stream) {
    var state = stream._readableState;
    debug('endReadable', state.endEmitted);
    if (!state.endEmitted) {
      state.ended = true;
      process.nextTick(endReadableNT, state, stream);
    }
  }
  function endReadableNT(state, stream) {
    debug('endReadableNT', state.endEmitted, state.length);

    // Check that we didn't get one last unshift.
    if (!state.endEmitted && state.length === 0) {
      state.endEmitted = true;
      stream.readable = false;
      stream.emit('end');
      if (state.autoDestroy) {
        // In case of duplex streams we need a way to detect
        // if the writable side is ready for autoDestroy as well
        var wState = stream._writableState;
        if (!wState || wState.autoDestroy && wState.finished) {
          stream.destroy();
        }
      }
    }
  }
  if (typeof Symbol === 'function') {
    Readable.from = function (iterable, opts) {
      if (from === undefined) {
        from = requireFromBrowser();
      }
      return from(Readable, iterable, opts);
    };
  }
  function indexOf(xs, x) {
    for (var i = 0, l = xs.length; i < l; i++) {
      if (xs[i] === x) return i;
    }
    return -1;
  }
  return _stream_readable;
}

var _stream_transform = Transform$4;
var _require$codes$1 = errorsBrowser.codes,
  ERR_METHOD_NOT_IMPLEMENTED = _require$codes$1.ERR_METHOD_NOT_IMPLEMENTED,
  ERR_MULTIPLE_CALLBACK = _require$codes$1.ERR_MULTIPLE_CALLBACK,
  ERR_TRANSFORM_ALREADY_TRANSFORMING = _require$codes$1.ERR_TRANSFORM_ALREADY_TRANSFORMING,
  ERR_TRANSFORM_WITH_LENGTH_0 = _require$codes$1.ERR_TRANSFORM_WITH_LENGTH_0;
var Duplex$1 = require_stream_duplex();
inherits_browserExports(Transform$4, Duplex$1);
function afterTransform$1(er, data) {
  var ts = this._transformState;
  ts.transforming = false;
  var cb = ts.writecb;
  if (cb === null) {
    return this.emit('error', new ERR_MULTIPLE_CALLBACK());
  }
  ts.writechunk = null;
  ts.writecb = null;
  if (data != null)
    // single equals check for both `null` and `undefined`
    this.push(data);
  cb(er);
  var rs = this._readableState;
  rs.reading = false;
  if (rs.needReadable || rs.length < rs.highWaterMark) {
    this._read(rs.highWaterMark);
  }
}
function Transform$4(options) {
  if (!(this instanceof Transform$4)) return new Transform$4(options);
  Duplex$1.call(this, options);
  this._transformState = {
    afterTransform: afterTransform$1.bind(this),
    needTransform: false,
    transforming: false,
    writecb: null,
    writechunk: null,
    writeencoding: null
  };

  // start out asking for a readable event once data is transformed.
  this._readableState.needReadable = true;

  // we have implemented the _read method, and done the other things
  // that Readable wants before the first _read call, so unset the
  // sync guard flag.
  this._readableState.sync = false;
  if (options) {
    if (typeof options.transform === 'function') this._transform = options.transform;
    if (typeof options.flush === 'function') this._flush = options.flush;
  }

  // When the writable side finishes, then flush out anything remaining.
  this.on('prefinish', prefinish$1);
}
function prefinish$1() {
  var _this = this;
  if (typeof this._flush === 'function' && !this._readableState.destroyed) {
    this._flush(function (er, data) {
      done$1(_this, er, data);
    });
  } else {
    done$1(this, null, null);
  }
}
Transform$4.prototype.push = function (chunk, encoding) {
  this._transformState.needTransform = false;
  return Duplex$1.prototype.push.call(this, chunk, encoding);
};

// This is the part where you do stuff!
// override this function in implementation classes.
// 'chunk' is an input chunk.
//
// Call `push(newChunk)` to pass along transformed output
// to the readable side.  You may call 'push' zero or more times.
//
// Call `cb(err)` when you are done with this chunk.  If you pass
// an error, then that'll put the hurt on the whole operation.  If you
// never call cb(), then you'll never get another chunk.
Transform$4.prototype._transform = function (chunk, encoding, cb) {
  cb(new ERR_METHOD_NOT_IMPLEMENTED('_transform()'));
};
Transform$4.prototype._write = function (chunk, encoding, cb) {
  var ts = this._transformState;
  ts.writecb = cb;
  ts.writechunk = chunk;
  ts.writeencoding = encoding;
  if (!ts.transforming) {
    var rs = this._readableState;
    if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark) this._read(rs.highWaterMark);
  }
};

// Doesn't matter what the args are here.
// _transform does all the work.
// That we got here means that the readable side wants more data.
Transform$4.prototype._read = function (n) {
  var ts = this._transformState;
  if (ts.writechunk !== null && !ts.transforming) {
    ts.transforming = true;
    this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
  } else {
    // mark that we need a transform, so that any data that comes in
    // will get processed, now that we've asked for it.
    ts.needTransform = true;
  }
};
Transform$4.prototype._destroy = function (err, cb) {
  Duplex$1.prototype._destroy.call(this, err, function (err2) {
    cb(err2);
  });
};
function done$1(stream, er, data) {
  if (er) return stream.emit('error', er);
  if (data != null)
    // single equals check for both `null` and `undefined`
    stream.push(data);

  // TODO(BridgeAR): Write a test for these two error cases
  // if there's nothing in the write buffer, then that means
  // that nothing more will ever be provided
  if (stream._writableState.length) throw new ERR_TRANSFORM_WITH_LENGTH_0();
  if (stream._transformState.transforming) throw new ERR_TRANSFORM_ALREADY_TRANSFORMING();
  return stream.push(null);
}

var _stream_passthrough = PassThrough$1;
var Transform$3 = _stream_transform;
inherits_browserExports(PassThrough$1, Transform$3);
function PassThrough$1(options) {
  if (!(this instanceof PassThrough$1)) return new PassThrough$1(options);
  Transform$3.call(this, options);
}
PassThrough$1.prototype._transform = function (chunk, encoding, cb) {
  cb(null, chunk);
};

var eos;
function once(callback) {
  var called = false;
  return function () {
    if (called) return;
    called = true;
    callback.apply(void 0, arguments);
  };
}
var _require$codes = errorsBrowser.codes,
  ERR_MISSING_ARGS = _require$codes.ERR_MISSING_ARGS,
  ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED;
function noop(err) {
  // Rethrow the error if it exists to avoid swallowing it
  if (err) throw err;
}
function isRequest(stream) {
  return stream.setHeader && typeof stream.abort === 'function';
}
function destroyer(stream, reading, writing, callback) {
  callback = once(callback);
  var closed = false;
  stream.on('close', function () {
    closed = true;
  });
  if (eos === undefined) eos = endOfStream;
  eos(stream, {
    readable: reading,
    writable: writing
  }, function (err) {
    if (err) return callback(err);
    closed = true;
    callback();
  });
  var destroyed = false;
  return function (err) {
    if (closed) return;
    if (destroyed) return;
    destroyed = true;

    // request.destroy just do .end - .abort is what we want
    if (isRequest(stream)) return stream.abort();
    if (typeof stream.destroy === 'function') return stream.destroy();
    callback(err || new ERR_STREAM_DESTROYED('pipe'));
  };
}
function call(fn) {
  fn();
}
function pipe(from, to) {
  return from.pipe(to);
}
function popCallback(streams) {
  if (!streams.length) return noop;
  if (typeof streams[streams.length - 1] !== 'function') return noop;
  return streams.pop();
}
function pipeline() {
  for (var _len = arguments.length, streams = new Array(_len), _key = 0; _key < _len; _key++) {
    streams[_key] = arguments[_key];
  }
  var callback = popCallback(streams);
  if (Array.isArray(streams[0])) streams = streams[0];
  if (streams.length < 2) {
    throw new ERR_MISSING_ARGS('streams');
  }
  var error;
  var destroys = streams.map(function (stream, i) {
    var reading = i < streams.length - 1;
    var writing = i > 0;
    return destroyer(stream, reading, writing, function (err) {
      if (!error) error = err;
      if (err) destroys.forEach(call);
      if (reading) return;
      destroys.forEach(call);
      callback(error);
    });
  });
  return streams.reduce(pipe);
}
var pipeline_1 = pipeline;

readableBrowser.exports;
(function (module, exports) {
  exports = module.exports = require_stream_readable();
  exports.Stream = exports;
  exports.Readable = exports;
  exports.Writable = require_stream_writable();
  exports.Duplex = require_stream_duplex();
  exports.Transform = _stream_transform;
  exports.PassThrough = _stream_passthrough;
  exports.finished = endOfStream;
  exports.pipeline = pipeline_1;
})(readableBrowser, readableBrowser.exports);
var readableBrowserExports = readableBrowser.exports;

var Buffer$c = safeBufferExports.Buffer;
var Transform$2 = readableBrowserExports.Transform;
var inherits$a = inherits_browserExports;
function throwIfNotStringOrBuffer(val, prefix) {
  if (!Buffer$c.isBuffer(val) && typeof val !== 'string') {
    throw new TypeError(prefix + ' must be a string or a buffer');
  }
}
function HashBase$2(blockSize) {
  Transform$2.call(this);
  this._block = Buffer$c.allocUnsafe(blockSize);
  this._blockSize = blockSize;
  this._blockOffset = 0;
  this._length = [0, 0, 0, 0];
  this._finalized = false;
}
inherits$a(HashBase$2, Transform$2);
HashBase$2.prototype._transform = function (chunk, encoding, callback) {
  var error = null;
  try {
    this.update(chunk, encoding);
  } catch (err) {
    error = err;
  }
  callback(error);
};
HashBase$2.prototype._flush = function (callback) {
  var error = null;
  try {
    this.push(this.digest());
  } catch (err) {
    error = err;
  }
  callback(error);
};
HashBase$2.prototype.update = function (data, encoding) {
  throwIfNotStringOrBuffer(data, 'Data');
  if (this._finalized) throw new Error('Digest already called');
  if (!Buffer$c.isBuffer(data)) data = Buffer$c.from(data, encoding);

  // consume data
  var block = this._block;
  var offset = 0;
  while (this._blockOffset + data.length - offset >= this._blockSize) {
    for (var i = this._blockOffset; i < this._blockSize;) block[i++] = data[offset++];
    this._update();
    this._blockOffset = 0;
  }
  while (offset < data.length) block[this._blockOffset++] = data[offset++];

  // update length
  for (var j = 0, carry = data.length * 8; carry > 0; ++j) {
    this._length[j] += carry;
    carry = this._length[j] / 0x0100000000 | 0;
    if (carry > 0) this._length[j] -= 0x0100000000 * carry;
  }
  return this;
};
HashBase$2.prototype._update = function () {
  throw new Error('_update is not implemented');
};
HashBase$2.prototype.digest = function (encoding) {
  if (this._finalized) throw new Error('Digest already called');
  this._finalized = true;
  var digest = this._digest();
  if (encoding !== undefined) digest = digest.toString(encoding);

  // reset state
  this._block.fill(0);
  this._blockOffset = 0;
  for (var i = 0; i < 4; ++i) this._length[i] = 0;
  return digest;
};
HashBase$2.prototype._digest = function () {
  throw new Error('_digest is not implemented');
};
var hashBase = HashBase$2;

var inherits$9 = inherits_browserExports;
var HashBase$1 = hashBase;
var Buffer$b = safeBufferExports.Buffer;
var ARRAY16$1 = new Array(16);
function MD5$1() {
  HashBase$1.call(this, 64);

  // state
  this._a = 0x67452301;
  this._b = 0xefcdab89;
  this._c = 0x98badcfe;
  this._d = 0x10325476;
}
inherits$9(MD5$1, HashBase$1);
MD5$1.prototype._update = function () {
  var M = ARRAY16$1;
  for (var i = 0; i < 16; ++i) M[i] = this._block.readInt32LE(i * 4);
  var a = this._a;
  var b = this._b;
  var c = this._c;
  var d = this._d;
  a = fnF(a, b, c, d, M[0], 0xd76aa478, 7);
  d = fnF(d, a, b, c, M[1], 0xe8c7b756, 12);
  c = fnF(c, d, a, b, M[2], 0x242070db, 17);
  b = fnF(b, c, d, a, M[3], 0xc1bdceee, 22);
  a = fnF(a, b, c, d, M[4], 0xf57c0faf, 7);
  d = fnF(d, a, b, c, M[5], 0x4787c62a, 12);
  c = fnF(c, d, a, b, M[6], 0xa8304613, 17);
  b = fnF(b, c, d, a, M[7], 0xfd469501, 22);
  a = fnF(a, b, c, d, M[8], 0x698098d8, 7);
  d = fnF(d, a, b, c, M[9], 0x8b44f7af, 12);
  c = fnF(c, d, a, b, M[10], 0xffff5bb1, 17);
  b = fnF(b, c, d, a, M[11], 0x895cd7be, 22);
  a = fnF(a, b, c, d, M[12], 0x6b901122, 7);
  d = fnF(d, a, b, c, M[13], 0xfd987193, 12);
  c = fnF(c, d, a, b, M[14], 0xa679438e, 17);
  b = fnF(b, c, d, a, M[15], 0x49b40821, 22);
  a = fnG(a, b, c, d, M[1], 0xf61e2562, 5);
  d = fnG(d, a, b, c, M[6], 0xc040b340, 9);
  c = fnG(c, d, a, b, M[11], 0x265e5a51, 14);
  b = fnG(b, c, d, a, M[0], 0xe9b6c7aa, 20);
  a = fnG(a, b, c, d, M[5], 0xd62f105d, 5);
  d = fnG(d, a, b, c, M[10], 0x02441453, 9);
  c = fnG(c, d, a, b, M[15], 0xd8a1e681, 14);
  b = fnG(b, c, d, a, M[4], 0xe7d3fbc8, 20);
  a = fnG(a, b, c, d, M[9], 0x21e1cde6, 5);
  d = fnG(d, a, b, c, M[14], 0xc33707d6, 9);
  c = fnG(c, d, a, b, M[3], 0xf4d50d87, 14);
  b = fnG(b, c, d, a, M[8], 0x455a14ed, 20);
  a = fnG(a, b, c, d, M[13], 0xa9e3e905, 5);
  d = fnG(d, a, b, c, M[2], 0xfcefa3f8, 9);
  c = fnG(c, d, a, b, M[7], 0x676f02d9, 14);
  b = fnG(b, c, d, a, M[12], 0x8d2a4c8a, 20);
  a = fnH(a, b, c, d, M[5], 0xfffa3942, 4);
  d = fnH(d, a, b, c, M[8], 0x8771f681, 11);
  c = fnH(c, d, a, b, M[11], 0x6d9d6122, 16);
  b = fnH(b, c, d, a, M[14], 0xfde5380c, 23);
  a = fnH(a, b, c, d, M[1], 0xa4beea44, 4);
  d = fnH(d, a, b, c, M[4], 0x4bdecfa9, 11);
  c = fnH(c, d, a, b, M[7], 0xf6bb4b60, 16);
  b = fnH(b, c, d, a, M[10], 0xbebfbc70, 23);
  a = fnH(a, b, c, d, M[13], 0x289b7ec6, 4);
  d = fnH(d, a, b, c, M[0], 0xeaa127fa, 11);
  c = fnH(c, d, a, b, M[3], 0xd4ef3085, 16);
  b = fnH(b, c, d, a, M[6], 0x04881d05, 23);
  a = fnH(a, b, c, d, M[9], 0xd9d4d039, 4);
  d = fnH(d, a, b, c, M[12], 0xe6db99e5, 11);
  c = fnH(c, d, a, b, M[15], 0x1fa27cf8, 16);
  b = fnH(b, c, d, a, M[2], 0xc4ac5665, 23);
  a = fnI(a, b, c, d, M[0], 0xf4292244, 6);
  d = fnI(d, a, b, c, M[7], 0x432aff97, 10);
  c = fnI(c, d, a, b, M[14], 0xab9423a7, 15);
  b = fnI(b, c, d, a, M[5], 0xfc93a039, 21);
  a = fnI(a, b, c, d, M[12], 0x655b59c3, 6);
  d = fnI(d, a, b, c, M[3], 0x8f0ccc92, 10);
  c = fnI(c, d, a, b, M[10], 0xffeff47d, 15);
  b = fnI(b, c, d, a, M[1], 0x85845dd1, 21);
  a = fnI(a, b, c, d, M[8], 0x6fa87e4f, 6);
  d = fnI(d, a, b, c, M[15], 0xfe2ce6e0, 10);
  c = fnI(c, d, a, b, M[6], 0xa3014314, 15);
  b = fnI(b, c, d, a, M[13], 0x4e0811a1, 21);
  a = fnI(a, b, c, d, M[4], 0xf7537e82, 6);
  d = fnI(d, a, b, c, M[11], 0xbd3af235, 10);
  c = fnI(c, d, a, b, M[2], 0x2ad7d2bb, 15);
  b = fnI(b, c, d, a, M[9], 0xeb86d391, 21);
  this._a = this._a + a | 0;
  this._b = this._b + b | 0;
  this._c = this._c + c | 0;
  this._d = this._d + d | 0;
};
MD5$1.prototype._digest = function () {
  // create padding and handle blocks
  this._block[this._blockOffset++] = 0x80;
  if (this._blockOffset > 56) {
    this._block.fill(0, this._blockOffset, 64);
    this._update();
    this._blockOffset = 0;
  }
  this._block.fill(0, this._blockOffset, 56);
  this._block.writeUInt32LE(this._length[0], 56);
  this._block.writeUInt32LE(this._length[1], 60);
  this._update();

  // produce result
  var buffer = Buffer$b.allocUnsafe(16);
  buffer.writeInt32LE(this._a, 0);
  buffer.writeInt32LE(this._b, 4);
  buffer.writeInt32LE(this._c, 8);
  buffer.writeInt32LE(this._d, 12);
  return buffer;
};
function rotl$1(x, n) {
  return x << n | x >>> 32 - n;
}
function fnF(a, b, c, d, m, k, s) {
  return rotl$1(a + (b & c | ~b & d) + m + k | 0, s) + b | 0;
}
function fnG(a, b, c, d, m, k, s) {
  return rotl$1(a + (b & d | c & ~d) + m + k | 0, s) + b | 0;
}
function fnH(a, b, c, d, m, k, s) {
  return rotl$1(a + (b ^ c ^ d) + m + k | 0, s) + b | 0;
}
function fnI(a, b, c, d, m, k, s) {
  return rotl$1(a + (c ^ (b | ~d)) + m + k | 0, s) + b | 0;
}
var md5_js = MD5$1;

var Buffer$a = require$$0$1.Buffer;
var inherits$8 = inherits_browserExports;
var HashBase = hashBase;
var ARRAY16 = new Array(16);
var zl = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8, 3, 10, 14, 4, 9, 15, 8, 1, 2, 7, 0, 6, 13, 11, 5, 12, 1, 9, 11, 10, 0, 8, 12, 4, 13, 3, 7, 15, 14, 5, 6, 2, 4, 0, 5, 9, 7, 12, 2, 10, 14, 1, 3, 8, 11, 6, 15, 13];
var zr = [5, 14, 7, 0, 9, 2, 11, 4, 13, 6, 15, 8, 1, 10, 3, 12, 6, 11, 3, 7, 0, 13, 5, 10, 14, 15, 8, 12, 4, 9, 1, 2, 15, 5, 1, 3, 7, 14, 6, 9, 11, 8, 12, 2, 10, 0, 4, 13, 8, 6, 4, 1, 3, 11, 15, 0, 5, 12, 2, 13, 9, 7, 10, 14, 12, 15, 10, 4, 1, 5, 8, 7, 6, 2, 13, 14, 0, 3, 9, 11];
var sl = [11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8, 7, 6, 8, 13, 11, 9, 7, 15, 7, 12, 15, 9, 11, 7, 13, 12, 11, 13, 6, 7, 14, 9, 13, 15, 14, 8, 13, 6, 5, 12, 7, 5, 11, 12, 14, 15, 14, 15, 9, 8, 9, 14, 5, 6, 8, 6, 5, 12, 9, 15, 5, 11, 6, 8, 13, 12, 5, 12, 13, 14, 11, 8, 5, 6];
var sr = [8, 9, 9, 11, 13, 15, 15, 5, 7, 7, 8, 11, 14, 14, 12, 6, 9, 13, 15, 7, 12, 8, 9, 11, 7, 7, 12, 7, 6, 15, 13, 11, 9, 7, 15, 11, 8, 6, 6, 14, 12, 13, 5, 14, 13, 13, 7, 5, 15, 5, 8, 11, 14, 14, 6, 14, 6, 9, 12, 9, 12, 5, 15, 8, 8, 5, 12, 9, 12, 5, 14, 6, 8, 13, 6, 5, 15, 13, 11, 11];
var hl = [0x00000000, 0x5a827999, 0x6ed9eba1, 0x8f1bbcdc, 0xa953fd4e];
var hr = [0x50a28be6, 0x5c4dd124, 0x6d703ef3, 0x7a6d76e9, 0x00000000];
function RIPEMD160$1() {
  HashBase.call(this, 64);

  // state
  this._a = 0x67452301;
  this._b = 0xefcdab89;
  this._c = 0x98badcfe;
  this._d = 0x10325476;
  this._e = 0xc3d2e1f0;
}
inherits$8(RIPEMD160$1, HashBase);
RIPEMD160$1.prototype._update = function () {
  var words = ARRAY16;
  for (var j = 0; j < 16; ++j) words[j] = this._block.readInt32LE(j * 4);
  var al = this._a | 0;
  var bl = this._b | 0;
  var cl = this._c | 0;
  var dl = this._d | 0;
  var el = this._e | 0;
  var ar = this._a | 0;
  var br = this._b | 0;
  var cr = this._c | 0;
  var dr = this._d | 0;
  var er = this._e | 0;

  // computation
  for (var i = 0; i < 80; i += 1) {
    var tl;
    var tr;
    if (i < 16) {
      tl = fn1(al, bl, cl, dl, el, words[zl[i]], hl[0], sl[i]);
      tr = fn5(ar, br, cr, dr, er, words[zr[i]], hr[0], sr[i]);
    } else if (i < 32) {
      tl = fn2(al, bl, cl, dl, el, words[zl[i]], hl[1], sl[i]);
      tr = fn4(ar, br, cr, dr, er, words[zr[i]], hr[1], sr[i]);
    } else if (i < 48) {
      tl = fn3(al, bl, cl, dl, el, words[zl[i]], hl[2], sl[i]);
      tr = fn3(ar, br, cr, dr, er, words[zr[i]], hr[2], sr[i]);
    } else if (i < 64) {
      tl = fn4(al, bl, cl, dl, el, words[zl[i]], hl[3], sl[i]);
      tr = fn2(ar, br, cr, dr, er, words[zr[i]], hr[3], sr[i]);
    } else {
      // if (i<80) {
      tl = fn5(al, bl, cl, dl, el, words[zl[i]], hl[4], sl[i]);
      tr = fn1(ar, br, cr, dr, er, words[zr[i]], hr[4], sr[i]);
    }
    al = el;
    el = dl;
    dl = rotl(cl, 10);
    cl = bl;
    bl = tl;
    ar = er;
    er = dr;
    dr = rotl(cr, 10);
    cr = br;
    br = tr;
  }

  // update state
  var t = this._b + cl + dr | 0;
  this._b = this._c + dl + er | 0;
  this._c = this._d + el + ar | 0;
  this._d = this._e + al + br | 0;
  this._e = this._a + bl + cr | 0;
  this._a = t;
};
RIPEMD160$1.prototype._digest = function () {
  // create padding and handle blocks
  this._block[this._blockOffset++] = 0x80;
  if (this._blockOffset > 56) {
    this._block.fill(0, this._blockOffset, 64);
    this._update();
    this._blockOffset = 0;
  }
  this._block.fill(0, this._blockOffset, 56);
  this._block.writeUInt32LE(this._length[0], 56);
  this._block.writeUInt32LE(this._length[1], 60);
  this._update();

  // produce result
  var buffer = Buffer$a.alloc ? Buffer$a.alloc(20) : new Buffer$a(20);
  buffer.writeInt32LE(this._a, 0);
  buffer.writeInt32LE(this._b, 4);
  buffer.writeInt32LE(this._c, 8);
  buffer.writeInt32LE(this._d, 12);
  buffer.writeInt32LE(this._e, 16);
  return buffer;
};
function rotl(x, n) {
  return x << n | x >>> 32 - n;
}
function fn1(a, b, c, d, e, m, k, s) {
  return rotl(a + (b ^ c ^ d) + m + k | 0, s) + e | 0;
}
function fn2(a, b, c, d, e, m, k, s) {
  return rotl(a + (b & c | ~b & d) + m + k | 0, s) + e | 0;
}
function fn3(a, b, c, d, e, m, k, s) {
  return rotl(a + ((b | ~c) ^ d) + m + k | 0, s) + e | 0;
}
function fn4(a, b, c, d, e, m, k, s) {
  return rotl(a + (b & d | c & ~d) + m + k | 0, s) + e | 0;
}
function fn5(a, b, c, d, e, m, k, s) {
  return rotl(a + (b ^ (c | ~d)) + m + k | 0, s) + e | 0;
}
var ripemd160 = RIPEMD160$1;

var sha_js = {exports: {}};

var Buffer$9 = safeBufferExports.Buffer;

// prototype class for hash functions
function Hash$7(blockSize, finalSize) {
  this._block = Buffer$9.alloc(blockSize);
  this._finalSize = finalSize;
  this._blockSize = blockSize;
  this._len = 0;
}
Hash$7.prototype.update = function (data, enc) {
  if (typeof data === 'string') {
    enc = enc || 'utf8';
    data = Buffer$9.from(data, enc);
  }
  var block = this._block;
  var blockSize = this._blockSize;
  var length = data.length;
  var accum = this._len;
  for (var offset = 0; offset < length;) {
    var assigned = accum % blockSize;
    var remainder = Math.min(length - offset, blockSize - assigned);
    for (var i = 0; i < remainder; i++) {
      block[assigned + i] = data[offset + i];
    }
    accum += remainder;
    offset += remainder;
    if (accum % blockSize === 0) {
      this._update(block);
    }
  }
  this._len += length;
  return this;
};
Hash$7.prototype.digest = function (enc) {
  var rem = this._len % this._blockSize;
  this._block[rem] = 0x80;

  // zero (rem + 1) trailing bits, where (rem + 1) is the smallest
  // non-negative solution to the equation (length + 1 + (rem + 1)) === finalSize mod blockSize
  this._block.fill(0, rem + 1);
  if (rem >= this._finalSize) {
    this._update(this._block);
    this._block.fill(0);
  }
  var bits = this._len * 8;

  // uint32
  if (bits <= 0xffffffff) {
    this._block.writeUInt32BE(bits, this._blockSize - 4);

    // uint64
  } else {
    var lowBits = (bits & 0xffffffff) >>> 0;
    var highBits = (bits - lowBits) / 0x100000000;
    this._block.writeUInt32BE(highBits, this._blockSize - 8);
    this._block.writeUInt32BE(lowBits, this._blockSize - 4);
  }
  this._update(this._block);
  var hash = this._hash();
  return enc ? hash.toString(enc) : hash;
};
Hash$7.prototype._update = function () {
  throw new Error('_update must be implemented by subclass');
};
var hash = Hash$7;

/*
 * A JavaScript implementation of the Secure Hash Algorithm, SHA-0, as defined
 * in FIPS PUB 180-1
 * This source code is derived from sha1.js of the same repository.
 * The difference between SHA-0 and SHA-1 is just a bitwise rotate left
 * operation was added.
 */
var inherits$7 = inherits_browserExports;
var Hash$6 = hash;
var Buffer$8 = safeBufferExports.Buffer;
var K$3 = [0x5a827999, 0x6ed9eba1, 0x8f1bbcdc | 0, 0xca62c1d6 | 0];
var W$5 = new Array(80);
function Sha() {
  this.init();
  this._w = W$5;
  Hash$6.call(this, 64, 56);
}
inherits$7(Sha, Hash$6);
Sha.prototype.init = function () {
  this._a = 0x67452301;
  this._b = 0xefcdab89;
  this._c = 0x98badcfe;
  this._d = 0x10325476;
  this._e = 0xc3d2e1f0;
  return this;
};
function rotl5$1(num) {
  return num << 5 | num >>> 27;
}
function rotl30$1(num) {
  return num << 30 | num >>> 2;
}
function ft$1(s, b, c, d) {
  if (s === 0) return b & c | ~b & d;
  if (s === 2) return b & c | b & d | c & d;
  return b ^ c ^ d;
}
Sha.prototype._update = function (M) {
  var W = this._w;
  var a = this._a | 0;
  var b = this._b | 0;
  var c = this._c | 0;
  var d = this._d | 0;
  var e = this._e | 0;
  for (var i = 0; i < 16; ++i) W[i] = M.readInt32BE(i * 4);
  for (; i < 80; ++i) W[i] = W[i - 3] ^ W[i - 8] ^ W[i - 14] ^ W[i - 16];
  for (var j = 0; j < 80; ++j) {
    var s = ~~(j / 20);
    var t = rotl5$1(a) + ft$1(s, b, c, d) + e + W[j] + K$3[s] | 0;
    e = d;
    d = c;
    c = rotl30$1(b);
    b = a;
    a = t;
  }
  this._a = a + this._a | 0;
  this._b = b + this._b | 0;
  this._c = c + this._c | 0;
  this._d = d + this._d | 0;
  this._e = e + this._e | 0;
};
Sha.prototype._hash = function () {
  var H = Buffer$8.allocUnsafe(20);
  H.writeInt32BE(this._a | 0, 0);
  H.writeInt32BE(this._b | 0, 4);
  H.writeInt32BE(this._c | 0, 8);
  H.writeInt32BE(this._d | 0, 12);
  H.writeInt32BE(this._e | 0, 16);
  return H;
};
var sha$1 = Sha;

/*
 * A JavaScript implementation of the Secure Hash Algorithm, SHA-1, as defined
 * in FIPS PUB 180-1
 * Version 2.1a Copyright Paul Johnston 2000 - 2002.
 * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
 * Distributed under the BSD License
 * See http://pajhome.org.uk/crypt/md5 for details.
 */
var inherits$6 = inherits_browserExports;
var Hash$5 = hash;
var Buffer$7 = safeBufferExports.Buffer;
var K$2 = [0x5a827999, 0x6ed9eba1, 0x8f1bbcdc | 0, 0xca62c1d6 | 0];
var W$4 = new Array(80);
function Sha1() {
  this.init();
  this._w = W$4;
  Hash$5.call(this, 64, 56);
}
inherits$6(Sha1, Hash$5);
Sha1.prototype.init = function () {
  this._a = 0x67452301;
  this._b = 0xefcdab89;
  this._c = 0x98badcfe;
  this._d = 0x10325476;
  this._e = 0xc3d2e1f0;
  return this;
};
function rotl1(num) {
  return num << 1 | num >>> 31;
}
function rotl5(num) {
  return num << 5 | num >>> 27;
}
function rotl30(num) {
  return num << 30 | num >>> 2;
}
function ft(s, b, c, d) {
  if (s === 0) return b & c | ~b & d;
  if (s === 2) return b & c | b & d | c & d;
  return b ^ c ^ d;
}
Sha1.prototype._update = function (M) {
  var W = this._w;
  var a = this._a | 0;
  var b = this._b | 0;
  var c = this._c | 0;
  var d = this._d | 0;
  var e = this._e | 0;
  for (var i = 0; i < 16; ++i) W[i] = M.readInt32BE(i * 4);
  for (; i < 80; ++i) W[i] = rotl1(W[i - 3] ^ W[i - 8] ^ W[i - 14] ^ W[i - 16]);
  for (var j = 0; j < 80; ++j) {
    var s = ~~(j / 20);
    var t = rotl5(a) + ft(s, b, c, d) + e + W[j] + K$2[s] | 0;
    e = d;
    d = c;
    c = rotl30(b);
    b = a;
    a = t;
  }
  this._a = a + this._a | 0;
  this._b = b + this._b | 0;
  this._c = c + this._c | 0;
  this._d = d + this._d | 0;
  this._e = e + this._e | 0;
};
Sha1.prototype._hash = function () {
  var H = Buffer$7.allocUnsafe(20);
  H.writeInt32BE(this._a | 0, 0);
  H.writeInt32BE(this._b | 0, 4);
  H.writeInt32BE(this._c | 0, 8);
  H.writeInt32BE(this._d | 0, 12);
  H.writeInt32BE(this._e | 0, 16);
  return H;
};
var sha1 = Sha1;

/**
 * A JavaScript implementation of the Secure Hash Algorithm, SHA-256, as defined
 * in FIPS 180-2
 * Version 2.2-beta Copyright Angel Marin, Paul Johnston 2000 - 2009.
 * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
 *
 */
var inherits$5 = inherits_browserExports;
var Hash$4 = hash;
var Buffer$6 = safeBufferExports.Buffer;
var K$1 = [0x428A2F98, 0x71374491, 0xB5C0FBCF, 0xE9B5DBA5, 0x3956C25B, 0x59F111F1, 0x923F82A4, 0xAB1C5ED5, 0xD807AA98, 0x12835B01, 0x243185BE, 0x550C7DC3, 0x72BE5D74, 0x80DEB1FE, 0x9BDC06A7, 0xC19BF174, 0xE49B69C1, 0xEFBE4786, 0x0FC19DC6, 0x240CA1CC, 0x2DE92C6F, 0x4A7484AA, 0x5CB0A9DC, 0x76F988DA, 0x983E5152, 0xA831C66D, 0xB00327C8, 0xBF597FC7, 0xC6E00BF3, 0xD5A79147, 0x06CA6351, 0x14292967, 0x27B70A85, 0x2E1B2138, 0x4D2C6DFC, 0x53380D13, 0x650A7354, 0x766A0ABB, 0x81C2C92E, 0x92722C85, 0xA2BFE8A1, 0xA81A664B, 0xC24B8B70, 0xC76C51A3, 0xD192E819, 0xD6990624, 0xF40E3585, 0x106AA070, 0x19A4C116, 0x1E376C08, 0x2748774C, 0x34B0BCB5, 0x391C0CB3, 0x4ED8AA4A, 0x5B9CCA4F, 0x682E6FF3, 0x748F82EE, 0x78A5636F, 0x84C87814, 0x8CC70208, 0x90BEFFFA, 0xA4506CEB, 0xBEF9A3F7, 0xC67178F2];
var W$3 = new Array(64);
function Sha256$1() {
  this.init();
  this._w = W$3; // new Array(64)

  Hash$4.call(this, 64, 56);
}
inherits$5(Sha256$1, Hash$4);
Sha256$1.prototype.init = function () {
  this._a = 0x6a09e667;
  this._b = 0xbb67ae85;
  this._c = 0x3c6ef372;
  this._d = 0xa54ff53a;
  this._e = 0x510e527f;
  this._f = 0x9b05688c;
  this._g = 0x1f83d9ab;
  this._h = 0x5be0cd19;
  return this;
};
function ch(x, y, z) {
  return z ^ x & (y ^ z);
}
function maj$1(x, y, z) {
  return x & y | z & (x | y);
}
function sigma0$1(x) {
  return (x >>> 2 | x << 30) ^ (x >>> 13 | x << 19) ^ (x >>> 22 | x << 10);
}
function sigma1$1(x) {
  return (x >>> 6 | x << 26) ^ (x >>> 11 | x << 21) ^ (x >>> 25 | x << 7);
}
function gamma0(x) {
  return (x >>> 7 | x << 25) ^ (x >>> 18 | x << 14) ^ x >>> 3;
}
function gamma1(x) {
  return (x >>> 17 | x << 15) ^ (x >>> 19 | x << 13) ^ x >>> 10;
}
Sha256$1.prototype._update = function (M) {
  var W = this._w;
  var a = this._a | 0;
  var b = this._b | 0;
  var c = this._c | 0;
  var d = this._d | 0;
  var e = this._e | 0;
  var f = this._f | 0;
  var g = this._g | 0;
  var h = this._h | 0;
  for (var i = 0; i < 16; ++i) W[i] = M.readInt32BE(i * 4);
  for (; i < 64; ++i) W[i] = gamma1(W[i - 2]) + W[i - 7] + gamma0(W[i - 15]) + W[i - 16] | 0;
  for (var j = 0; j < 64; ++j) {
    var T1 = h + sigma1$1(e) + ch(e, f, g) + K$1[j] + W[j] | 0;
    var T2 = sigma0$1(a) + maj$1(a, b, c) | 0;
    h = g;
    g = f;
    f = e;
    e = d + T1 | 0;
    d = c;
    c = b;
    b = a;
    a = T1 + T2 | 0;
  }
  this._a = a + this._a | 0;
  this._b = b + this._b | 0;
  this._c = c + this._c | 0;
  this._d = d + this._d | 0;
  this._e = e + this._e | 0;
  this._f = f + this._f | 0;
  this._g = g + this._g | 0;
  this._h = h + this._h | 0;
};
Sha256$1.prototype._hash = function () {
  var H = Buffer$6.allocUnsafe(32);
  H.writeInt32BE(this._a, 0);
  H.writeInt32BE(this._b, 4);
  H.writeInt32BE(this._c, 8);
  H.writeInt32BE(this._d, 12);
  H.writeInt32BE(this._e, 16);
  H.writeInt32BE(this._f, 20);
  H.writeInt32BE(this._g, 24);
  H.writeInt32BE(this._h, 28);
  return H;
};
var sha256 = Sha256$1;

/**
 * A JavaScript implementation of the Secure Hash Algorithm, SHA-256, as defined
 * in FIPS 180-2
 * Version 2.2-beta Copyright Angel Marin, Paul Johnston 2000 - 2009.
 * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
 *
 */
var inherits$4 = inherits_browserExports;
var Sha256 = sha256;
var Hash$3 = hash;
var Buffer$5 = safeBufferExports.Buffer;
var W$2 = new Array(64);
function Sha224() {
  this.init();
  this._w = W$2; // new Array(64)

  Hash$3.call(this, 64, 56);
}
inherits$4(Sha224, Sha256);
Sha224.prototype.init = function () {
  this._a = 0xc1059ed8;
  this._b = 0x367cd507;
  this._c = 0x3070dd17;
  this._d = 0xf70e5939;
  this._e = 0xffc00b31;
  this._f = 0x68581511;
  this._g = 0x64f98fa7;
  this._h = 0xbefa4fa4;
  return this;
};
Sha224.prototype._hash = function () {
  var H = Buffer$5.allocUnsafe(28);
  H.writeInt32BE(this._a, 0);
  H.writeInt32BE(this._b, 4);
  H.writeInt32BE(this._c, 8);
  H.writeInt32BE(this._d, 12);
  H.writeInt32BE(this._e, 16);
  H.writeInt32BE(this._f, 20);
  H.writeInt32BE(this._g, 24);
  return H;
};
var sha224 = Sha224;

var inherits$3 = inherits_browserExports;
var Hash$2 = hash;
var Buffer$4 = safeBufferExports.Buffer;
var K = [0x428a2f98, 0xd728ae22, 0x71374491, 0x23ef65cd, 0xb5c0fbcf, 0xec4d3b2f, 0xe9b5dba5, 0x8189dbbc, 0x3956c25b, 0xf348b538, 0x59f111f1, 0xb605d019, 0x923f82a4, 0xaf194f9b, 0xab1c5ed5, 0xda6d8118, 0xd807aa98, 0xa3030242, 0x12835b01, 0x45706fbe, 0x243185be, 0x4ee4b28c, 0x550c7dc3, 0xd5ffb4e2, 0x72be5d74, 0xf27b896f, 0x80deb1fe, 0x3b1696b1, 0x9bdc06a7, 0x25c71235, 0xc19bf174, 0xcf692694, 0xe49b69c1, 0x9ef14ad2, 0xefbe4786, 0x384f25e3, 0x0fc19dc6, 0x8b8cd5b5, 0x240ca1cc, 0x77ac9c65, 0x2de92c6f, 0x592b0275, 0x4a7484aa, 0x6ea6e483, 0x5cb0a9dc, 0xbd41fbd4, 0x76f988da, 0x831153b5, 0x983e5152, 0xee66dfab, 0xa831c66d, 0x2db43210, 0xb00327c8, 0x98fb213f, 0xbf597fc7, 0xbeef0ee4, 0xc6e00bf3, 0x3da88fc2, 0xd5a79147, 0x930aa725, 0x06ca6351, 0xe003826f, 0x14292967, 0x0a0e6e70, 0x27b70a85, 0x46d22ffc, 0x2e1b2138, 0x5c26c926, 0x4d2c6dfc, 0x5ac42aed, 0x53380d13, 0x9d95b3df, 0x650a7354, 0x8baf63de, 0x766a0abb, 0x3c77b2a8, 0x81c2c92e, 0x47edaee6, 0x92722c85, 0x1482353b, 0xa2bfe8a1, 0x4cf10364, 0xa81a664b, 0xbc423001, 0xc24b8b70, 0xd0f89791, 0xc76c51a3, 0x0654be30, 0xd192e819, 0xd6ef5218, 0xd6990624, 0x5565a910, 0xf40e3585, 0x5771202a, 0x106aa070, 0x32bbd1b8, 0x19a4c116, 0xb8d2d0c8, 0x1e376c08, 0x5141ab53, 0x2748774c, 0xdf8eeb99, 0x34b0bcb5, 0xe19b48a8, 0x391c0cb3, 0xc5c95a63, 0x4ed8aa4a, 0xe3418acb, 0x5b9cca4f, 0x7763e373, 0x682e6ff3, 0xd6b2b8a3, 0x748f82ee, 0x5defb2fc, 0x78a5636f, 0x43172f60, 0x84c87814, 0xa1f0ab72, 0x8cc70208, 0x1a6439ec, 0x90befffa, 0x23631e28, 0xa4506ceb, 0xde82bde9, 0xbef9a3f7, 0xb2c67915, 0xc67178f2, 0xe372532b, 0xca273ece, 0xea26619c, 0xd186b8c7, 0x21c0c207, 0xeada7dd6, 0xcde0eb1e, 0xf57d4f7f, 0xee6ed178, 0x06f067aa, 0x72176fba, 0x0a637dc5, 0xa2c898a6, 0x113f9804, 0xbef90dae, 0x1b710b35, 0x131c471b, 0x28db77f5, 0x23047d84, 0x32caab7b, 0x40c72493, 0x3c9ebe0a, 0x15c9bebc, 0x431d67c4, 0x9c100d4c, 0x4cc5d4be, 0xcb3e42b6, 0x597f299c, 0xfc657e2a, 0x5fcb6fab, 0x3ad6faec, 0x6c44198c, 0x4a475817];
var W$1 = new Array(160);
function Sha512() {
  this.init();
  this._w = W$1;
  Hash$2.call(this, 128, 112);
}
inherits$3(Sha512, Hash$2);
Sha512.prototype.init = function () {
  this._ah = 0x6a09e667;
  this._bh = 0xbb67ae85;
  this._ch = 0x3c6ef372;
  this._dh = 0xa54ff53a;
  this._eh = 0x510e527f;
  this._fh = 0x9b05688c;
  this._gh = 0x1f83d9ab;
  this._hh = 0x5be0cd19;
  this._al = 0xf3bcc908;
  this._bl = 0x84caa73b;
  this._cl = 0xfe94f82b;
  this._dl = 0x5f1d36f1;
  this._el = 0xade682d1;
  this._fl = 0x2b3e6c1f;
  this._gl = 0xfb41bd6b;
  this._hl = 0x137e2179;
  return this;
};
function Ch(x, y, z) {
  return z ^ x & (y ^ z);
}
function maj(x, y, z) {
  return x & y | z & (x | y);
}
function sigma0(x, xl) {
  return (x >>> 28 | xl << 4) ^ (xl >>> 2 | x << 30) ^ (xl >>> 7 | x << 25);
}
function sigma1(x, xl) {
  return (x >>> 14 | xl << 18) ^ (x >>> 18 | xl << 14) ^ (xl >>> 9 | x << 23);
}
function Gamma0(x, xl) {
  return (x >>> 1 | xl << 31) ^ (x >>> 8 | xl << 24) ^ x >>> 7;
}
function Gamma0l(x, xl) {
  return (x >>> 1 | xl << 31) ^ (x >>> 8 | xl << 24) ^ (x >>> 7 | xl << 25);
}
function Gamma1(x, xl) {
  return (x >>> 19 | xl << 13) ^ (xl >>> 29 | x << 3) ^ x >>> 6;
}
function Gamma1l(x, xl) {
  return (x >>> 19 | xl << 13) ^ (xl >>> 29 | x << 3) ^ (x >>> 6 | xl << 26);
}
function getCarry(a, b) {
  return a >>> 0 < b >>> 0 ? 1 : 0;
}
Sha512.prototype._update = function (M) {
  var W = this._w;
  var ah = this._ah | 0;
  var bh = this._bh | 0;
  var ch = this._ch | 0;
  var dh = this._dh | 0;
  var eh = this._eh | 0;
  var fh = this._fh | 0;
  var gh = this._gh | 0;
  var hh = this._hh | 0;
  var al = this._al | 0;
  var bl = this._bl | 0;
  var cl = this._cl | 0;
  var dl = this._dl | 0;
  var el = this._el | 0;
  var fl = this._fl | 0;
  var gl = this._gl | 0;
  var hl = this._hl | 0;
  for (var i = 0; i < 32; i += 2) {
    W[i] = M.readInt32BE(i * 4);
    W[i + 1] = M.readInt32BE(i * 4 + 4);
  }
  for (; i < 160; i += 2) {
    var xh = W[i - 15 * 2];
    var xl = W[i - 15 * 2 + 1];
    var gamma0 = Gamma0(xh, xl);
    var gamma0l = Gamma0l(xl, xh);
    xh = W[i - 2 * 2];
    xl = W[i - 2 * 2 + 1];
    var gamma1 = Gamma1(xh, xl);
    var gamma1l = Gamma1l(xl, xh);

    // W[i] = gamma0 + W[i - 7] + gamma1 + W[i - 16]
    var Wi7h = W[i - 7 * 2];
    var Wi7l = W[i - 7 * 2 + 1];
    var Wi16h = W[i - 16 * 2];
    var Wi16l = W[i - 16 * 2 + 1];
    var Wil = gamma0l + Wi7l | 0;
    var Wih = gamma0 + Wi7h + getCarry(Wil, gamma0l) | 0;
    Wil = Wil + gamma1l | 0;
    Wih = Wih + gamma1 + getCarry(Wil, gamma1l) | 0;
    Wil = Wil + Wi16l | 0;
    Wih = Wih + Wi16h + getCarry(Wil, Wi16l) | 0;
    W[i] = Wih;
    W[i + 1] = Wil;
  }
  for (var j = 0; j < 160; j += 2) {
    Wih = W[j];
    Wil = W[j + 1];
    var majh = maj(ah, bh, ch);
    var majl = maj(al, bl, cl);
    var sigma0h = sigma0(ah, al);
    var sigma0l = sigma0(al, ah);
    var sigma1h = sigma1(eh, el);
    var sigma1l = sigma1(el, eh);

    // t1 = h + sigma1 + ch + K[j] + W[j]
    var Kih = K[j];
    var Kil = K[j + 1];
    var chh = Ch(eh, fh, gh);
    var chl = Ch(el, fl, gl);
    var t1l = hl + sigma1l | 0;
    var t1h = hh + sigma1h + getCarry(t1l, hl) | 0;
    t1l = t1l + chl | 0;
    t1h = t1h + chh + getCarry(t1l, chl) | 0;
    t1l = t1l + Kil | 0;
    t1h = t1h + Kih + getCarry(t1l, Kil) | 0;
    t1l = t1l + Wil | 0;
    t1h = t1h + Wih + getCarry(t1l, Wil) | 0;

    // t2 = sigma0 + maj
    var t2l = sigma0l + majl | 0;
    var t2h = sigma0h + majh + getCarry(t2l, sigma0l) | 0;
    hh = gh;
    hl = gl;
    gh = fh;
    gl = fl;
    fh = eh;
    fl = el;
    el = dl + t1l | 0;
    eh = dh + t1h + getCarry(el, dl) | 0;
    dh = ch;
    dl = cl;
    ch = bh;
    cl = bl;
    bh = ah;
    bl = al;
    al = t1l + t2l | 0;
    ah = t1h + t2h + getCarry(al, t1l) | 0;
  }
  this._al = this._al + al | 0;
  this._bl = this._bl + bl | 0;
  this._cl = this._cl + cl | 0;
  this._dl = this._dl + dl | 0;
  this._el = this._el + el | 0;
  this._fl = this._fl + fl | 0;
  this._gl = this._gl + gl | 0;
  this._hl = this._hl + hl | 0;
  this._ah = this._ah + ah + getCarry(this._al, al) | 0;
  this._bh = this._bh + bh + getCarry(this._bl, bl) | 0;
  this._ch = this._ch + ch + getCarry(this._cl, cl) | 0;
  this._dh = this._dh + dh + getCarry(this._dl, dl) | 0;
  this._eh = this._eh + eh + getCarry(this._el, el) | 0;
  this._fh = this._fh + fh + getCarry(this._fl, fl) | 0;
  this._gh = this._gh + gh + getCarry(this._gl, gl) | 0;
  this._hh = this._hh + hh + getCarry(this._hl, hl) | 0;
};
Sha512.prototype._hash = function () {
  var H = Buffer$4.allocUnsafe(64);
  function writeInt64BE(h, l, offset) {
    H.writeInt32BE(h, offset);
    H.writeInt32BE(l, offset + 4);
  }
  writeInt64BE(this._ah, this._al, 0);
  writeInt64BE(this._bh, this._bl, 8);
  writeInt64BE(this._ch, this._cl, 16);
  writeInt64BE(this._dh, this._dl, 24);
  writeInt64BE(this._eh, this._el, 32);
  writeInt64BE(this._fh, this._fl, 40);
  writeInt64BE(this._gh, this._gl, 48);
  writeInt64BE(this._hh, this._hl, 56);
  return H;
};
var sha512 = Sha512;

var inherits$2 = inherits_browserExports;
var SHA512 = sha512;
var Hash$1 = hash;
var Buffer$3 = safeBufferExports.Buffer;
var W = new Array(160);
function Sha384() {
  this.init();
  this._w = W;
  Hash$1.call(this, 128, 112);
}
inherits$2(Sha384, SHA512);
Sha384.prototype.init = function () {
  this._ah = 0xcbbb9d5d;
  this._bh = 0x629a292a;
  this._ch = 0x9159015a;
  this._dh = 0x152fecd8;
  this._eh = 0x67332667;
  this._fh = 0x8eb44a87;
  this._gh = 0xdb0c2e0d;
  this._hh = 0x47b5481d;
  this._al = 0xc1059ed8;
  this._bl = 0x367cd507;
  this._cl = 0x3070dd17;
  this._dl = 0xf70e5939;
  this._el = 0xffc00b31;
  this._fl = 0x68581511;
  this._gl = 0x64f98fa7;
  this._hl = 0xbefa4fa4;
  return this;
};
Sha384.prototype._hash = function () {
  var H = Buffer$3.allocUnsafe(48);
  function writeInt64BE(h, l, offset) {
    H.writeInt32BE(h, offset);
    H.writeInt32BE(l, offset + 4);
  }
  writeInt64BE(this._ah, this._al, 0);
  writeInt64BE(this._bh, this._bl, 8);
  writeInt64BE(this._ch, this._cl, 16);
  writeInt64BE(this._dh, this._dl, 24);
  writeInt64BE(this._eh, this._el, 32);
  writeInt64BE(this._fh, this._fl, 40);
  return H;
};
var sha384 = Sha384;

var exports = sha_js.exports = function SHA(algorithm) {
  algorithm = algorithm.toLowerCase();
  var Algorithm = exports[algorithm];
  if (!Algorithm) throw new Error(algorithm + ' is not supported (we accept pull requests)');
  return new Algorithm();
};
exports.sha = sha$1;
exports.sha1 = sha1;
exports.sha224 = sha224;
exports.sha256 = sha256;
exports.sha384 = sha384;
exports.sha512 = sha512;
var sha_jsExports = sha_js.exports;

function BufferList() {
  this.head = null;
  this.tail = null;
  this.length = 0;
}
BufferList.prototype.push = function (v) {
  var entry = {
    data: v,
    next: null
  };
  if (this.length > 0) this.tail.next = entry;else this.head = entry;
  this.tail = entry;
  ++this.length;
};
BufferList.prototype.unshift = function (v) {
  var entry = {
    data: v,
    next: this.head
  };
  if (this.length === 0) this.tail = entry;
  this.head = entry;
  ++this.length;
};
BufferList.prototype.shift = function () {
  if (this.length === 0) return;
  var ret = this.head.data;
  if (this.length === 1) this.head = this.tail = null;else this.head = this.head.next;
  --this.length;
  return ret;
};
BufferList.prototype.clear = function () {
  this.head = this.tail = null;
  this.length = 0;
};
BufferList.prototype.join = function (s) {
  if (this.length === 0) return '';
  var p = this.head;
  var ret = '' + p.data;
  while (p = p.next) {
    ret += s + p.data;
  }
  return ret;
};
BufferList.prototype.concat = function (n) {
  if (this.length === 0) return Buffer$d.alloc(0);
  if (this.length === 1) return this.head.data;
  var ret = Buffer$d.allocUnsafe(n >>> 0);
  var p = this.head;
  var i = 0;
  while (p) {
    p.data.copy(ret, i);
    i += p.data.length;
    p = p.next;
  }
  return ret;
};

// Copyright Joyent, Inc. and other Node contributors.
var isBufferEncoding = Buffer$d.isEncoding || function (encoding) {
  switch (encoding && encoding.toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'binary':
    case 'base64':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
    case 'raw':
      return true;
    default:
      return false;
  }
};
function assertEncoding(encoding) {
  if (encoding && !isBufferEncoding(encoding)) {
    throw new Error('Unknown encoding: ' + encoding);
  }
}

// StringDecoder provides an interface for efficiently splitting a series of
// buffers into a series of JS strings without breaking apart multi-byte
// characters. CESU-8 is handled as part of the UTF-8 encoding.
//
// @TODO Handling all encodings inside a single object makes it very difficult
// to reason about this code, so it should be split up in the future.
// @TODO There should be a utf8-strict encoding that rejects invalid UTF-8 code
// points as used by CESU-8.
function StringDecoder$1(encoding) {
  this.encoding = (encoding || 'utf8').toLowerCase().replace(/[-_]/, '');
  assertEncoding(encoding);
  switch (this.encoding) {
    case 'utf8':
      // CESU-8 represents each of Surrogate Pair by 3-bytes
      this.surrogateSize = 3;
      break;
    case 'ucs2':
    case 'utf16le':
      // UTF-16 represents each of Surrogate Pair by 2-bytes
      this.surrogateSize = 2;
      this.detectIncompleteChar = utf16DetectIncompleteChar;
      break;
    case 'base64':
      // Base-64 stores 3 bytes in 4 chars, and pads the remainder.
      this.surrogateSize = 3;
      this.detectIncompleteChar = base64DetectIncompleteChar;
      break;
    default:
      this.write = passThroughWrite;
      return;
  }

  // Enough space to store all bytes of a single character. UTF-8 needs 4
  // bytes, but CESU-8 may require up to 6 (3 bytes per surrogate).
  this.charBuffer = new Buffer$d(6);
  // Number of bytes received for the current incomplete multi-byte character.
  this.charReceived = 0;
  // Number of bytes expected for the current incomplete multi-byte character.
  this.charLength = 0;
}

// write decodes the given buffer and returns it as JS string that is
// guaranteed to not contain any partial multi-byte characters. Any partial
// character found at the end of the buffer is buffered up, and will be
// returned when calling write again with the remaining bytes.
//
// Note: Converting a Buffer containing an orphan surrogate to a String
// currently works, but converting a String to a Buffer (via `new Buffer`, or
// Buffer#write) will replace incomplete surrogates with the unicode
// replacement character. See https://codereview.chromium.org/121173009/ .
StringDecoder$1.prototype.write = function (buffer) {
  var charStr = '';
  // if our last write ended with an incomplete multibyte character
  while (this.charLength) {
    // determine how many remaining bytes this buffer has to offer for this char
    var available = buffer.length >= this.charLength - this.charReceived ? this.charLength - this.charReceived : buffer.length;

    // add the new bytes to the char buffer
    buffer.copy(this.charBuffer, this.charReceived, 0, available);
    this.charReceived += available;
    if (this.charReceived < this.charLength) {
      // still not enough chars in this buffer? wait for more ...
      return '';
    }

    // remove bytes belonging to the current character from the buffer
    buffer = buffer.slice(available, buffer.length);

    // get the character that was split
    charStr = this.charBuffer.slice(0, this.charLength).toString(this.encoding);

    // CESU-8: lead surrogate (D800-DBFF) is also the incomplete character
    var charCode = charStr.charCodeAt(charStr.length - 1);
    if (charCode >= 0xD800 && charCode <= 0xDBFF) {
      this.charLength += this.surrogateSize;
      charStr = '';
      continue;
    }
    this.charReceived = this.charLength = 0;

    // if there are no more bytes in this buffer, just emit our char
    if (buffer.length === 0) {
      return charStr;
    }
    break;
  }

  // determine and set charLength / charReceived
  this.detectIncompleteChar(buffer);
  var end = buffer.length;
  if (this.charLength) {
    // buffer the incomplete character bytes we got
    buffer.copy(this.charBuffer, 0, buffer.length - this.charReceived, end);
    end -= this.charReceived;
  }
  charStr += buffer.toString(this.encoding, 0, end);
  var end = charStr.length - 1;
  var charCode = charStr.charCodeAt(end);
  // CESU-8: lead surrogate (D800-DBFF) is also the incomplete character
  if (charCode >= 0xD800 && charCode <= 0xDBFF) {
    var size = this.surrogateSize;
    this.charLength += size;
    this.charReceived += size;
    this.charBuffer.copy(this.charBuffer, size, 0, size);
    buffer.copy(this.charBuffer, 0, 0, size);
    return charStr.substring(0, end);
  }

  // or just emit the charStr
  return charStr;
};

// detectIncompleteChar determines if there is an incomplete UTF-8 character at
// the end of the given buffer. If so, it sets this.charLength to the byte
// length that character, and sets this.charReceived to the number of bytes
// that are available for this character.
StringDecoder$1.prototype.detectIncompleteChar = function (buffer) {
  // determine how many bytes we have to check at the end of this buffer
  var i = buffer.length >= 3 ? 3 : buffer.length;

  // Figure out if one of the last i bytes of our buffer announces an
  // incomplete char.
  for (; i > 0; i--) {
    var c = buffer[buffer.length - i];

    // See http://en.wikipedia.org/wiki/UTF-8#Description

    // 110XXXXX
    if (i == 1 && c >> 5 == 0x06) {
      this.charLength = 2;
      break;
    }

    // 1110XXXX
    if (i <= 2 && c >> 4 == 0x0E) {
      this.charLength = 3;
      break;
    }

    // 11110XXX
    if (i <= 3 && c >> 3 == 0x1E) {
      this.charLength = 4;
      break;
    }
  }
  this.charReceived = i;
};
StringDecoder$1.prototype.end = function (buffer) {
  var res = '';
  if (buffer && buffer.length) res = this.write(buffer);
  if (this.charReceived) {
    var cr = this.charReceived;
    var buf = this.charBuffer;
    var enc = this.encoding;
    res += buf.slice(0, cr).toString(enc);
  }
  return res;
};
function passThroughWrite(buffer) {
  return buffer.toString(this.encoding);
}
function utf16DetectIncompleteChar(buffer) {
  this.charReceived = buffer.length % 2;
  this.charLength = this.charReceived ? 2 : 0;
}
function base64DetectIncompleteChar(buffer) {
  this.charReceived = buffer.length % 3;
  this.charLength = this.charReceived ? 3 : 0;
}

var stringDecoder = /*#__PURE__*/Object.freeze({
  __proto__: null,
  StringDecoder: StringDecoder$1
});

Readable.ReadableState = ReadableState;
var debug = debuglog('stream');
inherits$c(Readable, EventEmitter);
function prependListener(emitter, event, fn) {
  // Sadly this is not cacheable as some libraries bundle their own
  // event emitter implementation with them.
  if (typeof emitter.prependListener === 'function') {
    return emitter.prependListener(event, fn);
  } else {
    // This is a hack to make sure that our error handler is attached before any
    // userland ones.  NEVER DO THIS. This is here only because this code needs
    // to continue to work with older versions of Node.js that do not include
    // the prependListener() method. The goal is to eventually remove this hack.
    if (!emitter._events || !emitter._events[event]) emitter.on(event, fn);else if (Array.isArray(emitter._events[event])) emitter._events[event].unshift(fn);else emitter._events[event] = [fn, emitter._events[event]];
  }
}
function listenerCount(emitter, type) {
  return emitter.listeners(type).length;
}
function ReadableState(options, stream) {
  options = options || {};

  // object stream flag. Used to make read(n) ignore n and to
  // make all the buffer merging and length checks go away
  this.objectMode = !!options.objectMode;
  if (stream instanceof Duplex) this.objectMode = this.objectMode || !!options.readableObjectMode;

  // the point at which it stops calling _read() to fill the buffer
  // Note: 0 is a valid value, means "don't call _read preemptively ever"
  var hwm = options.highWaterMark;
  var defaultHwm = this.objectMode ? 16 : 16 * 1024;
  this.highWaterMark = hwm || hwm === 0 ? hwm : defaultHwm;

  // cast to ints.
  this.highWaterMark = ~~this.highWaterMark;

  // A linked list is used to store data chunks instead of an array because the
  // linked list can remove elements from the beginning faster than
  // array.shift()
  this.buffer = new BufferList();
  this.length = 0;
  this.pipes = null;
  this.pipesCount = 0;
  this.flowing = null;
  this.ended = false;
  this.endEmitted = false;
  this.reading = false;

  // a flag to be able to tell if the onwrite cb is called immediately,
  // or on a later tick.  We set this to true at first, because any
  // actions that shouldn't happen until "later" should generally also
  // not happen before the first write call.
  this.sync = true;

  // whenever we return null, then we set a flag to say
  // that we're awaiting a 'readable' event emission.
  this.needReadable = false;
  this.emittedReadable = false;
  this.readableListening = false;
  this.resumeScheduled = false;

  // Crypto is kind of old and crusty.  Historically, its default string
  // encoding is 'binary' so we have to make this configurable.
  // Everything else in the universe uses 'utf8', though.
  this.defaultEncoding = options.defaultEncoding || 'utf8';

  // when piping, we only care about 'readable' events that happen
  // after read()ing all the bytes and not getting any pushback.
  this.ranOut = false;

  // the number of writers that are awaiting a drain event in .pipe()s
  this.awaitDrain = 0;

  // if true, a maybeReadMore has been scheduled
  this.readingMore = false;
  this.decoder = null;
  this.encoding = null;
  if (options.encoding) {
    this.decoder = new StringDecoder$1(options.encoding);
    this.encoding = options.encoding;
  }
}
function Readable(options) {
  if (!(this instanceof Readable)) return new Readable(options);
  this._readableState = new ReadableState(options, this);

  // legacy
  this.readable = true;
  if (options && typeof options.read === 'function') this._read = options.read;
  EventEmitter.call(this);
}

// Manually shove something into the read() buffer.
// This returns true if the highWaterMark has not been hit yet,
// similar to how Writable.write() returns true if you should
// write() some more.
Readable.prototype.push = function (chunk, encoding) {
  var state = this._readableState;
  if (!state.objectMode && typeof chunk === 'string') {
    encoding = encoding || state.defaultEncoding;
    if (encoding !== state.encoding) {
      chunk = Buffer$d.from(chunk, encoding);
      encoding = '';
    }
  }
  return readableAddChunk(this, state, chunk, encoding, false);
};

// Unshift should *always* be something directly out of read()
Readable.prototype.unshift = function (chunk) {
  var state = this._readableState;
  return readableAddChunk(this, state, chunk, '', true);
};
Readable.prototype.isPaused = function () {
  return this._readableState.flowing === false;
};
function readableAddChunk(stream, state, chunk, encoding, addToFront) {
  var er = chunkInvalid(state, chunk);
  if (er) {
    stream.emit('error', er);
  } else if (chunk === null) {
    state.reading = false;
    onEofChunk(stream, state);
  } else if (state.objectMode || chunk && chunk.length > 0) {
    if (state.ended && !addToFront) {
      var e = new Error('stream.push() after EOF');
      stream.emit('error', e);
    } else if (state.endEmitted && addToFront) {
      var _e = new Error('stream.unshift() after end event');
      stream.emit('error', _e);
    } else {
      var skipAdd;
      if (state.decoder && !addToFront && !encoding) {
        chunk = state.decoder.write(chunk);
        skipAdd = !state.objectMode && chunk.length === 0;
      }
      if (!addToFront) state.reading = false;

      // Don't add to the buffer if we've decoded to an empty string chunk and
      // we're not in object mode
      if (!skipAdd) {
        // if we want the data now, just emit it.
        if (state.flowing && state.length === 0 && !state.sync) {
          stream.emit('data', chunk);
          stream.read(0);
        } else {
          // update the buffer info.
          state.length += state.objectMode ? 1 : chunk.length;
          if (addToFront) state.buffer.unshift(chunk);else state.buffer.push(chunk);
          if (state.needReadable) emitReadable(stream);
        }
      }
      maybeReadMore(stream, state);
    }
  } else if (!addToFront) {
    state.reading = false;
  }
  return needMoreData(state);
}

// if it's past the high water mark, we can push in some more.
// Also, if we have no data yet, we can stand some
// more bytes.  This is to work around cases where hwm=0,
// such as the repl.  Also, if the push() triggered a
// readable event, and the user called read(largeNumber) such that
// needReadable was set, then we ought to push more, so that another
// 'readable' event will be triggered.
function needMoreData(state) {
  return !state.ended && (state.needReadable || state.length < state.highWaterMark || state.length === 0);
}

// backwards compatibility.
Readable.prototype.setEncoding = function (enc) {
  this._readableState.decoder = new StringDecoder$1(enc);
  this._readableState.encoding = enc;
  return this;
};

// Don't raise the hwm > 8MB
var MAX_HWM = 0x800000;
function computeNewHighWaterMark(n) {
  if (n >= MAX_HWM) {
    n = MAX_HWM;
  } else {
    // Get the next highest power of 2 to prevent increasing hwm excessively in
    // tiny amounts
    n--;
    n |= n >>> 1;
    n |= n >>> 2;
    n |= n >>> 4;
    n |= n >>> 8;
    n |= n >>> 16;
    n++;
  }
  return n;
}

// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function howMuchToRead(n, state) {
  if (n <= 0 || state.length === 0 && state.ended) return 0;
  if (state.objectMode) return 1;
  if (n !== n) {
    // Only flow one buffer at a time
    if (state.flowing && state.length) return state.buffer.head.data.length;else return state.length;
  }
  // If we're asking for more than the current hwm, then raise the hwm.
  if (n > state.highWaterMark) state.highWaterMark = computeNewHighWaterMark(n);
  if (n <= state.length) return n;
  // Don't have enough
  if (!state.ended) {
    state.needReadable = true;
    return 0;
  }
  return state.length;
}

// you can override either this method, or the async _read(n) below.
Readable.prototype.read = function (n) {
  debug('read', n);
  n = parseInt(n, 10);
  var state = this._readableState;
  var nOrig = n;
  if (n !== 0) state.emittedReadable = false;

  // if we're doing read(0) to trigger a readable event, but we
  // already have a bunch of data in the buffer, then just trigger
  // the 'readable' event and move on.
  if (n === 0 && state.needReadable && (state.length >= state.highWaterMark || state.ended)) {
    debug('read: emitReadable', state.length, state.ended);
    if (state.length === 0 && state.ended) endReadable(this);else emitReadable(this);
    return null;
  }
  n = howMuchToRead(n, state);

  // if we've ended, and we're now clear, then finish it up.
  if (n === 0 && state.ended) {
    if (state.length === 0) endReadable(this);
    return null;
  }

  // All the actual chunk generation logic needs to be
  // *below* the call to _read.  The reason is that in certain
  // synthetic stream cases, such as passthrough streams, _read
  // may be a completely synchronous operation which may change
  // the state of the read buffer, providing enough data when
  // before there was *not* enough.
  //
  // So, the steps are:
  // 1. Figure out what the state of things will be after we do
  // a read from the buffer.
  //
  // 2. If that resulting state will trigger a _read, then call _read.
  // Note that this may be asynchronous, or synchronous.  Yes, it is
  // deeply ugly to write APIs this way, but that still doesn't mean
  // that the Readable class should behave improperly, as streams are
  // designed to be sync/async agnostic.
  // Take note if the _read call is sync or async (ie, if the read call
  // has returned yet), so that we know whether or not it's safe to emit
  // 'readable' etc.
  //
  // 3. Actually pull the requested chunks out of the buffer and return.

  // if we need a readable event, then we need to do some reading.
  var doRead = state.needReadable;
  debug('need readable', doRead);

  // if we currently have less than the highWaterMark, then also read some
  if (state.length === 0 || state.length - n < state.highWaterMark) {
    doRead = true;
    debug('length less than watermark', doRead);
  }

  // however, if we've ended, then there's no point, and if we're already
  // reading, then it's unnecessary.
  if (state.ended || state.reading) {
    doRead = false;
    debug('reading or ended', doRead);
  } else if (doRead) {
    debug('do read');
    state.reading = true;
    state.sync = true;
    // if the length is currently zero, then we *need* a readable event.
    if (state.length === 0) state.needReadable = true;
    // call internal read method
    this._read(state.highWaterMark);
    state.sync = false;
    // If _read pushed data synchronously, then `reading` will be false,
    // and we need to re-evaluate how much data we can return to the user.
    if (!state.reading) n = howMuchToRead(nOrig, state);
  }
  var ret;
  if (n > 0) ret = fromList(n, state);else ret = null;
  if (ret === null) {
    state.needReadable = true;
    n = 0;
  } else {
    state.length -= n;
  }
  if (state.length === 0) {
    // If we have nothing in the buffer, then we want to know
    // as soon as we *do* get something into the buffer.
    if (!state.ended) state.needReadable = true;

    // If we tried to read() past the EOF, then emit end on the next tick.
    if (nOrig !== n && state.ended) endReadable(this);
  }
  if (ret !== null) this.emit('data', ret);
  return ret;
};
function chunkInvalid(state, chunk) {
  var er = null;
  if (!Buffer$d.isBuffer(chunk) && typeof chunk !== 'string' && chunk !== null && chunk !== undefined && !state.objectMode) {
    er = new TypeError('Invalid non-string/buffer chunk');
  }
  return er;
}
function onEofChunk(stream, state) {
  if (state.ended) return;
  if (state.decoder) {
    var chunk = state.decoder.end();
    if (chunk && chunk.length) {
      state.buffer.push(chunk);
      state.length += state.objectMode ? 1 : chunk.length;
    }
  }
  state.ended = true;

  // emit 'readable' now to make sure it gets picked up.
  emitReadable(stream);
}

// Don't emit readable right away in sync mode, because this can trigger
// another read() call => stack overflow.  This way, it might trigger
// a nextTick recursion warning, but that's not so bad.
function emitReadable(stream) {
  var state = stream._readableState;
  state.needReadable = false;
  if (!state.emittedReadable) {
    debug('emitReadable', state.flowing);
    state.emittedReadable = true;
    if (state.sync) nextTick(emitReadable_, stream);else emitReadable_(stream);
  }
}
function emitReadable_(stream) {
  debug('emit readable');
  stream.emit('readable');
  flow(stream);
}

// at this point, the user has presumably seen the 'readable' event,
// and called read() to consume some data.  that may have triggered
// in turn another _read(n) call, in which case reading = true if
// it's in progress.
// However, if we're not ended, or reading, and the length < hwm,
// then go ahead and try to read some more preemptively.
function maybeReadMore(stream, state) {
  if (!state.readingMore) {
    state.readingMore = true;
    nextTick(maybeReadMore_, stream, state);
  }
}
function maybeReadMore_(stream, state) {
  var len = state.length;
  while (!state.reading && !state.flowing && !state.ended && state.length < state.highWaterMark) {
    debug('maybeReadMore read 0');
    stream.read(0);
    if (len === state.length)
      // didn't get any data, stop spinning.
      break;else len = state.length;
  }
  state.readingMore = false;
}

// abstract method.  to be overridden in specific implementation classes.
// call cb(er, data) where data is <= n in length.
// for virtual (non-string, non-buffer) streams, "length" is somewhat
// arbitrary, and perhaps not very meaningful.
Readable.prototype._read = function (n) {
  this.emit('error', new Error('not implemented'));
};
Readable.prototype.pipe = function (dest, pipeOpts) {
  var src = this;
  var state = this._readableState;
  switch (state.pipesCount) {
    case 0:
      state.pipes = dest;
      break;
    case 1:
      state.pipes = [state.pipes, dest];
      break;
    default:
      state.pipes.push(dest);
      break;
  }
  state.pipesCount += 1;
  debug('pipe count=%d opts=%j', state.pipesCount, pipeOpts);
  var doEnd = !pipeOpts || pipeOpts.end !== false;
  var endFn = doEnd ? onend : cleanup;
  if (state.endEmitted) nextTick(endFn);else src.once('end', endFn);
  dest.on('unpipe', onunpipe);
  function onunpipe(readable) {
    debug('onunpipe');
    if (readable === src) {
      cleanup();
    }
  }
  function onend() {
    debug('onend');
    dest.end();
  }

  // when the dest drains, it reduces the awaitDrain counter
  // on the source.  This would be more elegant with a .once()
  // handler in flow(), but adding and removing repeatedly is
  // too slow.
  var ondrain = pipeOnDrain(src);
  dest.on('drain', ondrain);
  var cleanedUp = false;
  function cleanup() {
    debug('cleanup');
    // cleanup event handlers once the pipe is broken
    dest.removeListener('close', onclose);
    dest.removeListener('finish', onfinish);
    dest.removeListener('drain', ondrain);
    dest.removeListener('error', onerror);
    dest.removeListener('unpipe', onunpipe);
    src.removeListener('end', onend);
    src.removeListener('end', cleanup);
    src.removeListener('data', ondata);
    cleanedUp = true;

    // if the reader is waiting for a drain event from this
    // specific writer, then it would cause it to never start
    // flowing again.
    // So, if this is awaiting a drain, then we just call it now.
    // If we don't know, then assume that we are waiting for one.
    if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain)) ondrain();
  }

  // If the user pushes more data while we're writing to dest then we'll end up
  // in ondata again. However, we only want to increase awaitDrain once because
  // dest will only emit one 'drain' event for the multiple writes.
  // => Introduce a guard on increasing awaitDrain.
  var increasedAwaitDrain = false;
  src.on('data', ondata);
  function ondata(chunk) {
    debug('ondata');
    increasedAwaitDrain = false;
    var ret = dest.write(chunk);
    if (false === ret && !increasedAwaitDrain) {
      // If the user unpiped during `dest.write()`, it is possible
      // to get stuck in a permanently paused state if that write
      // also returned false.
      // => Check whether `dest` is still a piping destination.
      if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {
        debug('false write response, pause', src._readableState.awaitDrain);
        src._readableState.awaitDrain++;
        increasedAwaitDrain = true;
      }
      src.pause();
    }
  }

  // if the dest has an error, then stop piping into it.
  // however, don't suppress the throwing behavior for this.
  function onerror(er) {
    debug('onerror', er);
    unpipe();
    dest.removeListener('error', onerror);
    if (listenerCount(dest, 'error') === 0) dest.emit('error', er);
  }

  // Make sure our error handler is attached before userland ones.
  prependListener(dest, 'error', onerror);

  // Both close and finish should trigger unpipe, but only once.
  function onclose() {
    dest.removeListener('finish', onfinish);
    unpipe();
  }
  dest.once('close', onclose);
  function onfinish() {
    debug('onfinish');
    dest.removeListener('close', onclose);
    unpipe();
  }
  dest.once('finish', onfinish);
  function unpipe() {
    debug('unpipe');
    src.unpipe(dest);
  }

  // tell the dest that it's being piped to
  dest.emit('pipe', src);

  // start the flow if it hasn't been started already.
  if (!state.flowing) {
    debug('pipe resume');
    src.resume();
  }
  return dest;
};
function pipeOnDrain(src) {
  return function () {
    var state = src._readableState;
    debug('pipeOnDrain', state.awaitDrain);
    if (state.awaitDrain) state.awaitDrain--;
    if (state.awaitDrain === 0 && src.listeners('data').length) {
      state.flowing = true;
      flow(src);
    }
  };
}
Readable.prototype.unpipe = function (dest) {
  var state = this._readableState;

  // if we're not piping anywhere, then do nothing.
  if (state.pipesCount === 0) return this;

  // just one destination.  most common case.
  if (state.pipesCount === 1) {
    // passed in one, but it's not the right one.
    if (dest && dest !== state.pipes) return this;
    if (!dest) dest = state.pipes;

    // got a match.
    state.pipes = null;
    state.pipesCount = 0;
    state.flowing = false;
    if (dest) dest.emit('unpipe', this);
    return this;
  }

  // slow case. multiple pipe destinations.

  if (!dest) {
    // remove all.
    var dests = state.pipes;
    var len = state.pipesCount;
    state.pipes = null;
    state.pipesCount = 0;
    state.flowing = false;
    for (var _i = 0; _i < len; _i++) {
      dests[_i].emit('unpipe', this);
    }
    return this;
  }

  // try to find the right one.
  var i = indexOf(state.pipes, dest);
  if (i === -1) return this;
  state.pipes.splice(i, 1);
  state.pipesCount -= 1;
  if (state.pipesCount === 1) state.pipes = state.pipes[0];
  dest.emit('unpipe', this);
  return this;
};

// set up data events if they are asked for
// Ensure readable listeners eventually get something
Readable.prototype.on = function (ev, fn) {
  var res = EventEmitter.prototype.on.call(this, ev, fn);
  if (ev === 'data') {
    // Start flowing on next tick if stream isn't explicitly paused
    if (this._readableState.flowing !== false) this.resume();
  } else if (ev === 'readable') {
    var state = this._readableState;
    if (!state.endEmitted && !state.readableListening) {
      state.readableListening = state.needReadable = true;
      state.emittedReadable = false;
      if (!state.reading) {
        nextTick(nReadingNextTick, this);
      } else if (state.length) {
        emitReadable(this);
      }
    }
  }
  return res;
};
Readable.prototype.addListener = Readable.prototype.on;
function nReadingNextTick(self) {
  debug('readable nexttick read 0');
  self.read(0);
}

// pause() and resume() are remnants of the legacy readable stream API
// If the user uses them, then switch into old mode.
Readable.prototype.resume = function () {
  var state = this._readableState;
  if (!state.flowing) {
    debug('resume');
    state.flowing = true;
    resume(this, state);
  }
  return this;
};
function resume(stream, state) {
  if (!state.resumeScheduled) {
    state.resumeScheduled = true;
    nextTick(resume_, stream, state);
  }
}
function resume_(stream, state) {
  if (!state.reading) {
    debug('resume read 0');
    stream.read(0);
  }
  state.resumeScheduled = false;
  state.awaitDrain = 0;
  stream.emit('resume');
  flow(stream);
  if (state.flowing && !state.reading) stream.read(0);
}
Readable.prototype.pause = function () {
  debug('call pause flowing=%j', this._readableState.flowing);
  if (false !== this._readableState.flowing) {
    debug('pause');
    this._readableState.flowing = false;
    this.emit('pause');
  }
  return this;
};
function flow(stream) {
  var state = stream._readableState;
  debug('flow', state.flowing);
  while (state.flowing && stream.read() !== null) {}
}

// wrap an old-style stream as the async data source.
// This is *not* part of the readable stream interface.
// It is an ugly unfortunate mess of history.
Readable.prototype.wrap = function (stream) {
  var state = this._readableState;
  var paused = false;
  var self = this;
  stream.on('end', function () {
    debug('wrapped end');
    if (state.decoder && !state.ended) {
      var chunk = state.decoder.end();
      if (chunk && chunk.length) self.push(chunk);
    }
    self.push(null);
  });
  stream.on('data', function (chunk) {
    debug('wrapped data');
    if (state.decoder) chunk = state.decoder.write(chunk);

    // don't skip over falsy values in objectMode
    if (state.objectMode && (chunk === null || chunk === undefined)) return;else if (!state.objectMode && (!chunk || !chunk.length)) return;
    var ret = self.push(chunk);
    if (!ret) {
      paused = true;
      stream.pause();
    }
  });

  // proxy all the other methods.
  // important when wrapping filters and duplexes.
  for (var i in stream) {
    if (this[i] === undefined && typeof stream[i] === 'function') {
      this[i] = function (method) {
        return function () {
          return stream[method].apply(stream, arguments);
        };
      }(i);
    }
  }

  // proxy certain important events.
  var events = ['error', 'close', 'destroy', 'pause', 'resume'];
  forEach(events, function (ev) {
    stream.on(ev, self.emit.bind(self, ev));
  });

  // when we try to consume some more bytes, simply unpause the
  // underlying stream.
  self._read = function (n) {
    debug('wrapped _read', n);
    if (paused) {
      paused = false;
      stream.resume();
    }
  };
  return self;
};

// exposed for testing purposes only.
Readable._fromList = fromList;

// Pluck off n bytes from an array of buffers.
// Length is the combined lengths of all the buffers in the list.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function fromList(n, state) {
  // nothing buffered
  if (state.length === 0) return null;
  var ret;
  if (state.objectMode) ret = state.buffer.shift();else if (!n || n >= state.length) {
    // read it all, truncate the list
    if (state.decoder) ret = state.buffer.join('');else if (state.buffer.length === 1) ret = state.buffer.head.data;else ret = state.buffer.concat(state.length);
    state.buffer.clear();
  } else {
    // read part of list
    ret = fromListPartial(n, state.buffer, state.decoder);
  }
  return ret;
}

// Extracts only enough buffered data to satisfy the amount requested.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function fromListPartial(n, list, hasStrings) {
  var ret;
  if (n < list.head.data.length) {
    // slice is the same for buffers and strings
    ret = list.head.data.slice(0, n);
    list.head.data = list.head.data.slice(n);
  } else if (n === list.head.data.length) {
    // first chunk is a perfect match
    ret = list.shift();
  } else {
    // result spans more than one buffer
    ret = hasStrings ? copyFromBufferString(n, list) : copyFromBuffer(n, list);
  }
  return ret;
}

// Copies a specified amount of characters from the list of buffered data
// chunks.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function copyFromBufferString(n, list) {
  var p = list.head;
  var c = 1;
  var ret = p.data;
  n -= ret.length;
  while (p = p.next) {
    var str = p.data;
    var nb = n > str.length ? str.length : n;
    if (nb === str.length) ret += str;else ret += str.slice(0, n);
    n -= nb;
    if (n === 0) {
      if (nb === str.length) {
        ++c;
        if (p.next) list.head = p.next;else list.head = list.tail = null;
      } else {
        list.head = p;
        p.data = str.slice(nb);
      }
      break;
    }
    ++c;
  }
  list.length -= c;
  return ret;
}

// Copies a specified amount of bytes from the list of buffered data chunks.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function copyFromBuffer(n, list) {
  var ret = Buffer$d.allocUnsafe(n);
  var p = list.head;
  var c = 1;
  p.data.copy(ret);
  n -= p.data.length;
  while (p = p.next) {
    var buf = p.data;
    var nb = n > buf.length ? buf.length : n;
    buf.copy(ret, ret.length - n, 0, nb);
    n -= nb;
    if (n === 0) {
      if (nb === buf.length) {
        ++c;
        if (p.next) list.head = p.next;else list.head = list.tail = null;
      } else {
        list.head = p;
        p.data = buf.slice(nb);
      }
      break;
    }
    ++c;
  }
  list.length -= c;
  return ret;
}
function endReadable(stream) {
  var state = stream._readableState;

  // If we get here before consuming all the bytes, then that is a
  // bug in node.  Should never happen.
  if (state.length > 0) throw new Error('"endReadable()" called on non-empty stream');
  if (!state.endEmitted) {
    state.ended = true;
    nextTick(endReadableNT, state, stream);
  }
}
function endReadableNT(state, stream) {
  // Check that we didn't get one last unshift.
  if (!state.endEmitted && state.length === 0) {
    state.endEmitted = true;
    stream.readable = false;
    stream.emit('end');
  }
}
function forEach(xs, f) {
  for (var i = 0, l = xs.length; i < l; i++) {
    f(xs[i], i);
  }
}
function indexOf(xs, x) {
  for (var i = 0, l = xs.length; i < l; i++) {
    if (xs[i] === x) return i;
  }
  return -1;
}

// A bit simpler than readable streams.
Writable.WritableState = WritableState;
inherits$c(Writable, EventEmitter);
function nop() {}
function WriteReq(chunk, encoding, cb) {
  this.chunk = chunk;
  this.encoding = encoding;
  this.callback = cb;
  this.next = null;
}
function WritableState(options, stream) {
  Object.defineProperty(this, 'buffer', {
    get: deprecate$1(function () {
      return this.getBuffer();
    }, '_writableState.buffer is deprecated. Use _writableState.getBuffer ' + 'instead.')
  });
  options = options || {};

  // object stream flag to indicate whether or not this stream
  // contains buffers or objects.
  this.objectMode = !!options.objectMode;
  if (stream instanceof Duplex) this.objectMode = this.objectMode || !!options.writableObjectMode;

  // the point at which write() starts returning false
  // Note: 0 is a valid value, means that we always return false if
  // the entire buffer is not flushed immediately on write()
  var hwm = options.highWaterMark;
  var defaultHwm = this.objectMode ? 16 : 16 * 1024;
  this.highWaterMark = hwm || hwm === 0 ? hwm : defaultHwm;

  // cast to ints.
  this.highWaterMark = ~~this.highWaterMark;
  this.needDrain = false;
  // at the start of calling end()
  this.ending = false;
  // when end() has been called, and returned
  this.ended = false;
  // when 'finish' is emitted
  this.finished = false;

  // should we decode strings into buffers before passing to _write?
  // this is here so that some node-core streams can optimize string
  // handling at a lower level.
  var noDecode = options.decodeStrings === false;
  this.decodeStrings = !noDecode;

  // Crypto is kind of old and crusty.  Historically, its default string
  // encoding is 'binary' so we have to make this configurable.
  // Everything else in the universe uses 'utf8', though.
  this.defaultEncoding = options.defaultEncoding || 'utf8';

  // not an actual buffer we keep track of, but a measurement
  // of how much we're waiting to get pushed to some underlying
  // socket or file.
  this.length = 0;

  // a flag to see when we're in the middle of a write.
  this.writing = false;

  // when true all writes will be buffered until .uncork() call
  this.corked = 0;

  // a flag to be able to tell if the onwrite cb is called immediately,
  // or on a later tick.  We set this to true at first, because any
  // actions that shouldn't happen until "later" should generally also
  // not happen before the first write call.
  this.sync = true;

  // a flag to know if we're processing previously buffered items, which
  // may call the _write() callback in the same tick, so that we don't
  // end up in an overlapped onwrite situation.
  this.bufferProcessing = false;

  // the callback that's passed to _write(chunk,cb)
  this.onwrite = function (er) {
    onwrite(stream, er);
  };

  // the callback that the user supplies to write(chunk,encoding,cb)
  this.writecb = null;

  // the amount that is being written when _write is called.
  this.writelen = 0;
  this.bufferedRequest = null;
  this.lastBufferedRequest = null;

  // number of pending user-supplied write callbacks
  // this must be 0 before 'finish' can be emitted
  this.pendingcb = 0;

  // emit prefinish if the only thing we're waiting for is _write cbs
  // This is relevant for synchronous Transform streams
  this.prefinished = false;

  // True if the error was already emitted and should not be thrown again
  this.errorEmitted = false;

  // count buffered requests
  this.bufferedRequestCount = 0;

  // allocate the first CorkedRequest, there is always
  // one allocated and free to use, and we maintain at most two
  this.corkedRequestsFree = new CorkedRequest(this);
}
WritableState.prototype.getBuffer = function writableStateGetBuffer() {
  var current = this.bufferedRequest;
  var out = [];
  while (current) {
    out.push(current);
    current = current.next;
  }
  return out;
};
function Writable(options) {
  // Writable ctor is applied to Duplexes, though they're not
  // instanceof Writable, they're instanceof Readable.
  if (!(this instanceof Writable) && !(this instanceof Duplex)) return new Writable(options);
  this._writableState = new WritableState(options, this);

  // legacy.
  this.writable = true;
  if (options) {
    if (typeof options.write === 'function') this._write = options.write;
    if (typeof options.writev === 'function') this._writev = options.writev;
  }
  EventEmitter.call(this);
}

// Otherwise people can pipe Writable streams, which is just wrong.
Writable.prototype.pipe = function () {
  this.emit('error', new Error('Cannot pipe, not readable'));
};
function writeAfterEnd(stream, cb) {
  var er = new Error('write after end');
  // TODO: defer error events consistently everywhere, not just the cb
  stream.emit('error', er);
  nextTick(cb, er);
}

// If we get something that is not a buffer, string, null, or undefined,
// and we're not in objectMode, then that's an error.
// Otherwise stream chunks are all considered to be of length=1, and the
// watermarks determine how many objects to keep in the buffer, rather than
// how many bytes or characters.
function validChunk(stream, state, chunk, cb) {
  var valid = true;
  var er = false;
  // Always throw error if a null is written
  // if we are not in object mode then throw
  // if it is not a buffer, string, or undefined.
  if (chunk === null) {
    er = new TypeError('May not write null values to stream');
  } else if (!Buffer$d.isBuffer(chunk) && typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {
    er = new TypeError('Invalid non-string/buffer chunk');
  }
  if (er) {
    stream.emit('error', er);
    nextTick(cb, er);
    valid = false;
  }
  return valid;
}
Writable.prototype.write = function (chunk, encoding, cb) {
  var state = this._writableState;
  var ret = false;
  if (typeof encoding === 'function') {
    cb = encoding;
    encoding = null;
  }
  if (Buffer$d.isBuffer(chunk)) encoding = 'buffer';else if (!encoding) encoding = state.defaultEncoding;
  if (typeof cb !== 'function') cb = nop;
  if (state.ended) writeAfterEnd(this, cb);else if (validChunk(this, state, chunk, cb)) {
    state.pendingcb++;
    ret = writeOrBuffer(this, state, chunk, encoding, cb);
  }
  return ret;
};
Writable.prototype.cork = function () {
  var state = this._writableState;
  state.corked++;
};
Writable.prototype.uncork = function () {
  var state = this._writableState;
  if (state.corked) {
    state.corked--;
    if (!state.writing && !state.corked && !state.finished && !state.bufferProcessing && state.bufferedRequest) clearBuffer(this, state);
  }
};
Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
  // node::ParseEncoding() requires lower case.
  if (typeof encoding === 'string') encoding = encoding.toLowerCase();
  if (!(['hex', 'utf8', 'utf-8', 'ascii', 'binary', 'base64', 'ucs2', 'ucs-2', 'utf16le', 'utf-16le', 'raw'].indexOf((encoding + '').toLowerCase()) > -1)) throw new TypeError('Unknown encoding: ' + encoding);
  this._writableState.defaultEncoding = encoding;
  return this;
};
function decodeChunk(state, chunk, encoding) {
  if (!state.objectMode && state.decodeStrings !== false && typeof chunk === 'string') {
    chunk = Buffer$d.from(chunk, encoding);
  }
  return chunk;
}

// if we're already writing something, then just put this
// in the queue, and wait our turn.  Otherwise, call _write
// If we return false, then we need a drain event, so set that flag.
function writeOrBuffer(stream, state, chunk, encoding, cb) {
  chunk = decodeChunk(state, chunk, encoding);
  if (Buffer$d.isBuffer(chunk)) encoding = 'buffer';
  var len = state.objectMode ? 1 : chunk.length;
  state.length += len;
  var ret = state.length < state.highWaterMark;
  // we must ensure that previous needDrain will not be reset to false.
  if (!ret) state.needDrain = true;
  if (state.writing || state.corked) {
    var last = state.lastBufferedRequest;
    state.lastBufferedRequest = new WriteReq(chunk, encoding, cb);
    if (last) {
      last.next = state.lastBufferedRequest;
    } else {
      state.bufferedRequest = state.lastBufferedRequest;
    }
    state.bufferedRequestCount += 1;
  } else {
    doWrite(stream, state, false, len, chunk, encoding, cb);
  }
  return ret;
}
function doWrite(stream, state, writev, len, chunk, encoding, cb) {
  state.writelen = len;
  state.writecb = cb;
  state.writing = true;
  state.sync = true;
  if (writev) stream._writev(chunk, state.onwrite);else stream._write(chunk, encoding, state.onwrite);
  state.sync = false;
}
function onwriteError(stream, state, sync, er, cb) {
  --state.pendingcb;
  if (sync) nextTick(cb, er);else cb(er);
  stream._writableState.errorEmitted = true;
  stream.emit('error', er);
}
function onwriteStateUpdate(state) {
  state.writing = false;
  state.writecb = null;
  state.length -= state.writelen;
  state.writelen = 0;
}
function onwrite(stream, er) {
  var state = stream._writableState;
  var sync = state.sync;
  var cb = state.writecb;
  onwriteStateUpdate(state);
  if (er) onwriteError(stream, state, sync, er, cb);else {
    // Check if we're actually ready to finish, but don't emit yet
    var finished = needFinish(state);
    if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {
      clearBuffer(stream, state);
    }
    if (sync) {
      /*<replacement>*/
      nextTick(afterWrite, stream, state, finished, cb);
      /*</replacement>*/
    } else {
      afterWrite(stream, state, finished, cb);
    }
  }
}
function afterWrite(stream, state, finished, cb) {
  if (!finished) onwriteDrain(stream, state);
  state.pendingcb--;
  cb();
  finishMaybe(stream, state);
}

// Must force callback to be called on nextTick, so that we don't
// emit 'drain' before the write() consumer gets the 'false' return
// value, and has a chance to attach a 'drain' listener.
function onwriteDrain(stream, state) {
  if (state.length === 0 && state.needDrain) {
    state.needDrain = false;
    stream.emit('drain');
  }
}

// if there's something in the buffer waiting, then process it
function clearBuffer(stream, state) {
  state.bufferProcessing = true;
  var entry = state.bufferedRequest;
  if (stream._writev && entry && entry.next) {
    // Fast case, write everything using _writev()
    var l = state.bufferedRequestCount;
    var buffer = new Array(l);
    var holder = state.corkedRequestsFree;
    holder.entry = entry;
    var count = 0;
    while (entry) {
      buffer[count] = entry;
      entry = entry.next;
      count += 1;
    }
    doWrite(stream, state, true, state.length, buffer, '', holder.finish);

    // doWrite is almost always async, defer these to save a bit of time
    // as the hot path ends with doWrite
    state.pendingcb++;
    state.lastBufferedRequest = null;
    if (holder.next) {
      state.corkedRequestsFree = holder.next;
      holder.next = null;
    } else {
      state.corkedRequestsFree = new CorkedRequest(state);
    }
  } else {
    // Slow case, write chunks one-by-one
    while (entry) {
      var chunk = entry.chunk;
      var encoding = entry.encoding;
      var cb = entry.callback;
      var len = state.objectMode ? 1 : chunk.length;
      doWrite(stream, state, false, len, chunk, encoding, cb);
      entry = entry.next;
      // if we didn't call the onwrite immediately, then
      // it means that we need to wait until it does.
      // also, that means that the chunk and cb are currently
      // being processed, so move the buffer counter past them.
      if (state.writing) {
        break;
      }
    }
    if (entry === null) state.lastBufferedRequest = null;
  }
  state.bufferedRequestCount = 0;
  state.bufferedRequest = entry;
  state.bufferProcessing = false;
}
Writable.prototype._write = function (chunk, encoding, cb) {
  cb(new Error('not implemented'));
};
Writable.prototype._writev = null;
Writable.prototype.end = function (chunk, encoding, cb) {
  var state = this._writableState;
  if (typeof chunk === 'function') {
    cb = chunk;
    chunk = null;
    encoding = null;
  } else if (typeof encoding === 'function') {
    cb = encoding;
    encoding = null;
  }
  if (chunk !== null && chunk !== undefined) this.write(chunk, encoding);

  // .end() fully uncorks
  if (state.corked) {
    state.corked = 1;
    this.uncork();
  }

  // ignore unnecessary end() calls.
  if (!state.ending && !state.finished) endWritable(this, state, cb);
};
function needFinish(state) {
  return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
}
function prefinish(stream, state) {
  if (!state.prefinished) {
    state.prefinished = true;
    stream.emit('prefinish');
  }
}
function finishMaybe(stream, state) {
  var need = needFinish(state);
  if (need) {
    if (state.pendingcb === 0) {
      prefinish(stream, state);
      state.finished = true;
      stream.emit('finish');
    } else {
      prefinish(stream, state);
    }
  }
  return need;
}
function endWritable(stream, state, cb) {
  state.ending = true;
  finishMaybe(stream, state);
  if (cb) {
    if (state.finished) nextTick(cb);else stream.once('finish', cb);
  }
  state.ended = true;
  stream.writable = false;
}

// It seems a linked list but it is not
// there will be only 2 of these for each stream
function CorkedRequest(state) {
  var _this = this;
  this.next = null;
  this.entry = null;
  this.finish = function (err) {
    var entry = _this.entry;
    _this.entry = null;
    while (entry) {
      var cb = entry.callback;
      state.pendingcb--;
      cb(err);
      entry = entry.next;
    }
    if (state.corkedRequestsFree) {
      state.corkedRequestsFree.next = _this;
    } else {
      state.corkedRequestsFree = _this;
    }
  };
}

inherits$c(Duplex, Readable);
var keys = Object.keys(Writable.prototype);
for (var v = 0; v < keys.length; v++) {
  var method = keys[v];
  if (!Duplex.prototype[method]) Duplex.prototype[method] = Writable.prototype[method];
}
function Duplex(options) {
  if (!(this instanceof Duplex)) return new Duplex(options);
  Readable.call(this, options);
  Writable.call(this, options);
  if (options && options.readable === false) this.readable = false;
  if (options && options.writable === false) this.writable = false;
  this.allowHalfOpen = true;
  if (options && options.allowHalfOpen === false) this.allowHalfOpen = false;
  this.once('end', onend);
}

// the no-half-open enforcer
function onend() {
  // if we allow half-open state, or if the writable side ended,
  // then we're ok.
  if (this.allowHalfOpen || this._writableState.ended) return;

  // no more data can be written.
  // But allow more writes to happen in this tick.
  nextTick(onEndNT, this);
}
function onEndNT(self) {
  self.end();
}

// a transform stream is a readable/writable stream where you do
inherits$c(Transform$1, Duplex);
function TransformState(stream) {
  this.afterTransform = function (er, data) {
    return afterTransform(stream, er, data);
  };
  this.needTransform = false;
  this.transforming = false;
  this.writecb = null;
  this.writechunk = null;
  this.writeencoding = null;
}
function afterTransform(stream, er, data) {
  var ts = stream._transformState;
  ts.transforming = false;
  var cb = ts.writecb;
  if (!cb) return stream.emit('error', new Error('no writecb in Transform class'));
  ts.writechunk = null;
  ts.writecb = null;
  if (data !== null && data !== undefined) stream.push(data);
  cb(er);
  var rs = stream._readableState;
  rs.reading = false;
  if (rs.needReadable || rs.length < rs.highWaterMark) {
    stream._read(rs.highWaterMark);
  }
}
function Transform$1(options) {
  if (!(this instanceof Transform$1)) return new Transform$1(options);
  Duplex.call(this, options);
  this._transformState = new TransformState(this);

  // when the writable side finishes, then flush out anything remaining.
  var stream = this;

  // start out asking for a readable event once data is transformed.
  this._readableState.needReadable = true;

  // we have implemented the _read method, and done the other things
  // that Readable wants before the first _read call, so unset the
  // sync guard flag.
  this._readableState.sync = false;
  if (options) {
    if (typeof options.transform === 'function') this._transform = options.transform;
    if (typeof options.flush === 'function') this._flush = options.flush;
  }
  this.once('prefinish', function () {
    if (typeof this._flush === 'function') this._flush(function (er) {
      done(stream, er);
    });else done(stream);
  });
}
Transform$1.prototype.push = function (chunk, encoding) {
  this._transformState.needTransform = false;
  return Duplex.prototype.push.call(this, chunk, encoding);
};

// This is the part where you do stuff!
// override this function in implementation classes.
// 'chunk' is an input chunk.
//
// Call `push(newChunk)` to pass along transformed output
// to the readable side.  You may call 'push' zero or more times.
//
// Call `cb(err)` when you are done with this chunk.  If you pass
// an error, then that'll put the hurt on the whole operation.  If you
// never call cb(), then you'll never get another chunk.
Transform$1.prototype._transform = function (chunk, encoding, cb) {
  throw new Error('Not implemented');
};
Transform$1.prototype._write = function (chunk, encoding, cb) {
  var ts = this._transformState;
  ts.writecb = cb;
  ts.writechunk = chunk;
  ts.writeencoding = encoding;
  if (!ts.transforming) {
    var rs = this._readableState;
    if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark) this._read(rs.highWaterMark);
  }
};

// Doesn't matter what the args are here.
// _transform does all the work.
// That we got here means that the readable side wants more data.
Transform$1.prototype._read = function (n) {
  var ts = this._transformState;
  if (ts.writechunk !== null && ts.writecb && !ts.transforming) {
    ts.transforming = true;
    this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
  } else {
    // mark that we need a transform, so that any data that comes in
    // will get processed, now that we've asked for it.
    ts.needTransform = true;
  }
};
function done(stream, er) {
  if (er) return stream.emit('error', er);

  // if there's nothing in the write buffer, then that means
  // that nothing more will ever be provided
  var ws = stream._writableState;
  var ts = stream._transformState;
  if (ws.length) throw new Error('Calling transform done when ws.length != 0');
  if (ts.transforming) throw new Error('Calling transform done when still transforming');
  return stream.push(null);
}

inherits$c(PassThrough, Transform$1);
function PassThrough(options) {
  if (!(this instanceof PassThrough)) return new PassThrough(options);
  Transform$1.call(this, options);
}
PassThrough.prototype._transform = function (chunk, encoding, cb) {
  cb(null, chunk);
};

inherits$c(Stream, EventEmitter);
Stream.Readable = Readable;
Stream.Writable = Writable;
Stream.Duplex = Duplex;
Stream.Transform = Transform$1;
Stream.PassThrough = PassThrough;

// Backwards-compat with node 0.4.x
Stream.Stream = Stream;

// old-style streams.  Note that the pipe method (the only relevant
// part of this class) is overridden in the Readable class.

function Stream() {
  EventEmitter.call(this);
}
Stream.prototype.pipe = function (dest, options) {
  var source = this;
  function ondata(chunk) {
    if (dest.writable) {
      if (false === dest.write(chunk) && source.pause) {
        source.pause();
      }
    }
  }
  source.on('data', ondata);
  function ondrain() {
    if (source.readable && source.resume) {
      source.resume();
    }
  }
  dest.on('drain', ondrain);

  // If the 'end' option is not supplied, dest.end() will be called when
  // source gets the 'end' or 'close' events.  Only dest.end() once.
  if (!dest._isStdio && (!options || options.end !== false)) {
    source.on('end', onend);
    source.on('close', onclose);
  }
  var didOnEnd = false;
  function onend() {
    if (didOnEnd) return;
    didOnEnd = true;
    dest.end();
  }
  function onclose() {
    if (didOnEnd) return;
    didOnEnd = true;
    if (typeof dest.destroy === 'function') dest.destroy();
  }

  // don't leave dangling pipes when there are errors.
  function onerror(er) {
    cleanup();
    if (EventEmitter.listenerCount(this, 'error') === 0) {
      throw er; // Unhandled stream error in pipe.
    }
  }

  source.on('error', onerror);
  dest.on('error', onerror);

  // remove all the event listeners that were added.
  function cleanup() {
    source.removeListener('data', ondata);
    dest.removeListener('drain', ondrain);
    source.removeListener('end', onend);
    source.removeListener('close', onclose);
    source.removeListener('error', onerror);
    dest.removeListener('error', onerror);
    source.removeListener('end', cleanup);
    source.removeListener('close', cleanup);
    dest.removeListener('close', cleanup);
  }
  source.on('end', cleanup);
  source.on('close', cleanup);
  dest.on('close', cleanup);
  dest.emit('pipe', source);

  // Allow for unix-like usage: A.pipe(B).pipe(C)
  return dest;
};

var stream = /*#__PURE__*/Object.freeze({
  __proto__: null,
  'default': Stream,
  Readable: Readable,
  Writable: Writable,
  Duplex: Duplex,
  Transform: Transform$1,
  PassThrough: PassThrough,
  Stream: Stream
});

var require$$1 = /*@__PURE__*/getAugmentedNamespace(stream);

var require$$2 = /*@__PURE__*/getAugmentedNamespace(stringDecoder);

var Buffer$2 = safeBufferExports.Buffer;
var Transform = require$$1.Transform;
var StringDecoder = require$$2.StringDecoder;
var inherits$1 = inherits_browserExports;
function CipherBase(hashMode) {
  Transform.call(this);
  this.hashMode = typeof hashMode === 'string';
  if (this.hashMode) {
    this[hashMode] = this._finalOrDigest;
  } else {
    this.final = this._finalOrDigest;
  }
  if (this._final) {
    this.__final = this._final;
    this._final = null;
  }
  this._decoder = null;
  this._encoding = null;
}
inherits$1(CipherBase, Transform);
CipherBase.prototype.update = function (data, inputEnc, outputEnc) {
  if (typeof data === 'string') {
    data = Buffer$2.from(data, inputEnc);
  }
  var outData = this._update(data);
  if (this.hashMode) return this;
  if (outputEnc) {
    outData = this._toString(outData, outputEnc);
  }
  return outData;
};
CipherBase.prototype.setAutoPadding = function () {};
CipherBase.prototype.getAuthTag = function () {
  throw new Error('trying to get auth tag in unsupported state');
};
CipherBase.prototype.setAuthTag = function () {
  throw new Error('trying to set auth tag in unsupported state');
};
CipherBase.prototype.setAAD = function () {
  throw new Error('trying to set aad in unsupported state');
};
CipherBase.prototype._transform = function (data, _, next) {
  var err;
  try {
    if (this.hashMode) {
      this._update(data);
    } else {
      this.push(this._update(data));
    }
  } catch (e) {
    err = e;
  } finally {
    next(err);
  }
};
CipherBase.prototype._flush = function (done) {
  var err;
  try {
    this.push(this.__final());
  } catch (e) {
    err = e;
  }
  done(err);
};
CipherBase.prototype._finalOrDigest = function (outputEnc) {
  var outData = this.__final() || Buffer$2.alloc(0);
  if (outputEnc) {
    outData = this._toString(outData, outputEnc, true);
  }
  return outData;
};
CipherBase.prototype._toString = function (value, enc, fin) {
  if (!this._decoder) {
    this._decoder = new StringDecoder(enc);
    this._encoding = enc;
  }
  if (this._encoding !== enc) throw new Error('can\'t switch encodings');
  var out = this._decoder.write(value);
  if (fin) {
    out += this._decoder.end();
  }
  return out;
};
var cipherBase = CipherBase;

var inherits = inherits_browserExports;
var MD5 = md5_js;
var RIPEMD160 = ripemd160;
var sha = sha_jsExports;
var Base = cipherBase;
function Hash(hash) {
  Base.call(this, 'digest');
  this._hash = hash;
}
inherits(Hash, Base);
Hash.prototype._update = function (data) {
  this._hash.update(data);
};
Hash.prototype._final = function () {
  return this._hash.digest();
};
var browser = function createHash(alg) {
  alg = alg.toLowerCase();
  if (alg === 'md5') return new MD5();
  if (alg === 'rmd160' || alg === 'ripemd160') return new RIPEMD160();
  return new Hash(sha(alg));
};

// base-x encoding / decoding
// Copyright (c) 2018 base-x contributors
// Copyright (c) 2014-2018 The Bitcoin Core developers (base58.cpp)
// Distributed under the MIT software license, see the accompanying
// file LICENSE or http://www.opensource.org/licenses/mit-license.php.
// @ts-ignore
var _Buffer = safeBufferExports.Buffer;
function base$1(ALPHABET) {
  if (ALPHABET.length >= 255) {
    throw new TypeError('Alphabet too long');
  }
  var BASE_MAP = new Uint8Array(256);
  for (var j = 0; j < BASE_MAP.length; j++) {
    BASE_MAP[j] = 255;
  }
  for (var i = 0; i < ALPHABET.length; i++) {
    var x = ALPHABET.charAt(i);
    var xc = x.charCodeAt(0);
    if (BASE_MAP[xc] !== 255) {
      throw new TypeError(x + ' is ambiguous');
    }
    BASE_MAP[xc] = i;
  }
  var BASE = ALPHABET.length;
  var LEADER = ALPHABET.charAt(0);
  var FACTOR = Math.log(BASE) / Math.log(256); // log(BASE) / log(256), rounded up
  var iFACTOR = Math.log(256) / Math.log(BASE); // log(256) / log(BASE), rounded up
  function encode(source) {
    if (Array.isArray(source) || source instanceof Uint8Array) {
      source = _Buffer.from(source);
    }
    if (!_Buffer.isBuffer(source)) {
      throw new TypeError('Expected Buffer');
    }
    if (source.length === 0) {
      return '';
    }
    // Skip & count leading zeroes.
    var zeroes = 0;
    var length = 0;
    var pbegin = 0;
    var pend = source.length;
    while (pbegin !== pend && source[pbegin] === 0) {
      pbegin++;
      zeroes++;
    }
    // Allocate enough space in big-endian base58 representation.
    var size = (pend - pbegin) * iFACTOR + 1 >>> 0;
    var b58 = new Uint8Array(size);
    // Process the bytes.
    while (pbegin !== pend) {
      var carry = source[pbegin];
      // Apply "b58 = b58 * 256 + ch".
      var i = 0;
      for (var it1 = size - 1; (carry !== 0 || i < length) && it1 !== -1; it1--, i++) {
        carry += 256 * b58[it1] >>> 0;
        b58[it1] = carry % BASE >>> 0;
        carry = carry / BASE >>> 0;
      }
      if (carry !== 0) {
        throw new Error('Non-zero carry');
      }
      length = i;
      pbegin++;
    }
    // Skip leading zeroes in base58 result.
    var it2 = size - length;
    while (it2 !== size && b58[it2] === 0) {
      it2++;
    }
    // Translate the result into a string.
    var str = LEADER.repeat(zeroes);
    for (; it2 < size; ++it2) {
      str += ALPHABET.charAt(b58[it2]);
    }
    return str;
  }
  function decodeUnsafe(source) {
    if (typeof source !== 'string') {
      throw new TypeError('Expected String');
    }
    if (source.length === 0) {
      return _Buffer.alloc(0);
    }
    var psz = 0;
    // Skip and count leading '1's.
    var zeroes = 0;
    var length = 0;
    while (source[psz] === LEADER) {
      zeroes++;
      psz++;
    }
    // Allocate enough space in big-endian base256 representation.
    var size = (source.length - psz) * FACTOR + 1 >>> 0; // log(58) / log(256), rounded up.
    var b256 = new Uint8Array(size);
    // Process the characters.
    while (source[psz]) {
      // Decode character
      var carry = BASE_MAP[source.charCodeAt(psz)];
      // Invalid character
      if (carry === 255) {
        return;
      }
      var i = 0;
      for (var it3 = size - 1; (carry !== 0 || i < length) && it3 !== -1; it3--, i++) {
        carry += BASE * b256[it3] >>> 0;
        b256[it3] = carry % 256 >>> 0;
        carry = carry / 256 >>> 0;
      }
      if (carry !== 0) {
        throw new Error('Non-zero carry');
      }
      length = i;
      psz++;
    }
    // Skip leading zeroes in b256.
    var it4 = size - length;
    while (it4 !== size && b256[it4] === 0) {
      it4++;
    }
    var vch = _Buffer.allocUnsafe(zeroes + (size - it4));
    vch.fill(0x00, 0, zeroes);
    var j = zeroes;
    while (it4 !== size) {
      vch[j++] = b256[it4++];
    }
    return vch;
  }
  function decode(string) {
    var buffer = decodeUnsafe(string);
    if (buffer) {
      return buffer;
    }
    throw new Error('Non-base' + BASE + ' character');
  }
  return {
    encode: encode,
    decodeUnsafe: decodeUnsafe,
    decode: decode
  };
}
var src = base$1;

var basex = src;
var ALPHABET = '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz';
var bs58 = basex(ALPHABET);

var base58 = bs58;
var Buffer$1 = safeBufferExports.Buffer;
var base = function base(checksumFn) {
  // Encode a buffer as a base58-check encoded string
  function encode(payload) {
    var checksum = checksumFn(payload);
    return base58.encode(Buffer$1.concat([payload, checksum], payload.length + 4));
  }
  function decodeRaw(buffer) {
    var payload = buffer.slice(0, -4);
    var checksum = buffer.slice(-4);
    var newChecksum = checksumFn(payload);
    if (checksum[0] ^ newChecksum[0] | checksum[1] ^ newChecksum[1] | checksum[2] ^ newChecksum[2] | checksum[3] ^ newChecksum[3]) return;
    return payload;
  }

  // Decode a base58-check encoded string to a buffer, no result if checksum is wrong
  function decodeUnsafe(string) {
    var buffer = base58.decodeUnsafe(string);
    if (!buffer) return;
    return decodeRaw(buffer);
  }
  function decode(string) {
    var buffer = base58.decode(string);
    var payload = decodeRaw(buffer);
    if (!payload) throw new Error('Invalid checksum');
    return payload;
  }
  return {
    encode: encode,
    decode: decode,
    decodeUnsafe: decodeUnsafe
  };
};

var createHash = browser;
var bs58checkBase = base;

// SHA256(SHA256(buffer))
function sha256x2(buffer) {
  var tmp = createHash('sha256').update(buffer).digest();
  return createHash('sha256').update(tmp).digest();
}
var bs58check$2 = bs58checkBase(sha256x2);

/**
 * @license
 * https://github.com/ealmansi/cashaddrjs
 * Copyright (c) 2017-2020 Emilio Almansi
 * Distributed under the MIT software license, see the accompanying
 * file LICENSE or http://www.opensource.org/licenses/mit-license.php.
 */

/**
 * Validation utility.
 *
 * @module validation
 */

/**
 * Error thrown when encoding or decoding fail due to invalid input.
 *
 * @constructor ValidationError
 * @param {string} message Error description.
 */
function ValidationError$1(message) {
  var error = new Error();
  this.name = error.name = 'ValidationError';
  this.message = error.message = message;
  this.stack = error.stack;
}
ValidationError$1.prototype = Object.create(Error.prototype);

/**
 * Validates a given condition, throwing a {@link ValidationError} if
 * the given condition does not hold.
 *
 * @static
 * @param {boolean} condition Condition to validate.
 * @param {string} message Error message in case the condition does not hold.
 */
function validate$3(condition, message) {
  if (!condition) {
    throw new ValidationError$1(message);
  }
}
var validation$1 = {
  ValidationError: ValidationError$1,
  validate: validate$3
};

/**
 * @license
 * https://github.com/ealmansi/cashaddrjs
 * Copyright (c) 2017-2020 Emilio Almansi
 * Distributed under the MIT software license, see the accompanying
 * file LICENSE or http://www.opensource.org/licenses/mit-license.php.
 */
var validate$2 = validation$1.validate;

/**
 * Base32 encoding and decoding.
 *
 * @module base32
 */

/**
 * Charset containing the 32 symbols used in the base32 encoding.
 * @private
 */
var CHARSET = 'qpzry9x8gf2tvdw0s3jn54khce6mua7l';

/**
 * Inverted index mapping each symbol into its index within the charset.
 * @private
 */
var CHARSET_INVERSE_INDEX = {
  'q': 0,
  'p': 1,
  'z': 2,
  'r': 3,
  'y': 4,
  '9': 5,
  'x': 6,
  '8': 7,
  'g': 8,
  'f': 9,
  '2': 10,
  't': 11,
  'v': 12,
  'd': 13,
  'w': 14,
  '0': 15,
  's': 16,
  '3': 17,
  'j': 18,
  'n': 19,
  '5': 20,
  '4': 21,
  'k': 22,
  'h': 23,
  'c': 24,
  'e': 25,
  '6': 26,
  'm': 27,
  'u': 28,
  'a': 29,
  '7': 30,
  'l': 31
};

/**
 * Encodes the given array of 5-bit integers as a base32-encoded string.
 *
 * @static
 * @param {Uint8Array} data Array of integers between 0 and 31 inclusive.
 * @returns {string}
 * @throws {ValidationError}
 */
function encode$3(data) {
  validate$2(data instanceof Uint8Array, 'Invalid data: ' + data + '.');
  var base32 = '';
  for (var i = 0; i < data.length; ++i) {
    var value = data[i];
    validate$2(0 <= value && value < 32, 'Invalid value: ' + value + '.');
    base32 += CHARSET[value];
  }
  return base32;
}

/**
 * Decodes the given base32-encoded string into an array of 5-bit integers.
 *
 * @static
 * @param {string} string
 * @returns {Uint8Array}
 * @throws {ValidationError}
 */
function decode$3(string) {
  validate$2(typeof string === 'string', 'Invalid base32-encoded string: ' + string + '.');
  var data = new Uint8Array(string.length);
  for (var i = 0; i < string.length; ++i) {
    var value = string[i];
    validate$2(value in CHARSET_INVERSE_INDEX, 'Invalid value: ' + value + '.');
    data[i] = CHARSET_INVERSE_INDEX[value];
  }
  return data;
}
var base32$1 = {
  encode: encode$3,
  decode: decode$3
};

var BigInteger = {exports: {}};

BigInteger.exports;
(function (module) {
  var bigInt = function (undefined$1) {

    var BASE = 1e7,
      LOG_BASE = 7,
      MAX_INT = 9007199254740992,
      MAX_INT_ARR = smallToArray(MAX_INT),
      LOG_MAX_INT = Math.log(MAX_INT);
    function Integer(v, radix) {
      if (typeof v === "undefined") return Integer[0];
      if (typeof radix !== "undefined") return +radix === 10 ? parseValue(v) : parseBase(v, radix);
      return parseValue(v);
    }
    function BigInteger(value, sign) {
      this.value = value;
      this.sign = sign;
      this.isSmall = false;
    }
    BigInteger.prototype = Object.create(Integer.prototype);
    function SmallInteger(value) {
      this.value = value;
      this.sign = value < 0;
      this.isSmall = true;
    }
    SmallInteger.prototype = Object.create(Integer.prototype);
    function isPrecise(n) {
      return -MAX_INT < n && n < MAX_INT;
    }
    function smallToArray(n) {
      // For performance reasons doesn't reference BASE, need to change this function if BASE changes
      if (n < 1e7) return [n];
      if (n < 1e14) return [n % 1e7, Math.floor(n / 1e7)];
      return [n % 1e7, Math.floor(n / 1e7) % 1e7, Math.floor(n / 1e14)];
    }
    function arrayToSmall(arr) {
      // If BASE changes this function may need to change
      trim(arr);
      var length = arr.length;
      if (length < 4 && compareAbs(arr, MAX_INT_ARR) < 0) {
        switch (length) {
          case 0:
            return 0;
          case 1:
            return arr[0];
          case 2:
            return arr[0] + arr[1] * BASE;
          default:
            return arr[0] + (arr[1] + arr[2] * BASE) * BASE;
        }
      }
      return arr;
    }
    function trim(v) {
      var i = v.length;
      while (v[--i] === 0);
      v.length = i + 1;
    }
    function createArray(length) {
      // function shamelessly stolen from Yaffle's library https://github.com/Yaffle/BigInteger
      var x = new Array(length);
      var i = -1;
      while (++i < length) {
        x[i] = 0;
      }
      return x;
    }
    function truncate(n) {
      if (n > 0) return Math.floor(n);
      return Math.ceil(n);
    }
    function add(a, b) {
      // assumes a and b are arrays with a.length >= b.length
      var l_a = a.length,
        l_b = b.length,
        r = new Array(l_a),
        carry = 0,
        base = BASE,
        sum,
        i;
      for (i = 0; i < l_b; i++) {
        sum = a[i] + b[i] + carry;
        carry = sum >= base ? 1 : 0;
        r[i] = sum - carry * base;
      }
      while (i < l_a) {
        sum = a[i] + carry;
        carry = sum === base ? 1 : 0;
        r[i++] = sum - carry * base;
      }
      if (carry > 0) r.push(carry);
      return r;
    }
    function addAny(a, b) {
      if (a.length >= b.length) return add(a, b);
      return add(b, a);
    }
    function addSmall(a, carry) {
      // assumes a is array, carry is number with 0 <= carry < MAX_INT
      var l = a.length,
        r = new Array(l),
        base = BASE,
        sum,
        i;
      for (i = 0; i < l; i++) {
        sum = a[i] - base + carry;
        carry = Math.floor(sum / base);
        r[i] = sum - carry * base;
        carry += 1;
      }
      while (carry > 0) {
        r[i++] = carry % base;
        carry = Math.floor(carry / base);
      }
      return r;
    }
    BigInteger.prototype.add = function (v) {
      var n = parseValue(v);
      if (this.sign !== n.sign) {
        return this.subtract(n.negate());
      }
      var a = this.value,
        b = n.value;
      if (n.isSmall) {
        return new BigInteger(addSmall(a, Math.abs(b)), this.sign);
      }
      return new BigInteger(addAny(a, b), this.sign);
    };
    BigInteger.prototype.plus = BigInteger.prototype.add;
    SmallInteger.prototype.add = function (v) {
      var n = parseValue(v);
      var a = this.value;
      if (a < 0 !== n.sign) {
        return this.subtract(n.negate());
      }
      var b = n.value;
      if (n.isSmall) {
        if (isPrecise(a + b)) return new SmallInteger(a + b);
        b = smallToArray(Math.abs(b));
      }
      return new BigInteger(addSmall(b, Math.abs(a)), a < 0);
    };
    SmallInteger.prototype.plus = SmallInteger.prototype.add;
    function subtract(a, b) {
      // assumes a and b are arrays with a >= b
      var a_l = a.length,
        b_l = b.length,
        r = new Array(a_l),
        borrow = 0,
        base = BASE,
        i,
        difference;
      for (i = 0; i < b_l; i++) {
        difference = a[i] - borrow - b[i];
        if (difference < 0) {
          difference += base;
          borrow = 1;
        } else borrow = 0;
        r[i] = difference;
      }
      for (i = b_l; i < a_l; i++) {
        difference = a[i] - borrow;
        if (difference < 0) difference += base;else {
          r[i++] = difference;
          break;
        }
        r[i] = difference;
      }
      for (; i < a_l; i++) {
        r[i] = a[i];
      }
      trim(r);
      return r;
    }
    function subtractAny(a, b, sign) {
      var value;
      if (compareAbs(a, b) >= 0) {
        value = subtract(a, b);
      } else {
        value = subtract(b, a);
        sign = !sign;
      }
      value = arrayToSmall(value);
      if (typeof value === "number") {
        if (sign) value = -value;
        return new SmallInteger(value);
      }
      return new BigInteger(value, sign);
    }
    function subtractSmall(a, b, sign) {
      // assumes a is array, b is number with 0 <= b < MAX_INT
      var l = a.length,
        r = new Array(l),
        carry = -b,
        base = BASE,
        i,
        difference;
      for (i = 0; i < l; i++) {
        difference = a[i] + carry;
        carry = Math.floor(difference / base);
        difference %= base;
        r[i] = difference < 0 ? difference + base : difference;
      }
      r = arrayToSmall(r);
      if (typeof r === "number") {
        if (sign) r = -r;
        return new SmallInteger(r);
      }
      return new BigInteger(r, sign);
    }
    BigInteger.prototype.subtract = function (v) {
      var n = parseValue(v);
      if (this.sign !== n.sign) {
        return this.add(n.negate());
      }
      var a = this.value,
        b = n.value;
      if (n.isSmall) return subtractSmall(a, Math.abs(b), this.sign);
      return subtractAny(a, b, this.sign);
    };
    BigInteger.prototype.minus = BigInteger.prototype.subtract;
    SmallInteger.prototype.subtract = function (v) {
      var n = parseValue(v);
      var a = this.value;
      if (a < 0 !== n.sign) {
        return this.add(n.negate());
      }
      var b = n.value;
      if (n.isSmall) {
        return new SmallInteger(a - b);
      }
      return subtractSmall(b, Math.abs(a), a >= 0);
    };
    SmallInteger.prototype.minus = SmallInteger.prototype.subtract;
    BigInteger.prototype.negate = function () {
      return new BigInteger(this.value, !this.sign);
    };
    SmallInteger.prototype.negate = function () {
      var sign = this.sign;
      var small = new SmallInteger(-this.value);
      small.sign = !sign;
      return small;
    };
    BigInteger.prototype.abs = function () {
      return new BigInteger(this.value, false);
    };
    SmallInteger.prototype.abs = function () {
      return new SmallInteger(Math.abs(this.value));
    };
    function multiplyLong(a, b) {
      var a_l = a.length,
        b_l = b.length,
        l = a_l + b_l,
        r = createArray(l),
        base = BASE,
        product,
        carry,
        i,
        a_i,
        b_j;
      for (i = 0; i < a_l; ++i) {
        a_i = a[i];
        for (var j = 0; j < b_l; ++j) {
          b_j = b[j];
          product = a_i * b_j + r[i + j];
          carry = Math.floor(product / base);
          r[i + j] = product - carry * base;
          r[i + j + 1] += carry;
        }
      }
      trim(r);
      return r;
    }
    function multiplySmall(a, b) {
      // assumes a is array, b is number with |b| < BASE
      var l = a.length,
        r = new Array(l),
        base = BASE,
        carry = 0,
        product,
        i;
      for (i = 0; i < l; i++) {
        product = a[i] * b + carry;
        carry = Math.floor(product / base);
        r[i] = product - carry * base;
      }
      while (carry > 0) {
        r[i++] = carry % base;
        carry = Math.floor(carry / base);
      }
      return r;
    }
    function shiftLeft(x, n) {
      var r = [];
      while (n-- > 0) r.push(0);
      return r.concat(x);
    }
    function multiplyKaratsuba(x, y) {
      var n = Math.max(x.length, y.length);
      if (n <= 30) return multiplyLong(x, y);
      n = Math.ceil(n / 2);
      var b = x.slice(n),
        a = x.slice(0, n),
        d = y.slice(n),
        c = y.slice(0, n);
      var ac = multiplyKaratsuba(a, c),
        bd = multiplyKaratsuba(b, d),
        abcd = multiplyKaratsuba(addAny(a, b), addAny(c, d));
      var product = addAny(addAny(ac, shiftLeft(subtract(subtract(abcd, ac), bd), n)), shiftLeft(bd, 2 * n));
      trim(product);
      return product;
    }

    // The following function is derived from a surface fit of a graph plotting the performance difference
    // between long multiplication and karatsuba multiplication versus the lengths of the two arrays.
    function useKaratsuba(l1, l2) {
      return -0.012 * l1 - 0.012 * l2 + 0.000015 * l1 * l2 > 0;
    }
    BigInteger.prototype.multiply = function (v) {
      var n = parseValue(v),
        a = this.value,
        b = n.value,
        sign = this.sign !== n.sign,
        abs;
      if (n.isSmall) {
        if (b === 0) return Integer[0];
        if (b === 1) return this;
        if (b === -1) return this.negate();
        abs = Math.abs(b);
        if (abs < BASE) {
          return new BigInteger(multiplySmall(a, abs), sign);
        }
        b = smallToArray(abs);
      }
      if (useKaratsuba(a.length, b.length))
        // Karatsuba is only faster for certain array sizes
        return new BigInteger(multiplyKaratsuba(a, b), sign);
      return new BigInteger(multiplyLong(a, b), sign);
    };
    BigInteger.prototype.times = BigInteger.prototype.multiply;
    function multiplySmallAndArray(a, b, sign) {
      // a >= 0
      if (a < BASE) {
        return new BigInteger(multiplySmall(b, a), sign);
      }
      return new BigInteger(multiplyLong(b, smallToArray(a)), sign);
    }
    SmallInteger.prototype._multiplyBySmall = function (a) {
      if (isPrecise(a.value * this.value)) {
        return new SmallInteger(a.value * this.value);
      }
      return multiplySmallAndArray(Math.abs(a.value), smallToArray(Math.abs(this.value)), this.sign !== a.sign);
    };
    BigInteger.prototype._multiplyBySmall = function (a) {
      if (a.value === 0) return Integer[0];
      if (a.value === 1) return this;
      if (a.value === -1) return this.negate();
      return multiplySmallAndArray(Math.abs(a.value), this.value, this.sign !== a.sign);
    };
    SmallInteger.prototype.multiply = function (v) {
      return parseValue(v)._multiplyBySmall(this);
    };
    SmallInteger.prototype.times = SmallInteger.prototype.multiply;
    function square(a) {
      //console.assert(2 * BASE * BASE < MAX_INT);
      var l = a.length,
        r = createArray(l + l),
        base = BASE,
        product,
        carry,
        i,
        a_i,
        a_j;
      for (i = 0; i < l; i++) {
        a_i = a[i];
        carry = 0 - a_i * a_i;
        for (var j = i; j < l; j++) {
          a_j = a[j];
          product = 2 * (a_i * a_j) + r[i + j] + carry;
          carry = Math.floor(product / base);
          r[i + j] = product - carry * base;
        }
        r[i + l] = carry;
      }
      trim(r);
      return r;
    }
    BigInteger.prototype.square = function () {
      return new BigInteger(square(this.value), false);
    };
    SmallInteger.prototype.square = function () {
      var value = this.value * this.value;
      if (isPrecise(value)) return new SmallInteger(value);
      return new BigInteger(square(smallToArray(Math.abs(this.value))), false);
    };
    function divMod1(a, b) {
      // Left over from previous version. Performs faster than divMod2 on smaller input sizes.
      var a_l = a.length,
        b_l = b.length,
        base = BASE,
        result = createArray(b.length),
        divisorMostSignificantDigit = b[b_l - 1],
        // normalization
        lambda = Math.ceil(base / (2 * divisorMostSignificantDigit)),
        remainder = multiplySmall(a, lambda),
        divisor = multiplySmall(b, lambda),
        quotientDigit,
        shift,
        carry,
        borrow,
        i,
        l,
        q;
      if (remainder.length <= a_l) remainder.push(0);
      divisor.push(0);
      divisorMostSignificantDigit = divisor[b_l - 1];
      for (shift = a_l - b_l; shift >= 0; shift--) {
        quotientDigit = base - 1;
        if (remainder[shift + b_l] !== divisorMostSignificantDigit) {
          quotientDigit = Math.floor((remainder[shift + b_l] * base + remainder[shift + b_l - 1]) / divisorMostSignificantDigit);
        }
        // quotientDigit <= base - 1
        carry = 0;
        borrow = 0;
        l = divisor.length;
        for (i = 0; i < l; i++) {
          carry += quotientDigit * divisor[i];
          q = Math.floor(carry / base);
          borrow += remainder[shift + i] - (carry - q * base);
          carry = q;
          if (borrow < 0) {
            remainder[shift + i] = borrow + base;
            borrow = -1;
          } else {
            remainder[shift + i] = borrow;
            borrow = 0;
          }
        }
        while (borrow !== 0) {
          quotientDigit -= 1;
          carry = 0;
          for (i = 0; i < l; i++) {
            carry += remainder[shift + i] - base + divisor[i];
            if (carry < 0) {
              remainder[shift + i] = carry + base;
              carry = 0;
            } else {
              remainder[shift + i] = carry;
              carry = 1;
            }
          }
          borrow += carry;
        }
        result[shift] = quotientDigit;
      }
      // denormalization
      remainder = divModSmall(remainder, lambda)[0];
      return [arrayToSmall(result), arrayToSmall(remainder)];
    }
    function divMod2(a, b) {
      // Implementation idea shamelessly stolen from Silent Matt's library http://silentmatt.com/biginteger/
      // Performs faster than divMod1 on larger input sizes.
      var a_l = a.length,
        b_l = b.length,
        result = [],
        part = [],
        base = BASE,
        guess,
        xlen,
        highx,
        highy,
        check;
      while (a_l) {
        part.unshift(a[--a_l]);
        trim(part);
        if (compareAbs(part, b) < 0) {
          result.push(0);
          continue;
        }
        xlen = part.length;
        highx = part[xlen - 1] * base + part[xlen - 2];
        highy = b[b_l - 1] * base + b[b_l - 2];
        if (xlen > b_l) {
          highx = (highx + 1) * base;
        }
        guess = Math.ceil(highx / highy);
        do {
          check = multiplySmall(b, guess);
          if (compareAbs(check, part) <= 0) break;
          guess--;
        } while (guess);
        result.push(guess);
        part = subtract(part, check);
      }
      result.reverse();
      return [arrayToSmall(result), arrayToSmall(part)];
    }
    function divModSmall(value, lambda) {
      var length = value.length,
        quotient = createArray(length),
        base = BASE,
        i,
        q,
        remainder,
        divisor;
      remainder = 0;
      for (i = length - 1; i >= 0; --i) {
        divisor = remainder * base + value[i];
        q = truncate(divisor / lambda);
        remainder = divisor - q * lambda;
        quotient[i] = q | 0;
      }
      return [quotient, remainder | 0];
    }
    function divModAny(self, v) {
      var value,
        n = parseValue(v);
      var a = self.value,
        b = n.value;
      var quotient;
      if (b === 0) throw new Error("Cannot divide by zero");
      if (self.isSmall) {
        if (n.isSmall) {
          return [new SmallInteger(truncate(a / b)), new SmallInteger(a % b)];
        }
        return [Integer[0], self];
      }
      if (n.isSmall) {
        if (b === 1) return [self, Integer[0]];
        if (b == -1) return [self.negate(), Integer[0]];
        var abs = Math.abs(b);
        if (abs < BASE) {
          value = divModSmall(a, abs);
          quotient = arrayToSmall(value[0]);
          var remainder = value[1];
          if (self.sign) remainder = -remainder;
          if (typeof quotient === "number") {
            if (self.sign !== n.sign) quotient = -quotient;
            return [new SmallInteger(quotient), new SmallInteger(remainder)];
          }
          return [new BigInteger(quotient, self.sign !== n.sign), new SmallInteger(remainder)];
        }
        b = smallToArray(abs);
      }
      var comparison = compareAbs(a, b);
      if (comparison === -1) return [Integer[0], self];
      if (comparison === 0) return [Integer[self.sign === n.sign ? 1 : -1], Integer[0]];

      // divMod1 is faster on smaller input sizes
      if (a.length + b.length <= 200) value = divMod1(a, b);else value = divMod2(a, b);
      quotient = value[0];
      var qSign = self.sign !== n.sign,
        mod = value[1],
        mSign = self.sign;
      if (typeof quotient === "number") {
        if (qSign) quotient = -quotient;
        quotient = new SmallInteger(quotient);
      } else quotient = new BigInteger(quotient, qSign);
      if (typeof mod === "number") {
        if (mSign) mod = -mod;
        mod = new SmallInteger(mod);
      } else mod = new BigInteger(mod, mSign);
      return [quotient, mod];
    }
    BigInteger.prototype.divmod = function (v) {
      var result = divModAny(this, v);
      return {
        quotient: result[0],
        remainder: result[1]
      };
    };
    SmallInteger.prototype.divmod = BigInteger.prototype.divmod;
    BigInteger.prototype.divide = function (v) {
      return divModAny(this, v)[0];
    };
    SmallInteger.prototype.over = SmallInteger.prototype.divide = BigInteger.prototype.over = BigInteger.prototype.divide;
    BigInteger.prototype.mod = function (v) {
      return divModAny(this, v)[1];
    };
    SmallInteger.prototype.remainder = SmallInteger.prototype.mod = BigInteger.prototype.remainder = BigInteger.prototype.mod;
    BigInteger.prototype.pow = function (v) {
      var n = parseValue(v),
        a = this.value,
        b = n.value,
        value,
        x,
        y;
      if (b === 0) return Integer[1];
      if (a === 0) return Integer[0];
      if (a === 1) return Integer[1];
      if (a === -1) return n.isEven() ? Integer[1] : Integer[-1];
      if (n.sign) {
        return Integer[0];
      }
      if (!n.isSmall) throw new Error("The exponent " + n.toString() + " is too large.");
      if (this.isSmall) {
        if (isPrecise(value = Math.pow(a, b))) return new SmallInteger(truncate(value));
      }
      x = this;
      y = Integer[1];
      while (true) {
        if (b & 1 === 1) {
          y = y.times(x);
          --b;
        }
        if (b === 0) break;
        b /= 2;
        x = x.square();
      }
      return y;
    };
    SmallInteger.prototype.pow = BigInteger.prototype.pow;
    BigInteger.prototype.modPow = function (exp, mod) {
      exp = parseValue(exp);
      mod = parseValue(mod);
      if (mod.isZero()) throw new Error("Cannot take modPow with modulus 0");
      var r = Integer[1],
        base = this.mod(mod);
      while (exp.isPositive()) {
        if (base.isZero()) return Integer[0];
        if (exp.isOdd()) r = r.multiply(base).mod(mod);
        exp = exp.divide(2);
        base = base.square().mod(mod);
      }
      return r;
    };
    SmallInteger.prototype.modPow = BigInteger.prototype.modPow;
    function compareAbs(a, b) {
      if (a.length !== b.length) {
        return a.length > b.length ? 1 : -1;
      }
      for (var i = a.length - 1; i >= 0; i--) {
        if (a[i] !== b[i]) return a[i] > b[i] ? 1 : -1;
      }
      return 0;
    }
    BigInteger.prototype.compareAbs = function (v) {
      var n = parseValue(v),
        a = this.value,
        b = n.value;
      if (n.isSmall) return 1;
      return compareAbs(a, b);
    };
    SmallInteger.prototype.compareAbs = function (v) {
      var n = parseValue(v),
        a = Math.abs(this.value),
        b = n.value;
      if (n.isSmall) {
        b = Math.abs(b);
        return a === b ? 0 : a > b ? 1 : -1;
      }
      return -1;
    };
    BigInteger.prototype.compare = function (v) {
      // See discussion about comparison with Infinity:
      // https://github.com/peterolson/BigInteger.js/issues/61
      if (v === Infinity) {
        return -1;
      }
      if (v === -Infinity) {
        return 1;
      }
      var n = parseValue(v),
        a = this.value,
        b = n.value;
      if (this.sign !== n.sign) {
        return n.sign ? 1 : -1;
      }
      if (n.isSmall) {
        return this.sign ? -1 : 1;
      }
      return compareAbs(a, b) * (this.sign ? -1 : 1);
    };
    BigInteger.prototype.compareTo = BigInteger.prototype.compare;
    SmallInteger.prototype.compare = function (v) {
      if (v === Infinity) {
        return -1;
      }
      if (v === -Infinity) {
        return 1;
      }
      var n = parseValue(v),
        a = this.value,
        b = n.value;
      if (n.isSmall) {
        return a == b ? 0 : a > b ? 1 : -1;
      }
      if (a < 0 !== n.sign) {
        return a < 0 ? -1 : 1;
      }
      return a < 0 ? 1 : -1;
    };
    SmallInteger.prototype.compareTo = SmallInteger.prototype.compare;
    BigInteger.prototype.equals = function (v) {
      return this.compare(v) === 0;
    };
    SmallInteger.prototype.eq = SmallInteger.prototype.equals = BigInteger.prototype.eq = BigInteger.prototype.equals;
    BigInteger.prototype.notEquals = function (v) {
      return this.compare(v) !== 0;
    };
    SmallInteger.prototype.neq = SmallInteger.prototype.notEquals = BigInteger.prototype.neq = BigInteger.prototype.notEquals;
    BigInteger.prototype.greater = function (v) {
      return this.compare(v) > 0;
    };
    SmallInteger.prototype.gt = SmallInteger.prototype.greater = BigInteger.prototype.gt = BigInteger.prototype.greater;
    BigInteger.prototype.lesser = function (v) {
      return this.compare(v) < 0;
    };
    SmallInteger.prototype.lt = SmallInteger.prototype.lesser = BigInteger.prototype.lt = BigInteger.prototype.lesser;
    BigInteger.prototype.greaterOrEquals = function (v) {
      return this.compare(v) >= 0;
    };
    SmallInteger.prototype.geq = SmallInteger.prototype.greaterOrEquals = BigInteger.prototype.geq = BigInteger.prototype.greaterOrEquals;
    BigInteger.prototype.lesserOrEquals = function (v) {
      return this.compare(v) <= 0;
    };
    SmallInteger.prototype.leq = SmallInteger.prototype.lesserOrEquals = BigInteger.prototype.leq = BigInteger.prototype.lesserOrEquals;
    BigInteger.prototype.isEven = function () {
      return (this.value[0] & 1) === 0;
    };
    SmallInteger.prototype.isEven = function () {
      return (this.value & 1) === 0;
    };
    BigInteger.prototype.isOdd = function () {
      return (this.value[0] & 1) === 1;
    };
    SmallInteger.prototype.isOdd = function () {
      return (this.value & 1) === 1;
    };
    BigInteger.prototype.isPositive = function () {
      return !this.sign;
    };
    SmallInteger.prototype.isPositive = function () {
      return this.value > 0;
    };
    BigInteger.prototype.isNegative = function () {
      return this.sign;
    };
    SmallInteger.prototype.isNegative = function () {
      return this.value < 0;
    };
    BigInteger.prototype.isUnit = function () {
      return false;
    };
    SmallInteger.prototype.isUnit = function () {
      return Math.abs(this.value) === 1;
    };
    BigInteger.prototype.isZero = function () {
      return false;
    };
    SmallInteger.prototype.isZero = function () {
      return this.value === 0;
    };
    BigInteger.prototype.isDivisibleBy = function (v) {
      var n = parseValue(v);
      var value = n.value;
      if (value === 0) return false;
      if (value === 1) return true;
      if (value === 2) return this.isEven();
      return this.mod(n).equals(Integer[0]);
    };
    SmallInteger.prototype.isDivisibleBy = BigInteger.prototype.isDivisibleBy;
    function isBasicPrime(v) {
      var n = v.abs();
      if (n.isUnit()) return false;
      if (n.equals(2) || n.equals(3) || n.equals(5)) return true;
      if (n.isEven() || n.isDivisibleBy(3) || n.isDivisibleBy(5)) return false;
      if (n.lesser(49)) return true;
      // we don't know if it's prime: let the other functions figure it out
    }

    function millerRabinTest(n, a) {
      var nPrev = n.prev(),
        b = nPrev,
        r = 0,
        d,
        i,
        x;
      while (b.isEven()) b = b.divide(2), r++;
      next: for (i = 0; i < a.length; i++) {
        if (n.lesser(a[i])) continue;
        x = bigInt(a[i]).modPow(b, n);
        if (x.equals(Integer[1]) || x.equals(nPrev)) continue;
        for (d = r - 1; d != 0; d--) {
          x = x.square().mod(n);
          if (x.isUnit()) return false;
          if (x.equals(nPrev)) continue next;
        }
        return false;
      }
      return true;
    }

    // Set "strict" to true to force GRH-supported lower bound of 2*log(N)^2
    BigInteger.prototype.isPrime = function (strict) {
      var isPrime = isBasicPrime(this);
      if (isPrime !== undefined$1) return isPrime;
      var n = this.abs();
      var bits = n.bitLength();
      if (bits <= 64) return millerRabinTest(n, [2, 325, 9375, 28178, 450775, 9780504, 1795265022]);
      var logN = Math.log(2) * bits;
      var t = Math.ceil(strict === true ? 2 * Math.pow(logN, 2) : logN);
      for (var a = [], i = 0; i < t; i++) {
        a.push(bigInt(i + 2));
      }
      return millerRabinTest(n, a);
    };
    SmallInteger.prototype.isPrime = BigInteger.prototype.isPrime;
    BigInteger.prototype.isProbablePrime = function (iterations) {
      var isPrime = isBasicPrime(this);
      if (isPrime !== undefined$1) return isPrime;
      var n = this.abs();
      var t = iterations === undefined$1 ? 5 : iterations;
      for (var a = [], i = 0; i < t; i++) {
        a.push(bigInt.randBetween(2, n.minus(2)));
      }
      return millerRabinTest(n, a);
    };
    SmallInteger.prototype.isProbablePrime = BigInteger.prototype.isProbablePrime;
    BigInteger.prototype.modInv = function (n) {
      var t = bigInt.zero,
        newT = bigInt.one,
        r = parseValue(n),
        newR = this.abs(),
        q,
        lastT,
        lastR;
      while (!newR.equals(bigInt.zero)) {
        q = r.divide(newR);
        lastT = t;
        lastR = r;
        t = newT;
        r = newR;
        newT = lastT.subtract(q.multiply(newT));
        newR = lastR.subtract(q.multiply(newR));
      }
      if (!r.equals(1)) throw new Error(this.toString() + " and " + n.toString() + " are not co-prime");
      if (t.compare(0) === -1) {
        t = t.add(n);
      }
      if (this.isNegative()) {
        return t.negate();
      }
      return t;
    };
    SmallInteger.prototype.modInv = BigInteger.prototype.modInv;
    BigInteger.prototype.next = function () {
      var value = this.value;
      if (this.sign) {
        return subtractSmall(value, 1, this.sign);
      }
      return new BigInteger(addSmall(value, 1), this.sign);
    };
    SmallInteger.prototype.next = function () {
      var value = this.value;
      if (value + 1 < MAX_INT) return new SmallInteger(value + 1);
      return new BigInteger(MAX_INT_ARR, false);
    };
    BigInteger.prototype.prev = function () {
      var value = this.value;
      if (this.sign) {
        return new BigInteger(addSmall(value, 1), true);
      }
      return subtractSmall(value, 1, this.sign);
    };
    SmallInteger.prototype.prev = function () {
      var value = this.value;
      if (value - 1 > -MAX_INT) return new SmallInteger(value - 1);
      return new BigInteger(MAX_INT_ARR, true);
    };
    var powersOfTwo = [1];
    while (2 * powersOfTwo[powersOfTwo.length - 1] <= BASE) powersOfTwo.push(2 * powersOfTwo[powersOfTwo.length - 1]);
    var powers2Length = powersOfTwo.length,
      highestPower2 = powersOfTwo[powers2Length - 1];
    function shift_isSmall(n) {
      return (typeof n === "number" || typeof n === "string") && +Math.abs(n) <= BASE || n instanceof BigInteger && n.value.length <= 1;
    }
    BigInteger.prototype.shiftLeft = function (n) {
      if (!shift_isSmall(n)) {
        throw new Error(String(n) + " is too large for shifting.");
      }
      n = +n;
      if (n < 0) return this.shiftRight(-n);
      var result = this;
      if (result.isZero()) return result;
      while (n >= powers2Length) {
        result = result.multiply(highestPower2);
        n -= powers2Length - 1;
      }
      return result.multiply(powersOfTwo[n]);
    };
    SmallInteger.prototype.shiftLeft = BigInteger.prototype.shiftLeft;
    BigInteger.prototype.shiftRight = function (n) {
      var remQuo;
      if (!shift_isSmall(n)) {
        throw new Error(String(n) + " is too large for shifting.");
      }
      n = +n;
      if (n < 0) return this.shiftLeft(-n);
      var result = this;
      while (n >= powers2Length) {
        if (result.isZero() || result.isNegative() && result.isUnit()) return result;
        remQuo = divModAny(result, highestPower2);
        result = remQuo[1].isNegative() ? remQuo[0].prev() : remQuo[0];
        n -= powers2Length - 1;
      }
      remQuo = divModAny(result, powersOfTwo[n]);
      return remQuo[1].isNegative() ? remQuo[0].prev() : remQuo[0];
    };
    SmallInteger.prototype.shiftRight = BigInteger.prototype.shiftRight;
    function bitwise(x, y, fn) {
      y = parseValue(y);
      var xSign = x.isNegative(),
        ySign = y.isNegative();
      var xRem = xSign ? x.not() : x,
        yRem = ySign ? y.not() : y;
      var xDigit = 0,
        yDigit = 0;
      var xDivMod = null,
        yDivMod = null;
      var result = [];
      while (!xRem.isZero() || !yRem.isZero()) {
        xDivMod = divModAny(xRem, highestPower2);
        xDigit = xDivMod[1].toJSNumber();
        if (xSign) {
          xDigit = highestPower2 - 1 - xDigit; // two's complement for negative numbers
        }

        yDivMod = divModAny(yRem, highestPower2);
        yDigit = yDivMod[1].toJSNumber();
        if (ySign) {
          yDigit = highestPower2 - 1 - yDigit; // two's complement for negative numbers
        }

        xRem = xDivMod[0];
        yRem = yDivMod[0];
        result.push(fn(xDigit, yDigit));
      }
      var sum = fn(xSign ? 1 : 0, ySign ? 1 : 0) !== 0 ? bigInt(-1) : bigInt(0);
      for (var i = result.length - 1; i >= 0; i -= 1) {
        sum = sum.multiply(highestPower2).add(bigInt(result[i]));
      }
      return sum;
    }
    BigInteger.prototype.not = function () {
      return this.negate().prev();
    };
    SmallInteger.prototype.not = BigInteger.prototype.not;
    BigInteger.prototype.and = function (n) {
      return bitwise(this, n, function (a, b) {
        return a & b;
      });
    };
    SmallInteger.prototype.and = BigInteger.prototype.and;
    BigInteger.prototype.or = function (n) {
      return bitwise(this, n, function (a, b) {
        return a | b;
      });
    };
    SmallInteger.prototype.or = BigInteger.prototype.or;
    BigInteger.prototype.xor = function (n) {
      return bitwise(this, n, function (a, b) {
        return a ^ b;
      });
    };
    SmallInteger.prototype.xor = BigInteger.prototype.xor;
    var LOBMASK_I = 1 << 30,
      LOBMASK_BI = (BASE & -BASE) * (BASE & -BASE) | LOBMASK_I;
    function roughLOB(n) {
      // get lowestOneBit (rough)
      // SmallInteger: return Min(lowestOneBit(n), 1 << 30)
      // BigInteger: return Min(lowestOneBit(n), 1 << 14) [BASE=1e7]
      var v = n.value,
        x = typeof v === "number" ? v | LOBMASK_I : v[0] + v[1] * BASE | LOBMASK_BI;
      return x & -x;
    }
    function integerLogarithm(value, base) {
      if (base.compareTo(value) <= 0) {
        var tmp = integerLogarithm(value, base.square(base));
        var p = tmp.p;
        var e = tmp.e;
        var t = p.multiply(base);
        return t.compareTo(value) <= 0 ? {
          p: t,
          e: e * 2 + 1
        } : {
          p: p,
          e: e * 2
        };
      }
      return {
        p: bigInt(1),
        e: 0
      };
    }
    BigInteger.prototype.bitLength = function () {
      var n = this;
      if (n.compareTo(bigInt(0)) < 0) {
        n = n.negate().subtract(bigInt(1));
      }
      if (n.compareTo(bigInt(0)) === 0) {
        return bigInt(0);
      }
      return bigInt(integerLogarithm(n, bigInt(2)).e).add(bigInt(1));
    };
    SmallInteger.prototype.bitLength = BigInteger.prototype.bitLength;
    function max(a, b) {
      a = parseValue(a);
      b = parseValue(b);
      return a.greater(b) ? a : b;
    }
    function min(a, b) {
      a = parseValue(a);
      b = parseValue(b);
      return a.lesser(b) ? a : b;
    }
    function gcd(a, b) {
      a = parseValue(a).abs();
      b = parseValue(b).abs();
      if (a.equals(b)) return a;
      if (a.isZero()) return b;
      if (b.isZero()) return a;
      var c = Integer[1],
        d,
        t;
      while (a.isEven() && b.isEven()) {
        d = Math.min(roughLOB(a), roughLOB(b));
        a = a.divide(d);
        b = b.divide(d);
        c = c.multiply(d);
      }
      while (a.isEven()) {
        a = a.divide(roughLOB(a));
      }
      do {
        while (b.isEven()) {
          b = b.divide(roughLOB(b));
        }
        if (a.greater(b)) {
          t = b;
          b = a;
          a = t;
        }
        b = b.subtract(a);
      } while (!b.isZero());
      return c.isUnit() ? a : a.multiply(c);
    }
    function lcm(a, b) {
      a = parseValue(a).abs();
      b = parseValue(b).abs();
      return a.divide(gcd(a, b)).multiply(b);
    }
    function randBetween(a, b) {
      a = parseValue(a);
      b = parseValue(b);
      var low = min(a, b),
        high = max(a, b);
      var range = high.subtract(low).add(1);
      if (range.isSmall) return low.add(Math.floor(Math.random() * range));
      var length = range.value.length - 1;
      var result = [],
        restricted = true;
      for (var i = length; i >= 0; i--) {
        var top = restricted ? range.value[i] : BASE;
        var digit = truncate(Math.random() * top);
        result.unshift(digit);
        if (digit < top) restricted = false;
      }
      result = arrayToSmall(result);
      return low.add(typeof result === "number" ? new SmallInteger(result) : new BigInteger(result, false));
    }
    var parseBase = function parseBase(text, base) {
      var length = text.length;
      var i;
      var absBase = Math.abs(base);
      for (var i = 0; i < length; i++) {
        var c = text[i].toLowerCase();
        if (c === "-") continue;
        if (/[a-z0-9]/.test(c)) {
          if (/[0-9]/.test(c) && +c >= absBase) {
            if (c === "1" && absBase === 1) continue;
            throw new Error(c + " is not a valid digit in base " + base + ".");
          } else if (c.charCodeAt(0) - 87 >= absBase) {
            throw new Error(c + " is not a valid digit in base " + base + ".");
          }
        }
      }
      if (2 <= base && base <= 36) {
        if (length <= LOG_MAX_INT / Math.log(base)) {
          var result = parseInt(text, base);
          if (isNaN(result)) {
            throw new Error(c + " is not a valid digit in base " + base + ".");
          }
          return new SmallInteger(parseInt(text, base));
        }
      }
      base = parseValue(base);
      var digits = [];
      var isNegative = text[0] === "-";
      for (i = isNegative ? 1 : 0; i < text.length; i++) {
        var c = text[i].toLowerCase(),
          charCode = c.charCodeAt(0);
        if (48 <= charCode && charCode <= 57) digits.push(parseValue(c));else if (97 <= charCode && charCode <= 122) digits.push(parseValue(c.charCodeAt(0) - 87));else if (c === "<") {
          var start = i;
          do {
            i++;
          } while (text[i] !== ">");
          digits.push(parseValue(text.slice(start + 1, i)));
        } else throw new Error(c + " is not a valid character");
      }
      return parseBaseFromArray(digits, base, isNegative);
    };
    function parseBaseFromArray(digits, base, isNegative) {
      var val = Integer[0],
        pow = Integer[1],
        i;
      for (i = digits.length - 1; i >= 0; i--) {
        val = val.add(digits[i].times(pow));
        pow = pow.times(base);
      }
      return isNegative ? val.negate() : val;
    }
    function stringify(digit) {
      if (digit <= 35) {
        return "0123456789abcdefghijklmnopqrstuvwxyz".charAt(digit);
      }
      return "<" + digit + ">";
    }
    function toBase(n, base) {
      base = bigInt(base);
      if (base.isZero()) {
        if (n.isZero()) return {
          value: [0],
          isNegative: false
        };
        throw new Error("Cannot convert nonzero numbers to base 0.");
      }
      if (base.equals(-1)) {
        if (n.isZero()) return {
          value: [0],
          isNegative: false
        };
        if (n.isNegative()) return {
          value: [].concat.apply([], Array.apply(null, Array(-n)).map(Array.prototype.valueOf, [1, 0])),
          isNegative: false
        };
        var arr = Array.apply(null, Array(+n - 1)).map(Array.prototype.valueOf, [0, 1]);
        arr.unshift([1]);
        return {
          value: [].concat.apply([], arr),
          isNegative: false
        };
      }
      var neg = false;
      if (n.isNegative() && base.isPositive()) {
        neg = true;
        n = n.abs();
      }
      if (base.equals(1)) {
        if (n.isZero()) return {
          value: [0],
          isNegative: false
        };
        return {
          value: Array.apply(null, Array(+n)).map(Number.prototype.valueOf, 1),
          isNegative: neg
        };
      }
      var out = [];
      var left = n,
        divmod;
      while (left.isNegative() || left.compareAbs(base) >= 0) {
        divmod = left.divmod(base);
        left = divmod.quotient;
        var digit = divmod.remainder;
        if (digit.isNegative()) {
          digit = base.minus(digit).abs();
          left = left.next();
        }
        out.push(digit.toJSNumber());
      }
      out.push(left.toJSNumber());
      return {
        value: out.reverse(),
        isNegative: neg
      };
    }
    function toBaseString(n, base) {
      var arr = toBase(n, base);
      return (arr.isNegative ? "-" : "") + arr.value.map(stringify).join('');
    }
    BigInteger.prototype.toArray = function (radix) {
      return toBase(this, radix);
    };
    SmallInteger.prototype.toArray = function (radix) {
      return toBase(this, radix);
    };
    BigInteger.prototype.toString = function (radix) {
      if (radix === undefined$1) radix = 10;
      if (radix !== 10) return toBaseString(this, radix);
      var v = this.value,
        l = v.length,
        str = String(v[--l]),
        zeros = "0000000",
        digit;
      while (--l >= 0) {
        digit = String(v[l]);
        str += zeros.slice(digit.length) + digit;
      }
      var sign = this.sign ? "-" : "";
      return sign + str;
    };
    SmallInteger.prototype.toString = function (radix) {
      if (radix === undefined$1) radix = 10;
      if (radix != 10) return toBaseString(this, radix);
      return String(this.value);
    };
    BigInteger.prototype.toJSON = SmallInteger.prototype.toJSON = function () {
      return this.toString();
    };
    BigInteger.prototype.valueOf = function () {
      return parseInt(this.toString(), 10);
    };
    BigInteger.prototype.toJSNumber = BigInteger.prototype.valueOf;
    SmallInteger.prototype.valueOf = function () {
      return this.value;
    };
    SmallInteger.prototype.toJSNumber = SmallInteger.prototype.valueOf;
    function parseStringValue(v) {
      if (isPrecise(+v)) {
        var x = +v;
        if (x === truncate(x)) return new SmallInteger(x);
        throw new Error("Invalid integer: " + v);
      }
      var sign = v[0] === "-";
      if (sign) v = v.slice(1);
      var split = v.split(/e/i);
      if (split.length > 2) throw new Error("Invalid integer: " + split.join("e"));
      if (split.length === 2) {
        var exp = split[1];
        if (exp[0] === "+") exp = exp.slice(1);
        exp = +exp;
        if (exp !== truncate(exp) || !isPrecise(exp)) throw new Error("Invalid integer: " + exp + " is not a valid exponent.");
        var text = split[0];
        var decimalPlace = text.indexOf(".");
        if (decimalPlace >= 0) {
          exp -= text.length - decimalPlace - 1;
          text = text.slice(0, decimalPlace) + text.slice(decimalPlace + 1);
        }
        if (exp < 0) throw new Error("Cannot include negative exponent part for integers");
        text += new Array(exp + 1).join("0");
        v = text;
      }
      var isValid = /^([0-9][0-9]*)$/.test(v);
      if (!isValid) throw new Error("Invalid integer: " + v);
      var r = [],
        max = v.length,
        l = LOG_BASE,
        min = max - l;
      while (max > 0) {
        r.push(+v.slice(min, max));
        min -= l;
        if (min < 0) min = 0;
        max -= l;
      }
      trim(r);
      return new BigInteger(r, sign);
    }
    function parseNumberValue(v) {
      if (isPrecise(v)) {
        if (v !== truncate(v)) throw new Error(v + " is not an integer.");
        return new SmallInteger(v);
      }
      return parseStringValue(v.toString());
    }
    function parseValue(v) {
      if (typeof v === "number") {
        return parseNumberValue(v);
      }
      if (typeof v === "string") {
        return parseStringValue(v);
      }
      return v;
    }
    // Pre-define numbers in range [-999,999]
    for (var i = 0; i < 1000; i++) {
      Integer[i] = new SmallInteger(i);
      if (i > 0) Integer[-i] = new SmallInteger(-i);
    }
    // Backwards compatibility
    Integer.one = Integer[1];
    Integer.zero = Integer[0];
    Integer.minusOne = Integer[-1];
    Integer.max = max;
    Integer.min = min;
    Integer.gcd = gcd;
    Integer.lcm = lcm;
    Integer.isInstance = function (x) {
      return x instanceof BigInteger || x instanceof SmallInteger;
    };
    Integer.randBetween = randBetween;
    Integer.fromArray = function (digits, base, isNegative) {
      return parseBaseFromArray(digits.map(parseValue), parseValue(base || 10), isNegative);
    };
    return Integer;
  }();

  // Node.js check
  if (module.hasOwnProperty("exports")) {
    module.exports = bigInt;
  }
})(BigInteger);
var BigIntegerExports = BigInteger.exports;

var validate$1 = validation$1.validate;

/**
 * Converts an array of integers made up of 'from' bits into an
 * array of integers made up of 'to' bits. The output array is
 * zero-padded if necessary, unless strict mode is true.
 * Throws a {@link ValidationError} if input is invalid.
 * Original by Pieter Wuille: https://github.com/sipa/bech32.
 *
 * @param {Uint8Array} data Array of integers made up of 'from' bits.
 * @param {number} from Length in bits of elements in the input array.
 * @param {number} to Length in bits of elements in the output array.
 * @param {bool} strictMode Require the conversion to be completed without padding.
 * @returns {Uint8Array}
 */
var convertBits$1 = function convertBits(data, from, to, strictMode) {
  var length = strictMode ? Math.floor(data.length * from / to) : Math.ceil(data.length * from / to);
  var mask = (1 << to) - 1;
  var result = new Uint8Array(length);
  var index = 0;
  var accumulator = 0;
  var bits = 0;
  for (var i = 0; i < data.length; ++i) {
    var value = data[i];
    validate$1(0 <= value && value >> from === 0, 'Invalid value: ' + value + '.');
    accumulator = accumulator << from | value;
    bits += from;
    while (bits >= to) {
      bits -= to;
      result[index] = accumulator >> bits & mask;
      ++index;
    }
  }
  if (!strictMode) {
    if (bits > 0) {
      result[index] = accumulator << to - bits & mask;
      ++index;
    }
  } else {
    validate$1(bits < from && (accumulator << to - bits & mask) === 0, 'Input cannot be converted to ' + to + ' bits without padding, but strict mode was used.');
  }
  return result;
};

/**
 * @license
 * https://github.com/ealmansi/cashaddrjs
 * Copyright (c) 2017-2020 Emilio Almansi
 * Distributed under the MIT software license, see the accompanying
 * file LICENSE or http://www.opensource.org/licenses/mit-license.php.
 */
var base32 = base32$1;
var bigInt = BigIntegerExports;
var convertBits = convertBits$1;
var validation = validation$1;
var validate = validation.validate;

/**
 * Encoding and decoding of the new Cash Address format for Bitcoin Cash. <br />
 * Compliant with the original cashaddr specification:
 * {@link https://github.com/bitcoincashorg/bitcoincash.org/blob/master/spec/cashaddr.md}
 * @module cashaddr
 */

/**
 * Encodes a hash from a given type into a Bitcoin Cash address with the given prefix.
 * 
 * @static
 * @param {string} prefix Network prefix. E.g.: 'bitcoincash'.
 * @param {string} type Type of address to generate. Either 'P2PKH' or 'P2SH'.
 * @param {Uint8Array} hash Hash to encode represented as an array of 8-bit integers.
 * @returns {string}
 * @throws {ValidationError}
 */
function encode$2(prefix, type, hash) {
  validate(typeof prefix === 'string' && isValidPrefix(prefix), 'Invalid prefix: ' + prefix + '.');
  validate(typeof type === 'string', 'Invalid type: ' + type + '.');
  validate(hash instanceof Uint8Array, 'Invalid hash: ' + hash + '.');
  var prefixData = concat(prefixToUint5Array(prefix), new Uint8Array(1));
  var versionByte = getTypeBits(type) + getHashSizeBits(hash);
  var payloadData = toUint5Array(concat(new Uint8Array([versionByte]), hash));
  var checksumData = concat(concat(prefixData, payloadData), new Uint8Array(8));
  var payload = concat(payloadData, checksumToUint5Array(polymod(checksumData)));
  return prefix + ':' + base32.encode(payload);
}

/**
 * Decodes the given address into its constituting prefix, type and hash. See [#encode()]{@link encode}.
 * 
 * @static
 * @param {string} address Address to decode. E.g.: 'bitcoincash:qpm2qsznhks23z7629mms6s4cwef74vcwvy22gdx6a'.
 * @returns {object}
 * @throws {ValidationError}
 */
function decode$2(address) {
  validate(typeof address === 'string' && hasSingleCase(address), 'Invalid address: ' + address + '.');
  var pieces = address.toLowerCase().split(':');
  validate(pieces.length === 2, 'Missing prefix: ' + address + '.');
  var prefix = pieces[0];
  var payload = base32.decode(pieces[1]);
  validate(validChecksum(prefix, payload), 'Invalid checksum: ' + address + '.');
  var payloadData = fromUint5Array(payload.subarray(0, -8));
  var versionByte = payloadData[0];
  var hash = payloadData.subarray(1);
  validate(getHashSize(versionByte) === hash.length * 8, 'Invalid hash size: ' + address + '.');
  var type = getType(versionByte);
  return {
    prefix: prefix,
    type: type,
    hash: hash
  };
}

/**
 * Error thrown when encoding or decoding fail due to invalid input.
 *
 * @constructor ValidationError
 * @param {string} message Error description.
 */
var ValidationError = validation.ValidationError;

/**
 * Valid address prefixes.
 *
 * @private
 */
var VALID_PREFIXES = ['bitcoincash', 'bchtest', 'bchreg'];

/**
 * Checks whether a string is a valid prefix; ie., it has a single letter case
 * and is one of 'bitcoincash', 'bchtest', or 'bchreg'.
 *
 * @private
 * @param {string} prefix 
 * @returns {boolean}
 */
function isValidPrefix(prefix) {
  return hasSingleCase(prefix) && VALID_PREFIXES.indexOf(prefix.toLowerCase()) !== -1;
}

/**
 * Derives an array from the given prefix to be used in the computation
 * of the address' checksum.
 *
 * @private
 * @param {string} prefix Network prefix. E.g.: 'bitcoincash'. 
 * @returns {Uint8Array}
 */
function prefixToUint5Array(prefix) {
  var result = new Uint8Array(prefix.length);
  for (var i = 0; i < prefix.length; ++i) {
    result[i] = prefix[i].charCodeAt(0) & 31;
  }
  return result;
}

/**
 * Returns an array representation of the given checksum to be encoded
 * within the address' payload.
 *
 * @private
 * @param {BigInteger} checksum Computed checksum.
 * @returns {Uint8Array}
 */
function checksumToUint5Array(checksum) {
  var result = new Uint8Array(8);
  for (var i = 0; i < 8; ++i) {
    result[7 - i] = checksum.and(31).toJSNumber();
    checksum = checksum.shiftRight(5);
  }
  return result;
}

/**
 * Returns the bit representation of the given type within the version
 * byte.
 *
 * @private
 * @param {string} type Address type. Either 'P2PKH' or 'P2SH'.
 * @returns {number}
 * @throws {ValidationError}
 */
function getTypeBits(type) {
  switch (type) {
    case 'P2PKH':
      return 0;
    case 'P2SH':
      return 8;
    default:
      throw new ValidationError('Invalid type: ' + type + '.');
  }
}

/**
 * Retrieves the address type from its bit representation within the
 * version byte.
 *
 * @private
 * @param {number} versionByte
 * @returns {string}
 * @throws {ValidationError}
 */
function getType(versionByte) {
  switch (versionByte & 120) {
    case 0:
      return 'P2PKH';
    case 8:
      return 'P2SH';
    default:
      throw new ValidationError('Invalid address type in version byte: ' + versionByte + '.');
  }
}

/**
 * Returns the bit representation of the length in bits of the given
 * hash within the version byte.
 *
 * @private
 * @param {Uint8Array} hash Hash to encode represented as an array of 8-bit integers.
 * @returns {number}
 * @throws {ValidationError}
 */
function getHashSizeBits(hash) {
  switch (hash.length * 8) {
    case 160:
      return 0;
    case 192:
      return 1;
    case 224:
      return 2;
    case 256:
      return 3;
    case 320:
      return 4;
    case 384:
      return 5;
    case 448:
      return 6;
    case 512:
      return 7;
    default:
      throw new ValidationError('Invalid hash size: ' + hash.length + '.');
  }
}

/**
 * Retrieves the the length in bits of the encoded hash from its bit
 * representation within the version byte.
 *
 * @private
 * @param {number} versionByte
 * @returns {number}
 */
function getHashSize(versionByte) {
  switch (versionByte & 7) {
    case 0:
      return 160;
    case 1:
      return 192;
    case 2:
      return 224;
    case 3:
      return 256;
    case 4:
      return 320;
    case 5:
      return 384;
    case 6:
      return 448;
    case 7:
      return 512;
  }
}

/**
 * Converts an array of 8-bit integers into an array of 5-bit integers,
 * right-padding with zeroes if necessary.
 *
 * @private
 * @param {Uint8Array} data
 * @returns {Uint8Array}
 */
function toUint5Array(data) {
  return convertBits(data, 8, 5);
}

/**
 * Converts an array of 5-bit integers back into an array of 8-bit integers,
 * removing extra zeroes left from padding if necessary.
 * Throws a {@link ValidationError} if input is not a zero-padded array of 8-bit integers.
 *
 * @private
 * @param {Uint8Array} data
 * @returns {Uint8Array}
 * @throws {ValidationError}
 */
function fromUint5Array(data) {
  return convertBits(data, 5, 8, true);
}

/**
 * Returns the concatenation a and b.
 *
 * @private
 * @param {Uint8Array} a 
 * @param {Uint8Array} b 
 * @returns {Uint8Array}
 * @throws {ValidationError}
 */
function concat(a, b) {
  var ab = new Uint8Array(a.length + b.length);
  ab.set(a);
  ab.set(b, a.length);
  return ab;
}

/**
 * Computes a checksum from the given input data as specified for the CashAddr
 * format: https://github.com/Bitcoin-UAHF/spec/blob/master/cashaddr.md.
 *
 * @private
 * @param {Uint8Array} data Array of 5-bit integers over which the checksum is to be computed.
 * @returns {BigInteger}
 */
function polymod(data) {
  var GENERATOR = [0x98f2bc8e61, 0x79b76d99e2, 0xf33e5fb3c4, 0xae2eabe2a8, 0x1e4f43e470];
  var checksum = bigInt(1);
  for (var i = 0; i < data.length; ++i) {
    var value = data[i];
    var topBits = checksum.shiftRight(35);
    checksum = checksum.and(0x07ffffffff).shiftLeft(5).xor(value);
    for (var j = 0; j < GENERATOR.length; ++j) {
      if (topBits.shiftRight(j).and(1).equals(1)) {
        checksum = checksum.xor(GENERATOR[j]);
      }
    }
  }
  return checksum.xor(1);
}

/**
 * Verify that the payload has not been corrupted by checking that the
 * checksum is valid.
 * 
 * @private
 * @param {string} prefix Network prefix. E.g.: 'bitcoincash'.
 * @param {Uint8Array} payload Array of 5-bit integers containing the address' payload.
 * @returns {boolean}
 */
function validChecksum(prefix, payload) {
  var prefixData = concat(prefixToUint5Array(prefix), new Uint8Array(1));
  var checksumData = concat(prefixData, payload);
  return polymod(checksumData).equals(0);
}

/**
 * Returns true if, and only if, the given string contains either uppercase
 * or lowercase letters, but not both.
 *
 * @private
 * @param {string} string Input string.
 * @returns {boolean}
 */
function hasSingleCase(string) {
  return string === string.toLowerCase() || string === string.toUpperCase();
}
var cashaddr$1 = {
  encode: encode$2,
  decode: decode$2,
  ValidationError: ValidationError
};

var buffer = {};

var base64Js = {};

base64Js.byteLength = byteLength;
base64Js.toByteArray = toByteArray;
base64Js.fromByteArray = fromByteArray;
var lookup = [];
var revLookup = [];
var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array;
var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
for (var i = 0, len = code.length; i < len; ++i) {
  lookup[i] = code[i];
  revLookup[code.charCodeAt(i)] = i;
}

// Support decoding URL-safe base64 strings, as Node.js does.
// See: https://en.wikipedia.org/wiki/Base64#URL_applications
revLookup['-'.charCodeAt(0)] = 62;
revLookup['_'.charCodeAt(0)] = 63;
function getLens(b64) {
  var len = b64.length;
  if (len % 4 > 0) {
    throw new Error('Invalid string. Length must be a multiple of 4');
  }

  // Trim off extra bytes after placeholder bytes are found
  // See: https://github.com/beatgammit/base64-js/issues/42
  var validLen = b64.indexOf('=');
  if (validLen === -1) validLen = len;
  var placeHoldersLen = validLen === len ? 0 : 4 - validLen % 4;
  return [validLen, placeHoldersLen];
}

// base64 is 4/3 + up to two characters of the original data
function byteLength(b64) {
  var lens = getLens(b64);
  var validLen = lens[0];
  var placeHoldersLen = lens[1];
  return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
}
function _byteLength(b64, validLen, placeHoldersLen) {
  return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
}
function toByteArray(b64) {
  var tmp;
  var lens = getLens(b64);
  var validLen = lens[0];
  var placeHoldersLen = lens[1];
  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));
  var curByte = 0;

  // if there are placeholders, only get up to the last complete 4 chars
  var len = placeHoldersLen > 0 ? validLen - 4 : validLen;
  var i;
  for (i = 0; i < len; i += 4) {
    tmp = revLookup[b64.charCodeAt(i)] << 18 | revLookup[b64.charCodeAt(i + 1)] << 12 | revLookup[b64.charCodeAt(i + 2)] << 6 | revLookup[b64.charCodeAt(i + 3)];
    arr[curByte++] = tmp >> 16 & 0xFF;
    arr[curByte++] = tmp >> 8 & 0xFF;
    arr[curByte++] = tmp & 0xFF;
  }
  if (placeHoldersLen === 2) {
    tmp = revLookup[b64.charCodeAt(i)] << 2 | revLookup[b64.charCodeAt(i + 1)] >> 4;
    arr[curByte++] = tmp & 0xFF;
  }
  if (placeHoldersLen === 1) {
    tmp = revLookup[b64.charCodeAt(i)] << 10 | revLookup[b64.charCodeAt(i + 1)] << 4 | revLookup[b64.charCodeAt(i + 2)] >> 2;
    arr[curByte++] = tmp >> 8 & 0xFF;
    arr[curByte++] = tmp & 0xFF;
  }
  return arr;
}
function tripletToBase64(num) {
  return lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F];
}
function encodeChunk(uint8, start, end) {
  var tmp;
  var output = [];
  for (var i = start; i < end; i += 3) {
    tmp = (uint8[i] << 16 & 0xFF0000) + (uint8[i + 1] << 8 & 0xFF00) + (uint8[i + 2] & 0xFF);
    output.push(tripletToBase64(tmp));
  }
  return output.join('');
}
function fromByteArray(uint8) {
  var tmp;
  var len = uint8.length;
  var extraBytes = len % 3; // if we have 1 byte left, pad 2 bytes
  var parts = [];
  var maxChunkLength = 16383; // must be multiple of 3

  // go through the array every three bytes, we'll deal with trailing stuff later
  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
    parts.push(encodeChunk(uint8, i, i + maxChunkLength > len2 ? len2 : i + maxChunkLength));
  }

  // pad the end with zeros, but make sure to not forget the extra bytes
  if (extraBytes === 1) {
    tmp = uint8[len - 1];
    parts.push(lookup[tmp >> 2] + lookup[tmp << 4 & 0x3F] + '==');
  } else if (extraBytes === 2) {
    tmp = (uint8[len - 2] << 8) + uint8[len - 1];
    parts.push(lookup[tmp >> 10] + lookup[tmp >> 4 & 0x3F] + lookup[tmp << 2 & 0x3F] + '=');
  }
  return parts.join('');
}

var ieee754 = {};

/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
ieee754.read = function (buffer, offset, isLE, mLen, nBytes) {
  var e, m;
  var eLen = nBytes * 8 - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var nBits = -7;
  var i = isLE ? nBytes - 1 : 0;
  var d = isLE ? -1 : 1;
  var s = buffer[offset + i];
  i += d;
  e = s & (1 << -nBits) - 1;
  s >>= -nBits;
  nBits += eLen;
  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}
  m = e & (1 << -nBits) - 1;
  e >>= -nBits;
  nBits += mLen;
  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}
  if (e === 0) {
    e = 1 - eBias;
  } else if (e === eMax) {
    return m ? NaN : (s ? -1 : 1) * Infinity;
  } else {
    m = m + Math.pow(2, mLen);
    e = e - eBias;
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
};
ieee754.write = function (buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c;
  var eLen = nBytes * 8 - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
  var i = isLE ? 0 : nBytes - 1;
  var d = isLE ? 1 : -1;
  var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
  value = Math.abs(value);
  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0;
    e = eMax;
  } else {
    e = Math.floor(Math.log(value) / Math.LN2);
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--;
      c *= 2;
    }
    if (e + eBias >= 1) {
      value += rt / c;
    } else {
      value += rt * Math.pow(2, 1 - eBias);
    }
    if (value * c >= 2) {
      e++;
      c /= 2;
    }
    if (e + eBias >= eMax) {
      m = 0;
      e = eMax;
    } else if (e + eBias >= 1) {
      m = (value * c - 1) * Math.pow(2, mLen);
      e = e + eBias;
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
      e = 0;
    }
  }
  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}
  e = e << mLen | m;
  eLen += mLen;
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}
  buffer[offset + i - d] |= s * 128;
};

(function (exports) {

  var base64 = base64Js;
  var ieee754$1 = ieee754;
  var customInspectSymbol = typeof Symbol === 'function' && typeof Symbol['for'] === 'function' // eslint-disable-line dot-notation
  ? Symbol['for']('nodejs.util.inspect.custom') // eslint-disable-line dot-notation
  : null;
  exports.Buffer = Buffer;
  exports.SlowBuffer = SlowBuffer;
  exports.INSPECT_MAX_BYTES = 50;
  var K_MAX_LENGTH = 0x7fffffff;
  exports.kMaxLength = K_MAX_LENGTH;

  /**
   * If `Buffer.TYPED_ARRAY_SUPPORT`:
   *   === true    Use Uint8Array implementation (fastest)
   *   === false   Print warning and recommend using `buffer` v4.x which has an Object
   *               implementation (most compatible, even IE6)
   *
   * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
   * Opera 11.6+, iOS 4.2+.
   *
   * We report that the browser does not support typed arrays if the are not subclassable
   * using __proto__. Firefox 4-29 lacks support for adding new properties to `Uint8Array`
   * (See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438). IE 10 lacks support
   * for __proto__ and has a buggy typed array implementation.
   */
  Buffer.TYPED_ARRAY_SUPPORT = typedArraySupport();
  if (!Buffer.TYPED_ARRAY_SUPPORT && typeof console !== 'undefined' && typeof console.error === 'function') {
    console.error('This browser lacks typed array (Uint8Array) support which is required by ' + '`buffer` v5.x. Use `buffer` v4.x if you require old browser support.');
  }
  function typedArraySupport() {
    // Can typed array instances can be augmented?
    try {
      var arr = new Uint8Array(1);
      var proto = {
        foo: function foo() {
          return 42;
        }
      };
      Object.setPrototypeOf(proto, Uint8Array.prototype);
      Object.setPrototypeOf(arr, proto);
      return arr.foo() === 42;
    } catch (e) {
      return false;
    }
  }
  Object.defineProperty(Buffer.prototype, 'parent', {
    enumerable: true,
    get: function get() {
      if (!Buffer.isBuffer(this)) return undefined;
      return this.buffer;
    }
  });
  Object.defineProperty(Buffer.prototype, 'offset', {
    enumerable: true,
    get: function get() {
      if (!Buffer.isBuffer(this)) return undefined;
      return this.byteOffset;
    }
  });
  function createBuffer(length) {
    if (length > K_MAX_LENGTH) {
      throw new RangeError('The value "' + length + '" is invalid for option "size"');
    }
    // Return an augmented `Uint8Array` instance
    var buf = new Uint8Array(length);
    Object.setPrototypeOf(buf, Buffer.prototype);
    return buf;
  }

  /**
   * The Buffer constructor returns instances of `Uint8Array` that have their
   * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
   * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
   * and the `Uint8Array` methods. Square bracket notation works as expected -- it
   * returns a single octet.
   *
   * The `Uint8Array` prototype remains unmodified.
   */

  function Buffer(arg, encodingOrOffset, length) {
    // Common case.
    if (typeof arg === 'number') {
      if (typeof encodingOrOffset === 'string') {
        throw new TypeError('The "string" argument must be of type string. Received type number');
      }
      return allocUnsafe(arg);
    }
    return from(arg, encodingOrOffset, length);
  }
  Buffer.poolSize = 8192; // not used by this implementation

  function from(value, encodingOrOffset, length) {
    if (typeof value === 'string') {
      return fromString(value, encodingOrOffset);
    }
    if (ArrayBuffer.isView(value)) {
      return fromArrayView(value);
    }
    if (value == null) {
      throw new TypeError('The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' + 'or Array-like Object. Received type ' + _typeof(value));
    }
    if (isInstance(value, ArrayBuffer) || value && isInstance(value.buffer, ArrayBuffer)) {
      return fromArrayBuffer(value, encodingOrOffset, length);
    }
    if (typeof SharedArrayBuffer !== 'undefined' && (isInstance(value, SharedArrayBuffer) || value && isInstance(value.buffer, SharedArrayBuffer))) {
      return fromArrayBuffer(value, encodingOrOffset, length);
    }
    if (typeof value === 'number') {
      throw new TypeError('The "value" argument must not be of type number. Received type number');
    }
    var valueOf = value.valueOf && value.valueOf();
    if (valueOf != null && valueOf !== value) {
      return Buffer.from(valueOf, encodingOrOffset, length);
    }
    var b = fromObject(value);
    if (b) return b;
    if (typeof Symbol !== 'undefined' && Symbol.toPrimitive != null && typeof value[Symbol.toPrimitive] === 'function') {
      return Buffer.from(value[Symbol.toPrimitive]('string'), encodingOrOffset, length);
    }
    throw new TypeError('The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' + 'or Array-like Object. Received type ' + _typeof(value));
  }

  /**
   * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
   * if value is a number.
   * Buffer.from(str[, encoding])
   * Buffer.from(array)
   * Buffer.from(buffer)
   * Buffer.from(arrayBuffer[, byteOffset[, length]])
   **/
  Buffer.from = function (value, encodingOrOffset, length) {
    return from(value, encodingOrOffset, length);
  };

  // Note: Change prototype *after* Buffer.from is defined to workaround Chrome bug:
  // https://github.com/feross/buffer/pull/148
  Object.setPrototypeOf(Buffer.prototype, Uint8Array.prototype);
  Object.setPrototypeOf(Buffer, Uint8Array);
  function assertSize(size) {
    if (typeof size !== 'number') {
      throw new TypeError('"size" argument must be of type number');
    } else if (size < 0) {
      throw new RangeError('The value "' + size + '" is invalid for option "size"');
    }
  }
  function alloc(size, fill, encoding) {
    assertSize(size);
    if (size <= 0) {
      return createBuffer(size);
    }
    if (fill !== undefined) {
      // Only pay attention to encoding if it's a string. This
      // prevents accidentally sending in a number that would
      // be interpreted as a start offset.
      return typeof encoding === 'string' ? createBuffer(size).fill(fill, encoding) : createBuffer(size).fill(fill);
    }
    return createBuffer(size);
  }

  /**
   * Creates a new filled Buffer instance.
   * alloc(size[, fill[, encoding]])
   **/
  Buffer.alloc = function (size, fill, encoding) {
    return alloc(size, fill, encoding);
  };
  function allocUnsafe(size) {
    assertSize(size);
    return createBuffer(size < 0 ? 0 : checked(size) | 0);
  }

  /**
   * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
   * */
  Buffer.allocUnsafe = function (size) {
    return allocUnsafe(size);
  };
  /**
   * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
   */
  Buffer.allocUnsafeSlow = function (size) {
    return allocUnsafe(size);
  };
  function fromString(string, encoding) {
    if (typeof encoding !== 'string' || encoding === '') {
      encoding = 'utf8';
    }
    if (!Buffer.isEncoding(encoding)) {
      throw new TypeError('Unknown encoding: ' + encoding);
    }
    var length = byteLength(string, encoding) | 0;
    var buf = createBuffer(length);
    var actual = buf.write(string, encoding);
    if (actual !== length) {
      // Writing a hex string, for example, that contains invalid characters will
      // cause everything after the first invalid character to be ignored. (e.g.
      // 'abxxcd' will be treated as 'ab')
      buf = buf.slice(0, actual);
    }
    return buf;
  }
  function fromArrayLike(array) {
    var length = array.length < 0 ? 0 : checked(array.length) | 0;
    var buf = createBuffer(length);
    for (var i = 0; i < length; i += 1) {
      buf[i] = array[i] & 255;
    }
    return buf;
  }
  function fromArrayView(arrayView) {
    if (isInstance(arrayView, Uint8Array)) {
      var copy = new Uint8Array(arrayView);
      return fromArrayBuffer(copy.buffer, copy.byteOffset, copy.byteLength);
    }
    return fromArrayLike(arrayView);
  }
  function fromArrayBuffer(array, byteOffset, length) {
    if (byteOffset < 0 || array.byteLength < byteOffset) {
      throw new RangeError('"offset" is outside of buffer bounds');
    }
    if (array.byteLength < byteOffset + (length || 0)) {
      throw new RangeError('"length" is outside of buffer bounds');
    }
    var buf;
    if (byteOffset === undefined && length === undefined) {
      buf = new Uint8Array(array);
    } else if (length === undefined) {
      buf = new Uint8Array(array, byteOffset);
    } else {
      buf = new Uint8Array(array, byteOffset, length);
    }

    // Return an augmented `Uint8Array` instance
    Object.setPrototypeOf(buf, Buffer.prototype);
    return buf;
  }
  function fromObject(obj) {
    if (Buffer.isBuffer(obj)) {
      var len = checked(obj.length) | 0;
      var buf = createBuffer(len);
      if (buf.length === 0) {
        return buf;
      }
      obj.copy(buf, 0, 0, len);
      return buf;
    }
    if (obj.length !== undefined) {
      if (typeof obj.length !== 'number' || numberIsNaN(obj.length)) {
        return createBuffer(0);
      }
      return fromArrayLike(obj);
    }
    if (obj.type === 'Buffer' && Array.isArray(obj.data)) {
      return fromArrayLike(obj.data);
    }
  }
  function checked(length) {
    // Note: cannot use `length < K_MAX_LENGTH` here because that fails when
    // length is NaN (which is otherwise coerced to zero.)
    if (length >= K_MAX_LENGTH) {
      throw new RangeError('Attempt to allocate Buffer larger than maximum ' + 'size: 0x' + K_MAX_LENGTH.toString(16) + ' bytes');
    }
    return length | 0;
  }
  function SlowBuffer(length) {
    if (+length != length) {
      // eslint-disable-line eqeqeq
      length = 0;
    }
    return Buffer.alloc(+length);
  }
  Buffer.isBuffer = function isBuffer(b) {
    return b != null && b._isBuffer === true && b !== Buffer.prototype; // so Buffer.isBuffer(Buffer.prototype) will be false
  };

  Buffer.compare = function compare(a, b) {
    if (isInstance(a, Uint8Array)) a = Buffer.from(a, a.offset, a.byteLength);
    if (isInstance(b, Uint8Array)) b = Buffer.from(b, b.offset, b.byteLength);
    if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
      throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');
    }
    if (a === b) return 0;
    var x = a.length;
    var y = b.length;
    for (var i = 0, len = Math.min(x, y); i < len; ++i) {
      if (a[i] !== b[i]) {
        x = a[i];
        y = b[i];
        break;
      }
    }
    if (x < y) return -1;
    if (y < x) return 1;
    return 0;
  };
  Buffer.isEncoding = function isEncoding(encoding) {
    switch (String(encoding).toLowerCase()) {
      case 'hex':
      case 'utf8':
      case 'utf-8':
      case 'ascii':
      case 'latin1':
      case 'binary':
      case 'base64':
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return true;
      default:
        return false;
    }
  };
  Buffer.concat = function concat(list, length) {
    if (!Array.isArray(list)) {
      throw new TypeError('"list" argument must be an Array of Buffers');
    }
    if (list.length === 0) {
      return Buffer.alloc(0);
    }
    var i;
    if (length === undefined) {
      length = 0;
      for (i = 0; i < list.length; ++i) {
        length += list[i].length;
      }
    }
    var buffer = Buffer.allocUnsafe(length);
    var pos = 0;
    for (i = 0; i < list.length; ++i) {
      var buf = list[i];
      if (isInstance(buf, Uint8Array)) {
        if (pos + buf.length > buffer.length) {
          if (!Buffer.isBuffer(buf)) buf = Buffer.from(buf);
          buf.copy(buffer, pos);
        } else {
          Uint8Array.prototype.set.call(buffer, buf, pos);
        }
      } else if (!Buffer.isBuffer(buf)) {
        throw new TypeError('"list" argument must be an Array of Buffers');
      } else {
        buf.copy(buffer, pos);
      }
      pos += buf.length;
    }
    return buffer;
  };
  function byteLength(string, encoding) {
    if (Buffer.isBuffer(string)) {
      return string.length;
    }
    if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {
      return string.byteLength;
    }
    if (typeof string !== 'string') {
      throw new TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. ' + 'Received type ' + _typeof(string));
    }
    var len = string.length;
    var mustMatch = arguments.length > 2 && arguments[2] === true;
    if (!mustMatch && len === 0) return 0;

    // Use a for loop to avoid recursion
    var loweredCase = false;
    for (;;) {
      switch (encoding) {
        case 'ascii':
        case 'latin1':
        case 'binary':
          return len;
        case 'utf8':
        case 'utf-8':
          return utf8ToBytes(string).length;
        case 'ucs2':
        case 'ucs-2':
        case 'utf16le':
        case 'utf-16le':
          return len * 2;
        case 'hex':
          return len >>> 1;
        case 'base64':
          return base64ToBytes(string).length;
        default:
          if (loweredCase) {
            return mustMatch ? -1 : utf8ToBytes(string).length; // assume utf8
          }

          encoding = ('' + encoding).toLowerCase();
          loweredCase = true;
      }
    }
  }
  Buffer.byteLength = byteLength;
  function slowToString(encoding, start, end) {
    var loweredCase = false;

    // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
    // property of a typed array.

    // This behaves neither like String nor Uint8Array in that we set start/end
    // to their upper/lower bounds if the value passed is out of range.
    // undefined is handled specially as per ECMA-262 6th Edition,
    // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
    if (start === undefined || start < 0) {
      start = 0;
    }
    // Return early if start > this.length. Done here to prevent potential uint32
    // coercion fail below.
    if (start > this.length) {
      return '';
    }
    if (end === undefined || end > this.length) {
      end = this.length;
    }
    if (end <= 0) {
      return '';
    }

    // Force coercion to uint32. This will also coerce falsey/NaN values to 0.
    end >>>= 0;
    start >>>= 0;
    if (end <= start) {
      return '';
    }
    if (!encoding) encoding = 'utf8';
    while (true) {
      switch (encoding) {
        case 'hex':
          return hexSlice(this, start, end);
        case 'utf8':
        case 'utf-8':
          return utf8Slice(this, start, end);
        case 'ascii':
          return asciiSlice(this, start, end);
        case 'latin1':
        case 'binary':
          return latin1Slice(this, start, end);
        case 'base64':
          return base64Slice(this, start, end);
        case 'ucs2':
        case 'ucs-2':
        case 'utf16le':
        case 'utf-16le':
          return utf16leSlice(this, start, end);
        default:
          if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding);
          encoding = (encoding + '').toLowerCase();
          loweredCase = true;
      }
    }
  }

  // This property is used by `Buffer.isBuffer` (and the `is-buffer` npm package)
  // to detect a Buffer instance. It's not possible to use `instanceof Buffer`
  // reliably in a browserify context because there could be multiple different
  // copies of the 'buffer' package in use. This method works even for Buffer
  // instances that were created from another copy of the `buffer` package.
  // See: https://github.com/feross/buffer/issues/154
  Buffer.prototype._isBuffer = true;
  function swap(b, n, m) {
    var i = b[n];
    b[n] = b[m];
    b[m] = i;
  }
  Buffer.prototype.swap16 = function swap16() {
    var len = this.length;
    if (len % 2 !== 0) {
      throw new RangeError('Buffer size must be a multiple of 16-bits');
    }
    for (var i = 0; i < len; i += 2) {
      swap(this, i, i + 1);
    }
    return this;
  };
  Buffer.prototype.swap32 = function swap32() {
    var len = this.length;
    if (len % 4 !== 0) {
      throw new RangeError('Buffer size must be a multiple of 32-bits');
    }
    for (var i = 0; i < len; i += 4) {
      swap(this, i, i + 3);
      swap(this, i + 1, i + 2);
    }
    return this;
  };
  Buffer.prototype.swap64 = function swap64() {
    var len = this.length;
    if (len % 8 !== 0) {
      throw new RangeError('Buffer size must be a multiple of 64-bits');
    }
    for (var i = 0; i < len; i += 8) {
      swap(this, i, i + 7);
      swap(this, i + 1, i + 6);
      swap(this, i + 2, i + 5);
      swap(this, i + 3, i + 4);
    }
    return this;
  };
  Buffer.prototype.toString = function toString() {
    var length = this.length;
    if (length === 0) return '';
    if (arguments.length === 0) return utf8Slice(this, 0, length);
    return slowToString.apply(this, arguments);
  };
  Buffer.prototype.toLocaleString = Buffer.prototype.toString;
  Buffer.prototype.equals = function equals(b) {
    if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer');
    if (this === b) return true;
    return Buffer.compare(this, b) === 0;
  };
  Buffer.prototype.inspect = function inspect() {
    var str = '';
    var max = exports.INSPECT_MAX_BYTES;
    str = this.toString('hex', 0, max).replace(/(.{2})/g, '$1 ').trim();
    if (this.length > max) str += ' ... ';
    return '<Buffer ' + str + '>';
  };
  if (customInspectSymbol) {
    Buffer.prototype[customInspectSymbol] = Buffer.prototype.inspect;
  }
  Buffer.prototype.compare = function compare(target, start, end, thisStart, thisEnd) {
    if (isInstance(target, Uint8Array)) {
      target = Buffer.from(target, target.offset, target.byteLength);
    }
    if (!Buffer.isBuffer(target)) {
      throw new TypeError('The "target" argument must be one of type Buffer or Uint8Array. ' + 'Received type ' + _typeof(target));
    }
    if (start === undefined) {
      start = 0;
    }
    if (end === undefined) {
      end = target ? target.length : 0;
    }
    if (thisStart === undefined) {
      thisStart = 0;
    }
    if (thisEnd === undefined) {
      thisEnd = this.length;
    }
    if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
      throw new RangeError('out of range index');
    }
    if (thisStart >= thisEnd && start >= end) {
      return 0;
    }
    if (thisStart >= thisEnd) {
      return -1;
    }
    if (start >= end) {
      return 1;
    }
    start >>>= 0;
    end >>>= 0;
    thisStart >>>= 0;
    thisEnd >>>= 0;
    if (this === target) return 0;
    var x = thisEnd - thisStart;
    var y = end - start;
    var len = Math.min(x, y);
    var thisCopy = this.slice(thisStart, thisEnd);
    var targetCopy = target.slice(start, end);
    for (var i = 0; i < len; ++i) {
      if (thisCopy[i] !== targetCopy[i]) {
        x = thisCopy[i];
        y = targetCopy[i];
        break;
      }
    }
    if (x < y) return -1;
    if (y < x) return 1;
    return 0;
  };

  // Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
  // OR the last index of `val` in `buffer` at offset <= `byteOffset`.
  //
  // Arguments:
  // - buffer - a Buffer to search
  // - val - a string, Buffer, or number
  // - byteOffset - an index into `buffer`; will be clamped to an int32
  // - encoding - an optional encoding, relevant is val is a string
  // - dir - true for indexOf, false for lastIndexOf
  function bidirectionalIndexOf(buffer, val, byteOffset, encoding, dir) {
    // Empty buffer means no match
    if (buffer.length === 0) return -1;

    // Normalize byteOffset
    if (typeof byteOffset === 'string') {
      encoding = byteOffset;
      byteOffset = 0;
    } else if (byteOffset > 0x7fffffff) {
      byteOffset = 0x7fffffff;
    } else if (byteOffset < -0x80000000) {
      byteOffset = -0x80000000;
    }
    byteOffset = +byteOffset; // Coerce to Number.
    if (numberIsNaN(byteOffset)) {
      // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
      byteOffset = dir ? 0 : buffer.length - 1;
    }

    // Normalize byteOffset: negative offsets start from the end of the buffer
    if (byteOffset < 0) byteOffset = buffer.length + byteOffset;
    if (byteOffset >= buffer.length) {
      if (dir) return -1;else byteOffset = buffer.length - 1;
    } else if (byteOffset < 0) {
      if (dir) byteOffset = 0;else return -1;
    }

    // Normalize val
    if (typeof val === 'string') {
      val = Buffer.from(val, encoding);
    }

    // Finally, search either indexOf (if dir is true) or lastIndexOf
    if (Buffer.isBuffer(val)) {
      // Special case: looking for empty string/buffer always fails
      if (val.length === 0) {
        return -1;
      }
      return arrayIndexOf(buffer, val, byteOffset, encoding, dir);
    } else if (typeof val === 'number') {
      val = val & 0xFF; // Search for a byte value [0-255]
      if (typeof Uint8Array.prototype.indexOf === 'function') {
        if (dir) {
          return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset);
        } else {
          return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset);
        }
      }
      return arrayIndexOf(buffer, [val], byteOffset, encoding, dir);
    }
    throw new TypeError('val must be string, number or Buffer');
  }
  function arrayIndexOf(arr, val, byteOffset, encoding, dir) {
    var indexSize = 1;
    var arrLength = arr.length;
    var valLength = val.length;
    if (encoding !== undefined) {
      encoding = String(encoding).toLowerCase();
      if (encoding === 'ucs2' || encoding === 'ucs-2' || encoding === 'utf16le' || encoding === 'utf-16le') {
        if (arr.length < 2 || val.length < 2) {
          return -1;
        }
        indexSize = 2;
        arrLength /= 2;
        valLength /= 2;
        byteOffset /= 2;
      }
    }
    function read(buf, i) {
      if (indexSize === 1) {
        return buf[i];
      } else {
        return buf.readUInt16BE(i * indexSize);
      }
    }
    var i;
    if (dir) {
      var foundIndex = -1;
      for (i = byteOffset; i < arrLength; i++) {
        if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
          if (foundIndex === -1) foundIndex = i;
          if (i - foundIndex + 1 === valLength) return foundIndex * indexSize;
        } else {
          if (foundIndex !== -1) i -= i - foundIndex;
          foundIndex = -1;
        }
      }
    } else {
      if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength;
      for (i = byteOffset; i >= 0; i--) {
        var found = true;
        for (var j = 0; j < valLength; j++) {
          if (read(arr, i + j) !== read(val, j)) {
            found = false;
            break;
          }
        }
        if (found) return i;
      }
    }
    return -1;
  }
  Buffer.prototype.includes = function includes(val, byteOffset, encoding) {
    return this.indexOf(val, byteOffset, encoding) !== -1;
  };
  Buffer.prototype.indexOf = function indexOf(val, byteOffset, encoding) {
    return bidirectionalIndexOf(this, val, byteOffset, encoding, true);
  };
  Buffer.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {
    return bidirectionalIndexOf(this, val, byteOffset, encoding, false);
  };
  function hexWrite(buf, string, offset, length) {
    offset = Number(offset) || 0;
    var remaining = buf.length - offset;
    if (!length) {
      length = remaining;
    } else {
      length = Number(length);
      if (length > remaining) {
        length = remaining;
      }
    }
    var strLen = string.length;
    if (length > strLen / 2) {
      length = strLen / 2;
    }
    var i;
    for (i = 0; i < length; ++i) {
      var parsed = parseInt(string.substr(i * 2, 2), 16);
      if (numberIsNaN(parsed)) return i;
      buf[offset + i] = parsed;
    }
    return i;
  }
  function utf8Write(buf, string, offset, length) {
    return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length);
  }
  function asciiWrite(buf, string, offset, length) {
    return blitBuffer(asciiToBytes(string), buf, offset, length);
  }
  function base64Write(buf, string, offset, length) {
    return blitBuffer(base64ToBytes(string), buf, offset, length);
  }
  function ucs2Write(buf, string, offset, length) {
    return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length);
  }
  Buffer.prototype.write = function write(string, offset, length, encoding) {
    // Buffer#write(string)
    if (offset === undefined) {
      encoding = 'utf8';
      length = this.length;
      offset = 0;
      // Buffer#write(string, encoding)
    } else if (length === undefined && typeof offset === 'string') {
      encoding = offset;
      length = this.length;
      offset = 0;
      // Buffer#write(string, offset[, length][, encoding])
    } else if (isFinite(offset)) {
      offset = offset >>> 0;
      if (isFinite(length)) {
        length = length >>> 0;
        if (encoding === undefined) encoding = 'utf8';
      } else {
        encoding = length;
        length = undefined;
      }
    } else {
      throw new Error('Buffer.write(string, encoding, offset[, length]) is no longer supported');
    }
    var remaining = this.length - offset;
    if (length === undefined || length > remaining) length = remaining;
    if (string.length > 0 && (length < 0 || offset < 0) || offset > this.length) {
      throw new RangeError('Attempt to write outside buffer bounds');
    }
    if (!encoding) encoding = 'utf8';
    var loweredCase = false;
    for (;;) {
      switch (encoding) {
        case 'hex':
          return hexWrite(this, string, offset, length);
        case 'utf8':
        case 'utf-8':
          return utf8Write(this, string, offset, length);
        case 'ascii':
        case 'latin1':
        case 'binary':
          return asciiWrite(this, string, offset, length);
        case 'base64':
          // Warning: maxLength not taken into account in base64Write
          return base64Write(this, string, offset, length);
        case 'ucs2':
        case 'ucs-2':
        case 'utf16le':
        case 'utf-16le':
          return ucs2Write(this, string, offset, length);
        default:
          if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding);
          encoding = ('' + encoding).toLowerCase();
          loweredCase = true;
      }
    }
  };
  Buffer.prototype.toJSON = function toJSON() {
    return {
      type: 'Buffer',
      data: Array.prototype.slice.call(this._arr || this, 0)
    };
  };
  function base64Slice(buf, start, end) {
    if (start === 0 && end === buf.length) {
      return base64.fromByteArray(buf);
    } else {
      return base64.fromByteArray(buf.slice(start, end));
    }
  }
  function utf8Slice(buf, start, end) {
    end = Math.min(buf.length, end);
    var res = [];
    var i = start;
    while (i < end) {
      var firstByte = buf[i];
      var codePoint = null;
      var bytesPerSequence = firstByte > 0xEF ? 4 : firstByte > 0xDF ? 3 : firstByte > 0xBF ? 2 : 1;
      if (i + bytesPerSequence <= end) {
        var secondByte = void 0,
          thirdByte = void 0,
          fourthByte = void 0,
          tempCodePoint = void 0;
        switch (bytesPerSequence) {
          case 1:
            if (firstByte < 0x80) {
              codePoint = firstByte;
            }
            break;
          case 2:
            secondByte = buf[i + 1];
            if ((secondByte & 0xC0) === 0x80) {
              tempCodePoint = (firstByte & 0x1F) << 0x6 | secondByte & 0x3F;
              if (tempCodePoint > 0x7F) {
                codePoint = tempCodePoint;
              }
            }
            break;
          case 3:
            secondByte = buf[i + 1];
            thirdByte = buf[i + 2];
            if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
              tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | thirdByte & 0x3F;
              if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
                codePoint = tempCodePoint;
              }
            }
            break;
          case 4:
            secondByte = buf[i + 1];
            thirdByte = buf[i + 2];
            fourthByte = buf[i + 3];
            if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
              tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | fourthByte & 0x3F;
              if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
                codePoint = tempCodePoint;
              }
            }
        }
      }
      if (codePoint === null) {
        // we did not generate a valid codePoint so insert a
        // replacement char (U+FFFD) and advance only 1 byte
        codePoint = 0xFFFD;
        bytesPerSequence = 1;
      } else if (codePoint > 0xFFFF) {
        // encode to utf16 (surrogate pair dance)
        codePoint -= 0x10000;
        res.push(codePoint >>> 10 & 0x3FF | 0xD800);
        codePoint = 0xDC00 | codePoint & 0x3FF;
      }
      res.push(codePoint);
      i += bytesPerSequence;
    }
    return decodeCodePointsArray(res);
  }

  // Based on http://stackoverflow.com/a/22747272/680742, the browser with
  // the lowest limit is Chrome, with 0x10000 args.
  // We go 1 magnitude less, for safety
  var MAX_ARGUMENTS_LENGTH = 0x1000;
  function decodeCodePointsArray(codePoints) {
    var len = codePoints.length;
    if (len <= MAX_ARGUMENTS_LENGTH) {
      return String.fromCharCode.apply(String, codePoints); // avoid extra slice()
    }

    // Decode in chunks to avoid "call stack size exceeded".
    var res = '';
    var i = 0;
    while (i < len) {
      res += String.fromCharCode.apply(String, codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH));
    }
    return res;
  }
  function asciiSlice(buf, start, end) {
    var ret = '';
    end = Math.min(buf.length, end);
    for (var i = start; i < end; ++i) {
      ret += String.fromCharCode(buf[i] & 0x7F);
    }
    return ret;
  }
  function latin1Slice(buf, start, end) {
    var ret = '';
    end = Math.min(buf.length, end);
    for (var i = start; i < end; ++i) {
      ret += String.fromCharCode(buf[i]);
    }
    return ret;
  }
  function hexSlice(buf, start, end) {
    var len = buf.length;
    if (!start || start < 0) start = 0;
    if (!end || end < 0 || end > len) end = len;
    var out = '';
    for (var i = start; i < end; ++i) {
      out += hexSliceLookupTable[buf[i]];
    }
    return out;
  }
  function utf16leSlice(buf, start, end) {
    var bytes = buf.slice(start, end);
    var res = '';
    // If bytes.length is odd, the last 8 bits must be ignored (same as node.js)
    for (var i = 0; i < bytes.length - 1; i += 2) {
      res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);
    }
    return res;
  }
  Buffer.prototype.slice = function slice(start, end) {
    var len = this.length;
    start = ~~start;
    end = end === undefined ? len : ~~end;
    if (start < 0) {
      start += len;
      if (start < 0) start = 0;
    } else if (start > len) {
      start = len;
    }
    if (end < 0) {
      end += len;
      if (end < 0) end = 0;
    } else if (end > len) {
      end = len;
    }
    if (end < start) end = start;
    var newBuf = this.subarray(start, end);
    // Return an augmented `Uint8Array` instance
    Object.setPrototypeOf(newBuf, Buffer.prototype);
    return newBuf;
  };

  /*
   * Need to make sure that buffer isn't trying to write out of bounds.
   */
  function checkOffset(offset, ext, length) {
    if (offset % 1 !== 0 || offset < 0) throw new RangeError('offset is not uint');
    if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length');
  }
  Buffer.prototype.readUintLE = Buffer.prototype.readUIntLE = function readUIntLE(offset, byteLength, noAssert) {
    offset = offset >>> 0;
    byteLength = byteLength >>> 0;
    if (!noAssert) checkOffset(offset, byteLength, this.length);
    var val = this[offset];
    var mul = 1;
    var i = 0;
    while (++i < byteLength && (mul *= 0x100)) {
      val += this[offset + i] * mul;
    }
    return val;
  };
  Buffer.prototype.readUintBE = Buffer.prototype.readUIntBE = function readUIntBE(offset, byteLength, noAssert) {
    offset = offset >>> 0;
    byteLength = byteLength >>> 0;
    if (!noAssert) {
      checkOffset(offset, byteLength, this.length);
    }
    var val = this[offset + --byteLength];
    var mul = 1;
    while (byteLength > 0 && (mul *= 0x100)) {
      val += this[offset + --byteLength] * mul;
    }
    return val;
  };
  Buffer.prototype.readUint8 = Buffer.prototype.readUInt8 = function readUInt8(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 1, this.length);
    return this[offset];
  };
  Buffer.prototype.readUint16LE = Buffer.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 2, this.length);
    return this[offset] | this[offset + 1] << 8;
  };
  Buffer.prototype.readUint16BE = Buffer.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 2, this.length);
    return this[offset] << 8 | this[offset + 1];
  };
  Buffer.prototype.readUint32LE = Buffer.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 4, this.length);
    return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 0x1000000;
  };
  Buffer.prototype.readUint32BE = Buffer.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 4, this.length);
    return this[offset] * 0x1000000 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);
  };
  Buffer.prototype.readBigUInt64LE = defineBigIntMethod(function readBigUInt64LE(offset) {
    offset = offset >>> 0;
    validateNumber(offset, 'offset');
    var first = this[offset];
    var last = this[offset + 7];
    if (first === undefined || last === undefined) {
      boundsError(offset, this.length - 8);
    }
    var lo = first + this[++offset] * Math.pow(2, 8) + this[++offset] * Math.pow(2, 16) + this[++offset] * Math.pow(2, 24);
    var hi = this[++offset] + this[++offset] * Math.pow(2, 8) + this[++offset] * Math.pow(2, 16) + last * Math.pow(2, 24);
    return BigInt(lo) + (BigInt(hi) << BigInt(32));
  });
  Buffer.prototype.readBigUInt64BE = defineBigIntMethod(function readBigUInt64BE(offset) {
    offset = offset >>> 0;
    validateNumber(offset, 'offset');
    var first = this[offset];
    var last = this[offset + 7];
    if (first === undefined || last === undefined) {
      boundsError(offset, this.length - 8);
    }
    var hi = first * Math.pow(2, 24) + this[++offset] * Math.pow(2, 16) + this[++offset] * Math.pow(2, 8) + this[++offset];
    var lo = this[++offset] * Math.pow(2, 24) + this[++offset] * Math.pow(2, 16) + this[++offset] * Math.pow(2, 8) + last;
    return (BigInt(hi) << BigInt(32)) + BigInt(lo);
  });
  Buffer.prototype.readIntLE = function readIntLE(offset, byteLength, noAssert) {
    offset = offset >>> 0;
    byteLength = byteLength >>> 0;
    if (!noAssert) checkOffset(offset, byteLength, this.length);
    var val = this[offset];
    var mul = 1;
    var i = 0;
    while (++i < byteLength && (mul *= 0x100)) {
      val += this[offset + i] * mul;
    }
    mul *= 0x80;
    if (val >= mul) val -= Math.pow(2, 8 * byteLength);
    return val;
  };
  Buffer.prototype.readIntBE = function readIntBE(offset, byteLength, noAssert) {
    offset = offset >>> 0;
    byteLength = byteLength >>> 0;
    if (!noAssert) checkOffset(offset, byteLength, this.length);
    var i = byteLength;
    var mul = 1;
    var val = this[offset + --i];
    while (i > 0 && (mul *= 0x100)) {
      val += this[offset + --i] * mul;
    }
    mul *= 0x80;
    if (val >= mul) val -= Math.pow(2, 8 * byteLength);
    return val;
  };
  Buffer.prototype.readInt8 = function readInt8(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 1, this.length);
    if (!(this[offset] & 0x80)) return this[offset];
    return (0xff - this[offset] + 1) * -1;
  };
  Buffer.prototype.readInt16LE = function readInt16LE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 2, this.length);
    var val = this[offset] | this[offset + 1] << 8;
    return val & 0x8000 ? val | 0xFFFF0000 : val;
  };
  Buffer.prototype.readInt16BE = function readInt16BE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 2, this.length);
    var val = this[offset + 1] | this[offset] << 8;
    return val & 0x8000 ? val | 0xFFFF0000 : val;
  };
  Buffer.prototype.readInt32LE = function readInt32LE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 4, this.length);
    return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;
  };
  Buffer.prototype.readInt32BE = function readInt32BE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 4, this.length);
    return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];
  };
  Buffer.prototype.readBigInt64LE = defineBigIntMethod(function readBigInt64LE(offset) {
    offset = offset >>> 0;
    validateNumber(offset, 'offset');
    var first = this[offset];
    var last = this[offset + 7];
    if (first === undefined || last === undefined) {
      boundsError(offset, this.length - 8);
    }
    var val = this[offset + 4] + this[offset + 5] * Math.pow(2, 8) + this[offset + 6] * Math.pow(2, 16) + (last << 24); // Overflow

    return (BigInt(val) << BigInt(32)) + BigInt(first + this[++offset] * Math.pow(2, 8) + this[++offset] * Math.pow(2, 16) + this[++offset] * Math.pow(2, 24));
  });
  Buffer.prototype.readBigInt64BE = defineBigIntMethod(function readBigInt64BE(offset) {
    offset = offset >>> 0;
    validateNumber(offset, 'offset');
    var first = this[offset];
    var last = this[offset + 7];
    if (first === undefined || last === undefined) {
      boundsError(offset, this.length - 8);
    }
    var val = (first << 24) +
    // Overflow
    this[++offset] * Math.pow(2, 16) + this[++offset] * Math.pow(2, 8) + this[++offset];
    return (BigInt(val) << BigInt(32)) + BigInt(this[++offset] * Math.pow(2, 24) + this[++offset] * Math.pow(2, 16) + this[++offset] * Math.pow(2, 8) + last);
  });
  Buffer.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 4, this.length);
    return ieee754$1.read(this, offset, true, 23, 4);
  };
  Buffer.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 4, this.length);
    return ieee754$1.read(this, offset, false, 23, 4);
  };
  Buffer.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 8, this.length);
    return ieee754$1.read(this, offset, true, 52, 8);
  };
  Buffer.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 8, this.length);
    return ieee754$1.read(this, offset, false, 52, 8);
  };
  function checkInt(buf, value, offset, ext, max, min) {
    if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance');
    if (value > max || value < min) throw new RangeError('"value" argument is out of bounds');
    if (offset + ext > buf.length) throw new RangeError('Index out of range');
  }
  Buffer.prototype.writeUintLE = Buffer.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength, noAssert) {
    value = +value;
    offset = offset >>> 0;
    byteLength = byteLength >>> 0;
    if (!noAssert) {
      var maxBytes = Math.pow(2, 8 * byteLength) - 1;
      checkInt(this, value, offset, byteLength, maxBytes, 0);
    }
    var mul = 1;
    var i = 0;
    this[offset] = value & 0xFF;
    while (++i < byteLength && (mul *= 0x100)) {
      this[offset + i] = value / mul & 0xFF;
    }
    return offset + byteLength;
  };
  Buffer.prototype.writeUintBE = Buffer.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength, noAssert) {
    value = +value;
    offset = offset >>> 0;
    byteLength = byteLength >>> 0;
    if (!noAssert) {
      var maxBytes = Math.pow(2, 8 * byteLength) - 1;
      checkInt(this, value, offset, byteLength, maxBytes, 0);
    }
    var i = byteLength - 1;
    var mul = 1;
    this[offset + i] = value & 0xFF;
    while (--i >= 0 && (mul *= 0x100)) {
      this[offset + i] = value / mul & 0xFF;
    }
    return offset + byteLength;
  };
  Buffer.prototype.writeUint8 = Buffer.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0);
    this[offset] = value & 0xff;
    return offset + 1;
  };
  Buffer.prototype.writeUint16LE = Buffer.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);
    this[offset] = value & 0xff;
    this[offset + 1] = value >>> 8;
    return offset + 2;
  };
  Buffer.prototype.writeUint16BE = Buffer.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);
    this[offset] = value >>> 8;
    this[offset + 1] = value & 0xff;
    return offset + 2;
  };
  Buffer.prototype.writeUint32LE = Buffer.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);
    this[offset + 3] = value >>> 24;
    this[offset + 2] = value >>> 16;
    this[offset + 1] = value >>> 8;
    this[offset] = value & 0xff;
    return offset + 4;
  };
  Buffer.prototype.writeUint32BE = Buffer.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);
    this[offset] = value >>> 24;
    this[offset + 1] = value >>> 16;
    this[offset + 2] = value >>> 8;
    this[offset + 3] = value & 0xff;
    return offset + 4;
  };
  function wrtBigUInt64LE(buf, value, offset, min, max) {
    checkIntBI(value, min, max, buf, offset, 7);
    var lo = Number(value & BigInt(0xffffffff));
    buf[offset++] = lo;
    lo = lo >> 8;
    buf[offset++] = lo;
    lo = lo >> 8;
    buf[offset++] = lo;
    lo = lo >> 8;
    buf[offset++] = lo;
    var hi = Number(value >> BigInt(32) & BigInt(0xffffffff));
    buf[offset++] = hi;
    hi = hi >> 8;
    buf[offset++] = hi;
    hi = hi >> 8;
    buf[offset++] = hi;
    hi = hi >> 8;
    buf[offset++] = hi;
    return offset;
  }
  function wrtBigUInt64BE(buf, value, offset, min, max) {
    checkIntBI(value, min, max, buf, offset, 7);
    var lo = Number(value & BigInt(0xffffffff));
    buf[offset + 7] = lo;
    lo = lo >> 8;
    buf[offset + 6] = lo;
    lo = lo >> 8;
    buf[offset + 5] = lo;
    lo = lo >> 8;
    buf[offset + 4] = lo;
    var hi = Number(value >> BigInt(32) & BigInt(0xffffffff));
    buf[offset + 3] = hi;
    hi = hi >> 8;
    buf[offset + 2] = hi;
    hi = hi >> 8;
    buf[offset + 1] = hi;
    hi = hi >> 8;
    buf[offset] = hi;
    return offset + 8;
  }
  Buffer.prototype.writeBigUInt64LE = defineBigIntMethod(function writeBigUInt64LE(value) {
    var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
    return wrtBigUInt64LE(this, value, offset, BigInt(0), BigInt('0xffffffffffffffff'));
  });
  Buffer.prototype.writeBigUInt64BE = defineBigIntMethod(function writeBigUInt64BE(value) {
    var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
    return wrtBigUInt64BE(this, value, offset, BigInt(0), BigInt('0xffffffffffffffff'));
  });
  Buffer.prototype.writeIntLE = function writeIntLE(value, offset, byteLength, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) {
      var limit = Math.pow(2, 8 * byteLength - 1);
      checkInt(this, value, offset, byteLength, limit - 1, -limit);
    }
    var i = 0;
    var mul = 1;
    var sub = 0;
    this[offset] = value & 0xFF;
    while (++i < byteLength && (mul *= 0x100)) {
      if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
        sub = 1;
      }
      this[offset + i] = (value / mul >> 0) - sub & 0xFF;
    }
    return offset + byteLength;
  };
  Buffer.prototype.writeIntBE = function writeIntBE(value, offset, byteLength, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) {
      var limit = Math.pow(2, 8 * byteLength - 1);
      checkInt(this, value, offset, byteLength, limit - 1, -limit);
    }
    var i = byteLength - 1;
    var mul = 1;
    var sub = 0;
    this[offset + i] = value & 0xFF;
    while (--i >= 0 && (mul *= 0x100)) {
      if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
        sub = 1;
      }
      this[offset + i] = (value / mul >> 0) - sub & 0xFF;
    }
    return offset + byteLength;
  };
  Buffer.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80);
    if (value < 0) value = 0xff + value + 1;
    this[offset] = value & 0xff;
    return offset + 1;
  };
  Buffer.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000);
    this[offset] = value & 0xff;
    this[offset + 1] = value >>> 8;
    return offset + 2;
  };
  Buffer.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000);
    this[offset] = value >>> 8;
    this[offset + 1] = value & 0xff;
    return offset + 2;
  };
  Buffer.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);
    this[offset] = value & 0xff;
    this[offset + 1] = value >>> 8;
    this[offset + 2] = value >>> 16;
    this[offset + 3] = value >>> 24;
    return offset + 4;
  };
  Buffer.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);
    if (value < 0) value = 0xffffffff + value + 1;
    this[offset] = value >>> 24;
    this[offset + 1] = value >>> 16;
    this[offset + 2] = value >>> 8;
    this[offset + 3] = value & 0xff;
    return offset + 4;
  };
  Buffer.prototype.writeBigInt64LE = defineBigIntMethod(function writeBigInt64LE(value) {
    var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
    return wrtBigUInt64LE(this, value, offset, -BigInt('0x8000000000000000'), BigInt('0x7fffffffffffffff'));
  });
  Buffer.prototype.writeBigInt64BE = defineBigIntMethod(function writeBigInt64BE(value) {
    var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
    return wrtBigUInt64BE(this, value, offset, -BigInt('0x8000000000000000'), BigInt('0x7fffffffffffffff'));
  });
  function checkIEEE754(buf, value, offset, ext, max, min) {
    if (offset + ext > buf.length) throw new RangeError('Index out of range');
    if (offset < 0) throw new RangeError('Index out of range');
  }
  function writeFloat(buf, value, offset, littleEndian, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) {
      checkIEEE754(buf, value, offset, 4);
    }
    ieee754$1.write(buf, value, offset, littleEndian, 23, 4);
    return offset + 4;
  }
  Buffer.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {
    return writeFloat(this, value, offset, true, noAssert);
  };
  Buffer.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {
    return writeFloat(this, value, offset, false, noAssert);
  };
  function writeDouble(buf, value, offset, littleEndian, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) {
      checkIEEE754(buf, value, offset, 8);
    }
    ieee754$1.write(buf, value, offset, littleEndian, 52, 8);
    return offset + 8;
  }
  Buffer.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {
    return writeDouble(this, value, offset, true, noAssert);
  };
  Buffer.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {
    return writeDouble(this, value, offset, false, noAssert);
  };

  // copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
  Buffer.prototype.copy = function copy(target, targetStart, start, end) {
    if (!Buffer.isBuffer(target)) throw new TypeError('argument should be a Buffer');
    if (!start) start = 0;
    if (!end && end !== 0) end = this.length;
    if (targetStart >= target.length) targetStart = target.length;
    if (!targetStart) targetStart = 0;
    if (end > 0 && end < start) end = start;

    // Copy 0 bytes; we're done
    if (end === start) return 0;
    if (target.length === 0 || this.length === 0) return 0;

    // Fatal error conditions
    if (targetStart < 0) {
      throw new RangeError('targetStart out of bounds');
    }
    if (start < 0 || start >= this.length) throw new RangeError('Index out of range');
    if (end < 0) throw new RangeError('sourceEnd out of bounds');

    // Are we oob?
    if (end > this.length) end = this.length;
    if (target.length - targetStart < end - start) {
      end = target.length - targetStart + start;
    }
    var len = end - start;
    if (this === target && typeof Uint8Array.prototype.copyWithin === 'function') {
      // Use built-in when available, missing from IE11
      this.copyWithin(targetStart, start, end);
    } else {
      Uint8Array.prototype.set.call(target, this.subarray(start, end), targetStart);
    }
    return len;
  };

  // Usage:
  //    buffer.fill(number[, offset[, end]])
  //    buffer.fill(buffer[, offset[, end]])
  //    buffer.fill(string[, offset[, end]][, encoding])
  Buffer.prototype.fill = function fill(val, start, end, encoding) {
    // Handle string cases:
    if (typeof val === 'string') {
      if (typeof start === 'string') {
        encoding = start;
        start = 0;
        end = this.length;
      } else if (typeof end === 'string') {
        encoding = end;
        end = this.length;
      }
      if (encoding !== undefined && typeof encoding !== 'string') {
        throw new TypeError('encoding must be a string');
      }
      if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
        throw new TypeError('Unknown encoding: ' + encoding);
      }
      if (val.length === 1) {
        var code = val.charCodeAt(0);
        if (encoding === 'utf8' && code < 128 || encoding === 'latin1') {
          // Fast path: If `val` fits into a single byte, use that numeric value.
          val = code;
        }
      }
    } else if (typeof val === 'number') {
      val = val & 255;
    } else if (typeof val === 'boolean') {
      val = Number(val);
    }

    // Invalid ranges are not set to a default, so can range check early.
    if (start < 0 || this.length < start || this.length < end) {
      throw new RangeError('Out of range index');
    }
    if (end <= start) {
      return this;
    }
    start = start >>> 0;
    end = end === undefined ? this.length : end >>> 0;
    if (!val) val = 0;
    var i;
    if (typeof val === 'number') {
      for (i = start; i < end; ++i) {
        this[i] = val;
      }
    } else {
      var bytes = Buffer.isBuffer(val) ? val : Buffer.from(val, encoding);
      var len = bytes.length;
      if (len === 0) {
        throw new TypeError('The value "' + val + '" is invalid for argument "value"');
      }
      for (i = 0; i < end - start; ++i) {
        this[i + start] = bytes[i % len];
      }
    }
    return this;
  };

  // CUSTOM ERRORS
  // =============

  // Simplified versions from Node, changed for Buffer-only usage
  var errors = {};
  function E(sym, getMessage, Base) {
    errors[sym] = /*#__PURE__*/function (_Base) {
      _inherits(NodeError, _Base);
      var _super = _createSuper(NodeError);
      function NodeError() {
        var _this;
        _classCallCheck(this, NodeError);
        _this = _super.call(this);
        Object.defineProperty(_assertThisInitialized(_this), 'message', {
          value: getMessage.apply(_assertThisInitialized(_this), arguments),
          writable: true,
          configurable: true
        });

        // Add the error code to the name to include it in the stack trace.
        _this.name = "".concat(_this.name, " [").concat(sym, "]");
        // Access the stack to generate the error message including the error code
        // from the name.
        _this.stack; // eslint-disable-line no-unused-expressions
        // Reset the name to the actual name.
        delete _this.name;
        return _this;
      }
      _createClass(NodeError, [{
        key: "code",
        get: function get() {
          return sym;
        },
        set: function set(value) {
          Object.defineProperty(this, 'code', {
            configurable: true,
            enumerable: true,
            value: value,
            writable: true
          });
        }
      }, {
        key: "toString",
        value: function toString() {
          return "".concat(this.name, " [").concat(sym, "]: ").concat(this.message);
        }
      }]);
      return NodeError;
    }(Base);
  }
  E('ERR_BUFFER_OUT_OF_BOUNDS', function (name) {
    if (name) {
      return "".concat(name, " is outside of buffer bounds");
    }
    return 'Attempt to access memory outside buffer bounds';
  }, RangeError);
  E('ERR_INVALID_ARG_TYPE', function (name, actual) {
    return "The \"".concat(name, "\" argument must be of type number. Received type ").concat(_typeof(actual));
  }, TypeError);
  E('ERR_OUT_OF_RANGE', function (str, range, input) {
    var msg = "The value of \"".concat(str, "\" is out of range.");
    var received = input;
    if (Number.isInteger(input) && Math.abs(input) > Math.pow(2, 32)) {
      received = addNumericalSeparator(String(input));
    } else if (typeof input === 'bigint') {
      received = String(input);
      if (input > Math.pow(BigInt(2), BigInt(32)) || input < -Math.pow(BigInt(2), BigInt(32))) {
        received = addNumericalSeparator(received);
      }
      received += 'n';
    }
    msg += " It must be ".concat(range, ". Received ").concat(received);
    return msg;
  }, RangeError);
  function addNumericalSeparator(val) {
    var res = '';
    var i = val.length;
    var start = val[0] === '-' ? 1 : 0;
    for (; i >= start + 4; i -= 3) {
      res = "_".concat(val.slice(i - 3, i)).concat(res);
    }
    return "".concat(val.slice(0, i)).concat(res);
  }

  // CHECK FUNCTIONS
  // ===============

  function checkBounds(buf, offset, byteLength) {
    validateNumber(offset, 'offset');
    if (buf[offset] === undefined || buf[offset + byteLength] === undefined) {
      boundsError(offset, buf.length - (byteLength + 1));
    }
  }
  function checkIntBI(value, min, max, buf, offset, byteLength) {
    if (value > max || value < min) {
      var n = typeof min === 'bigint' ? 'n' : '';
      var range;
      if (byteLength > 3) {
        if (min === 0 || min === BigInt(0)) {
          range = ">= 0".concat(n, " and < 2").concat(n, " ** ").concat((byteLength + 1) * 8).concat(n);
        } else {
          range = ">= -(2".concat(n, " ** ").concat((byteLength + 1) * 8 - 1).concat(n, ") and < 2 ** ") + "".concat((byteLength + 1) * 8 - 1).concat(n);
        }
      } else {
        range = ">= ".concat(min).concat(n, " and <= ").concat(max).concat(n);
      }
      throw new errors.ERR_OUT_OF_RANGE('value', range, value);
    }
    checkBounds(buf, offset, byteLength);
  }
  function validateNumber(value, name) {
    if (typeof value !== 'number') {
      throw new errors.ERR_INVALID_ARG_TYPE(name, 'number', value);
    }
  }
  function boundsError(value, length, type) {
    if (Math.floor(value) !== value) {
      validateNumber(value, type);
      throw new errors.ERR_OUT_OF_RANGE(type || 'offset', 'an integer', value);
    }
    if (length < 0) {
      throw new errors.ERR_BUFFER_OUT_OF_BOUNDS();
    }
    throw new errors.ERR_OUT_OF_RANGE(type || 'offset', ">= ".concat(type ? 1 : 0, " and <= ").concat(length), value);
  }

  // HELPER FUNCTIONS
  // ================

  var INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g;
  function base64clean(str) {
    // Node takes equal signs as end of the Base64 encoding
    str = str.split('=')[0];
    // Node strips out invalid characters like \n and \t from the string, base64-js does not
    str = str.trim().replace(INVALID_BASE64_RE, '');
    // Node converts strings with length < 2 to ''
    if (str.length < 2) return '';
    // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
    while (str.length % 4 !== 0) {
      str = str + '=';
    }
    return str;
  }
  function utf8ToBytes(string, units) {
    units = units || Infinity;
    var codePoint;
    var length = string.length;
    var leadSurrogate = null;
    var bytes = [];
    for (var i = 0; i < length; ++i) {
      codePoint = string.charCodeAt(i);

      // is surrogate component
      if (codePoint > 0xD7FF && codePoint < 0xE000) {
        // last char was a lead
        if (!leadSurrogate) {
          // no lead yet
          if (codePoint > 0xDBFF) {
            // unexpected trail
            if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
            continue;
          } else if (i + 1 === length) {
            // unpaired lead
            if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
            continue;
          }

          // valid lead
          leadSurrogate = codePoint;
          continue;
        }

        // 2 leads in a row
        if (codePoint < 0xDC00) {
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
          leadSurrogate = codePoint;
          continue;
        }

        // valid surrogate pair
        codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000;
      } else if (leadSurrogate) {
        // valid bmp char, but last char was a lead
        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
      }
      leadSurrogate = null;

      // encode utf8
      if (codePoint < 0x80) {
        if ((units -= 1) < 0) break;
        bytes.push(codePoint);
      } else if (codePoint < 0x800) {
        if ((units -= 2) < 0) break;
        bytes.push(codePoint >> 0x6 | 0xC0, codePoint & 0x3F | 0x80);
      } else if (codePoint < 0x10000) {
        if ((units -= 3) < 0) break;
        bytes.push(codePoint >> 0xC | 0xE0, codePoint >> 0x6 & 0x3F | 0x80, codePoint & 0x3F | 0x80);
      } else if (codePoint < 0x110000) {
        if ((units -= 4) < 0) break;
        bytes.push(codePoint >> 0x12 | 0xF0, codePoint >> 0xC & 0x3F | 0x80, codePoint >> 0x6 & 0x3F | 0x80, codePoint & 0x3F | 0x80);
      } else {
        throw new Error('Invalid code point');
      }
    }
    return bytes;
  }
  function asciiToBytes(str) {
    var byteArray = [];
    for (var i = 0; i < str.length; ++i) {
      // Node's code seems to be doing this and not & 0x7F..
      byteArray.push(str.charCodeAt(i) & 0xFF);
    }
    return byteArray;
  }
  function utf16leToBytes(str, units) {
    var c, hi, lo;
    var byteArray = [];
    for (var i = 0; i < str.length; ++i) {
      if ((units -= 2) < 0) break;
      c = str.charCodeAt(i);
      hi = c >> 8;
      lo = c % 256;
      byteArray.push(lo);
      byteArray.push(hi);
    }
    return byteArray;
  }
  function base64ToBytes(str) {
    return base64.toByteArray(base64clean(str));
  }
  function blitBuffer(src, dst, offset, length) {
    var i;
    for (i = 0; i < length; ++i) {
      if (i + offset >= dst.length || i >= src.length) break;
      dst[i + offset] = src[i];
    }
    return i;
  }

  // ArrayBuffer or Uint8Array objects from other contexts (i.e. iframes) do not pass
  // the `instanceof` check but they should be treated as of that type.
  // See: https://github.com/feross/buffer/issues/166
  function isInstance(obj, type) {
    return obj instanceof type || obj != null && obj.constructor != null && obj.constructor.name != null && obj.constructor.name === type.name;
  }
  function numberIsNaN(obj) {
    // For IE11 support
    return obj !== obj; // eslint-disable-line no-self-compare
  }

  // Create lookup table for `toString('hex')`
  // See: https://github.com/feross/buffer/issues/219
  var hexSliceLookupTable = function () {
    var alphabet = '0123456789abcdef';
    var table = new Array(256);
    for (var i = 0; i < 16; ++i) {
      var i16 = i * 16;
      for (var j = 0; j < 16; ++j) {
        table[i16 + j] = alphabet[i] + alphabet[j];
      }
    }
    return table;
  }();

  // Return not function with Error if BigInt not supported
  function defineBigIntMethod(fn) {
    return typeof BigInt === 'undefined' ? BufferBigIntNotDefined : fn;
  }
  function BufferBigIntNotDefined() {
    throw new Error('BigInt not supported');
  }
})(buffer);

/***
 * @license
 * https://github.com/ealmansi/bchaddrjs
 * Copyright (c) 2018-2020 Emilio Almansi
 * Distributed under the MIT software license, see the accompanying
 * file LICENSE or http://www.opensource.org/licenses/mit-license.php.
 */
var bs58check$1 = bs58check$2;
var cashaddr = cashaddr$1;
var Buffer = buffer.Buffer;

/**
 * General purpose Bitcoin Cash address detection and translation.<br />
 * Supports all major Bitcoin Cash address formats.<br />
 * Currently:
 * <ul>
 *    <li> Legacy format </li>
 *    <li> Bitpay format </li>
 *    <li> Cashaddr format </li>
 * </ul>
 * @module bchaddr
 */

/**
 * @static
 * Supported Bitcoin Cash address formats.
 */
var Format = {};
Format.Legacy = 'legacy';
Format.Bitpay = 'bitpay';
Format.Cashaddr = 'cashaddr';

/**
 * @static
 * Supported networks.
 */
var Network = {};
Network.Mainnet = 'mainnet';
Network.Testnet = 'testnet';

/**
 * @static
 * Supported address types.
 */
var Type = {};
Type.P2PKH = 'p2pkh';
Type.P2SH = 'p2sh';

/**
 * Returns a boolean indicating whether the given input is a valid Bitcoin Cash address.
 * @static
 * @param {*} input - Any input to check for validity.
 * @returns {boolean}
 */
function isValidAddress(input) {
  try {
    decodeAddress(input);
    return true;
  } catch (error) {
    return false;
  }
}

/**
 * Detects what is the given address' format.
 * @static
 * @param {string} address - A valid Bitcoin Cash address in any format.
 * @return {string}
 * @throws {InvalidAddressError}
 */
function detectAddressFormat(address) {
  return decodeAddress(address).format;
}

/**
 * Detects what is the given address' network.
 * @static
 * @param {string} address - A valid Bitcoin Cash address in any format.
 * @return {string}
 * @throws {InvalidAddressError}
 */
function detectAddressNetwork(address) {
  return decodeAddress(address).network;
}

/**
 * Detects what is the given address' type.
 * @static
 * @param {string} address - A valid Bitcoin Cash address in any format.
 * @return {string}
 * @throws {InvalidAddressError}
 */
function detectAddressType(address) {
  return decodeAddress(address).type;
}

/**
 * Translates the given address into legacy format.
 * @static
 * @param {string} address - A valid Bitcoin Cash address in any format.
 * @return {string}
 * @throws {InvalidAddressError}
 */
function toLegacyAddress(address) {
  var decoded = decodeAddress(address);
  if (decoded.format === Format.Legacy) {
    return address;
  }
  return encodeAsLegacy(decoded);
}

/**
 * Translates the given address into bitpay format.
 * @static
 * @param {string} address - A valid Bitcoin Cash address in any format.
 * @return {string}
 * @throws {InvalidAddressError}
 */
function toBitpayAddress(address) {
  var decoded = decodeAddress(address);
  if (decoded.format === Format.Bitpay) {
    return address;
  }
  return encodeAsBitpay(decoded);
}

/**
 * Translates the given address into cashaddr format.
 * @static
 * @param {string} address - A valid Bitcoin Cash address in any format.
 * @return {string}
 * @throws {InvalidAddressError}
 */
function toCashAddress(address) {
  var decoded = decodeAddress(address);
  return encodeAsCashaddr(decoded);
}

/**
 * Version byte table for base58 formats.
 * @private
 */
var VERSION_BYTE = {};
VERSION_BYTE[Format.Legacy] = {};
VERSION_BYTE[Format.Legacy][Network.Mainnet] = {};
VERSION_BYTE[Format.Legacy][Network.Mainnet][Type.P2PKH] = 0;
VERSION_BYTE[Format.Legacy][Network.Mainnet][Type.P2SH] = 5;
VERSION_BYTE[Format.Legacy][Network.Testnet] = {};
VERSION_BYTE[Format.Legacy][Network.Testnet][Type.P2PKH] = 111;
VERSION_BYTE[Format.Legacy][Network.Testnet][Type.P2SH] = 196;
VERSION_BYTE[Format.Bitpay] = {};
VERSION_BYTE[Format.Bitpay][Network.Mainnet] = {};
VERSION_BYTE[Format.Bitpay][Network.Mainnet][Type.P2PKH] = 28;
VERSION_BYTE[Format.Bitpay][Network.Mainnet][Type.P2SH] = 40;
VERSION_BYTE[Format.Bitpay][Network.Testnet] = {};
VERSION_BYTE[Format.Bitpay][Network.Testnet][Type.P2PKH] = 111;
VERSION_BYTE[Format.Bitpay][Network.Testnet][Type.P2SH] = 196;

/**
 * Decodes the given address into its constituting hash, format, network and type.
 * @private
 * @param {string} address - A valid Bitcoin Cash address in any format.
 * @return {object}
 * @throws {InvalidAddressError}
 */
function decodeAddress(address) {
  try {
    return decodeBase58Address(address);
  } catch (error) {}
  try {
    return decodeCashAddress(address);
  } catch (error) {}
  throw new InvalidAddressError();
}

/**
 * Length of a valid base58check encoding payload: 1 byte for
 * the version byte plus 20 bytes for a RIPEMD-160 hash.
 * @private
 */
var BASE_58_CHECK_PAYLOAD_LENGTH = 21;

/**
 * Attempts to decode the given address assuming it is a base58 address.
 * @private
 * @param {string} address - A valid Bitcoin Cash address in any format.
 * @return {object}
 * @throws {InvalidAddressError}
 */
function decodeBase58Address(address) {
  try {
    var payload = bs58check$1.decode(address);
    if (payload.length !== BASE_58_CHECK_PAYLOAD_LENGTH) {
      throw new InvalidAddressError();
    }
    var versionByte = payload[0];
    var hash = Array.prototype.slice.call(payload, 1);
    switch (versionByte) {
      case VERSION_BYTE[Format.Legacy][Network.Mainnet][Type.P2PKH]:
        return {
          hash: hash,
          format: Format.Legacy,
          network: Network.Mainnet,
          type: Type.P2PKH
        };
      case VERSION_BYTE[Format.Legacy][Network.Mainnet][Type.P2SH]:
        return {
          hash: hash,
          format: Format.Legacy,
          network: Network.Mainnet,
          type: Type.P2SH
        };
      case VERSION_BYTE[Format.Legacy][Network.Testnet][Type.P2PKH]:
        return {
          hash: hash,
          format: Format.Legacy,
          network: Network.Testnet,
          type: Type.P2PKH
        };
      case VERSION_BYTE[Format.Legacy][Network.Testnet][Type.P2SH]:
        return {
          hash: hash,
          format: Format.Legacy,
          network: Network.Testnet,
          type: Type.P2SH
        };
      case VERSION_BYTE[Format.Bitpay][Network.Mainnet][Type.P2PKH]:
        return {
          hash: hash,
          format: Format.Bitpay,
          network: Network.Mainnet,
          type: Type.P2PKH
        };
      case VERSION_BYTE[Format.Bitpay][Network.Mainnet][Type.P2SH]:
        return {
          hash: hash,
          format: Format.Bitpay,
          network: Network.Mainnet,
          type: Type.P2SH
        };
    }
  } catch (error) {}
  throw new InvalidAddressError();
}

/**
 * Attempts to decode the given address assuming it is a cashaddr address.
 * @private
 * @param {string} address - A valid Bitcoin Cash address in any format.
 * @return {object}
 * @throws {InvalidAddressError}
 */
function decodeCashAddress(address) {
  if (address.indexOf(':') !== -1) {
    try {
      return decodeCashAddressWithPrefix(address);
    } catch (error) {}
  } else {
    var prefixes = ['bitcoincash', 'bchtest', 'bchreg'];
    for (var i = 0; i < prefixes.length; ++i) {
      try {
        var prefix = prefixes[i];
        return decodeCashAddressWithPrefix(prefix + ':' + address);
      } catch (error) {}
    }
  }
  throw new InvalidAddressError();
}

/**
 * Attempts to decode the given address assuming it is a cashaddr address with explicit prefix.
 * @private
 * @param {string} address - A valid Bitcoin Cash address in any format.
 * @return {object}
 * @throws {InvalidAddressError}
 */
function decodeCashAddressWithPrefix(address) {
  try {
    var decoded = cashaddr.decode(address);
    var hash = Array.prototype.slice.call(decoded.hash, 0);
    var type = decoded.type === 'P2PKH' ? Type.P2PKH : Type.P2SH;
    switch (decoded.prefix) {
      case 'bitcoincash':
        return {
          hash: hash,
          format: Format.Cashaddr,
          network: Network.Mainnet,
          type: type
        };
      case 'bchtest':
      case 'bchreg':
        return {
          hash: hash,
          format: Format.Cashaddr,
          network: Network.Testnet,
          type: type
        };
    }
  } catch (error) {}
  throw new InvalidAddressError();
}

/**
 * Encodes the given decoded address into legacy format.
 * @private
 * @param {object} decoded
 * @returns {string}
 */
function encodeAsLegacy(decoded) {
  var versionByte = VERSION_BYTE[Format.Legacy][decoded.network][decoded.type];
  var buffer = Buffer.alloc(1 + decoded.hash.length);
  buffer[0] = versionByte;
  buffer.set(decoded.hash, 1);
  return bs58check$1.encode(buffer);
}

/**
 * Encodes the given decoded address into bitpay format.
 * @private
 * @param {object} decoded
 * @returns {string}
 */
function encodeAsBitpay(decoded) {
  var versionByte = VERSION_BYTE[Format.Bitpay][decoded.network][decoded.type];
  var buffer = Buffer.alloc(1 + decoded.hash.length);
  buffer[0] = versionByte;
  buffer.set(decoded.hash, 1);
  return bs58check$1.encode(buffer);
}

/**
 * Encodes the given decoded address into cashaddr format.
 * @private
 * @param {object} decoded
 * @returns {string}
 */
function encodeAsCashaddr(decoded) {
  var prefix = decoded.network === Network.Mainnet ? 'bitcoincash' : 'bchtest';
  var type = decoded.type === Type.P2PKH ? 'P2PKH' : 'P2SH';
  var hash = new Uint8Array(decoded.hash);
  return cashaddr.encode(prefix, type, hash);
}

/**
 * Returns a boolean indicating whether the address is in legacy format.
 * @static
 * @param {string} address - A valid Bitcoin Cash address in any format.
 * @returns {boolean}
 * @throws {InvalidAddressError}
 */
function isLegacyAddress(address) {
  return detectAddressFormat(address) === Format.Legacy;
}

/**
 * Returns a boolean indicating whether the address is in bitpay format.
 * @static
 * @param {string} address - A valid Bitcoin Cash address in any format.
 * @returns {boolean}
 * @throws {InvalidAddressError}
 */
function isBitpayAddress(address) {
  return detectAddressFormat(address) === Format.Bitpay;
}

/**
 * Returns a boolean indicating whether the address is in cashaddr format.
 * @static
 * @param {string} address - A valid Bitcoin Cash address in any format.
 * @returns {boolean}
 * @throws {InvalidAddressError}
 */
function isCashAddress(address) {
  return detectAddressFormat(address) === Format.Cashaddr;
}

/**
 * Returns a boolean indicating whether the address is a mainnet address.
 * @static
 * @param {string} address - A valid Bitcoin Cash address in any format.
 * @returns {boolean}
 * @throws {InvalidAddressError}
 */
function isMainnetAddress(address) {
  return detectAddressNetwork(address) === Network.Mainnet;
}

/**
 * Returns a boolean indicating whether the address is a testnet address.
 * @static
 * @param {string} address - A valid Bitcoin Cash address in any format.
 * @returns {boolean}
 * @throws {InvalidAddressError}
 */
function isTestnetAddress(address) {
  return detectAddressNetwork(address) === Network.Testnet;
}

/**
 * Returns a boolean indicating whether the address is a p2pkh address.
 * @static
 * @param {string} address - A valid Bitcoin Cash address in any format.
 * @returns {boolean}
 * @throws {InvalidAddressError}
 */
function isP2PKHAddress(address) {
  return detectAddressType(address) === Type.P2PKH;
}

/**
 * Returns a boolean indicating whether the address is a p2sh address.
 * @static
 * @param {string} address - A valid Bitcoin Cash address in any format.
 * @returns {boolean}
 * @throws {InvalidAddressError}
 */
function isP2SHAddress(address) {
  return detectAddressType(address) === Type.P2SH;
}

/**
 * Error thrown when the address given as input is not a valid Bitcoin Cash address.
 * @constructor
 * InvalidAddressError
 */
function InvalidAddressError() {
  var error = new Error();
  this.name = error.name = 'InvalidAddressError';
  this.message = error.message = 'Received an invalid Bitcoin Cash address as input.';
  this.stack = error.stack;
}
InvalidAddressError.prototype = Object.create(Error.prototype);
var bchaddr$1 = {
  Format: Format,
  Network: Network,
  Type: Type,
  isValidAddress: isValidAddress,
  detectAddressFormat: detectAddressFormat,
  detectAddressNetwork: detectAddressNetwork,
  detectAddressType: detectAddressType,
  toLegacyAddress: toLegacyAddress,
  toBitpayAddress: toBitpayAddress,
  toCashAddress: toCashAddress,
  isLegacyAddress: isLegacyAddress,
  isBitpayAddress: isBitpayAddress,
  isCashAddress: isCashAddress,
  isMainnetAddress: isMainnetAddress,
  isTestnetAddress: isTestnetAddress,
  isP2PKHAddress: isP2PKHAddress,
  isP2SHAddress: isP2SHAddress,
  InvalidAddressError: InvalidAddressError
};

var bs58check = bs58check$2;
function decodeRaw(buffer, version) {
  // check version only if defined
  if (version !== undefined && buffer[0] !== version) throw new Error('Invalid network version');

  // uncompressed
  if (buffer.length === 33) {
    return {
      version: buffer[0],
      privateKey: buffer.slice(1, 33),
      compressed: false
    };
  }

  // invalid length
  if (buffer.length !== 34) throw new Error('Invalid WIF length');

  // invalid compression flag
  if (buffer[33] !== 0x01) throw new Error('Invalid compression flag');
  return {
    version: buffer[0],
    privateKey: buffer.slice(1, 33),
    compressed: true
  };
}
function encodeRaw(version, privateKey, compressed) {
  var result = new Buffer$d(compressed ? 34 : 33);
  result.writeUInt8(version, 0);
  privateKey.copy(result, 1);
  if (compressed) {
    result[33] = 0x01;
  }
  return result;
}
function decode$1(string, version) {
  return decodeRaw(bs58check.decode(string), version);
}
function encode$1(version, privateKey, compressed) {
  if (typeof version === 'number') return bs58check.encode(encodeRaw(version, privateKey, compressed));
  return bs58check.encode(encodeRaw(version.version, version.privateKey, version.compressed));
}
var wif$1 = {
  decode: decode$1,
  decodeRaw: decodeRaw,
  encode: encode$1,
  encodeRaw: encodeRaw
};

var msgpack_min = {exports: {}};

msgpack_min.exports;
(function (module, exports) {
  !function (t, e) {
    module.exports = e() ;
  }(commonjsGlobal, function () {
    return function (t) {
      var e = {};
      function r(n) {
        if (e[n]) return e[n].exports;
        var i = e[n] = {
          i: n,
          l: !1,
          exports: {}
        };
        return t[n].call(i.exports, i, i.exports, r), i.l = !0, i.exports;
      }
      return r.m = t, r.c = e, r.d = function (t, e, n) {
        r.o(t, e) || Object.defineProperty(t, e, {
          enumerable: !0,
          get: n
        });
      }, r.r = function (t) {
        "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(t, Symbol.toStringTag, {
          value: "Module"
        }), Object.defineProperty(t, "__esModule", {
          value: !0
        });
      }, r.t = function (t, e) {
        if (1 & e && (t = r(t)), 8 & e) return t;
        if (4 & e && "object" == _typeof(t) && t && t.__esModule) return t;
        var n = Object.create(null);
        if (r.r(n), Object.defineProperty(n, "default", {
          enumerable: !0,
          value: t
        }), 2 & e && "string" != typeof t) for (var i in t) r.d(n, i, function (e) {
          return t[e];
        }.bind(null, i));
        return n;
      }, r.n = function (t) {
        var e = t && t.__esModule ? function () {
          return t.default;
        } : function () {
          return t;
        };
        return r.d(e, "a", e), e;
      }, r.o = function (t, e) {
        return Object.prototype.hasOwnProperty.call(t, e);
      }, r.p = "", r(r.s = 0);
    }([function (t, e, r) {

      r.r(e), r.d(e, "encode", function () {
        return T;
      }), r.d(e, "decode", function () {
        return V;
      }), r.d(e, "decodeAsync", function () {
        return Y;
      }), r.d(e, "decodeArrayStream", function () {
        return Z;
      }), r.d(e, "decodeStream", function () {
        return $;
      }), r.d(e, "Decoder", function () {
        return O;
      }), r.d(e, "Encoder", function () {
        return I;
      }), r.d(e, "ExtensionCodec", function () {
        return S;
      }), r.d(e, "ExtData", function () {
        return p;
      }), r.d(e, "EXT_TIMESTAMP", function () {
        return w;
      }), r.d(e, "encodeDateToTimeSpec", function () {
        return g;
      }), r.d(e, "encodeTimeSpecToTimestamp", function () {
        return v;
      }), r.d(e, "decodeTimestampToTimeSpec", function () {
        return U;
      }), r.d(e, "encodeTimestampExtension", function () {
        return b;
      }), r.d(e, "decodeTimestampExtension", function () {
        return m;
      });
      var n = function n(t, e) {
          var r = "function" == typeof Symbol && t[Symbol.iterator];
          if (!r) return t;
          var n,
            i,
            o = r.call(t),
            s = [];
          try {
            for (; (void 0 === e || e-- > 0) && !(n = o.next()).done;) s.push(n.value);
          } catch (t) {
            i = {
              error: t
            };
          } finally {
            try {
              n && !n.done && (r = o.return) && r.call(o);
            } finally {
              if (i) throw i.error;
            }
          }
          return s;
        },
        i = function i() {
          for (var t = [], e = 0; e < arguments.length; e++) t = t.concat(n(arguments[e]));
          return t;
        },
        o = "undefined" != typeof process && "undefined" != typeof TextEncoder && "undefined" != typeof TextDecoder;
      function s(t) {
        for (var e = t.length, r = 0, n = 0; n < e;) {
          var i = t.charCodeAt(n++);
          if (0 != (4294967168 & i)) {
            if (0 == (4294965248 & i)) r += 2;else {
              if (i >= 55296 && i <= 56319 && n < e) {
                var o = t.charCodeAt(n);
                56320 == (64512 & o) && (++n, i = ((1023 & i) << 10) + (1023 & o) + 65536);
              }
              r += 0 == (4294901760 & i) ? 3 : 4;
            }
          } else r++;
        }
        return r;
      }
      var a = o ? new TextEncoder() : void 0,
        h = "undefined" != typeof process ? 200 : 0;
      var u = (null == a ? void 0 : a.encodeInto) ? function (t, e, r) {
        a.encodeInto(t, e.subarray(r));
      } : function (t, e, r) {
        e.set(a.encode(t), r);
      };
      function c(t, e, r) {
        for (var n = e, o = n + r, s = [], a = ""; n < o;) {
          var h = t[n++];
          if (0 == (128 & h)) s.push(h);else if (192 == (224 & h)) {
            var u = 63 & t[n++];
            s.push((31 & h) << 6 | u);
          } else if (224 == (240 & h)) {
            u = 63 & t[n++];
            var c = 63 & t[n++];
            s.push((31 & h) << 12 | u << 6 | c);
          } else if (240 == (248 & h)) {
            var f = (7 & h) << 18 | (u = 63 & t[n++]) << 12 | (c = 63 & t[n++]) << 6 | 63 & t[n++];
            f > 65535 && (f -= 65536, s.push(f >>> 10 & 1023 | 55296), f = 56320 | 1023 & f), s.push(f);
          } else s.push(h);
          s.length >= 4096 && (a += String.fromCharCode.apply(String, i(s)), s.length = 0);
        }
        return s.length > 0 && (a += String.fromCharCode.apply(String, i(s))), a;
      }
      var f = o ? new TextDecoder() : null,
        l = "undefined" != typeof process ? 200 : 0;
      var p = function p(t, e) {
        this.type = t, this.data = e;
      };
      function d(t, e, r) {
        var n = Math.floor(r / 4294967296),
          i = r;
        t.setUint32(e, n), t.setUint32(e + 4, i);
      }
      function y(t, e) {
        var r = t.getInt32(e),
          n = t.getUint32(e + 4),
          i = r < Math.floor(Number.MIN_SAFE_INTEGER / 4294967296) || r === Math.floor(Number.MIN_SAFE_INTEGER / 4294967296) && 0 === n,
          o = r > Math.floor(Number.MAX_SAFE_INTEGER / 4294967296);
        return i || o ? BigInt(r) * BigInt(4294967296) + BigInt(n) : 4294967296 * r + n;
      }
      var w = -1;
      function v(t) {
        var e = t.sec,
          r = t.nsec;
        if (e >= 0 && r >= 0 && e <= 17179869183) {
          if (0 === r && e <= 4294967295) {
            var n = new Uint8Array(4);
            return (s = new DataView(n.buffer)).setUint32(0, e), n;
          }
          var i = e / 4294967296,
            o = 4294967295 & e;
          n = new Uint8Array(8);
          return (s = new DataView(n.buffer)).setUint32(0, r << 2 | 3 & i), s.setUint32(4, o), n;
        }
        var s;
        n = new Uint8Array(12);
        return (s = new DataView(n.buffer)).setUint32(0, r), d(s, 4, e), n;
      }
      function g(t) {
        var e = t.getTime(),
          r = Math.floor(e / 1e3),
          n = 1e6 * (e - 1e3 * r),
          i = Math.floor(n / 1e9);
        return {
          sec: r + i,
          nsec: n - 1e9 * i
        };
      }
      function b(t) {
        return t instanceof Date ? v(g(t)) : null;
      }
      function U(t) {
        var e = new DataView(t.buffer, t.byteOffset, t.byteLength);
        switch (t.byteLength) {
          case 4:
            return {
              sec: e.getUint32(0),
              nsec: 0
            };
          case 8:
            var r = e.getUint32(0);
            return {
              sec: 4294967296 * (3 & r) + e.getUint32(4),
              nsec: r >>> 2
            };
          case 12:
            return {
              sec: y(e, 4),
              nsec: e.getUint32(0)
            };
          default:
            throw new Error("Unrecognized data size for timestamp: " + t.length);
        }
      }
      function m(t) {
        var e = U(t);
        return new Date(1e3 * e.sec + e.nsec / 1e6);
      }
      var x = {
          type: w,
          encode: b,
          decode: m
        },
        S = function () {
          function t() {
            this.builtInEncoders = [], this.builtInDecoders = [], this.encoders = [], this.decoders = [], this.register(x);
          }
          return t.prototype.register = function (t) {
            var e = t.type,
              r = t.encode,
              n = t.decode;
            if (e >= 0) this.encoders[e] = r, this.decoders[e] = n;else {
              var i = 1 + e;
              this.builtInEncoders[i] = r, this.builtInDecoders[i] = n;
            }
          }, t.prototype.tryToEncode = function (t, e) {
            for (var r = 0; r < this.builtInEncoders.length; r++) {
              if (null != (n = this.builtInEncoders[r])) if (null != (i = n(t, e))) return new p(-1 - r, i);
            }
            for (r = 0; r < this.encoders.length; r++) {
              var n, i;
              if (null != (n = this.encoders[r])) if (null != (i = n(t, e))) return new p(r, i);
            }
            return t instanceof p ? t : null;
          }, t.prototype.decode = function (t, e, r) {
            var n = e < 0 ? this.builtInDecoders[-1 - e] : this.decoders[e];
            return n ? n(t, e, r) : new p(e, t);
          }, t.defaultCodec = new t(), t;
        }();
      function B(t) {
        return t instanceof Uint8Array ? t : ArrayBuffer.isView(t) ? new Uint8Array(t.buffer, t.byteOffset, t.byteLength) : t instanceof ArrayBuffer ? new Uint8Array(t) : Uint8Array.from(t);
      }
      var E = function E(t) {
          var e = "function" == typeof Symbol && Symbol.iterator,
            r = e && t[e],
            n = 0;
          if (r) return r.call(t);
          if (t && "number" == typeof t.length) return {
            next: function next() {
              return t && n >= t.length && (t = void 0), {
                value: t && t[n++],
                done: !t
              };
            }
          };
          throw new TypeError(e ? "Object is not iterable." : "Symbol.iterator is not defined.");
        },
        I = function () {
          function t(t, e, r, n, i, o, s, a) {
            void 0 === t && (t = S.defaultCodec), void 0 === e && (e = void 0), void 0 === r && (r = 100), void 0 === n && (n = 2048), void 0 === i && (i = !1), void 0 === o && (o = !1), void 0 === s && (s = !1), void 0 === a && (a = !1), this.extensionCodec = t, this.context = e, this.maxDepth = r, this.initialBufferSize = n, this.sortKeys = i, this.forceFloat32 = o, this.ignoreUndefined = s, this.forceIntegerToFloat = a, this.pos = 0, this.view = new DataView(new ArrayBuffer(this.initialBufferSize)), this.bytes = new Uint8Array(this.view.buffer);
          }
          return t.prototype.getUint8Array = function () {
            return this.bytes.subarray(0, this.pos);
          }, t.prototype.reinitializeState = function () {
            this.pos = 0;
          }, t.prototype.encode = function (t) {
            return this.reinitializeState(), this.doEncode(t, 1), this.getUint8Array();
          }, t.prototype.doEncode = function (t, e) {
            if (e > this.maxDepth) throw new Error("Too deep objects in depth " + e);
            null == t ? this.encodeNil() : "boolean" == typeof t ? this.encodeBoolean(t) : "number" == typeof t ? this.encodeNumber(t) : "string" == typeof t ? this.encodeString(t) : "bigint" == typeof t ? this.encodebigint(t) : this.encodeObject(t, e);
          }, t.prototype.ensureBufferSizeToWrite = function (t) {
            var e = this.pos + t;
            this.view.byteLength < e && this.resizeBuffer(2 * e);
          }, t.prototype.resizeBuffer = function (t) {
            var e = new ArrayBuffer(t),
              r = new Uint8Array(e),
              n = new DataView(e);
            r.set(this.bytes), this.view = n, this.bytes = r;
          }, t.prototype.encodeNil = function () {
            this.writeU8(192);
          }, t.prototype.encodeBoolean = function (t) {
            !1 === t ? this.writeU8(194) : this.writeU8(195);
          }, t.prototype.encodeNumber = function (t) {
            Number.isSafeInteger(t) && !this.forceIntegerToFloat ? t >= 0 ? t < 128 ? this.writeU8(t) : t < 256 ? (this.writeU8(204), this.writeU8(t)) : t < 65536 ? (this.writeU8(205), this.writeU16(t)) : t < 4294967296 ? (this.writeU8(206), this.writeU32(t)) : (this.writeU8(207), this.writeU64(t)) : t >= -32 ? this.writeU8(224 | t + 32) : t >= -128 ? (this.writeU8(208), this.writeI8(t)) : t >= -32768 ? (this.writeU8(209), this.writeI16(t)) : t >= -2147483648 ? (this.writeU8(210), this.writeI32(t)) : (this.writeU8(211), this.writeI64(t)) : this.forceFloat32 ? (this.writeU8(202), this.writeF32(t)) : (this.writeU8(203), this.writeF64(t));
          }, t.prototype.encodebigint = function (t) {
            t >= BigInt(0) ? t < BigInt(128) ? this.writeU8(Number(t)) : t < BigInt(256) ? (this.writeU8(204), this.writeU8(Number(t))) : t < BigInt(65536) ? (this.writeU8(205), this.writeU16(Number(t))) : t < BigInt(4294967296) ? (this.writeU8(206), this.writeU32(Number(t))) : (this.writeU8(207), this.writeBig64(t)) : t >= BigInt(-32) ? this.writeU8(224 | Number(t) + 32) : t >= BigInt(-128) ? (this.writeU8(208), this.writeI8(Number(t))) : t >= BigInt(-32768) ? (this.writeU8(209), this.writeI16(Number(t))) : t >= BigInt(-2147483648) ? (this.writeU8(210), this.writeI32(Number(t))) : (this.writeU8(211), this.writeBig64(t));
          }, t.prototype.writeStringHeader = function (t) {
            if (t < 32) this.writeU8(160 + t);else if (t < 256) this.writeU8(217), this.writeU8(t);else if (t < 65536) this.writeU8(218), this.writeU16(t);else {
              if (!(t < 4294967296)) throw new Error("Too long string: " + t + " bytes in UTF-8");
              this.writeU8(219), this.writeU32(t);
            }
          }, t.prototype.encodeString = function (t) {
            var e = t.length;
            if (o && e > h) {
              var r = s(t);
              this.ensureBufferSizeToWrite(5 + r), this.writeStringHeader(r), u(t, this.bytes, this.pos), this.pos += r;
            } else {
              r = s(t);
              this.ensureBufferSizeToWrite(5 + r), this.writeStringHeader(r), function (t, e, r) {
                for (var n = t.length, i = r, o = 0; o < n;) {
                  var s = t.charCodeAt(o++);
                  if (0 != (4294967168 & s)) {
                    if (0 == (4294965248 & s)) e[i++] = s >> 6 & 31 | 192;else {
                      if (s >= 55296 && s <= 56319 && o < n) {
                        var a = t.charCodeAt(o);
                        56320 == (64512 & a) && (++o, s = ((1023 & s) << 10) + (1023 & a) + 65536);
                      }
                      0 == (4294901760 & s) ? (e[i++] = s >> 12 & 15 | 224, e[i++] = s >> 6 & 63 | 128) : (e[i++] = s >> 18 & 7 | 240, e[i++] = s >> 12 & 63 | 128, e[i++] = s >> 6 & 63 | 128);
                    }
                    e[i++] = 63 & s | 128;
                  } else e[i++] = s;
                }
              }(t, this.bytes, this.pos), this.pos += r;
            }
          }, t.prototype.encodeObject = function (t, e) {
            var r = this.extensionCodec.tryToEncode(t, this.context);
            if (null != r) this.encodeExtension(r);else if (Array.isArray(t)) this.encodeArray(t, e);else if (ArrayBuffer.isView(t)) this.encodeBinary(t);else {
              if ("object" != _typeof(t)) throw new Error("Unrecognized object: " + Object.prototype.toString.apply(t));
              this.encodeMap(t, e);
            }
          }, t.prototype.encodeBinary = function (t) {
            var e = t.byteLength;
            if (e < 256) this.writeU8(196), this.writeU8(e);else if (e < 65536) this.writeU8(197), this.writeU16(e);else {
              if (!(e < 4294967296)) throw new Error("Too large binary: " + e);
              this.writeU8(198), this.writeU32(e);
            }
            var r = B(t);
            this.writeU8a(r);
          }, t.prototype.encodeArray = function (t, e) {
            var r,
              n,
              i = t.length;
            if (i < 16) this.writeU8(144 + i);else if (i < 65536) this.writeU8(220), this.writeU16(i);else {
              if (!(i < 4294967296)) throw new Error("Too large array: " + i);
              this.writeU8(221), this.writeU32(i);
            }
            try {
              for (var o = E(t), s = o.next(); !s.done; s = o.next()) {
                var a = s.value;
                this.doEncode(a, e + 1);
              }
            } catch (t) {
              r = {
                error: t
              };
            } finally {
              try {
                s && !s.done && (n = o.return) && n.call(o);
              } finally {
                if (r) throw r.error;
              }
            }
          }, t.prototype.countWithoutUndefined = function (t, e) {
            var r,
              n,
              i = 0;
            try {
              for (var o = E(e), s = o.next(); !s.done; s = o.next()) {
                void 0 !== t[s.value] && i++;
              }
            } catch (t) {
              r = {
                error: t
              };
            } finally {
              try {
                s && !s.done && (n = o.return) && n.call(o);
              } finally {
                if (r) throw r.error;
              }
            }
            return i;
          }, t.prototype.encodeMap = function (t, e) {
            var r,
              n,
              i = Object.keys(t);
            this.sortKeys && i.sort();
            var o = this.ignoreUndefined ? this.countWithoutUndefined(t, i) : i.length;
            if (o < 16) this.writeU8(128 + o);else if (o < 65536) this.writeU8(222), this.writeU16(o);else {
              if (!(o < 4294967296)) throw new Error("Too large map object: " + o);
              this.writeU8(223), this.writeU32(o);
            }
            try {
              for (var s = E(i), a = s.next(); !a.done; a = s.next()) {
                var h = a.value,
                  u = t[h];
                this.ignoreUndefined && void 0 === u || (this.encodeString(h), this.doEncode(u, e + 1));
              }
            } catch (t) {
              r = {
                error: t
              };
            } finally {
              try {
                a && !a.done && (n = s.return) && n.call(s);
              } finally {
                if (r) throw r.error;
              }
            }
          }, t.prototype.encodeExtension = function (t) {
            var e = t.data.length;
            if (1 === e) this.writeU8(212);else if (2 === e) this.writeU8(213);else if (4 === e) this.writeU8(214);else if (8 === e) this.writeU8(215);else if (16 === e) this.writeU8(216);else if (e < 256) this.writeU8(199), this.writeU8(e);else if (e < 65536) this.writeU8(200), this.writeU16(e);else {
              if (!(e < 4294967296)) throw new Error("Too large extension object: " + e);
              this.writeU8(201), this.writeU32(e);
            }
            this.writeI8(t.type), this.writeU8a(t.data);
          }, t.prototype.writeU8 = function (t) {
            this.ensureBufferSizeToWrite(1), this.view.setUint8(this.pos, t), this.pos++;
          }, t.prototype.writeU8a = function (t) {
            var e = t.length;
            this.ensureBufferSizeToWrite(e), this.bytes.set(t, this.pos), this.pos += e;
          }, t.prototype.writeI8 = function (t) {
            this.ensureBufferSizeToWrite(1), this.view.setInt8(this.pos, t), this.pos++;
          }, t.prototype.writeU16 = function (t) {
            this.ensureBufferSizeToWrite(2), this.view.setUint16(this.pos, t), this.pos += 2;
          }, t.prototype.writeI16 = function (t) {
            this.ensureBufferSizeToWrite(2), this.view.setInt16(this.pos, t), this.pos += 2;
          }, t.prototype.writeU32 = function (t) {
            this.ensureBufferSizeToWrite(4), this.view.setUint32(this.pos, t), this.pos += 4;
          }, t.prototype.writeI32 = function (t) {
            this.ensureBufferSizeToWrite(4), this.view.setInt32(this.pos, t), this.pos += 4;
          }, t.prototype.writeF32 = function (t) {
            this.ensureBufferSizeToWrite(4), this.view.setFloat32(this.pos, t), this.pos += 4;
          }, t.prototype.writeF64 = function (t) {
            this.ensureBufferSizeToWrite(8), this.view.setFloat64(this.pos, t), this.pos += 8;
          }, t.prototype.writeU64 = function (t) {
            this.ensureBufferSizeToWrite(8), function (t, e, r) {
              var n = r / 4294967296,
                i = r;
              t.setUint32(e, n), t.setUint32(e + 4, i);
            }(this.view, this.pos, t), this.pos += 8;
          }, t.prototype.writeI64 = function (t) {
            this.ensureBufferSizeToWrite(8), d(this.view, this.pos, t), this.pos += 8;
          }, t.prototype.writeBig64 = function (t) {
            this.ensureBufferSizeToWrite(8), function (t, e, r) {
              var n = Number(r / BigInt(4294967296)),
                i = Number(r % BigInt(4294967296));
              n < 0 && 0 !== i && (n -= 1), t.setUint32(e, n), t.setUint32(e + 4, i);
            }(this.view, this.pos, t), this.pos += 8;
          }, t;
        }(),
        A = {};
      function T(t, e) {
        return void 0 === e && (e = A), new I(e.extensionCodec, e.context, e.maxDepth, e.initialBufferSize, e.sortKeys, e.forceFloat32, e.ignoreUndefined, e.forceIntegerToFloat).encode(t);
      }
      function L(t) {
        return (t < 0 ? "-" : "") + "0x" + Math.abs(t).toString(16).padStart(2, "0");
      }
      var M = function () {
          function t(t, e) {
            void 0 === t && (t = 16), void 0 === e && (e = 16), this.maxKeyLength = t, this.maxLengthPerKey = e, this.hit = 0, this.miss = 0, this.caches = [];
            for (var r = 0; r < this.maxKeyLength; r++) this.caches.push([]);
          }
          return t.prototype.canBeCached = function (t) {
            return t > 0 && t <= this.maxKeyLength;
          }, t.prototype.get = function (t, e, r) {
            var n = this.caches[r - 1],
              i = n.length;
            t: for (var o = 0; o < i; o++) {
              for (var s = n[o], a = s.bytes, h = 0; h < r; h++) if (a[h] !== t[e + h]) continue t;
              return s.value;
            }
            return null;
          }, t.prototype.store = function (t, e) {
            var r = this.caches[t.length - 1],
              n = {
                bytes: t,
                value: e
              };
            r.length >= this.maxLengthPerKey ? r[Math.random() * r.length | 0] = n : r.push(n);
          }, t.prototype.decode = function (t, e, r) {
            var n = this.get(t, e, r);
            if (null != n) return this.hit++, n;
            this.miss++;
            var i = c(t, e, r),
              o = Uint8Array.prototype.slice.call(t, e, e + r);
            return this.store(o, i), i;
          }, t;
        }(),
        k = function k(t, e, r, n) {
          return new (r || (r = Promise))(function (i, o) {
            function s(t) {
              try {
                h(n.next(t));
              } catch (t) {
                o(t);
              }
            }
            function a(t) {
              try {
                h(n.throw(t));
              } catch (t) {
                o(t);
              }
            }
            function h(t) {
              var e;
              t.done ? i(t.value) : (e = t.value, e instanceof r ? e : new r(function (t) {
                t(e);
              })).then(s, a);
            }
            h((n = n.apply(t, e || [])).next());
          });
        },
        z = function z(t, e) {
          var r,
            n,
            i,
            o,
            s = {
              label: 0,
              sent: function sent() {
                if (1 & i[0]) throw i[1];
                return i[1];
              },
              trys: [],
              ops: []
            };
          return o = {
            next: a(0),
            throw: a(1),
            return: a(2)
          }, "function" == typeof Symbol && (o[Symbol.iterator] = function () {
            return this;
          }), o;
          function a(o) {
            return function (a) {
              return function (o) {
                if (r) throw new TypeError("Generator is already executing.");
                for (; s;) try {
                  if (r = 1, n && (i = 2 & o[0] ? n.return : o[0] ? n.throw || ((i = n.return) && i.call(n), 0) : n.next) && !(i = i.call(n, o[1])).done) return i;
                  switch (n = 0, i && (o = [2 & o[0], i.value]), o[0]) {
                    case 0:
                    case 1:
                      i = o;
                      break;
                    case 4:
                      return s.label++, {
                        value: o[1],
                        done: !1
                      };
                    case 5:
                      s.label++, n = o[1], o = [0];
                      continue;
                    case 7:
                      o = s.ops.pop(), s.trys.pop();
                      continue;
                    default:
                      if (!(i = s.trys, (i = i.length > 0 && i[i.length - 1]) || 6 !== o[0] && 2 !== o[0])) {
                        s = 0;
                        continue;
                      }
                      if (3 === o[0] && (!i || o[1] > i[0] && o[1] < i[3])) {
                        s.label = o[1];
                        break;
                      }
                      if (6 === o[0] && s.label < i[1]) {
                        s.label = i[1], i = o;
                        break;
                      }
                      if (i && s.label < i[2]) {
                        s.label = i[2], s.ops.push(o);
                        break;
                      }
                      i[2] && s.ops.pop(), s.trys.pop();
                      continue;
                  }
                  o = e.call(t, s);
                } catch (t) {
                  o = [6, t], n = 0;
                } finally {
                  r = i = 0;
                }
                if (5 & o[0]) throw o[1];
                return {
                  value: o[0] ? o[1] : void 0,
                  done: !0
                };
              }([o, a]);
            };
          }
        },
        D = function D(t) {
          if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
          var e,
            r = t[Symbol.asyncIterator];
          return r ? r.call(t) : (t = "function" == typeof __values ? __values(t) : t[Symbol.iterator](), e = {}, n("next"), n("throw"), n("return"), e[Symbol.asyncIterator] = function () {
            return this;
          }, e);
          function n(r) {
            e[r] = t[r] && function (e) {
              return new Promise(function (n, i) {
                (function (t, e, r, n) {
                  Promise.resolve(n).then(function (e) {
                    t({
                      value: e,
                      done: r
                    });
                  }, e);
                })(n, i, (e = t[r](e)).done, e.value);
              });
            };
          }
        },
        N = function N(t) {
          return this instanceof N ? (this.v = t, this) : new N(t);
        },
        C = function C(t, e, r) {
          if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
          var n,
            i = r.apply(t, e || []),
            o = [];
          return n = {}, s("next"), s("throw"), s("return"), n[Symbol.asyncIterator] = function () {
            return this;
          }, n;
          function s(t) {
            i[t] && (n[t] = function (e) {
              return new Promise(function (r, n) {
                o.push([t, e, r, n]) > 1 || a(t, e);
              });
            });
          }
          function a(t, e) {
            try {
              (r = i[t](e)).value instanceof N ? Promise.resolve(r.value.v).then(h, u) : c(o[0][2], r);
            } catch (t) {
              c(o[0][3], t);
            }
            var r;
          }
          function h(t) {
            a("next", t);
          }
          function u(t) {
            a("throw", t);
          }
          function c(t, e) {
            t(e), o.shift(), o.length && a(o[0][0], o[0][1]);
          }
        },
        P = new DataView(new ArrayBuffer(0)),
        F = new Uint8Array(P.buffer),
        j = function () {
          try {
            P.getInt8(0);
          } catch (t) {
            return t.constructor;
          }
          throw new Error("never reached");
        }(),
        _ = new j("Insufficient data"),
        W = new M(),
        O = function () {
          function t(t, e, r, n, i, o, s, a) {
            void 0 === t && (t = S.defaultCodec), void 0 === e && (e = void 0), void 0 === r && (r = 4294967295), void 0 === n && (n = 4294967295), void 0 === i && (i = 4294967295), void 0 === o && (o = 4294967295), void 0 === s && (s = 4294967295), void 0 === a && (a = W), this.extensionCodec = t, this.context = e, this.maxStrLength = r, this.maxBinLength = n, this.maxArrayLength = i, this.maxMapLength = o, this.maxExtLength = s, this.keyDecoder = a, this.totalPos = 0, this.pos = 0, this.view = P, this.bytes = F, this.headByte = -1, this.stack = [];
          }
          return t.prototype.reinitializeState = function () {
            this.totalPos = 0, this.headByte = -1;
          }, t.prototype.setBuffer = function (t) {
            this.bytes = B(t), this.view = function (t) {
              if (t instanceof ArrayBuffer) return new DataView(t);
              var e = B(t);
              return new DataView(e.buffer, e.byteOffset, e.byteLength);
            }(this.bytes), this.pos = 0;
          }, t.prototype.appendBuffer = function (t) {
            if (-1 !== this.headByte || this.hasRemaining()) {
              var e = this.bytes.subarray(this.pos),
                r = B(t),
                n = new Uint8Array(e.length + r.length);
              n.set(e), n.set(r, e.length), this.setBuffer(n);
            } else this.setBuffer(t);
          }, t.prototype.hasRemaining = function (t) {
            return void 0 === t && (t = 1), this.view.byteLength - this.pos >= t;
          }, t.prototype.createNoExtraBytesError = function (t) {
            var e = this.view,
              r = this.pos;
            return new RangeError("Extra " + (e.byteLength - r) + " of " + e.byteLength + " byte(s) found at buffer[" + t + "]");
          }, t.prototype.decode = function (t) {
            return this.reinitializeState(), this.setBuffer(t), this.doDecodeSingleSync();
          }, t.prototype.doDecodeSingleSync = function () {
            var t = this.doDecodeSync();
            if (this.hasRemaining()) throw this.createNoExtraBytesError(this.pos);
            return t;
          }, t.prototype.decodeAsync = function (t) {
            var e, r, n, i;
            return k(this, void 0, void 0, function () {
              var o, s, a, h, u, c, f, l;
              return z(this, function (p) {
                switch (p.label) {
                  case 0:
                    o = !1, p.label = 1;
                  case 1:
                    p.trys.push([1, 6, 7, 12]), e = D(t), p.label = 2;
                  case 2:
                    return [4, e.next()];
                  case 3:
                    if ((r = p.sent()).done) return [3, 5];
                    if (a = r.value, o) throw this.createNoExtraBytesError(this.totalPos);
                    this.appendBuffer(a);
                    try {
                      s = this.doDecodeSync(), o = !0;
                    } catch (t) {
                      if (!(t instanceof j)) throw t;
                    }
                    this.totalPos += this.pos, p.label = 4;
                  case 4:
                    return [3, 2];
                  case 5:
                    return [3, 12];
                  case 6:
                    return h = p.sent(), n = {
                      error: h
                    }, [3, 12];
                  case 7:
                    return p.trys.push([7,, 10, 11]), r && !r.done && (i = e.return) ? [4, i.call(e)] : [3, 9];
                  case 8:
                    p.sent(), p.label = 9;
                  case 9:
                    return [3, 11];
                  case 10:
                    if (n) throw n.error;
                    return [7];
                  case 11:
                    return [7];
                  case 12:
                    if (o) {
                      if (this.hasRemaining()) throw this.createNoExtraBytesError(this.totalPos);
                      return [2, s];
                    }
                    throw c = (u = this).headByte, f = u.pos, l = u.totalPos, new RangeError("Insufficient data in parcing " + L(c) + " at " + l + " (" + f + " in the current buffer)");
                }
              });
            });
          }, t.prototype.decodeArrayStream = function (t) {
            return this.decodeMultiAsync(t, !0);
          }, t.prototype.decodeStream = function (t) {
            return this.decodeMultiAsync(t, !1);
          }, t.prototype.decodeMultiAsync = function (t, e) {
            return C(this, arguments, function () {
              var r, n, i, o, s, a, h, u, c;
              return z(this, function (f) {
                switch (f.label) {
                  case 0:
                    r = e, n = -1, f.label = 1;
                  case 1:
                    f.trys.push([1, 13, 14, 19]), i = D(t), f.label = 2;
                  case 2:
                    return [4, N(i.next())];
                  case 3:
                    if ((o = f.sent()).done) return [3, 12];
                    if (s = o.value, e && 0 === n) throw this.createNoExtraBytesError(this.totalPos);
                    this.appendBuffer(s), r && (n = this.readArraySize(), r = !1, this.complete()), f.label = 4;
                  case 4:
                    f.trys.push([4, 9,, 10]), f.label = 5;
                  case 5:
                    return [4, N(this.doDecodeSync())];
                  case 6:
                    return [4, f.sent()];
                  case 7:
                    return f.sent(), 0 == --n ? [3, 8] : [3, 5];
                  case 8:
                    return [3, 10];
                  case 9:
                    if (!((a = f.sent()) instanceof j)) throw a;
                    return [3, 10];
                  case 10:
                    this.totalPos += this.pos, f.label = 11;
                  case 11:
                    return [3, 2];
                  case 12:
                    return [3, 19];
                  case 13:
                    return h = f.sent(), u = {
                      error: h
                    }, [3, 19];
                  case 14:
                    return f.trys.push([14,, 17, 18]), o && !o.done && (c = i.return) ? [4, N(c.call(i))] : [3, 16];
                  case 15:
                    f.sent(), f.label = 16;
                  case 16:
                    return [3, 18];
                  case 17:
                    if (u) throw u.error;
                    return [7];
                  case 18:
                    return [7];
                  case 19:
                    return [2];
                }
              });
            });
          }, t.prototype.doDecodeSync = function () {
            t: for (;;) {
              var t = this.readHeadByte(),
                e = void 0;
              if (t >= 224) e = t - 256;else if (t < 192) {
                if (t < 128) e = t;else if (t < 144) {
                  if (0 !== (n = t - 128)) {
                    this.pushMapState(n), this.complete();
                    continue t;
                  }
                  e = {};
                } else if (t < 160) {
                  if (0 !== (n = t - 144)) {
                    this.pushArrayState(n), this.complete();
                    continue t;
                  }
                  e = [];
                } else {
                  var r = t - 160;
                  e = this.decodeUtf8String(r, 0);
                }
              } else if (192 === t) e = null;else if (194 === t) e = !1;else if (195 === t) e = !0;else if (202 === t) e = this.readF32();else if (203 === t) e = this.readF64();else if (204 === t) e = this.readU8();else if (205 === t) e = this.readU16();else if (206 === t) e = this.readU32();else if (207 === t) e = this.readU64();else if (208 === t) e = this.readI8();else if (209 === t) e = this.readI16();else if (210 === t) e = this.readI32();else if (211 === t) e = this.readI64();else if (217 === t) {
                r = this.lookU8();
                e = this.decodeUtf8String(r, 1);
              } else if (218 === t) {
                r = this.lookU16();
                e = this.decodeUtf8String(r, 2);
              } else if (219 === t) {
                r = this.lookU32();
                e = this.decodeUtf8String(r, 4);
              } else if (220 === t) {
                if (0 !== (n = this.readU16())) {
                  this.pushArrayState(n), this.complete();
                  continue t;
                }
                e = [];
              } else if (221 === t) {
                if (0 !== (n = this.readU32())) {
                  this.pushArrayState(n), this.complete();
                  continue t;
                }
                e = [];
              } else if (222 === t) {
                if (0 !== (n = this.readU16())) {
                  this.pushMapState(n), this.complete();
                  continue t;
                }
                e = {};
              } else if (223 === t) {
                if (0 !== (n = this.readU32())) {
                  this.pushMapState(n), this.complete();
                  continue t;
                }
                e = {};
              } else if (196 === t) {
                var n = this.lookU8();
                e = this.decodeBinary(n, 1);
              } else if (197 === t) {
                n = this.lookU16();
                e = this.decodeBinary(n, 2);
              } else if (198 === t) {
                n = this.lookU32();
                e = this.decodeBinary(n, 4);
              } else if (212 === t) e = this.decodeExtension(1, 0);else if (213 === t) e = this.decodeExtension(2, 0);else if (214 === t) e = this.decodeExtension(4, 0);else if (215 === t) e = this.decodeExtension(8, 0);else if (216 === t) e = this.decodeExtension(16, 0);else if (199 === t) {
                n = this.lookU8();
                e = this.decodeExtension(n, 1);
              } else if (200 === t) {
                n = this.lookU16();
                e = this.decodeExtension(n, 2);
              } else {
                if (201 !== t) throw new Error("Unrecognized type byte: " + L(t));
                n = this.lookU32();
                e = this.decodeExtension(n, 4);
              }
              this.complete();
              for (var i = this.stack; i.length > 0;) {
                var o = i[i.length - 1];
                if (0 === o.type) {
                  if (o.array[o.position] = e, o.position++, o.position !== o.size) continue t;
                  i.pop(), e = o.array;
                } else {
                  if (1 === o.type) {
                    if (s = void 0, "string" !== (s = _typeof(e)) && "number" !== s) throw new Error("The type of key must be string or number but " + _typeof(e));
                    o.key = e, o.type = 2;
                    continue t;
                  }
                  if (o.map[o.key] = e, o.readCount++, o.readCount !== o.size) {
                    o.key = null, o.type = 1;
                    continue t;
                  }
                  i.pop(), e = o.map;
                }
              }
              return e;
            }
            var s;
          }, t.prototype.readHeadByte = function () {
            return -1 === this.headByte && (this.headByte = this.readU8()), this.headByte;
          }, t.prototype.complete = function () {
            this.headByte = -1;
          }, t.prototype.readArraySize = function () {
            var t = this.readHeadByte();
            switch (t) {
              case 220:
                return this.readU16();
              case 221:
                return this.readU32();
              default:
                if (t < 160) return t - 144;
                throw new Error("Unrecognized array type byte: " + L(t));
            }
          }, t.prototype.pushMapState = function (t) {
            if (t > this.maxMapLength) throw new Error("Max length exceeded: map length (" + t + ") > maxMapLengthLength (" + this.maxMapLength + ")");
            this.stack.push({
              type: 1,
              size: t,
              key: null,
              readCount: 0,
              map: {}
            });
          }, t.prototype.pushArrayState = function (t) {
            if (t > this.maxArrayLength) throw new Error("Max length exceeded: array length (" + t + ") > maxArrayLength (" + this.maxArrayLength + ")");
            this.stack.push({
              type: 0,
              size: t,
              array: new Array(t),
              position: 0
            });
          }, t.prototype.decodeUtf8String = function (t, e) {
            var r;
            if (t > this.maxStrLength) throw new Error("Max length exceeded: UTF-8 byte length (" + t + ") > maxStrLength (" + this.maxStrLength + ")");
            if (this.bytes.byteLength < this.pos + e + t) throw _;
            var n,
              i = this.pos + e;
            return n = this.stateIsMapKey() && (null === (r = this.keyDecoder) || void 0 === r ? void 0 : r.canBeCached(t)) ? this.keyDecoder.decode(this.bytes, i, t) : o && t > l ? function (t, e, r) {
              var n = t.subarray(e, e + r);
              return f.decode(n);
            }(this.bytes, i, t) : c(this.bytes, i, t), this.pos += e + t, n;
          }, t.prototype.stateIsMapKey = function () {
            return this.stack.length > 0 && 1 === this.stack[this.stack.length - 1].type;
          }, t.prototype.decodeBinary = function (t, e) {
            if (t > this.maxBinLength) throw new Error("Max length exceeded: bin length (" + t + ") > maxBinLength (" + this.maxBinLength + ")");
            if (!this.hasRemaining(t + e)) throw _;
            var r = this.pos + e,
              n = this.bytes.subarray(r, r + t);
            return this.pos += e + t, n;
          }, t.prototype.decodeExtension = function (t, e) {
            if (t > this.maxExtLength) throw new Error("Max length exceeded: ext length (" + t + ") > maxExtLength (" + this.maxExtLength + ")");
            var r = this.view.getInt8(this.pos + e),
              n = this.decodeBinary(t, e + 1);
            return this.extensionCodec.decode(n, r, this.context);
          }, t.prototype.lookU8 = function () {
            return this.view.getUint8(this.pos);
          }, t.prototype.lookU16 = function () {
            return this.view.getUint16(this.pos);
          }, t.prototype.lookU32 = function () {
            return this.view.getUint32(this.pos);
          }, t.prototype.readU8 = function () {
            var t = this.view.getUint8(this.pos);
            return this.pos++, t;
          }, t.prototype.readI8 = function () {
            var t = this.view.getInt8(this.pos);
            return this.pos++, t;
          }, t.prototype.readU16 = function () {
            var t = this.view.getUint16(this.pos);
            return this.pos += 2, t;
          }, t.prototype.readI16 = function () {
            var t = this.view.getInt16(this.pos);
            return this.pos += 2, t;
          }, t.prototype.readU32 = function () {
            var t = this.view.getUint32(this.pos);
            return this.pos += 4, t;
          }, t.prototype.readI32 = function () {
            var t = this.view.getInt32(this.pos);
            return this.pos += 4, t;
          }, t.prototype.readU64 = function () {
            var t,
              e,
              r,
              n,
              i = (t = this.view, e = this.pos, r = t.getUint32(e), n = t.getUint32(e + 4), r > Math.floor(Number.MAX_SAFE_INTEGER / 4294967296) ? BigInt(r) * BigInt(4294967296) + BigInt(n) : 4294967296 * r + n);
            return this.pos += 8, i;
          }, t.prototype.readI64 = function () {
            var t = y(this.view, this.pos);
            return this.pos += 8, t;
          }, t.prototype.readF32 = function () {
            var t = this.view.getFloat32(this.pos);
            return this.pos += 4, t;
          }, t.prototype.readF64 = function () {
            var t = this.view.getFloat64(this.pos);
            return this.pos += 8, t;
          }, t;
        }(),
        R = {};
      function V(t, e) {
        return void 0 === e && (e = R), new O(e.extensionCodec, e.context, e.maxStrLength, e.maxBinLength, e.maxArrayLength, e.maxMapLength, e.maxExtLength).decode(t);
      }
      var K = function K(t, e) {
          var r,
            n,
            i,
            o,
            s = {
              label: 0,
              sent: function sent() {
                if (1 & i[0]) throw i[1];
                return i[1];
              },
              trys: [],
              ops: []
            };
          return o = {
            next: a(0),
            throw: a(1),
            return: a(2)
          }, "function" == typeof Symbol && (o[Symbol.iterator] = function () {
            return this;
          }), o;
          function a(o) {
            return function (a) {
              return function (o) {
                if (r) throw new TypeError("Generator is already executing.");
                for (; s;) try {
                  if (r = 1, n && (i = 2 & o[0] ? n.return : o[0] ? n.throw || ((i = n.return) && i.call(n), 0) : n.next) && !(i = i.call(n, o[1])).done) return i;
                  switch (n = 0, i && (o = [2 & o[0], i.value]), o[0]) {
                    case 0:
                    case 1:
                      i = o;
                      break;
                    case 4:
                      return s.label++, {
                        value: o[1],
                        done: !1
                      };
                    case 5:
                      s.label++, n = o[1], o = [0];
                      continue;
                    case 7:
                      o = s.ops.pop(), s.trys.pop();
                      continue;
                    default:
                      if (!(i = s.trys, (i = i.length > 0 && i[i.length - 1]) || 6 !== o[0] && 2 !== o[0])) {
                        s = 0;
                        continue;
                      }
                      if (3 === o[0] && (!i || o[1] > i[0] && o[1] < i[3])) {
                        s.label = o[1];
                        break;
                      }
                      if (6 === o[0] && s.label < i[1]) {
                        s.label = i[1], i = o;
                        break;
                      }
                      if (i && s.label < i[2]) {
                        s.label = i[2], s.ops.push(o);
                        break;
                      }
                      i[2] && s.ops.pop(), s.trys.pop();
                      continue;
                  }
                  o = e.call(t, s);
                } catch (t) {
                  o = [6, t], n = 0;
                } finally {
                  r = i = 0;
                }
                if (5 & o[0]) throw o[1];
                return {
                  value: o[0] ? o[1] : void 0,
                  done: !0
                };
              }([o, a]);
            };
          }
        },
        G = function G(t) {
          return this instanceof G ? (this.v = t, this) : new G(t);
        },
        H = function H(t, e, r) {
          if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
          var n,
            i = r.apply(t, e || []),
            o = [];
          return n = {}, s("next"), s("throw"), s("return"), n[Symbol.asyncIterator] = function () {
            return this;
          }, n;
          function s(t) {
            i[t] && (n[t] = function (e) {
              return new Promise(function (r, n) {
                o.push([t, e, r, n]) > 1 || a(t, e);
              });
            });
          }
          function a(t, e) {
            try {
              (r = i[t](e)).value instanceof G ? Promise.resolve(r.value.v).then(h, u) : c(o[0][2], r);
            } catch (t) {
              c(o[0][3], t);
            }
            var r;
          }
          function h(t) {
            a("next", t);
          }
          function u(t) {
            a("throw", t);
          }
          function c(t, e) {
            t(e), o.shift(), o.length && a(o[0][0], o[0][1]);
          }
        };
      function X(t) {
        if (null == t) throw new Error("Assertion Failure: value must not be null nor undefined");
      }
      function q(t) {
        return null != t[Symbol.asyncIterator] ? t : function (t) {
          return H(this, arguments, function () {
            var e, r, n, i;
            return K(this, function (o) {
              switch (o.label) {
                case 0:
                  e = t.getReader(), o.label = 1;
                case 1:
                  o.trys.push([1,, 9, 10]), o.label = 2;
                case 2:
                  return [4, G(e.read())];
                case 3:
                  return r = o.sent(), n = r.done, i = r.value, n ? [4, G(void 0)] : [3, 5];
                case 4:
                  return [2, o.sent()];
                case 5:
                  return X(i), [4, G(i)];
                case 6:
                  return [4, o.sent()];
                case 7:
                  return o.sent(), [3, 2];
                case 8:
                  return [3, 10];
                case 9:
                  return e.releaseLock(), [7];
                case 10:
                  return [2];
              }
            });
          });
        }(t);
      }
      var J = function J(t, e, r, n) {
          return new (r || (r = Promise))(function (i, o) {
            function s(t) {
              try {
                h(n.next(t));
              } catch (t) {
                o(t);
              }
            }
            function a(t) {
              try {
                h(n.throw(t));
              } catch (t) {
                o(t);
              }
            }
            function h(t) {
              var e;
              t.done ? i(t.value) : (e = t.value, e instanceof r ? e : new r(function (t) {
                t(e);
              })).then(s, a);
            }
            h((n = n.apply(t, e || [])).next());
          });
        },
        Q = function Q(t, e) {
          var r,
            n,
            i,
            o,
            s = {
              label: 0,
              sent: function sent() {
                if (1 & i[0]) throw i[1];
                return i[1];
              },
              trys: [],
              ops: []
            };
          return o = {
            next: a(0),
            throw: a(1),
            return: a(2)
          }, "function" == typeof Symbol && (o[Symbol.iterator] = function () {
            return this;
          }), o;
          function a(o) {
            return function (a) {
              return function (o) {
                if (r) throw new TypeError("Generator is already executing.");
                for (; s;) try {
                  if (r = 1, n && (i = 2 & o[0] ? n.return : o[0] ? n.throw || ((i = n.return) && i.call(n), 0) : n.next) && !(i = i.call(n, o[1])).done) return i;
                  switch (n = 0, i && (o = [2 & o[0], i.value]), o[0]) {
                    case 0:
                    case 1:
                      i = o;
                      break;
                    case 4:
                      return s.label++, {
                        value: o[1],
                        done: !1
                      };
                    case 5:
                      s.label++, n = o[1], o = [0];
                      continue;
                    case 7:
                      o = s.ops.pop(), s.trys.pop();
                      continue;
                    default:
                      if (!(i = s.trys, (i = i.length > 0 && i[i.length - 1]) || 6 !== o[0] && 2 !== o[0])) {
                        s = 0;
                        continue;
                      }
                      if (3 === o[0] && (!i || o[1] > i[0] && o[1] < i[3])) {
                        s.label = o[1];
                        break;
                      }
                      if (6 === o[0] && s.label < i[1]) {
                        s.label = i[1], i = o;
                        break;
                      }
                      if (i && s.label < i[2]) {
                        s.label = i[2], s.ops.push(o);
                        break;
                      }
                      i[2] && s.ops.pop(), s.trys.pop();
                      continue;
                  }
                  o = e.call(t, s);
                } catch (t) {
                  o = [6, t], n = 0;
                } finally {
                  r = i = 0;
                }
                if (5 & o[0]) throw o[1];
                return {
                  value: o[0] ? o[1] : void 0,
                  done: !0
                };
              }([o, a]);
            };
          }
        };
      function Y(t, e) {
        return void 0 === e && (e = R), J(this, void 0, void 0, function () {
          var r;
          return Q(this, function (n) {
            return r = q(t), [2, new O(e.extensionCodec, e.context, e.maxStrLength, e.maxBinLength, e.maxArrayLength, e.maxMapLength, e.maxExtLength).decodeAsync(r)];
          });
        });
      }
      function Z(t, e) {
        void 0 === e && (e = R);
        var r = q(t);
        return new O(e.extensionCodec, e.context, e.maxStrLength, e.maxBinLength, e.maxArrayLength, e.maxMapLength, e.maxExtLength).decodeArrayStream(r);
      }
      function $(t, e) {
        void 0 === e && (e = R);
        var r = q(t);
        return new O(e.extensionCodec, e.context, e.maxStrLength, e.maxBinLength, e.maxArrayLength, e.maxMapLength, e.maxExtLength).decodeStream(r);
      }
    }]);
  });
})(msgpack_min, msgpack_min.exports);
var msgpack_minExports = msgpack_min.exports;

var base64url$2 = {exports: {}};

var base64url$1 = {};

var padString$1 = {};

Object.defineProperty(padString$1, "__esModule", {
  value: true
});
function padString(input) {
  var segmentLength = 4;
  var stringLength = input.length;
  var diff = stringLength % segmentLength;
  if (!diff) {
    return input;
  }
  var position = stringLength;
  var padLength = segmentLength - diff;
  var paddedStringLength = stringLength + padLength;
  var buffer = Buffer$d.alloc(paddedStringLength);
  buffer.write(input);
  while (padLength--) {
    buffer.write("=", position++);
  }
  return buffer.toString();
}
padString$1.default = padString;

Object.defineProperty(base64url$1, "__esModule", {
  value: true
});
var pad_string_1 = padString$1;
function encode(input, encoding) {
  if (encoding === void 0) {
    encoding = "utf8";
  }
  if (Buffer$d.isBuffer(input)) {
    return fromBase64(input.toString("base64"));
  }
  return fromBase64(Buffer$d.from(input, encoding).toString("base64"));
}
function decode(base64url, encoding) {
  if (encoding === void 0) {
    encoding = "utf8";
  }
  return Buffer$d.from(toBase64(base64url), "base64").toString(encoding);
}
function toBase64(base64url) {
  base64url = base64url.toString();
  return pad_string_1.default(base64url).replace(/\-/g, "+").replace(/_/g, "/");
}
function fromBase64(base64) {
  return base64.replace(/=/g, "").replace(/\+/g, "-").replace(/\//g, "_");
}
function toBuffer(base64url) {
  return Buffer$d.from(toBase64(base64url), "base64");
}
var base64url = encode;
base64url.encode = encode;
base64url.decode = decode;
base64url.toBase64 = toBase64;
base64url.fromBase64 = fromBase64;
base64url.toBuffer = toBuffer;
base64url$1.default = base64url;

base64url$2.exports;
(function (module) {
  module.exports = base64url$1.default;
  module.exports.default = module.exports;
})(base64url$2);
var base64urlExports = base64url$2.exports;

Object.defineProperty(utils, "__esModule", {
  value: true
});
var unPack_1 = utils.unPack = pack_1 = utils.pack = signUnsignedTransaction_1 = utils.signUnsignedTransaction = extractOutputs_1 = utils.extractOutputs = deriveCashaddr_1 = utils.deriveCashaddr = wifToPrivateKey_1 = utils.wifToPrivateKey = textToUtf8Hex_1 = utils.textToUtf8Hex = hexSecretToHexPrivkey_1 = utils.hexSecretToHexPrivkey = uint8ArrayToHex_1 = utils.uint8ArrayToHex = cashAddrToLegacy_1 = utils.cashAddrToLegacy = hexToWif_1 = utils.hexToWif = void 0;
var libauth_1 = require$$0$2;
var bchaddr = bchaddr$1;
var wif = wif$1;
var Buffer_1 = buffer;
var algo_msgpack_with_bigint_1 = msgpack_minExports;
var base64url_1 = base64urlExports;
function hexToWif(hexStr, network) {
  var privateKey = new Buffer_1.Buffer(hexStr, 'hex');
  if (network == libauth_1.CashAddressNetworkPrefix.mainnet) {
    return wif.encode(128, privateKey, true);
  } else {
    return wif.encode(239, privateKey, true);
  }
}
var hexToWif_1 = utils.hexToWif = hexToWif;
function cashAddrToLegacy(cashAddr) {
  return bchaddr.toLegacyAddress(cashAddr);
}
var cashAddrToLegacy_1 = utils.cashAddrToLegacy = cashAddrToLegacy;
function uint8ArrayToHex(arr) {
  return (0, libauth_1.binToHex)(arr);
}
var uint8ArrayToHex_1 = utils.uint8ArrayToHex = uint8ArrayToHex;
function hexSecretToHexPrivkey(text) {
  if (!(0, libauth_1.isHex)(text)) {
    throw "Invalid Hex Secret";
  }
  var hashHex = (0, libauth_1.binToHex)(libauth_1.sha256.hash((0, libauth_1.hexToBin)(text)));
  var n = BigInt("0x" + hashHex);
  var m = BigInt("0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364140");
  n = n % m;
  return n.toString(16);
}
var hexSecretToHexPrivkey_1 = utils.hexSecretToHexPrivkey = hexSecretToHexPrivkey;
function textToUtf8Hex(text) {
  var encoder = new TextEncoder();
  return (0, libauth_1.binToHex)(encoder.encode(text));
}
var textToUtf8Hex_1 = utils.textToUtf8Hex = textToUtf8Hex;
function wifToPrivateKey(secret) {
  var wifResult = (0, libauth_1.decodePrivateKeyWif)(secret);
  if (typeof wifResult === "string") {
    throw Error(wifResult);
  }
  var resultData = wifResult;
  return resultData.privateKey;
}
var wifToPrivateKey_1 = utils.wifToPrivateKey = wifToPrivateKey;
function deriveCashaddr(privateKey, networkPrefix, addrType) {
  var publicKey = libauth_1.secp256k1.derivePublicKeyCompressed(privateKey);
  if (typeof publicKey === "string") {
    throw new Error(publicKey);
  }
  var pkh = (0, libauth_1.hash160)(publicKey);
  return (0, libauth_1.encodeCashAddress)(networkPrefix, addrType, pkh);
}
var deriveCashaddr_1 = utils.deriveCashaddr = deriveCashaddr;
function extractOutputs(tx, network) {
  var outputs = [];
  var _iterator = _createForOfIteratorHelper(tx.outputs),
    _step;
  try {
    for (_iterator.s(); !(_step = _iterator.n()).done;) {
      var out = _step.value;
      var result = (0, libauth_1.lockingBytecodeToCashAddress)(out.lockingBytecode, network);
      if (typeof result !== "string") {
        result = (0, libauth_1.disassembleBytecodeBCH)(out.lockingBytecode);
      }
      var entry = {
        valueSatoshis: out.valueSatoshis,
        cashAddress: result,
        token: out.token
      };
      outputs.push(entry);
    }
  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }
  return outputs;
}
var extractOutputs_1 = utils.extractOutputs = extractOutputs;
function signUnsignedTransaction(decoded, sourceOutputs, signingKey) {
  var template = (0, libauth_1.importAuthenticationTemplate)(libauth_1.authenticationTemplateP2pkhNonHd);
  if (typeof template === "string") {
    throw new Error("Transaction template error");
  }
  var compiler = (0, libauth_1.authenticationTemplateToCompilerBCH)(template);
  var transactionTemplate = Object.assign({}, decoded);
  var _iterator2 = _createForOfIteratorHelper(decoded.inputs.entries()),
    _step2;
  try {
    for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
      var _step2$value = _slicedToArray(_step2.value, 2),
        index = _step2$value[0],
        input = _step2$value[1];
      if (input.unlockingBytecode.byteLength > 0) {
        continue;
      }
      var sourceOutput = sourceOutputs[index];
      transactionTemplate.inputs[index] = Object.assign(Object.assign({}, input), {
        unlockingBytecode: {
          compiler: compiler,
          data: {
            keys: {
              privateKeys: {
                key: signingKey
              }
            }
          },
          valueSatoshis: sourceOutput.valueSatoshis,
          script: "unlock",
          token: sourceOutput.token
        }
      });
    }
  } catch (err) {
    _iterator2.e(err);
  } finally {
    _iterator2.f();
  }
  var result = (0, libauth_1.generateTransaction)(transactionTemplate);
  if (!result.success) {
    throw result.errors;
  }
  return (0, libauth_1.encodeTransaction)(result.transaction);
}
var signUnsignedTransaction_1 = utils.signUnsignedTransaction = signUnsignedTransaction;
function pack(tx) {
  var hex = Buffer_1.Buffer.from((0, algo_msgpack_with_bigint_1.encode)(tx)).toString("hex");
  return base64url_1.default.encode(hex);
}
var pack_1 = utils.pack = pack;
function unPack(tx) {
  var hex = base64url_1.default.decode(tx);
  var result = (0, algo_msgpack_with_bigint_1.decode)(Buffer_1.Buffer.from(hex, "hex"));
  return JSON.parse(JSON.stringify(result), function (key, value) {
    if (value && value.type === "Buffer") {
      return new Uint8Array(value.data);
    }
    if (["token", "nft"].includes(key) && value === null) {
      return undefined;
    }
    if (["valueSatoshis", "amount"].includes(key)) {
      return BigInt(value);
    }
    return value;
  });
}
unPack_1 = utils.unPack = unPack;

export { cashAddrToLegacy_1 as cashAddrToLegacy, utils as default, deriveCashaddr_1 as deriveCashaddr, extractOutputs_1 as extractOutputs, hexSecretToHexPrivkey_1 as hexSecretToHexPrivkey, hexToWif_1 as hexToWif, pack_1 as pack, signUnsignedTransaction_1 as signUnsignedTransaction, textToUtf8Hex_1 as textToUtf8Hex, uint8ArrayToHex_1 as uint8ArrayToHex, unPack_1 as unPack, wifToPrivateKey_1 as wifToPrivateKey };
